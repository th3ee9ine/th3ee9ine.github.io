<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 5.4.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>Java依赖注入详解 - Hexo</title>

  
    <meta name="description" content="摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。 前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那">
<meta property="og:type" content="article">
<meta property="og:title" content="Java依赖注入详解">
<meta property="og:url" content="http://example.com/2020/06/13/Java%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。 前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/blog/24/1.png">
<meta property="og:image" content="http://example.com/blog/24/2.png">
<meta property="og:image" content="http://example.com/blog/24/3.png">
<meta property="article:published_time" content="2020-06-13T07:05:22.573Z">
<meta property="article:modified_time" content="2021-05-01T13:09:43.357Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/blog/24/1.png">
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
</head>

<body>
  


  <div class='l_body' id='start'>
    <aside class='l_left'>
    

<header class='header'>
  <div class='logo-wrap'>
  
  
    <a class='title' href='/'>
      Hexo
    </a>
  
</div>

  <nav class="menu dis-select"></nav>
</header>

<div class='widgets'>
  
    
      
      
<div class="widget-wrap" id="toc"><div class="widget-header h4 dis-select"><span class="name">TOC</span></div><div class="widget-body fs14 post"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">依赖注入的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81setter%E6%B3%A8%E5%85%A5"><span class="toc-text">1、setter注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81field%E6%B3%A8%E5%85%A5"><span class="toc-text">2、field注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="toc-text">3、构造器注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-text">为什么推荐使用构造器注入？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">循环依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-text">1、什么是循环依赖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Spring%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-text">2、Spring怎么解决循环依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-text">三级缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%86%85%E5%AE%B9"><span class="toc-text">参考内容</span></a></li></ol></div></div></div>

    
  
</div>


    </aside>
    <div class='l_main'>
      

      


  <div class='bread-nav fs12'>
  
    
    <div id='breadcrumb'>
      <a class='cap breadcrumb' href='/'>Home</a>
      <span class="sep"></span>
      <a class='cap breadcrumb' href='/'>Blog</a>
      
        <span class="sep"></span>
        <a class="cap breadcrumb-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
      
    </div>
    <div id='post-meta'>
      Posted on&nbsp;<time datetime='2020-06-13T07:05:22.573Z'>2020-06-13</time>
    </div>
  
  </div>


<article class='content md post'>
<h1 class="article-title"><span>Java依赖注入详解</span></h1>
<h1 id="摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。"><a href="#摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。" class="headerlink" title="摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。"></a>摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。</h1><hr>
<h1 id="前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。"><a href="#前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。" class="headerlink" title="前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。"></a>前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。</h1><hr>
<h2 id="依赖注入的方法"><a href="#依赖注入的方法" class="headerlink" title="依赖注入的方法"></a>依赖注入的方法</h2><p>注：下面例子主要以spring为例。</p>
<h3 id="1、setter注入"><a href="#1、setter注入" class="headerlink" title="1、setter注入"></a>1、setter注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFooService</span><span class="params">(FooService fooService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fooService = fooService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​这种注入方式是在Spring3.x刚推出的时候，推荐使用的注入方式。</p>
<h3 id="2、field注入"><a href="#2、field注入" class="headerlink" title="2、field注入"></a>2、field注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Foo&gt; <span class="title">listFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fooService.list();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种注入方式非常简单，只要加入要注入的字段，附上@Autowired，即可完成。</p>
<h3 id="3、构造器注入"><a href="#3、构造器注入" class="headerlink" title="3、构造器注入"></a>3、构造器注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooController</span><span class="params">(FooService fooService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fooService = fooService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​这种注入方式是在Spring4.x版本中推荐使用的注入方式。</p>
<p>使用构造器注入的优点：</p>
<ol>
<li>能够保证注入的组件不可变。</li>
<li>确保需要的依赖不为空。</li>
<li>构造器注入的依赖总是能够保证完全初始化的状态。</li>
</ol>
<h2 id="为什么推荐使用构造器注入？"><a href="#为什么推荐使用构造器注入？" class="headerlink" title="为什么推荐使用构造器注入？"></a>为什么推荐使用构造器注入？</h2><ol>
<li><p>field注入<br>优点：注入简单。简洁明了。<br>缺点：循环依赖、重名依赖、依赖为空。</p>
</li>
<li><p>构造器注入<br>优点：初始化、不可变性、数据检查、依赖不为空。<br>缺点：循环依赖、注入的一多就非常的臃肿。</p>
</li>
<li><p>setter注入<br>优点：通过调用，可以让代码控制类依赖的顺序，解决循环依赖。<br>缺点：注入的一多就非常的臃肿、依赖可变性，不够安全。</p>
</li>
</ol>
<p>构造器注入和field注入的循环依赖的报错提示也有点不同，前者编译时就报错，后者使用时报错。</p>
<p>所以说为什么使用构造器注入呢，主要是因为：</p>
<ol>
<li>保证依赖不可变（final关键字）。</li>
<li>保证依赖不为空（省去了我们对其检查）。</li>
<li>保证返回客户端（调用）的代码的时候是完全初始化的状态。</li>
<li>如果产生了循环依赖的问题，可以在编译是就知道，这样可以及时解决（尽量把错误在编译时就发现才是最好的开发习惯！机器的可信度远高于人类！）。</li>
</ol>
<p>来自spring官方的解释：</p>
<p>We usually advise people to use constructor injection for all mandatory collaborators and setter injection for all other properties. Again, constructor injection ensures all mandatory properties have been satisfied, and it is simply not possible to instantiate an object in an invalid state (not having passed its collaborators). In other words, when using constructor injection you do not have to use a dedicated mechanism to ensure required properties are set (other than normal Java mechanisms).</p>
<p>具体详情可以参考一下这篇文章：<a target="_blank" rel="noopener" href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/</a></p>
<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><h3 id="1、什么是循环依赖？"><a href="#1、什么是循环依赖？" class="headerlink" title="1、什么是循环依赖？"></a>1、什么是循环依赖？</h3><p>循环依赖其实就是循环引用，也就是两个或者两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/24/1.png" alt="循环依赖图"></p>
<p>注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p>
<p>循环依赖场景有：</p>
<ol>
<li>构造器的循环依赖。</li>
<li>field属性的循环依赖。</li>
</ol>
<p>其中，构造器的循环依赖问题无法通过框架自动去解决，但是它会在编译时就报错，我们可以人为的解决它。在解决属性循环依赖时，Spring通过将实例化后的对象提前暴露给Spring容器中的singletonFactories，解决了循环依赖的问题。</p>
<h3 id="2、Spring怎么解决循环依赖"><a href="#2、Spring怎么解决循环依赖" class="headerlink" title="2、Spring怎么解决循环依赖"></a>2、Spring怎么解决循环依赖</h3><p>Spring的循环依赖的理论依据基于Java的引用传递，当获得对象的引用时，对象的属性是可以延后设置的（但是构造器必须是在获取引用之前）。</p>
<p>Spring的单例对象的初始化主要分为三步：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/24/2.png" alt="单例对象的初始化三步骤"></p>
<ol>
<li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象。</li>
<li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充。</li>
<li>initializeBean：初始化，调用spring xml中的init 方法。</li>
</ol>
<p>从上面单例bean的初始化可以知道：循环依赖主要发生在第一、二步，也就是构造器循环依赖和field循环依赖。那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p>
<h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>三级缓存分别指：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三级缓存主要指：</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>singletonFactories：单例对象工厂的cache。</li>
<li>earlySingletonObjects：提前暴光的单例对象的Cache。</li>
<li>singletonObjects：单例对象的cache。</li>
</ol>
<ul>
<li>在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。</li>
<li>如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。</li>
<li>如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()获取，如果获取到了则从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</li>
</ul>
<p>从上面三级缓存的分析中，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory。这里就是解决循环依赖的关键，发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p>
<p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况：</p>
<p>A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存 earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p>
<p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/blog/24/3.png" alt="DEBUG流程图"></p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27053548">https://www.zhihu.com/question/27053548</a></p>
<p><a target="_blank" rel="noopener" href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzq6032010/p/11406405.html">https://www.cnblogs.com/zzq6032010/p/11406405.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33808244/article/details/102453052">https://blog.csdn.net/qq_33808244/article/details/102453052</a></p>


<div class="article-footer fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap" id="read-next"><section class="header cap theme"><span>READ NEXT</span></section><section class="body"><div class="post-title h2"><a href="/2020/05/05/Flagr%E5%85%A5%E9%97%A8/">flagr入门</a></div><div class="post-title fs14"><a href="/2020/06/21/%E4%BF%9D%E8%AF%81%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">or prev: 如何保证类线程安全</a></div></section></div>








      
<footer class="page-footer fs12"><hr><div><p>All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</p>
<p>This site was deployed by <a href="http://example.com/">@John Doe</a> using <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0">Stellar</a>.</p>
</div></footer>

      <div class='float-panel mobile-only' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" viewBox="0 0 1228 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2849"><path d="M0 0m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2850"></path><path d="M0 389.560798m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.3902l-973.901995 0q-97.390199 0-97.390199-97.3902l0 0q0-97.390199 97.390199-97.390199Z" p-id="2851"></path><path d="M0 779.121596m97.390199 0l973.901995 0q97.390199 0 97.390199 97.390199l0 0q0 97.390199-97.390199 97.390199l-973.901995 0q-97.390199 0-97.390199-97.390199l0 0q0-97.390199 97.390199-97.390199Z" p-id="2852"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script')
      script.src = src
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.1.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js',
    sitesjs: '/js/plugins/sites.js',
    friendsjs: '/js/plugins/friends.js',
  };

  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper/swiper-bundle.min.css","js":"https://unpkg.com/swiper/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
