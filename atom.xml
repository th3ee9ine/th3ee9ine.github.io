<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教练，我想学技术!</title>
  
  <subtitle>会写一点Java、Go、Python、Vue的后端菜鸡</subtitle>
  <link href="https://www.blog.ajie39.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.ajie39.top/"/>
  <updated>2023-05-28T09:51:09.096Z</updated>
  <id>https://www.blog.ajie39.top/</id>
  
  <author>
    <name>th3ee9ine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git分支规范</title>
    <link href="https://www.blog.ajie39.top/2023/05/28/Git%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83/"/>
    <id>https://www.blog.ajie39.top/2023/05/28/Git%E5%88%86%E6%94%AF%E8%A7%84%E8%8C%83/</id>
    <published>2023-05-28T09:50:57.784Z</published>
    <updated>2023-05-28T09:51:09.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：本文介绍了一种规范的Git分支管理方法，旨在帮助团队高效地协作开发。"><a href="#摘要：本文介绍了一种规范的Git分支管理方法，旨在帮助团队高效地协作开发。" class="headerlink" title="摘要：本文介绍了一种规范的Git分支管理方法，旨在帮助团队高效地协作开发。"></a>摘要：本文介绍了一种规范的Git分支管理方法，旨在帮助团队高效地协作开发。</h1><hr><span id="more"></span><h2 id="git介绍"><a href="#git介绍" class="headerlink" title="git介绍"></a>git介绍</h2><p>Git 是一个分布式的版本管理工具。</p><h2 id="中心式协同工作流"><a href="#中心式协同工作流" class="headerlink" title="中心式协同工作流"></a>中心式协同工作流</h2><p>首先，先说明一下，Git 是可以像 SVN 这样的中心工作流一样工作的。</p><p>这个过程一般是下面这个样子的：</p><ol><li>从服务器上做git pull origin master把代码同步下来。</li><li>改完后，git commit到本地仓库中。</li><li>然后git push origin master到远程仓库中，这样其他同学就可以得到你的代码了。</li></ol><p>如果在第 3 步发现 push 失败，因为别人已经提交了，那么你需要先把服务器上的代码给 pull 下来，为了避免有 merge 动作，你可以使用 git pull –rebase 。这样就可以把服务器上的提交直接合并到你的代码中。</p><p>对此，Git 的操作是这样的：</p><ol><li>先把你本地提交的代码放到一边。</li><li>然后把服务器上的改动下载下来。</li><li>然后在本地把你之前的改动再重新一个一个地做 commit，直到全部成功。</li></ol><p>如下图所示。Git 会把 Origin/Master 的远程分支下载下来（绿色的），然后把本地的 Master 分支上的改动一个一个地提交上去（黄色的）。</p><p><img src="/img/image/blog/20230528-01/%E4%B8%AD%E5%BF%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%B5%81.png" alt="中心式协同工作流"></p><p>如果有冲突，那么你要先解决冲突，然后做 git rebase –continue 。如下图所示，git 在做 pull –rebase 时，会一个一个地应用（apply）本地提交的代码，如果有冲突就会停下来，等你解决冲突。</p><p><img src="/img/image/blog/20230528-01/%E4%B8%AD%E5%BF%83%E5%BC%8F%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%B5%812.png" alt="中心式协同工作流2"></p><h2 id="功能分支协同工作流"><a href="#功能分支协同工作流" class="headerlink" title="功能分支协同工作流"></a>功能分支协同工作流</h2><p>上面的那种方式最大的问题就是代码可能干扰太严重。尤其是，我们想安安静静地开发一个功能时，我们想把各个功能的代码变动隔离开来，同时各个功能又会有多个开发人员在开发。</p><p>这时，我们不想让各个功能的开发人员都在 Master 分支上共享他们的代码。我们想要的协同方式是这样的：同时开发一个功能的开发人员可以分享各自的代码，但是不会把代码分享给开发其他功能的开发人员，直到整个功能开发完毕后，才会分享给其他的开发人员（也就是进入主干分支）。</p><p>因此，我们引入“功能分支”。这个协同工作流的开发过程如下：</p><ol><li>首先使用 git checkout -b new-feature 创建 “feature_20220318”分支。</li><li>然后共同开发这个功能的程序员就在这个分支上工作，进行 add、commit 等操作。</li><li>然后通过 git push -u origin feature_20220318 把分支代码 push 到服务器上。</li><li>其他程序员可以通过git pull –rebase来拿到最新的这个分支的代码。</li><li>最后通过 Pull Request 的方式做完 Code Review 后合并到 Master 分支上。</li></ol><p><img src="/img/image/blog/20230528-01/%E5%8A%9F%E8%83%BD%E5%88%86%E6%94%AF%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%B5%81.png" alt="功能分支协同工作流"></p><p>就像上面这个图显示的一样，绿色的分支就是功能分支，合并后就会像上面这个样子。</p><p>我们可以看到，其实，这种开发也是以服务器为中心的开发，还不是 Git 分布式开发，它只不过是用分支来完成代码改动的隔离。</p><p>另外，我想提醒一下，为什么会叫“功能分支”，而不是“项目分支”？因为 Git 的最佳实践希望大家在开发的过程中，快速提交，快速合并，快速完成。这样可以少很多冲突的事，所以叫功能分支。</p><p>传统的项目分支开得太久，时间越长就越合不回去。这种玩法其实就是让我们把一个大项目切分成若干个小项目来执行（最好是一个小功能一个项目）。</p><p>这样才是互联网式的快速迭代式的开发流程。</p><h2 id="GitFlow-协同工作流"><a href="#GitFlow-协同工作流" class="headerlink" title="GitFlow 协同工作流"></a>GitFlow 协同工作流</h2><p>在真实的生产过程中，前面的协同工作流还是不能满足工作的要求。这主要因为我们的生产过程是比较复杂的，软件生产中会有各式各样的问题，并要面对不同的环境。</p><p>我们要在不停地开发新代码的同时，维护线上的代码，于是，就有了下面这些需求：</p><ol><li>希望有一个分支是非常干净的，上面是可以发布的代码，上面的改动永远都是可以发布到生产环境中的。这个分支上不能有中间开发过程中不可以上生产线的代码提交。</li><li>希望当代码达到可以上线的状态时，也就是在 alpha/beta release 时，在测试和交付的过程中，依然可以开发下一个版本的代码。</li><li>最后，对于已经发布的代码，也会有一些 Bug-fix 的改动，不会将正在开发的代码提交到生产线上去。</li></ol><p>面对这些需求，前面的那些协同方式就都不行了。因为我们不仅是要在整个团队中共享代码，我们要的更是管理好不同环境下的代码不互相干扰。<strong>说得技术一点儿就是，要管理好代码与环境的一致性。</strong></p><p>为了解决这些问题，GitFlow 协同工作流就出来了。这个协同工作流的核心思想如下图所示：</p><p><img src="/img/image/blog/20230528-01/GitFlow%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%B5%81.png" alt="GitFlow 协同工作流"></p><p>整个代码库中一共有五种分支。</p><ol><li>Master 分支：主干分支，用作发布环境，上面的每一次提交都是可以发布的。</li><li>Feature 分支：功能分支，用于开发功能，其对应的是开发环境。</li><li>Developer 分支：开发分支，一旦功能开发完成，就向 Developer 分支合并，合并完成后，删除功能分支。这个分支对应的是集成测试环境。</li><li>Release 分支：当 Developer 分支测试达到可以发布状态时，开出一个 Release 分支来，然后做发布前的准备工作。这个分支对应的是预发环境。之所以需要这个 Release 分支，是我们的开发可以继续向前，不会因为要发布而被 block 住而不能提交。 一旦 Release 分支上的代码达到可以上线的状态，那么需要把 Release 分支向 Master 分支和 Developer 分支同时合并，以保证代码的一致性。然后再把 Release 分支删除掉。</li><li>Hotfix 分支：是用于处理生产线上代码的 Bug-fix，每个线上代码的 Bug-fix 都需要开一个 Hotfix 分支，完成后，向 Developer 分支和 Master 分支上合并。合并完成后，删除 Hotfix 分支。</li></ol><p>这就是整个 GitFlow 协同工作流的工作过程。我们可以看到：</p><ol><li>我们需要长期维护 Master 和 Developer 两个分支。</li><li>这其中的方式还是有一定复杂度的，尤其是 Release 和 Hotfix 分支需要同时向两个分支作合并。所以，如果没有一个好的工具来支撑的话，这会因为我们可能会忘了做一些操作而导致代码不一致。</li><li>GitFlow 协同虽然工作流比较重。但是它几乎可以应对所有公司的各种开发流程，包括瀑布模型，或是快速迭代模型。</li></ol><h2 id="简化版-GitFlow-协同工作流"><a href="#简化版-GitFlow-协同工作流" class="headerlink" title="简化版 GitFlow 协同工作流"></a>简化版 GitFlow 协同工作流</h2><p>由于 GitFlow 协同工作流比较重，不太适合我们现在的团队情况，所以基于 GitFlow 协同工作流做出以下简化：</p><h3 id="1、分支构成"><a href="#1、分支构成" class="headerlink" title="1、分支构成"></a>1、分支构成</h3><ol><li>Master 分支：主干分支，用作发布环境，上面的每一次提交都是可以发布的。</li><li>Feature 分支：功能分支，用于开发功能，其对应的是开发环境。</li><li>Release 分支：当 Feature 分支达到可以提测状态时，需要将代码合并到 Release 分支。这个分支对应的是测试、预发环境。之所以需要这个 Release 分支，是我们的开发可以继续向前，不会因为要发布而被 block 住而不能提交。 一旦 Release 分支上的代码达到可以上线的状态，那么需要把 Release 分支向 Master 合并，以保证代码的一致性。然后再把 Release 分支删除掉。</li><li>Hotfix 分支：是用于处理生产线上代码的 Bug-fix，每个线上代码的 Bug-fix 都需要开一个 Hotfix 分支，完成后，向 Master 分支上合并。合并完成后，删除 Hotfix 分支。</li></ol><h3 id="2、命名规则"><a href="#2、命名规则" class="headerlink" title="2、命名规则"></a>2、命名规则</h3><p>分支类型 + 上线日期 + 负责人简称（分支创建人）</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Feature分支，20220318日上线，创建人陈杰</span><br><span class="line"></span><br><span class="line">feature_20220318_cj</span><br></pre></td></tr></table></figure><h3 id="3、开发步骤"><a href="#3、开发步骤" class="headerlink" title="3、开发步骤"></a>3、开发步骤</h3><h4 id="①正常需求开发"><a href="#①正常需求开发" class="headerlink" title="①正常需求开发"></a>①正常需求开发</h4><p>步骤一：一个新需求开始后，基于 Master 分支创建一个 Feature 分支，例如 feature_20220320_cj。<br>步骤二：当 Feature 分支的代码，自测、联调结束并且达到可以提测的状态后，基于 Master 分支创建一个 Release 分支，例如：release_20220320_cj。<br>步骤三：当测试同学测试通过后，将 Release 分支的代码合并到 Master 分支，并发布上线。如果测似过程中，发现 bug，则开发人员重复步骤 一、二，直到达到可以上线的标准为止。</p><h4 id="②线上问题紧急修复"><a href="#②线上问题紧急修复" class="headerlink" title="②线上问题紧急修复"></a>②线上问题紧急修复</h4><p>步骤一：当线上出现 bug ，需要紧急修复时，基于 Master 分支创建一个 Hotfix 分支，例如 hotfix_20220320_cj。<br>步骤二：当测试同学测试通过后，将 Hotfix 分支的代码合并到 Master 分支，并发布上线。如果测似过程中，发现 bug，则开发人员重复步骤一。</p><h4 id="③不同人员在同个-git-仓库进行功能开发"><a href="#③不同人员在同个-git-仓库进行功能开发" class="headerlink" title="③不同人员在同个 git 仓库进行功能开发"></a>③不同人员在同个 git 仓库进行功能开发</h4><p>参考<strong>①正常需求开发</strong>，区别点：</p><p>区别一：每个人员根据自己独立的功能模块，基于 Master 分支创建一个 Feature 分支，例如 feature_20220320_cj and feature_20220320_zs。<br>区别二：需要创建一个共同的 Release 分支，例如 release_20220320_saas3，当每个人员自己的功能模块达到可以提测状态后，将自己的代码提交到 Release 分支。<br>区别三：测试同学可以根据提测的不同的功能模块，进行测试，但是在最后代码都提交完毕后，还需要进行一次系统测试，确保合并后的代码是正确的（保证代码正确性）。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：本文介绍了一种规范的Git分支管理方法，旨在帮助团队高效地协作开发。&quot;&gt;&lt;a href=&quot;#摘要：本文介绍了一种规范的Git分支管理方法，旨在帮助团队高效地协作开发。&quot; class=&quot;headerlink&quot; title=&quot;摘要：本文介绍了一种规范的Git分支管理方法，旨在帮助团队高效地协作开发。&quot;&gt;&lt;/a&gt;摘要：本文介绍了一种规范的Git分支管理方法，旨在帮助团队高效地协作开发。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.blog.ajie39.top/categories/Git/"/>
    
    <category term="开发规范" scheme="https://www.blog.ajie39.top/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Git" scheme="https://www.blog.ajie39.top/tags/Git/"/>
    
    <category term="开发规范" scheme="https://www.blog.ajie39.top/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Git多账号配置</title>
    <link href="https://www.blog.ajie39.top/2023/05/28/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.blog.ajie39.top/2023/05/28/git%E5%A4%9A%E8%B4%A6%E5%8F%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2023-05-28T08:30:57.412Z</published>
    <updated>2023-05-28T09:38:56.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：本文介绍了如何配置Git多账号，以便在同一计算机上管理多个Git账号。"><a href="#摘要：本文介绍了如何配置Git多账号，以便在同一计算机上管理多个Git账号。" class="headerlink" title="摘要：本文介绍了如何配置Git多账号，以便在同一计算机上管理多个Git账号。"></a>摘要：本文介绍了如何配置Git多账号，以便在同一计算机上管理多个Git账号。</h1><hr><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>所谓多个git账号，可能存在一下的情况:</p><ul><li>我有多个 github 的账号，不同的账号对应不同的 repo，需要 push 的时候自动区分账号。</li><li>我有多个 git 的账号，有的是 github 的，有的是单位的 gitlab 的，不同账号对应不同的 repo，需要 push 的时候自动区分账号。</li></ul><p>以上的这两种情况的处理方法是一样的，大致步骤如下：</p><ul><li>1、清空原有的配置</li><li>2、分别生成不同账号的ssh公钥与密钥</li><li>3、将对应的 SSH Keys 添加到对应账号的配置中</li><li>4、修改git的配置，统一管理不同账号的信息</li><li>5、测试配置是否可用</li></ul><p>接下来我们来看一下每一个步骤的详细操作。</p><p>注：接下来的所有步骤，都是以 mac 系统为例。</p><span id="more"></span><h2 id="二、清空原有的配置"><a href="#二、清空原有的配置" class="headerlink" title="二、清空原有的配置"></a>二、清空原有的配置</h2><p>git的配置分为三个级别：</p><ul><li>system—–系统级别</li><li>global—–全局级别</li><li>local——项目级别</li></ul><p>优先级：local &gt; global &gt; system</p><h3 id="1、清空全局配置"><a href="#1、清空全局配置" class="headerlink" title="1、清空全局配置"></a>1、清空全局配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 全局git账户配置信息</span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line"># 清除 user.name 配置信息</span><br><span class="line">git config --global --unset user.name</span><br><span class="line"># 清除 user.email 配置信息</span><br><span class="line">git config --global --unset user.email</span><br><span class="line"></span><br><span class="line"># 设置 user.name 配置信息</span><br><span class="line">git config --local user.name &quot;xxxx&quot;</span><br><span class="line"># 设置 user.email 配置信息</span><br><span class="line">git config --local user.email &quot;xxxx&quot;</span><br></pre></td></tr></table></figure><h3 id="2、清空原有的-ssh-配置"><a href="#2、清空原有的-ssh-配置" class="headerlink" title="2、清空原有的 ssh 配置"></a>2、清空原有的 ssh 配置</h3><p>以 Mac 电脑为例，查看 ~/.ssh目录下如果包含 id_rsa、id_rsa.pub，类型的文件，全部删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除 ~&#x2F;.ssh 文件夹下的所有文件</span><br><span class="line">rm -rf ~&#x2F;.ssh&#x2F;*</span><br></pre></td></tr></table></figure><h2 id="三、分别生成不同账号的ssh公钥与密钥"><a href="#三、分别生成不同账号的ssh公钥与密钥" class="headerlink" title="三、分别生成不同账号的ssh公钥与密钥"></a>三、分别生成不同账号的ssh公钥与密钥</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 邮箱地址为gitlab的邮箱</span><br><span class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</span><br><span class="line"></span><br><span class="line"># 注意在输入指令后，会出现如下提示</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;Users&#x2F;&#123;你的用户名&#125;&#x2F;.ssh&#x2F;id_rsa):</span><br><span class="line"></span><br><span class="line"># 这一步如果直接回车，则会生成以 id_rsa 命名的文件，因为是多账号，所以在生成第二个文件时要输入不同的名称，例如：&#x2F;Users&#x2F;&#123;你的用户名&#125;&#x2F;.ssh&#x2F;id_gitlab_rsa</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后生成的文件如下图所示：</p><p><img src="/img/image/blog/20230528-02/ssh%E7%A7%98%E9%92%A5%E6%96%87%E4%BB%B6.png" alt="ssh秘钥文件"></p><h2 id="四、将对应的-SSH-Keys-添加到对应账号的配置中"><a href="#四、将对应的-SSH-Keys-添加到对应账号的配置中" class="headerlink" title="四、将对应的 SSH Keys 添加到对应账号的配置中"></a>四、将对应的 SSH Keys 添加到对应账号的配置中</h2><p>以 github 为例，打开 Settings -》 SSH and GPG keys，如下图</p><p><img src="/img/image/blog/20230528-02/ssh%E9%85%8D%E7%BD%AE%E4%B8%80.jpg" alt="ssh配置一"></p><p>点击 New SSH key，将生成的 ssh 公钥配置上去即可。</p><p>注：一定要将公钥复制全，不要遗漏。</p><h2 id="五、修改git的配置，统一管理不同账号的信息"><a href="#五、修改git的配置，统一管理不同账号的信息" class="headerlink" title="五、修改git的配置，统一管理不同账号的信息"></a>五、修改git的配置，统一管理不同账号的信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 创建 config 文件，如果已有，则忽略该步骤</span><br><span class="line">touch ~&#x2F;.ssh&#x2F;config</span><br><span class="line"></span><br><span class="line"># 在 config 文件中添加如下配置：</span><br><span class="line"></span><br><span class="line"># Git account 1</span><br><span class="line">Host github.com-account1</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_account1</span><br><span class="line"></span><br><span class="line"># Git account 2</span><br><span class="line">Host github.com-account2</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_account2</span><br></pre></td></tr></table></figure><p>字段解释：</p><ul><li>Host：仓库网站的别名(注：Host 就是可以替代 HostName 来使用的别名，而且后面验证是否成功需要这个名字)。</li><li>HostName：仓库网站的域名(IP地址也可以)</li><li>User：用户名</li><li>IdentityFile：私钥的路径</li></ul><h2 id="六、测试配置是否可用"><a href="#六、测试配置是否可用" class="headerlink" title="六、测试配置是否可用"></a>六、测试配置是否可用</h2><p>完成以上操作后，执行下面命令测试配置是否可用，以github为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：本文介绍了如何配置Git多账号，以便在同一计算机上管理多个Git账号。&quot;&gt;&lt;a href=&quot;#摘要：本文介绍了如何配置Git多账号，以便在同一计算机上管理多个Git账号。&quot; class=&quot;headerlink&quot; title=&quot;摘要：本文介绍了如何配置Git多账号，以便在同一计算机上管理多个Git账号。&quot;&gt;&lt;/a&gt;摘要：本文介绍了如何配置Git多账号，以便在同一计算机上管理多个Git账号。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;所谓多个git账号，可能存在一下的情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我有多个 github 的账号，不同的账号对应不同的 repo，需要 push 的时候自动区分账号。&lt;/li&gt;
&lt;li&gt;我有多个 git 的账号，有的是 github 的，有的是单位的 gitlab 的，不同账号对应不同的 repo，需要 push 的时候自动区分账号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的这两种情况的处理方法是一样的，大致步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、清空原有的配置&lt;/li&gt;
&lt;li&gt;2、分别生成不同账号的ssh公钥与密钥&lt;/li&gt;
&lt;li&gt;3、将对应的 SSH Keys 添加到对应账号的配置中&lt;/li&gt;
&lt;li&gt;4、修改git的配置，统一管理不同账号的信息&lt;/li&gt;
&lt;li&gt;5、测试配置是否可用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们来看一下每一个步骤的详细操作。&lt;/p&gt;
&lt;p&gt;注：接下来的所有步骤，都是以 mac 系统为例。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.blog.ajie39.top/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.blog.ajie39.top/tags/Git/"/>
    
    <category term="配置" scheme="https://www.blog.ajie39.top/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>办公软件安装指南</title>
    <link href="https://www.blog.ajie39.top/2022/12/18/%E5%BC%80%E5%8F%91%E6%96%B0%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <id>https://www.blog.ajie39.top/2022/12/18/%E5%BC%80%E5%8F%91%E6%96%B0%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</id>
    <published>2022-12-18T06:19:15.283Z</published>
    <updated>2023-05-28T07:49:48.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：自用办公软件汇总。"><a href="#摘要：自用办公软件汇总。" class="headerlink" title="摘要：自用办公软件汇总。"></a>摘要：自用办公软件汇总。</h1><hr><h2 id="一、日常工具介绍"><a href="#一、日常工具介绍" class="headerlink" title="一、日常工具介绍"></a>一、日常工具介绍</h2><ul><li>工作交流：钉钉 or 企业微信</li><li>邮箱：Foxmail</li><li>开发工具：IntelliJ IDEA、vscode、postman、XMind、burp</li><li>终端：tabby</li><li>输入法：搜狗输入法</li><li>梯子：v2rayU</li></ul><span id="more"></span><h2 id="二、brew-安装"><a href="#二、brew-安装" class="headerlink" title="二、brew 安装"></a>二、brew 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;zsh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;gitee.com&#x2F;cunkai&#x2F;HomebrewCN&#x2F;raw&#x2F;master&#x2F;Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><h2 id="三、JDK-安装"><a href="#三、JDK-安装" class="headerlink" title="三、JDK 安装"></a>三、JDK 安装</h2><h3 id="1、下载并安装"><a href="#1、下载并安装" class="headerlink" title="1、下载并安装"></a>1、下载并安装</h3><p>下载地址：</p><ul><li>jdk8：<a href="https://www.oracle.com/java/technologies/downloads/#java8">https://www.oracle.com/java/technologies/downloads/#java8</a></li><li>jdk11：<a href="https://www.oracle.com/java/technologies/downloads/#java11">https://www.oracle.com/java/technologies/downloads/#java11</a></li></ul><p>双击安装文件，按照提示步骤进行操作，即可完成安装</p><h3 id="2、设置环境变量"><a href="#2、设置环境变量" class="headerlink" title="2、设置环境变量"></a>2、设置环境变量</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>参考文章：<a href="https://www.runoob.com/w3cnote/windows10-java-setup.html">https://www.runoob.com/w3cnote/windows10-java-setup.html</a></p><p>①添加 JAVA_HOME 环境变量</p><ul><li>变量名：JAVA_HOME</li><li>变量值：jdk 安装地址，例如 D:\ProgramFiles\Java\jdk1.8.0_321</li></ul><p>②在 Path 环境变量中添加 JAVA_HOME 相关配置</p><ul><li>%JAVA_HOME%\bin</li><li>%JAVA_HOME%\jre\bin</li></ul><p>③添加 CLASSPATH 环境变量</p><ul><li>变量名：CLASSPATH</li><li>变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</li></ul><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p>①在 .bash_profile 文件配置环境变量</p><p>如果此前建过 .bash_profile 隐藏配置文件,直接在终端输入$ open -e .bash_profile打开文件即可,如果没有则输入下方命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .bash_profile</span><br></pre></td></tr></table></figure><p>接着输入下方命令打开此文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -e .bash_profile</span><br></pre></td></tr></table></figure><p>打开 .bash_profile 文件后中输入环境配置参数,将下方参数放入其中，并保存(如果用的是vi打开的按esc 输入:wq退出如果是文本直接command + S)退出即可。注意其中的JAVA_HOME这是上文提到的JDK安装路径，自己JDK安装路径放这放这，然后保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk&#x2F;Contents&#x2F;Home</span><br><span class="line">PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH:.</span><br><span class="line">CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure><p>②输入以下命令使配置文件生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure><p>③检查环境变量的路径，查看是否配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></table></figure><h3 id="3、测试是否安装完成"><a href="#3、测试是否安装完成" class="headerlink" title="3、测试是否安装完成"></a>3、测试是否安装完成</h3><p>打开命令行界面，输入：java -version</p><p>如果出现类似下面的提示，则表示安装完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;11.0.14&quot; 2022-01-18 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.14+8-LTS-263)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.14+8-LTS-263, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="四、maven-安装"><a href="#四、maven-安装" class="headerlink" title="四、maven 安装"></a>四、maven 安装</h2><h3 id="1、下载并安装-1"><a href="#1、下载并安装-1" class="headerlink" title="1、下载并安装"></a>1、下载并安装</h3><p>下载地址：<a href="https://maven.apache.org/">https://maven.apache.org/</a></p><p>解压至任意文件夹即可完成安装，例如：D:\ProgramFiles\Java\apache-maven-3.8.4</p><h3 id="2、配置环境变量"><a href="#2、配置环境变量" class="headerlink" title="2、配置环境变量"></a>2、配置环境变量</h3><h4 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h4><p>①添加 M2_HOME 环境变量</p><ul><li>变量名：M2_HOME</li><li>变量值：maven 安装地址，例如 D:\ProgramFiles\Java\apache-maven-3.8.4</li></ul><p>②在 Path 环境变量中添加 M2_HOME 相关配置</p><ul><li>%M2_HOME%\bin</li></ul><h4 id="Mac-1"><a href="#Mac-1" class="headerlink" title="Mac"></a>Mac</h4><p>打开 .bash_profile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -e .bash_profile</span><br></pre></td></tr></table></figure><p>添加以下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M2_HOME&#x3D;&#x2F;Library&#x2F;tools&#x2F;apache-maven-3.8.4</span><br><span class="line">export M2_HOME</span><br><span class="line"></span><br><span class="line">PATH&#x3D;$&#123;PATH&#125;:$&#123;M2_HOME&#125;&#x2F;bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><h3 id="3、测试是否安装完成-1"><a href="#3、测试是否安装完成-1" class="headerlink" title="3、测试是否安装完成"></a>3、测试是否安装完成</h3><p>打开命令行界面，输入：mvn -v</p><p>如果出现类似下面的提示，则表示安装完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Apache Maven 3.8.4 (9b656c72d54e5bacbed989b64718c159fe39b537)</span><br><span class="line">Maven home: D:\ProgramFiles\Java\apache-maven-3.8.4</span><br><span class="line">Java version: 1.8.0_321, vendor: Oracle Corporation, runtime: D:\ProgramFiles\Java\jdk1.8.0_321\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;</span><br></pre></td></tr></table></figure><h2 id="五、gradle-安装"><a href="#五、gradle-安装" class="headerlink" title="五、gradle 安装"></a>五、gradle 安装</h2><h3 id="1、下载并安装-2"><a href="#1、下载并安装-2" class="headerlink" title="1、下载并安装"></a>1、下载并安装</h3><p>下载地址：<a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p><p>解压至任意文件夹即可完成安装，例如：D:\ProgramFiles\Java\gradle</p><h3 id="2、配置环境变量-1"><a href="#2、配置环境变量-1" class="headerlink" title="2、配置环境变量"></a>2、配置环境变量</h3><h4 id="Windows-2"><a href="#Windows-2" class="headerlink" title="Windows"></a>Windows</h4><p>①添加 GRADLE_HOME 环境变量</p><ul><li>变量名：GRADLE_HOME</li><li>变量值：gradle 安装地址，例如 D:\ProgramFiles\Java\gradle</li></ul><p>②在 Path 环境变量中添加 GRADLE_HOME 相关配置</p><ul><li>%GRADLE_HOME%\bin</li></ul><h4 id="Mac-2"><a href="#Mac-2" class="headerlink" title="Mac"></a>Mac</h4><p>打开 .bash_profile 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -e .bash_profile</span><br></pre></td></tr></table></figure><p>添加以下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GRADLE_HOME&#x3D;&#x2F;Library&#x2F;tools&#x2F;gradle-7.5</span><br><span class="line">export GRADLE_HOME</span><br><span class="line"></span><br><span class="line">PATH&#x3D;$&#123;PATH&#125;:$&#123;GRADLE_HOME&#125;&#x2F;bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><h3 id="3、测试是否安装完成-2"><a href="#3、测试是否安装完成-2" class="headerlink" title="3、测试是否安装完成"></a>3、测试是否安装完成</h3><p>打开命令行界面，输入：gradle -v</p><p>如果出现类似下面的提示，则表示安装完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 7.5</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2022-07-14 12:48:15 UTC</span><br><span class="line">Revision:     c7db7b958189ad2b0c1472b6fe663e6d654a5103</span><br><span class="line"></span><br><span class="line">Kotlin:       1.6.21</span><br><span class="line">Groovy:       3.0.10</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.11 compiled on July 10 2021</span><br><span class="line">JVM:          1.8.0_333 (Oracle Corporation 25.333-b02)</span><br><span class="line">OS:           Mac OS X 12.4 x86_64</span><br></pre></td></tr></table></figure><h2 id="六、git-安装"><a href="#六、git-安装" class="headerlink" title="六、git 安装"></a>六、git 安装</h2><p>下载地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><p>参考地址：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">https://www.cnblogs.com/xueweisuoyong/p/11914045.html</a></p><p>git 配置 ssh 参考地址:<a href="https://www.cnblogs.com/yuqiliu/p/12551258.html">https://www.cnblogs.com/yuqiliu/p/12551258.html</a></p><h2 id="七、梯子安装"><a href="#七、梯子安装" class="headerlink" title="七、梯子安装"></a>七、梯子安装</h2><p>mac 下载地址：<a href="https://github.com/yanue/V2rayU/releases/">https://github.com/yanue/V2rayU/releases/</a></p><p>Windows 下载地址：<a href="https://github.com/2dust/v2rayN/releases/">https://github.com/2dust/v2rayN/releases/</a></p><p>安卓下载地址：<a href="https://github.com/2dust/v2rayNG/releases">https://github.com/2dust/v2rayNG/releases</a></p><h2 id="八、burp-安装"><a href="#八、burp-安装" class="headerlink" title="八、burp 安装"></a>八、burp 安装</h2><p>官方下载地址：</p><p><a href="https://portswigger.net/burp/releases">https://portswigger.net/burp/releases</a></p><p>破解工具下载地址：</p><p><a href="https://github.com/h3110w0r1d-y/BurpLoaderKeygen/releases">https://github.com/h3110w0r1d-y/BurpLoaderKeygen/releases</a></p><h2 id="九、一些-Mac-命令"><a href="#九、一些-Mac-命令" class="headerlink" title="九、一些 Mac 命令"></a>九、一些 Mac 命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Mac显示隐藏文件的命令：</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles YES</span><br><span class="line">Mac隐藏隐藏文件的命令：</span><br><span class="line">defaults write com.apple.finder AppleShowAllFiles NO</span><br><span class="line">然后重启Finder：鼠标单击窗口左上角的苹果标志--&gt;强制退出--&gt;Finder--&gt;重新启动</span><br><span class="line"></span><br><span class="line">关闭自动开机</span><br><span class="line">sudo nvram AutoBoot&#x3D;%00</span><br><span class="line">开启自动开机</span><br><span class="line">sudo nvram AutoBoot&#x3D;%03</span><br><span class="line"></span><br><span class="line">升级mac Catalina版本后无操作权限</span><br><span class="line"></span><br><span class="line">1、重启mac，按住Command+R，等到系统进入安全模式。</span><br><span class="line"></span><br><span class="line">2、选择一个账户，然后点击屏幕上方的工具栏找到命令行工具。</span><br><span class="line"></span><br><span class="line">3、执行，命令 csrutil disable</span><br><span class="line"></span><br><span class="line">4、重启电脑后，不要进入安全模式，执行命令sudo mount -uw &#x2F;</span><br><span class="line"></span><br><span class="line">5、执行命令sudo mkdir &#x2F;data</span><br><span class="line"></span><br><span class="line">6、执行命令sudo chmod 777 &#x2F;data</span><br><span class="line"></span><br><span class="line">7、重启电脑，进入安全模式，执行命令csrutil enable （开启SIP）</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：自用办公软件汇总。&quot;&gt;&lt;a href=&quot;#摘要：自用办公软件汇总。&quot; class=&quot;headerlink&quot; title=&quot;摘要：自用办公软件汇总。&quot;&gt;&lt;/a&gt;摘要：自用办公软件汇总。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、日常工具介绍&quot;&gt;&lt;a href=&quot;#一、日常工具介绍&quot; class=&quot;headerlink&quot; title=&quot;一、日常工具介绍&quot;&gt;&lt;/a&gt;一、日常工具介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;工作交流：钉钉 or 企业微信&lt;/li&gt;
&lt;li&gt;邮箱：Foxmail&lt;/li&gt;
&lt;li&gt;开发工具：IntelliJ IDEA、vscode、postman、XMind、burp&lt;/li&gt;
&lt;li&gt;终端：tabby&lt;/li&gt;
&lt;li&gt;输入法：搜狗输入法&lt;/li&gt;
&lt;li&gt;梯子：v2rayU&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="tools" scheme="https://www.blog.ajie39.top/categories/tools/"/>
    
    
    <category term="tools" scheme="https://www.blog.ajie39.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>feign坑点总结</title>
    <link href="https://www.blog.ajie39.top/2022/12/18/feign%E5%9D%91%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2022/12/18/feign%E5%9D%91%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2022-12-18T06:19:15.281Z</published>
    <updated>2023-01-02T07:23:19.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：主要是总结了一下这段时间在使用-feign-的过程中的遇到的一些坑点。"><a href="#摘要：主要是总结了一下这段时间在使用-feign-的过程中的遇到的一些坑点。" class="headerlink" title="摘要：主要是总结了一下这段时间在使用 feign 的过程中的遇到的一些坑点。"></a>摘要：主要是总结了一下这段时间在使用 feign 的过程中的遇到的一些坑点。</h1><hr><span id="more"></span><h2 id="一、Get请求自动转化成POST的问题"><a href="#一、Get请求自动转化成POST的问题" class="headerlink" title="一、Get请求自动转化成POST的问题"></a>一、Get请求自动转化成POST的问题</h2><h3 id="1、client-请求参数没有加上-RequestParam-注解"><a href="#1、client-请求参数没有加上-RequestParam-注解" class="headerlink" title="1、client 请求参数没有加上 @RequestParam 注解"></a>1、client 请求参数没有加上 @RequestParam 注解</h3><p>问题代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;showName&quot;)</span><br><span class="line">String showName(String name);</span><br></pre></td></tr></table></figure><p>错误提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;timestamp&quot;:&quot;2022-12-14T09:46:22.370+00:00&quot;,&quot;status&quot;:405,&quot;error&quot;:&quot;Method Not Allowed&quot;,&quot;path&quot;:&quot;&#x2F;showName&quot;&#125;]</span><br></pre></td></tr></table></figure><p>修改建议：</p><p>在对应的请求参数上加上 @RequestParam 注解，代码示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;showName&quot;)</span><br><span class="line">String showName(@RequestParam(&quot;name&quot;) String name);</span><br></pre></td></tr></table></figure><h3 id="2、client-请求参数中使用了-RequestBody-注解"><a href="#2、client-请求参数中使用了-RequestBody-注解" class="headerlink" title="2、client 请求参数中使用了 @RequestBody 注解"></a>2、client 请求参数中使用了 @RequestBody 注解</h3><p>问题代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;showBody&quot;)</span><br><span class="line">String showBody(@RequestBody String body);</span><br></pre></td></tr></table></figure><p>错误提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;timestamp&quot;:&quot;2022-12-14T10:04:08.943+00:00&quot;,&quot;status&quot;:405,&quot;error&quot;:&quot;Method Not Allowed&quot;,&quot;path&quot;:&quot;&#x2F;showBody&quot;&#125;]</span><br></pre></td></tr></table></figure><p>原因：</p><p>okhttp 和 HttpURLConnection 不支持 @RequestBody + RequestMethod.GET，只有 httpclient 支持，默认使用 HttpURLConnection。</p><p>修改建议：</p><p>1、最佳建议：要求提供方，更改为Post请求</p><p>2、使用 httpclient</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">引入 httpclient 包</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">修改配置：</span><br><span class="line">feign.httpclient.enabled &#x3D; true</span><br></pre></td></tr></table></figure><h2 id="二、Feign-Hystrix-熔断、线程使用坑点"><a href="#二、Feign-Hystrix-熔断、线程使用坑点" class="headerlink" title="二、Feign Hystrix 熔断、线程使用坑点"></a>二、Feign Hystrix 熔断、线程使用坑点</h2><p>hystrx 官方配置解释地址：<a href="https://github.com/Netflix/Hystrix/wiki/Configuration">https://github.com/Netflix/Hystrix/wiki/Configuration</a></p><h3 id="线程池队列配置问题"><a href="#线程池队列配置问题" class="headerlink" title="线程池队列配置问题"></a>线程池队列配置问题</h3><p>常用配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 核心线程池大小，默认值为：10</span><br><span class="line">hystrix.threadpool.default.coreSize &#x3D; 10</span><br><span class="line"></span><br><span class="line"># 调用超时时间，默认值为 1000ms</span><br><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds &#x3D; 15000</span><br><span class="line"></span><br><span class="line"># 最大线程池大小，这是在不开始拒绝的情况下可以支持的最大并发量。默认值为10。</span><br><span class="line">hystrix.threadpool.default.maximumSize &#x3D; 50</span><br><span class="line"></span><br><span class="line"># 队列大小拒绝阈值，默认值为 5。即使 maxQueueSize 未达到也会发生拒绝。在 maxQueueSize &#x3D;&#x3D; -1 时不生效。</span><br><span class="line">hystrix.threadpool.default.queueSizeRejectionThreshold &#x3D; 100</span><br><span class="line"></span><br><span class="line"># maximumSize 配置是否生效，默认值为 false。maximumSize 可以等于或高于 coreSize。</span><br><span class="line"># 设置 coreSize &lt; maximumSize 创建一个可以维持maximumSize并发性的线程池；</span><br><span class="line"># 但会在相对不活动期间将线程返回给系统。（受限于keepAliveTimeInMinutes）。</span><br><span class="line">hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize &#x3D; true</span><br><span class="line"></span><br><span class="line"># 最大队列大小，默认值为 -1。值为-1时：使用 thenSynchronousQueue；值为正值时：使用 LinkedBlockingQueue。</span><br><span class="line">hystrix.threadpool.default.maxQueueSize &#x3D; 50</span><br></pre></td></tr></table></figure><p>错误配置①：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds&#x3D;1000</span><br></pre></td></tr></table></figure><p>feign使用的是懒加载，第一次调用时，会初始化各种bean，速度很慢，默认1秒很容易超时。</p><p>错误配置②：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hystrix.threadpool.default.coreSize &#x3D; 10</span><br><span class="line">hystrix.threadpool.default.maxQueueSize &#x3D; 1000</span><br><span class="line">hystrix.threadpool.default.queueSizeRejectionThreshold &#x3D; 20</span><br></pre></td></tr></table></figure><p>因为 queueSizeRejectionThreshold 太小，实际上在并发达到 30 以上的时候，就会拒绝后面的请求了。</p><p>错误配置③：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hystrix.threadpool.default.coreSize &#x3D; 10</span><br><span class="line">hystrix.threadpool.default.maxQueueSize &#x3D; 20</span><br><span class="line">hystrix.threadpool.default.queueSizeRejectionThreshold &#x3D; 1000</span><br></pre></td></tr></table></figure><p>因为 maxQueueSize 太小，实际上在并发达到 30 以上的时候，就会拒绝后面的请求了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：主要是总结了一下这段时间在使用-feign-的过程中的遇到的一些坑点。&quot;&gt;&lt;a href=&quot;#摘要：主要是总结了一下这段时间在使用-feign-的过程中的遇到的一些坑点。&quot; class=&quot;headerlink&quot; title=&quot;摘要：主要是总结了一下这段时间在使用 feign 的过程中的遇到的一些坑点。&quot;&gt;&lt;/a&gt;摘要：主要是总结了一下这段时间在使用 feign 的过程中的遇到的一些坑点。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="rpc" scheme="https://www.blog.ajie39.top/categories/rpc/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="feign" scheme="https://www.blog.ajie39.top/tags/feign/"/>
    
    <category term="rpc" scheme="https://www.blog.ajie39.top/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>基于 Netty 实现在线聊天系统(实战篇一)</title>
    <link href="https://www.blog.ajie39.top/2022/07/06/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%AE%9E%E6%88%98%E7%AF%87%E4%B8%80)/"/>
    <id>https://www.blog.ajie39.top/2022/07/06/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%AE%9E%E6%88%98%E7%AF%87%E4%B8%80)/</id>
    <published>2022-07-06T06:32:33.112Z</published>
    <updated>2022-09-12T07:34:34.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：通过两篇原理篇的学习，我相信大家对于如何实现一个聊天系统已经有了一个大概的思路了。接下来我们就通过实战，来巩固一下这些知识点，并实现一个在线聊天系统吧。"><a href="#摘要：通过两篇原理篇的学习，我相信大家对于如何实现一个聊天系统已经有了一个大概的思路了。接下来我们就通过实战，来巩固一下这些知识点，并实现一个在线聊天系统吧。" class="headerlink" title="摘要：通过两篇原理篇的学习，我相信大家对于如何实现一个聊天系统已经有了一个大概的思路了。接下来我们就通过实战，来巩固一下这些知识点，并实现一个在线聊天系统吧。"></a>摘要：通过两篇原理篇的学习，我相信大家对于如何实现一个聊天系统已经有了一个大概的思路了。接下来我们就通过实战，来巩固一下这些知识点，并实现一个在线聊天系统吧。</h1><hr><h2 id="一、前提回顾"><a href="#一、前提回顾" class="headerlink" title="一、前提回顾"></a>一、前提回顾</h2><p><a href="https://www.blog.ajie39.top/2022/07/03/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%B8%80)%20/">基于 Netty 实现在线聊天系统(原理篇一)</a></p><p><a href="https://www.blog.ajie39.top/2022/07/05/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%BA%8C)%20/">基于 Netty 实现在线聊天系统(原理篇二)</a></p><h2 id="二、目录介绍"><a href="#二、目录介绍" class="headerlink" title="二、目录介绍"></a>二、目录介绍</h2><ul><li>功能梳理</li><li>具体实现</li></ul><span id="more"></span><h2 id="三、需求梳理"><a href="#三、需求梳理" class="headerlink" title="三、需求梳理"></a>三、需求梳理</h2><p>通过前面两章内容的学习，我们基本学会了如何使用 Netty 建立一个长连接，接下来我们就在这个基础上，实现一个单机版的 im 系统。</p><p>主要功能，我梳理了一下：</p><ul><li>登录</li><li>维持连接、心跳检测</li><li>聊天消息</li><li>消息ack</li></ul><p>使用到的相关组件：</p><ul><li>SpringBoot-job</li><li>GuavaCache</li></ul><h2 id="四、具体实现"><a href="#四、具体实现" class="headerlink" title="四、具体实现"></a>四、具体实现</h2><p>本期的内容是基于，原理篇一的 dome 代码基础上进行的，没有看过的原理一的小伙伴，建议先回顾一下原理篇一。</p><p>原理篇一的代码结构：</p><ul><li>Server（主程序）<ul><li>ServerHandler（业务处理程序）</li></ul></li></ul><p>实战篇一的代码结构：</p><ul><li>ImApplication（新，SpringBoot启动主程序）<ul><li>WebsocketServer（旧，基于原理篇一的 Server 代码结构进行了优化）<ul><li>WebsocketChannelInitializer（新，初始化 Channel）<ul><li>TextWebSocketFrameHandler（旧，基于原理篇一的 ServerHandler 代码结构进行了优化）<ul><li>ServerHeartBeatHandler（新，心跳处理程序）</li><li>WsMsgDispatcher（新，消息处理程序）<ul><li>UserLoginProcessor（新，登录处理程序）</li><li>HeartBeatProcessor（新，维持连接处理程序）</li><li>ChatProcessor（新，聊天处理程序）</li><li>AckProcessor（新，消息 ack 处理程序）</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>代码的层级结构如上所示，接下来，我们将会一个个模块对逻辑进行讲解。</p><h3 id="1、登录"><a href="#1、登录" class="headerlink" title="1、登录"></a>1、登录</h3><h4 id="1）实现逻辑"><a href="#1）实现逻辑" class="headerlink" title="1）实现逻辑"></a>1）实现逻辑</h4><p>不管是长连接还是短连接，鉴权这个动作都是要有的，我相信这个功能模块，大家是很好理解的。我这里就不在过多的赘述了，具体实现步骤如下所示：</p><p>1、前后端建立 ws 连接</p><p>2、前端发送登录类型的报文，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;token&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;10&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>token：这里的 token，就是用户登录标识，大家可以根据自己所依赖的业务系统，进行修改。</p><p>type：这里表示消息报文的类型，本文所有类型定义如下所示：</p><ul><li>USER_LOGIN(10, “用户上线”)</li><li>USER_LOGIN_RESP(11, “用户上线响应”)</li><li>HEARTBEAT_TIMEOUT(30, “心跳超时”)</li><li>PING(40, “心跳”)</li><li>PONG(41, “心跳响应”)</li><li>CHAT(80, “聊天”),</li><li>CHAT_RESP(81, “聊天响应”)</li><li>ACK(90, “确认”)</li><li>ACK_RESP(91, “确认响应”)</li><li>UNKNOWN(0, “未知类型”)</li></ul><p>示例代码如下图所示，WsMsgDispatcher.dispatch</p><p><img src="/img/image/blog/20220912/%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B.jpg" alt="消息类型"></p><p>3、后端对 token 进行校验，校验成功就记录用户登录信息。</p><p>示例代码如下图所示，UserLoginProcessor.login</p><p><img src="/img/image/blog/20220912/%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91.jpg" alt="登录业务逻辑"></p><h4 id="2）具体效果"><a href="#2）具体效果" class="headerlink" title="2）具体效果"></a>2）具体效果</h4><p>主要的业务代码我们已经讲解完毕了，接下来我们来看看效果：</p><p><img src="/img/image/blog/20220912/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.jpg" alt="用户登录"></p><p>从上图，我们可以看到，我们登录的两个用户都成功了，并且返回了对应的用户信息。</p><h3 id="2、维持连接、心跳检测"><a href="#2、维持连接、心跳检测" class="headerlink" title="2、维持连接、心跳检测"></a>2、维持连接、心跳检测</h3><p>这个模块的功能，其实我们在原理篇二的时候已经讲过了具体的实现方案了，这里也不再过多的赘述了，我们直接来看具体实现方法吧。</p><h4 id="1）维持连接"><a href="#1）维持连接" class="headerlink" title="1）维持连接"></a>1）维持连接</h4><p>1、前端每10秒发送一次心跳消息，报文如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;40&quot;,</span><br><span class="line">    &quot;fromId&quot;: &quot;2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：前端发送的每个消息，理论上都是需要带上用户表示的，后端都是需要进行鉴权操作的。我们这里为了方便讲解（偷懒，bushi）将这部分逻辑进行了简化，大家在具体实现的时候，记得一定要加上 <strong>鉴权逻辑</strong>。</p><p>2、后端检测，用户是否还在线，如果在线，则刷新用户的最新在线时间，并回复 PONG 消息。</p><p>示例代码如下图所示，HeartBeatProcessor.process</p><p><img src="/img/image/blog/20220912/%E7%BB%B4%E6%8C%81%E8%BF%9E%E6%8E%A51.jpg" alt="维持连接1"></p><p><img src="/img/image/blog/20220912/%E7%BB%B4%E6%8C%81%E8%BF%9E%E6%8E%A52.jpg" alt="维持连接2"></p><h4 id="2）心跳检测"><a href="#2）心跳检测" class="headerlink" title="2）心跳检测"></a>2）心跳检测</h4><p>这里主要是基于 IdleStateEvent 事件实现的。</p><p>TextWebSocketFrameHandler 继承 SimpleChannelInboundHandler 类，并实现 userEventTriggered 方法，具体代码如下所示：</p><p><img src="/img/image/blog/20220912/%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B.jpg" alt="心跳检测"></p><p>这里详细说一下，三种事件的区别：</p><ul><li>readerIdleTimeSeconds：读超时。即当在指定的时间间隔内没有从 Channel 读取到数据时，会触发一个 READER_IDLE 的 IdleStateEvent 事件。</li><li>writerIdleTimeSeconds: 写超时。即当在指定的时间间隔内没有数据写入到 Channel 时，会触发一个 WRITER_IDLE 的 IdleStateEvent 事件。</li><li>allIdleTimeSeconds: 读/写超时。即当在指定的时间间隔内没有读且没有写操作时，会触发一个 ALL_IDLE 的 IdleStateEvent 事件。</li></ul><p>所以，我们这里检测 ALL_IDLE 事件即可。</p><h4 id="3）具体效果"><a href="#3）具体效果" class="headerlink" title="3）具体效果"></a>3）具体效果</h4><p>维持连接效果如下所示：</p><p><img src="/img/image/blog/20220912/%E7%BB%B4%E6%8C%81%E8%BF%9E%E6%8E%A5%E6%95%88%E6%9E%9C.jpg" alt="维持连接效果"></p><p>心跳检测效果如下所示：</p><p><img src="/img/image/blog/20220912/%E5%BF%83%E8%B7%B3%E8%B6%85%E6%97%B6%E6%95%88%E6%9E%9C1.jpg" alt="心跳超时效果1"></p><p><img src="/img/image/blog/20220912/%E5%BF%83%E8%B7%B3%E8%B6%85%E6%97%B6%E6%95%88%E6%9E%9C2.jpg" alt="心跳超时效果2"></p><h3 id="3、聊天消息"><a href="#3、聊天消息" class="headerlink" title="3、聊天消息"></a>3、聊天消息</h3><p>聊天消息模块主要分为两部分：</p><ul><li>消息接收：客户端推送消息到服务端</li><li>消息推送：服务端将消息推送到指定的客户端</li></ul><p>这边主要的难点在于，服务端将消息推送到指定的客户端，具体场景有2种情况：</p><ul><li>消息的发送者和消息的接受者，在同一台服务器上建立的 ws 连接，这种情况，就很好处理，直接在服务器上找到建立的 ws 连接，然后将消息推送给对应的客户端。</li><li>消息的发送者和消息的接受者，在不同的服务器上建立的 ws 连接，这种情况就比较复杂，实现方案也很多，比较简单的实现方式就是，发送一条广播消息，让对应的服务器，将消息推送到指定的客户端。</li></ul><p>本文由于是 <strong>单机版</strong> 的 im，所以只会有第一种情况发生，第二种情况就留给大家自由发挥了。</p><h4 id="1）消息接收"><a href="#1）消息接收" class="headerlink" title="1）消息接收"></a>1）消息接收</h4><p>具体步骤如下所示：</p><p>1、客户端发送类型为80的报文，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;80&quot;,</span><br><span class="line">    &quot;fromId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;toId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;content&quot;: &#123;</span><br><span class="line">        &quot;contentType&quot;: 1,</span><br><span class="line">        &quot;body&quot;: &quot;测试消息&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、服务端(ChatProcessor)对消息进行处理，具体代码如下所示：</p><p><img src="/img/image/blog/20220912/%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6.png" alt="消息接收"></p><h4 id="2）消息推送"><a href="#2）消息推送" class="headerlink" title="2）消息推送"></a>2）消息推送</h4><p>具体步骤如下所示：</p><p>1、获取消息接受者所连接的服务器 ip 地址<br>2、判断当前服务器 ip 地址是否和上面的 ip 地址相同，如果相同则推送消息，否则转发给目标服务器</p><p>具体代码如下所示:</p><p><img src="/img/image/blog/20220912/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81.png" alt="消息推送"></p><h4 id="3）具体效果-1"><a href="#3）具体效果-1" class="headerlink" title="3）具体效果"></a>3）具体效果</h4><p>1、我们先登录两个用户，分别是张三、李四，如下图所示：</p><p><img src="/img/image/blog/20220912/%E8%81%8A%E5%A4%A9%E7%99%BB%E5%BD%95.png" alt="聊天登录"></p><p>2、张三发送消息给李四，如下图所示：</p><p><img src="/img/image/blog/20220912/%E5%BC%A0%E4%B8%89%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%BB%99%E6%9D%8E%E5%9B%9B.png" alt="张三发送消息给李四"></p><p>3、李四发送消息给张三，如下图所示：</p><p><img src="/img/image/blog/20220912/%E6%9D%8E%E5%9B%9B%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%BB%99%E5%BC%A0%E4%B8%89.png" alt="李四发送消息给张三"></p><h3 id="4、消息-ack"><a href="#4、消息-ack" class="headerlink" title="4、消息 ack"></a>4、消息 ack</h3><p>因为网络环境异常或者其他异常状况的发送，可能会出现消息推送失败的情况，这时候就需要 消息 ack 机制和重试，来保证我们的消息可以推送成功。</p><h4 id="1）消息-ack-机制"><a href="#1）消息-ack-机制" class="headerlink" title="1）消息 ack 机制"></a>1）消息 ack 机制</h4><p>具体步骤如下：</p><p>1、客户端收到 80 类型的消息，解析并发送 ack 报文，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;90&quot;,</span><br><span class="line">    &quot;msgId&quot;: &quot;2bfea133-72a8-4315-82aa-80049fe4fb7b&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、服务端收到 ack 消息，变更消息状态(AckProcessor)，具体代码如下图所示：</p><p><img src="/img/image/blog/20220912/%E6%B6%88%E6%81%AFack.png" alt="消息ack"></p><h4 id="2）消息重试"><a href="#2）消息重试" class="headerlink" title="2）消息重试"></a>2）消息重试</h4><p>这里因为是单机版 im，所以直接采用 SpringBoot-Job 实现，Job 代码如下所示：</p><p><img src="/img/image/blog/20220912/%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95.png" alt="消息重试"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了我们实战篇一，到这里结束了，希望大家都能跟着文中的思路，具体去实现一遍，如果遇到什么问题或者文中有什么错误的地方，欢迎大家留言。谢谢观看，点个赞再走吧。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：通过两篇原理篇的学习，我相信大家对于如何实现一个聊天系统已经有了一个大概的思路了。接下来我们就通过实战，来巩固一下这些知识点，并实现一个在线聊天系统吧。&quot;&gt;&lt;a href=&quot;#摘要：通过两篇原理篇的学习，我相信大家对于如何实现一个聊天系统已经有了一个大概的思路了。接下来我们就通过实战，来巩固一下这些知识点，并实现一个在线聊天系统吧。&quot; class=&quot;headerlink&quot; title=&quot;摘要：通过两篇原理篇的学习，我相信大家对于如何实现一个聊天系统已经有了一个大概的思路了。接下来我们就通过实战，来巩固一下这些知识点，并实现一个在线聊天系统吧。&quot;&gt;&lt;/a&gt;摘要：通过两篇原理篇的学习，我相信大家对于如何实现一个聊天系统已经有了一个大概的思路了。接下来我们就通过实战，来巩固一下这些知识点，并实现一个在线聊天系统吧。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、前提回顾&quot;&gt;&lt;a href=&quot;#一、前提回顾&quot; class=&quot;headerlink&quot; title=&quot;一、前提回顾&quot;&gt;&lt;/a&gt;一、前提回顾&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2022/07/03/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%B8%80)%20/&quot;&gt;基于 Netty 实现在线聊天系统(原理篇一)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2022/07/05/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%BA%8C)%20/&quot;&gt;基于 Netty 实现在线聊天系统(原理篇二)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、目录介绍&quot;&gt;&lt;a href=&quot;#二、目录介绍&quot; class=&quot;headerlink&quot; title=&quot;二、目录介绍&quot;&gt;&lt;/a&gt;二、目录介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;功能梳理&lt;/li&gt;
&lt;li&gt;具体实现&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="Netty" scheme="https://www.blog.ajie39.top/categories/Netty/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="Netty" scheme="https://www.blog.ajie39.top/tags/Netty/"/>
    
    <category term="IM" scheme="https://www.blog.ajie39.top/tags/IM/"/>
    
  </entry>
  
  <entry>
    <title>基于 Netty 实现在线聊天系统(原理篇二)</title>
    <link href="https://www.blog.ajie39.top/2022/07/05/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%BA%8C)%20/"/>
    <id>https://www.blog.ajie39.top/2022/07/05/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%BA%8C)%20/</id>
    <published>2022-07-05T06:37:04.718Z</published>
    <updated>2022-07-05T09:52:19.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：上一篇文章我们了解-Netty-的一些基本原理，并且写了一个简单的-WebSocket-服务端。接下来我们来详细的了解一下-WebSocket-相关的知识点。"><a href="#摘要：上一篇文章我们了解-Netty-的一些基本原理，并且写了一个简单的-WebSocket-服务端。接下来我们来详细的了解一下-WebSocket-相关的知识点。" class="headerlink" title="摘要：上一篇文章我们了解 Netty 的一些基本原理，并且写了一个简单的 WebSocket 服务端。接下来我们来详细的了解一下 WebSocket 相关的知识点。"></a>摘要：上一篇文章我们了解 Netty 的一些基本原理，并且写了一个简单的 WebSocket 服务端。接下来我们来详细的了解一下 WebSocket 相关的知识点。</h1><hr><h2 id="一、前提回顾"><a href="#一、前提回顾" class="headerlink" title="一、前提回顾"></a>一、前提回顾</h2><p><a href="https://www.blog.ajie39.top/2022/07/03/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%B8%80)%20/">基于 Netty 实现在线聊天系统(原理篇一)</a></p><h2 id="二、目录介绍"><a href="#二、目录介绍" class="headerlink" title="二、目录介绍"></a>二、目录介绍</h2><ul><li>什么是 WebSocket？</li><li>WebSocket 如何建立连接？</li><li>WebSocket 数据传输</li><li>WebSocket 如何维持连接？</li></ul><span id="more"></span><h2 id="三、什么是-WebSocket？"><a href="#三、什么是-WebSocket？" class="headerlink" title="三、什么是 WebSocket？"></a>三、什么是 WebSocket？</h2><p>WebSocket 是一种 <strong>网络传输协议</strong>，可在单个 TCP 连接上进行全双工通信，位于 OSI 模型的应用层。</p><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，<strong>允许服务端主动向客户端推送数据</strong>。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就可以建立持久性的连接，并进行双向数据传输。</p><p>WebSocket 协议规范将 <strong>ws（WebSocket）</strong> 和 <strong>wss（WebSocket Secure）</strong> 定义为两个新的统一资源标识符（URI）方案，分别对应明文和加密连接。除了方案名称和片段ID（不支持#）之外，其余的 URI 组件都被定义为此 URI 的通用语法。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ws:&#x2F;&#x2F;example.com&#x2F;api</span><br><span class="line">wss:&#x2F;&#x2F;example.com&#x2F;api</span><br><span class="line"></span><br><span class="line">wss 表示使用了 TLS 的 Websocket</span><br></pre></td></tr></table></figure><p>大多数浏览器都支持 WebSocket 协议，比如：</p><ul><li>Google Chrome</li><li>Firefox、Safari</li><li>Microsoft Edge</li><li>Internet Explorer</li><li>Opera</li></ul><h3 id="WebSocket-的优点"><a href="#WebSocket-的优点" class="headerlink" title="WebSocket 的优点"></a>WebSocket 的优点</h3><p>1、<strong>较少的控制开销</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在连接建立后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。</span><br><span class="line">在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；</span><br><span class="line">对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。</span><br><span class="line">相对于 HTTP 请求每次都要携带完整的头部，此项开销显著减少了。</span><br></pre></td></tr></table></figure><p>2、<strong>更强的实时性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。</span><br><span class="line">相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少；</span><br><span class="line">即使是和 Comet 等类似的长轮询比较，其也能在短时间内更多次地传递数据。</span><br></pre></td></tr></table></figure><p>3、<strong>保持连接状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">与 HTTP 不同的是，Websocket 需要先建立连接；</span><br><span class="line">这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。</span><br><span class="line">而 HTTP 请求可能需要在每个请求都携带状态信息（如身份认证等）。</span><br></pre></td></tr></table></figure><p>4、<strong>更好的二进制支持</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Websocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。</span><br></pre></td></tr></table></figure><p>5、<strong>可以支持扩展</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Websocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。</span><br><span class="line">如部分浏览器支持压缩等。</span><br></pre></td></tr></table></figure><p>6、<strong>更好的压缩效果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相对于 HTTP 压缩，Websocket 在适当的扩展支持下，可以沿用之前内容的上下文;</span><br><span class="line">在传递类似的数据时，可以显著地提高压缩率。</span><br></pre></td></tr></table></figure><h2 id="四、WebSocket-如何建立连接？"><a href="#四、WebSocket-如何建立连接？" class="headerlink" title="四、WebSocket 如何建立连接？"></a>四、WebSocket 如何建立连接？</h2><p>WebSocket 是独立的、建立在 TCP 上的协议。</p><p>Websocket 通过 HTTP/1.1 协议的101状态码进行握手。</p><p>为了建立 Websocket 连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（Handshaking）。</p><p>一个典型的 Websocket 握手请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">客户端请求：</span><br><span class="line"></span><br><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line"></span><br><span class="line">服务器回应：</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><ul><li>Connection：必须设置 Upgrade，表示客户端希望连接升级。</li><li>Upgrade：字段必须设置 Websocket，表示希望升级到 Websocket 协议。</li><li>Sec-WebSocket-Key：是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。把 “Sec-WebSocket-Key” 加上一个特殊字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” ，然后计算 SHA-1 摘要，之后进行 Base64 编码，将结果做为 “Sec-WebSocket-Accept” 头的值，返回给客户端。如此操作，<strong>可以尽量避免普通 HTTP 请求被误认为 Websocket 协议</strong>。</li><li>Sec-WebSocket-Version：表示支持的 Websocket 版本。RFC6455 要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin：Origin 字段是必须的。如果缺少 origin 字段，WebSocket 服务器需要回复 HTTP 403 状态码（禁止访问）。</li></ul><h2 id="五、WebSocket-数据传输"><a href="#五、WebSocket-数据传输" class="headerlink" title="五、WebSocket 数据传输"></a>五、WebSocket 数据传输</h2><p>WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</p><ul><li>发送端：将消息切割成多个帧，并发送给服务端。</li><li>接收端：接收消息帧，并将关联的帧重新组装成完整的消息。</li></ul><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p>接下来，我们来了解一下数据帧的格式。详细定义参考 <a href="https://datatracker.ietf.org/doc/html/rfc6455#section-5.2">RFC6455 5.2节</a>。</p><p>WebSocket 数据帧的统一格式，如下图所示：</p><p><img src="/img/image/blog/20220705/%E6%95%B0%E6%8D%AE%E5%B8%A7.png" alt="数据帧"></p><p><strong>FIN：1个比特</strong></p><p>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p><p><strong>RSV1, RSV2, RSV3：各占1个比特</strong></p><p>一般情况下全为0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用 WebSocket 扩展，连接出错。</p><p><strong>Opcode: 4个比特</strong></p><p>操作代码，Opcode 的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。</p><p>可选的操作代码如下：</p><ul><li>%x0：表示一个延续帧。当 Opcode 为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li><li>%x1：表示这是一个文本帧（frame）。</li><li>%x2：表示这是一个二进制帧（frame）。</li><li>%x3-7：保留的操作代码，用于后续定义的非控制帧。</li><li>%x8：表示连接断开。</li><li>%x9：表示这是一个ping操作。</li><li>%xA：表示这是一个pong操作。</li><li>%xB-F：保留的操作代码，用于后续定义的控制帧。</li></ul><p><strong>Mask: 1个比特</strong></p><p><strong>表示是否要对数据载荷进行掩码操作</strong>。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p><p>如果 Mask 是1，那么在 Masking-key 中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。<strong>所有客户端发送到服务端的数据帧，Mask 都是 1。</strong></p><p><strong>Payload length</strong></p><p>数据载荷的长度，单位是字节。为7位、7+16位，或7+64位。</p><p>假设数 Payload length == x，则</p><ul><li>x 为 0~125，则数据的长度为 x 字节。</li><li>x 为 126，则后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。</li><li>x 为 127，则后续8个字节代表一个64位的无符号整数（最高位必须为0），该无符号整数的值为数据的长度。</li></ul><p><strong>Masking-key：0 or 4字节</strong></p><p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask 为1，且携带了4字节的 Masking-key。如果 Mask 为0，则没有 Masking-key。</p><p>备注：载荷数据的长度，不包括 Masking-key 的长度。</p><p><strong>Payload data：(x+y) 字节</strong></p><p>载荷数据：包括了 Extension data(扩展数据)、Application data(应用数据)。其中，扩展数据 x 字节，应用数据 y 字节。</p><ul><li>Extension data(扩展数据): 如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</li><li>Application data(应用数据): 任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度减去扩展数据长度，就得到应用数据的长度。</li></ul><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>WebSocket 客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><p>WebSocket 的每条消息可能被切分成多个数据帧。当 WebSocket 的接收方收到一个数据帧时，会根据 FIN 的值来判断，是否已经收到消息的最后一个数据帧。</p><ul><li>FIN=1 表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。</li><li>FIN=0，则接收方还需要继续监听接收其余的数据帧。</li></ul><p>opcode 在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Client: FIN&#x3D;1, opcode&#x3D;0x1, msg&#x3D;&quot;你好，Server&quot;</span><br><span class="line">Server: (消息立即被处理) &quot;你好，Client&quot;.</span><br><span class="line">Client: FIN&#x3D;0, opcode&#x3D;0x1, msg&#x3D;&quot;Hello&quot;</span><br><span class="line">Server: (继续等待后续消息)</span><br><span class="line">Client: FIN&#x3D;1, opcode&#x3D;0x0, msg&#x3D;&quot;world!&quot;</span><br><span class="line">Server: (处理完成消息) &quot;good!&quot;</span><br></pre></td></tr></table></figure><p>第一条消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIN&#x3D;1, 表示是当前消息的最后一个数据帧。</span><br><span class="line">opcode&#x3D;0x1，表示客户端发送的是文本类型。</span><br></pre></td></tr></table></figure><p>第二条消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIN&#x3D;0，opcode&#x3D;0x1，表示发送的是文本类型，且消息还没发送完成。</span><br><span class="line">FIN&#x3D;1，opcode&#x3D;0x0，表示消息已经发送完成，没有后续的数据帧。</span><br></pre></td></tr></table></figure><h2 id="六、WebSocket-如何维持连接？"><a href="#六、WebSocket-如何维持连接？" class="headerlink" title="六、WebSocket 如何维持连接？"></a>六、WebSocket 如何维持连接？</h2><p>当浏览器对 WebSocket 建立的长连接都有节能策略，即 <strong>持续一段时间内没有数据传输时，浏览器会主动断开长连接</strong>。因此，我们如果需要维持长连接长时间不断开，需要设计特定的心跳来维持这条 WebSocket 连接，即心跳机制。</p><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>心跳机制是每隔一段时间会向服务器发送一个数据包，告诉服务器自己还活着，同时客户端会确认服务器端是否还活着，如果还活着的话，就会回传一个数据包给客户端来确定服务器端也还活着，否则的话，有可能是网络断开连接了，需要重连（服务器回复是用来检测网络和后端是否正常工作）。</p><p>注意：<strong>Nginx 中也有相关的长连接维持时长设置。</strong> 如果 WebSocket 连接在间隔比较短的时间就被后端主动断开（即触发close事件），而前端没有触发任何关闭操作，可以检查下 Nginx 相关配置项。</p><h3 id="如何处理断网或者后端异常情况"><a href="#如何处理断网或者后端异常情况" class="headerlink" title="如何处理断网或者后端异常情况"></a>如何处理断网或者后端异常情况</h3><p>在浏览器网络断开的情况下，WebSocket 是不会收到任何的事件的。由于 WebSocket 在断网时的表现和在线时无消息收发的状态无法区分，我们需要用其他的方法来进行判断和区分。</p><p>具体的方法有如下几种：</p><ul><li><strong>使用心跳包</strong>。我们在发送心跳包后，会收到相关的返回数据。如果我们无法收到此数据，就认为目前网络或者后端异常。</li><li><strong>offline事件</strong>。浏览器会在断网后给页面发送一个offline事件（不准确，可以作为参考），我们可以根据此事件来断开长连接。</li></ul><h3 id="如何快速的恢复连接"><a href="#如何快速的恢复连接" class="headerlink" title="如何快速的恢复连接"></a>如何快速的恢复连接</h3><p>当网络恢复时，我们需要快速的恢复长连接。我们可以根据以下几个方案，来恢复我们的 WebSocket 连接。</p><ul><li><strong>递增重试的时长</strong>：当我们短卡网络时，我们立即设置一个递增的时长（如 1,2,3,5,10,20 秒）来尝试恢复长连接。</li><li><strong>online 事件重置重试的时长</strong>：在浏览器网络恢复时，会发送一个online事件（同样不准确）。在监听到 online 事件时，我们只需要重置这个时长，立即尝试恢复即可（因为 online 事件触发时，网络仍然有可能处于抖动状态）。</li><li><strong>检测休眠重置重试的时长</strong>：当浏览器休眠时，JavaScript 不会执行。当电脑被唤醒时，如果 online 事件没有触发，那么重试的时长有可能由于多次尝试变成一个较大的值。因此我们在检测到休眠被唤醒后，需要立即重置重试的时长。具体方法为：设置一个setInterval，每次判断上次执行与本次执行时长间隔。因为休眠时 JavaScript 不会执行，因此，如果间隔时长较大（超过设置阈值），我们就认为电脑休眠被唤醒了。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.m.wikipedia.org/zh-hans/WebSocket">维基百科—WebSocket</a></li><li><a href="https://datatracker.ietf.org/doc/html/rfc6455">rfc6455</a></li><li><a href="https://cloud.tencent.com/developer/article/1341903">WebSocket系列之如何建立和维护可靠的连接</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：上一篇文章我们了解-Netty-的一些基本原理，并且写了一个简单的-WebSocket-服务端。接下来我们来详细的了解一下-WebSocket-相关的知识点。&quot;&gt;&lt;a href=&quot;#摘要：上一篇文章我们了解-Netty-的一些基本原理，并且写了一个简单的-WebSocket-服务端。接下来我们来详细的了解一下-WebSocket-相关的知识点。&quot; class=&quot;headerlink&quot; title=&quot;摘要：上一篇文章我们了解 Netty 的一些基本原理，并且写了一个简单的 WebSocket 服务端。接下来我们来详细的了解一下 WebSocket 相关的知识点。&quot;&gt;&lt;/a&gt;摘要：上一篇文章我们了解 Netty 的一些基本原理，并且写了一个简单的 WebSocket 服务端。接下来我们来详细的了解一下 WebSocket 相关的知识点。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、前提回顾&quot;&gt;&lt;a href=&quot;#一、前提回顾&quot; class=&quot;headerlink&quot; title=&quot;一、前提回顾&quot;&gt;&lt;/a&gt;一、前提回顾&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2022/07/03/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%B8%80)%20/&quot;&gt;基于 Netty 实现在线聊天系统(原理篇一)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、目录介绍&quot;&gt;&lt;a href=&quot;#二、目录介绍&quot; class=&quot;headerlink&quot; title=&quot;二、目录介绍&quot;&gt;&lt;/a&gt;二、目录介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是 WebSocket？&lt;/li&gt;
&lt;li&gt;WebSocket 如何建立连接？&lt;/li&gt;
&lt;li&gt;WebSocket 数据传输&lt;/li&gt;
&lt;li&gt;WebSocket 如何维持连接？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="Netty" scheme="https://www.blog.ajie39.top/categories/Netty/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="Netty" scheme="https://www.blog.ajie39.top/tags/Netty/"/>
    
    <category term="IM" scheme="https://www.blog.ajie39.top/tags/IM/"/>
    
    <category term="WebSocket" scheme="https://www.blog.ajie39.top/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>基于 Netty 实现在线聊天系统(原理篇一)</title>
    <link href="https://www.blog.ajie39.top/2022/07/03/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%B8%80)%20/"/>
    <id>https://www.blog.ajie39.top/2022/07/03/%E5%9F%BA%E4%BA%8E%20Netty%20%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F(%E5%8E%9F%E7%90%86%E7%AF%87%E4%B8%80)%20/</id>
    <published>2022-07-03T06:40:17.103Z</published>
    <updated>2022-07-03T18:14:17.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：边学-Netty-相关原理，边实现一个在线聊天系统。本篇文章主要讲述一些-Netty-的基本原理、流程，可能有点枯燥，不过也很重要，相关-demo-代码最好可以自己动手敲一遍，这样更容易理解。不过也不必担心过于复杂，这只是相当于-Netty-的-Hello-World。"><a href="#摘要：边学-Netty-相关原理，边实现一个在线聊天系统。本篇文章主要讲述一些-Netty-的基本原理、流程，可能有点枯燥，不过也很重要，相关-demo-代码最好可以自己动手敲一遍，这样更容易理解。不过也不必担心过于复杂，这只是相当于-Netty-的-Hello-World。" class="headerlink" title="摘要：边学 Netty 相关原理，边实现一个在线聊天系统。本篇文章主要讲述一些 Netty 的基本原理、流程，可能有点枯燥，不过也很重要，相关 demo 代码最好可以自己动手敲一遍，这样更容易理解。不过也不必担心过于复杂，这只是相当于 Netty 的 Hello World。"></a>摘要：边学 Netty 相关原理，边实现一个在线聊天系统。本篇文章主要讲述一些 Netty 的基本原理、流程，可能有点枯燥，不过也很重要，相关 demo 代码最好可以自己动手敲一遍，这样更容易理解。不过也不必担心过于复杂，这只是相当于 Netty 的 Hello World。</h1><hr><h2 id="一、目录介绍"><a href="#一、目录介绍" class="headerlink" title="一、目录介绍"></a>一、目录介绍</h2><ul><li>前置知识点<ul><li>NIO</li></ul></li><li>Netty 的核心组件<ul><li>Channel</li><li>Callback</li><li>Future 和 Promise</li><li>事件和 ChannelHandler</li></ul></li><li>Hello World</li></ul><span id="more"></span><h2 id="二、前置知识点"><a href="#二、前置知识点" class="headerlink" title="二、前置知识点"></a>二、前置知识点</h2><h3 id="1、NIO"><a href="#1、NIO" class="headerlink" title="1、NIO"></a>1、NIO</h3><p>首先我们需要回顾一下，同步、异步、阻塞、非阻塞的相关概念。</p><ul><li>同步：调用 API 后，调用者能“马上”就知道操作的结果。</li><li>异步：相对于同步，调用 API 后，调用者不能“马上”知道操作的结果，要等被调用方 <strong>回调</strong> 通知结果。</li><li>阻塞：等待全部数据读取(写入)完成后，才返回。</li><li>非阻塞：读取时，读多少返回多少；写入时，写入多少返回多少。<strong>不用等待，全部数据完成操作后，才返回。</strong></li></ul><p>NIO 是一种 <strong>同步非阻塞</strong> 的 <strong>I/O模型</strong>。</p><ul><li>同步是指线程不断轮询 I/O 事件是否就绪。</li><li>非阻塞是指线程在等待 I/O 的时候，可以同时做其他任务。</li></ul><p>同步的核心是 <strong>选择器</strong>，选择器代替了线程本身轮询 I/O 事件，避免了阻塞同时减少了不必要的线程消耗；非阻塞的核心就是 <strong>通道和缓冲区</strong>，当 I/O 事件就绪时，可以通过写到缓冲区，保证 I/O 的成功，而无需线程阻塞式地等待。</p><p>NIO主要有三大核心部分：</p><ul><li>Channel(通道)</li><li>Buffer(缓冲区)</li><li>Selector(选择器)</li></ul><p>传统 I/O 基于 <strong>字节流和字符流</strong> 进行操作，而 NIO 基于 Channel 和 Buffer 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector 用于监听多个通道的事件（连接打开，数据到达等）。因此，单个线程可以监听多个数据通道，如下图所示：</p><p><img src="/img/image/blog/20220704/NIO.png" alt="NIO"></p><h2 id="三、Netty-的核心组件"><a href="#三、Netty-的核心组件" class="headerlink" title="三、Netty 的核心组件"></a>三、Netty 的核心组件</h2><h3 id="1、Channel"><a href="#1、Channel" class="headerlink" title="1、Channel"></a>1、Channel</h3><p>Channel 是一个通道，用于连接字节缓冲区 Buffer 和另一端的实体。在 NIO 网络编程模型中，服务端和客户端进行 I/O 数据交互（得到彼此推送的信息）的媒介就是 Channel。</p><p>Netty 对 JDK 原生的 ServerSocketChannel 进行了封装和增强。</p><p>Netty的Channel增加了如下的组件：</p><ul><li>id 标识唯一身份信息</li><li>可能存在的 parent Channel</li><li>管道 pepiline</li><li>用于数据读写的 unsafe 内部类</li><li>事件循环执行器 NioEventLoop</li></ul><p>Channel可以分成两类:</p><ul><li>服务端: NioServerSocketChannel</li><li>客户端: NioSocketChannel</li></ul><p>具体依赖关系如下图所示：</p><p>服务端: NioServerSocketChannel</p><p><img src="/img/image/blog/20220704/NioServerSocketChannel.png" alt="NioServerSocketChannel"></p><p>客户端: NioSocketChannel</p><p><img src="/img/image/blog/20220704/NioSocketChannel.png" alt="NioSocketChannel"></p><h3 id="2、Callback"><a href="#2、Callback" class="headerlink" title="2、Callback"></a>2、Callback</h3><p>callback 就是回调，一个方法可以在适当的时候回过头来调用这个 callback 方法。callback 是用于通知相关方某个操作已经完成最常用的方法之一。</p><p>Netty 在处理事件时内部使用了 callback。当一个 callback 被触发，事件可以被 ChannelHandler 的接口实现处理。</p><p>一个简单的例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    &#x2F;&#x2F; 当一个新的连接建立时，channelActive 被调用</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">           System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当一个新的连接建立后，ChannelHandler 的 callback 方法 channelActive() 会被调用，然后打印一条消息。</span><br></pre></td></tr></table></figure><p>这个 ConnectHandler 实例（相当于被调用者）以参数的形式传入创建 Channel 连接的函数（调用者）中，之后这个函数创建新连接后，就会回来调用这个 ConnectHandler 的 channelActive 方法，这个过程就叫回调。</p><h3 id="3、Future-和-Promise"><a href="#3、Future-和-Promise" class="headerlink" title="3、Future 和 Promise"></a>3、Future 和 Promise</h3><p>Future 和 Promise 起源于函数式编程，目的是将值（Future）与其计算方式（Promise）分离，从而允许更灵活地进行计算，特别是通过并行化。</p><p>Future 表示目标计算的返回值，Promise 表示计算的方式，这个模型将返回结果和计算逻辑分离，目的是为了让计算逻辑不影响返回结果，从而抽象出一套异步编程模型。它们之间的纽带就是 Callback。</p><p>简单来说：Future 表示一个 <strong>异步任务的结果</strong>，针对这个结果可以添加 Callback 方法以便在任务 <strong>执行成功或失败后做出对应的操作</strong>，而 Promise 交由任务执行者，任务执行者通过 Promise 可以标记任务完成或者失败。</p><p>在 Netty 中：</p><ul><li>Future 接口定义了 isSuccess()，isCancellable()，cause() 等方法，这些判断异步执行状态的方法都是只读的。</li><li>Promise 接口在 extends Future 的基础上增加了 setSuccess()，setFailure() 等方法，这些方法是可写的，即 Promise 是可写的 Future。</li></ul><h3 id="4、事件-event-和-ChannelHandler"><a href="#4、事件-event-和-ChannelHandler" class="headerlink" title="4、事件(event) 和 ChannelHandler"></a>4、事件(event) 和 ChannelHandler</h3><h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p>Netty 是一个事件驱动的框架，所有的 event(事件) 都是由 Handler 来进行处理。</p><p>ChannelHandler 可以处理 I/O、拦截 I/O 或者将 event 传递给 ChannelPipeline 中的下一个 Handler 进行处理。</p><p>ChannelHandler 的结构很简单，只有三个方法，分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void handlerAdded(ChannelHandlerContext ctx) throws Exception;</span><br><span class="line">void handlerRemoved(ChannelHandlerContext ctx) throws Exception;</span><br><span class="line">void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;</span><br></pre></td></tr></table></figure><h4 id="event"><a href="#event" class="headerlink" title="event"></a>event</h4><p>Netty 用细分的 event(事件) 来通知我们状态的变化或者操作的状况。这让我们可以基于发的 event 来触发适当的行为。这类行为可能包括：</p><ul><li>日志记录</li><li>数据传送</li><li>流控制</li><li>应用逻辑</li></ul><p>event 按输入或者输出数据流的关系来分类。可能被输入数据或者相关状态改变触发的 event 包括：</p><ul><li>活跃或者停用的连接</li><li>读数据</li><li>用户 event</li><li>错误 event</li></ul><p>而输出 event 则是会触发将来行为的操作的结果，可能会是：</p><ul><li>打开或者关闭到远端的连接</li><li>写或者刷数据到一个 socket</li></ul><p>每一个 event 都可以被分派到一个用户实现的 handler 对象的方法。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>一个简单的 websocket 服务端，如下所示：</p><p>Server 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.channel.ChannelFuture;</span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.ChannelOption;</span><br><span class="line">import io.netty.channel.ChannelPipeline;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line">import io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line">import io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line">import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class="line">import io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketServerCompressionHandler;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; 用来接收客户端传进来的连接</span><br><span class="line">        NioEventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        &#x2F;&#x2F; 用来处理已被接收的连接</span><br><span class="line">        NioEventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">        &#x2F;&#x2F; 创建 netty 服务</span><br><span class="line">        ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();</span><br><span class="line">        try &#123;</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    &#x2F;&#x2F; 设置 NIO 模式</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    &#x2F;&#x2F; 设置 tcp 缓冲区</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                    &#x2F;&#x2F; 设置发送缓冲区数据大小</span><br><span class="line">                    .childOption(ChannelOption.SO_SNDBUF, 64 * 1024)</span><br><span class="line">                    &#x2F;&#x2F; 设置接收缓冲区数据大小</span><br><span class="line">                    .option(ChannelOption.SO_RCVBUF, 64 * 1024)</span><br><span class="line">                    &#x2F;&#x2F; 保持长连接</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline pipeline &#x3D; ch.pipeline();</span><br><span class="line">                            &#x2F;&#x2F; HttpClient编解码器</span><br><span class="line">                            pipeline.addLast(new HttpServerCodec());</span><br><span class="line">                            &#x2F;&#x2F; 设置最大内容长度</span><br><span class="line">                            pipeline.addLast(new HttpObjectAggregator(65536));</span><br><span class="line">                            &#x2F;&#x2F; WebSocket 数据压缩扩展</span><br><span class="line">                            pipeline.addLast(new WebSocketServerCompressionHandler());</span><br><span class="line">                            &#x2F;&#x2F; WebSocket 握手、控制帧处理</span><br><span class="line">                            pipeline.addLast(new WebSocketServerProtocolHandler(&quot;&#x2F;&quot;, null, true));</span><br><span class="line">                            &#x2F;&#x2F; 通道的初始化，数据传输过来进行拦截及执行</span><br><span class="line">                            pipeline.addLast(new ServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#x2F;&#x2F; 绑定端口启动服务</span><br><span class="line">            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServerHandler 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line">import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"></span><br><span class="line">public class ServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;通道激活（回调）&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 仅处理 TextWebSocketFrame</span><br><span class="line">        if (msg instanceof TextWebSocketFrame) &#123;</span><br><span class="line">            String request &#x3D; ((TextWebSocketFrame) msg).text();</span><br><span class="line">            System.out.println(&quot;收到请求：&quot; + request);</span><br><span class="line">            ctx.writeAndFlush(new TextWebSocketFrame(&quot;PONG&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;数据读取完成&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pom 依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.1.6.Final&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>然后运行 Server 即可。</p><p>接下来我们来测试一下程序是否正常，这里使用到一个在线测试网站：<a href="http://www.easyswoole.com/wstool.html">http://www.easyswoole.com/wstool.html</a></p><p>连接上我们的服务，如下图所示：</p><p><img src="/img/image/blog/20220704/%E8%BF%9E%E6%8E%A5websocket.png" alt="连接websocket"></p><p>如果出现 OPENED =&gt; 127.0.0.1:8080 的提示，则表示连接成功。否则请排查是否程序和示例代码一致。</p><p>然后我们点击开始发送按钮，如果出现以下提示则表示，消息发送成功啦。</p><p><img src="/img/image/blog/20220704/%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF1.png" alt="发送消息1"></p><p><img src="/img/image/blog/20220704/%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF2.png" alt="发送消息2"></p><p>好了到这里，我们的 Hello World 已经完成了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：边学-Netty-相关原理，边实现一个在线聊天系统。本篇文章主要讲述一些-Netty-的基本原理、流程，可能有点枯燥，不过也很重要，相关-demo-代码最好可以自己动手敲一遍，这样更容易理解。不过也不必担心过于复杂，这只是相当于-Netty-的-Hello-World。&quot;&gt;&lt;a href=&quot;#摘要：边学-Netty-相关原理，边实现一个在线聊天系统。本篇文章主要讲述一些-Netty-的基本原理、流程，可能有点枯燥，不过也很重要，相关-demo-代码最好可以自己动手敲一遍，这样更容易理解。不过也不必担心过于复杂，这只是相当于-Netty-的-Hello-World。&quot; class=&quot;headerlink&quot; title=&quot;摘要：边学 Netty 相关原理，边实现一个在线聊天系统。本篇文章主要讲述一些 Netty 的基本原理、流程，可能有点枯燥，不过也很重要，相关 demo 代码最好可以自己动手敲一遍，这样更容易理解。不过也不必担心过于复杂，这只是相当于 Netty 的 Hello World。&quot;&gt;&lt;/a&gt;摘要：边学 Netty 相关原理，边实现一个在线聊天系统。本篇文章主要讲述一些 Netty 的基本原理、流程，可能有点枯燥，不过也很重要，相关 demo 代码最好可以自己动手敲一遍，这样更容易理解。不过也不必担心过于复杂，这只是相当于 Netty 的 Hello World。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、目录介绍&quot;&gt;&lt;a href=&quot;#一、目录介绍&quot; class=&quot;headerlink&quot; title=&quot;一、目录介绍&quot;&gt;&lt;/a&gt;一、目录介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前置知识点&lt;ul&gt;
&lt;li&gt;NIO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Netty 的核心组件&lt;ul&gt;
&lt;li&gt;Channel&lt;/li&gt;
&lt;li&gt;Callback&lt;/li&gt;
&lt;li&gt;Future 和 Promise&lt;/li&gt;
&lt;li&gt;事件和 ChannelHandler&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hello World&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="Netty" scheme="https://www.blog.ajie39.top/categories/Netty/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="Netty" scheme="https://www.blog.ajie39.top/tags/Netty/"/>
    
    <category term="IM" scheme="https://www.blog.ajie39.top/tags/IM/"/>
    
  </entry>
  
  <entry>
    <title>redis 大 key 问题总结(附Go小工具)</title>
    <link href="https://www.blog.ajie39.top/2022/06/22/redis%E5%A4%A7key%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93(%E9%99%84Go%E5%B0%8F%E5%B7%A5%E5%85%B7)/"/>
    <id>https://www.blog.ajie39.top/2022/06/22/redis%E5%A4%A7key%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93(%E9%99%84Go%E5%B0%8F%E5%B7%A5%E5%85%B7)/</id>
    <published>2022-06-22T09:28:57.043Z</published>
    <updated>2022-07-02T16:43:07.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：在日常Redis的使用中，难免遇到因为-key-存储了过大的数据而造成请求缓慢甚至阻塞的情况，这个时候就需要排查-Redis-的大key去优化业务了，下面提供一些排查方案总结，仅供参考。"><a href="#摘要：在日常Redis的使用中，难免遇到因为-key-存储了过大的数据而造成请求缓慢甚至阻塞的情况，这个时候就需要排查-Redis-的大key去优化业务了，下面提供一些排查方案总结，仅供参考。" class="headerlink" title="摘要：在日常Redis的使用中，难免遇到因为 key 存储了过大的数据而造成请求缓慢甚至阻塞的情况，这个时候就需要排查 Redis 的大key去优化业务了，下面提供一些排查方案总结，仅供参考。"></a>摘要：在日常Redis的使用中，难免遇到因为 key 存储了过大的数据而造成请求缓慢甚至阻塞的情况，这个时候就需要排查 Redis 的大key去优化业务了，下面提供一些排查方案总结，仅供参考。</h1><hr><span id="more"></span><h2 id="一、多大的-key-算大呢？"><a href="#一、多大的-key-算大呢？" class="headerlink" title="一、多大的 key 算大呢？"></a>一、多大的 key 算大呢？</h2><p>Redis 实践总结（仅供参考）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">合理的 Key 中 Value 的字节大小，推荐小于 10 KB。</span><br><span class="line"></span><br><span class="line">过大的 Value 会引发数据倾斜、热点Key、实例流量或 CPU 性能被占满等问题，应从设计源头上避免此类问题带来的性能影响。</span><br></pre></td></tr></table></figure><p>那么 value Bytes &gt; 10 kb 可以作为判断 大 key 的一个参考值。</p><h2 id="二、排查大-key-的方法"><a href="#二、排查大-key-的方法" class="headerlink" title="二、排查大 key 的方法"></a>二、排查大 key 的方法</h2><h3 id="1、使用命令-–bigkeys"><a href="#1、使用命令-–bigkeys" class="headerlink" title="1、使用命令 –bigkeys"></a>1、使用命令 –bigkeys</h3><p>–bigkeys 是 redis 自带的命令，对整个 Key 进行扫描，统计 string，list，set，zset，hash 这几个常见数据类型中每种类型里的最大的 key。string 类型统计的是 value 的字节数；另外 4 种复杂结构的类型统计的是元素个数，不能直观的看出 value 占用字节数，所以 –bigkeys <strong>对分析 string 类型的大 key 是有用的</strong>，而复杂结构的类型还需要一些第三方工具。</p><p>注：元素个数少，不一定 value 不大；元素个数多，也不一定 value 就大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a &quot;password&quot; --bigkeys</span><br></pre></td></tr></table></figure><p>–bigkeys 是以 scan 延迟计算的方式扫描所有 key，因此执行过程中不会阻塞 redis，但实例存在大量的 keys 时，命令执行的时间会很长，这种情况建议在 slave 上扫描。</p><p>–-bigkeys 其实就是找出类型中最大的 key，最大的 key 不一定是大 key，最大的 key 都不超过 10kb 的话，说明不存在大 key。但某种类型如果存在较多的大key (&gt;10kb)，只会统计 top1 的那个 key，如果要统计所有大于 10kb 的 key，需要用第三方工具扫描 rdb 持久化文件。</p><h3 id="2、使用-memory-命令查看-key-的大小（仅支持-Redis-4-0-以后的版本）"><a href="#2、使用-memory-命令查看-key-的大小（仅支持-Redis-4-0-以后的版本）" class="headerlink" title="2、使用 memory 命令查看 key 的大小（仅支持 Redis 4.0 以后的版本）"></a>2、使用 memory 命令查看 key 的大小（仅支持 Redis 4.0 以后的版本）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a password</span><br><span class="line"></span><br><span class="line">MEMORY USAGE keyname1</span><br><span class="line">(integer) 157481</span><br><span class="line"></span><br><span class="line">MEMORY USAGE keyname2</span><br><span class="line">(integer) 312583</span><br></pre></td></tr></table></figure><h3 id="3、使用-Rdbtools-工具包"><a href="#3、使用-Rdbtools-工具包" class="headerlink" title="3、使用 Rdbtools 工具包"></a>3、使用 Rdbtools 工具包</h3><p>Rdbtools 是 python写的 一个第三方开源工具，用来解析 Redis 快照文件。除了解析 rdb 文件，还提供了统计单个 key 大小的工具。</p><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;sripathikrishnan&#x2F;redis-rdb-tools</span><br><span class="line">cd redis-rdb-tools sudo &amp;&amp; python setup.py install</span><br></pre></td></tr></table></figure><h4 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h4><p>从 dump.rdb 快照文件统计, 将所有 &gt; 10kb 的 key 输出到一个 csv 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdb dump.rdb -c memory --bytes 10240 -f live_redis.csv</span><br></pre></td></tr></table></figure><h3 id="4、使用-go-redis-bigkv"><a href="#4、使用-go-redis-bigkv" class="headerlink" title="4、使用 go-redis-bigkv"></a>4、使用 go-redis-bigkv</h3><p>go-redis-bigkv 是本人开发的一个小工具。主要是 <strong>基于 memory 命令</strong>，扫描 redis 中所有的 key，并将结果按照 <strong>内存大小进行排序</strong>，并将排序后的 <strong>结果输出到 txt 文件中</strong>。因为是 <strong>以 scan 延迟计算的方式扫描所有 key</strong>，因此执行过程中不会阻塞 redis，但实例存在大量的 keys 时，命令执行的时间会很长。</p><p>项目地址：<a href="https://github.com/th3ee9ine/go-redis-bigkv">https://github.com/th3ee9ine/go-redis-bigkv</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：在日常Redis的使用中，难免遇到因为-key-存储了过大的数据而造成请求缓慢甚至阻塞的情况，这个时候就需要排查-Redis-的大key去优化业务了，下面提供一些排查方案总结，仅供参考。&quot;&gt;&lt;a href=&quot;#摘要：在日常Redis的使用中，难免遇到因为-key-存储了过大的数据而造成请求缓慢甚至阻塞的情况，这个时候就需要排查-Redis-的大key去优化业务了，下面提供一些排查方案总结，仅供参考。&quot; class=&quot;headerlink&quot; title=&quot;摘要：在日常Redis的使用中，难免遇到因为 key 存储了过大的数据而造成请求缓慢甚至阻塞的情况，这个时候就需要排查 Redis 的大key去优化业务了，下面提供一些排查方案总结，仅供参考。&quot;&gt;&lt;/a&gt;摘要：在日常Redis的使用中，难免遇到因为 key 存储了过大的数据而造成请求缓慢甚至阻塞的情况，这个时候就需要排查 Redis 的大key去优化业务了，下面提供一些排查方案总结，仅供参考。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    <category term="redis" scheme="https://www.blog.ajie39.top/categories/redis/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    <category term="redis" scheme="https://www.blog.ajie39.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Go 项目结构（草稿）</title>
    <link href="https://www.blog.ajie39.top/2022/06/19/Go%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://www.blog.ajie39.top/2022/06/19/Go%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-06-19T08:36:50.874Z</published>
    <updated>2022-06-19T09:22:28.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：代码组织是编写软件最难的部分之一，但是它很少得到应有的关注。"><a href="#摘要：代码组织是编写软件最难的部分之一，但是它很少得到应有的关注。" class="headerlink" title="摘要：代码组织是编写软件最难的部分之一，但是它很少得到应有的关注。"></a>摘要：代码组织是编写软件最难的部分之一，但是它很少得到应有的关注。</h1><hr><span id="more"></span><h2 id="一、一些常见的目录介绍"><a href="#一、一些常见的目录介绍" class="headerlink" title="一、一些常见的目录介绍"></a>一、一些常见的目录介绍</h2><ul><li>Go 目录<ul><li>/cmd</li><li>/internal</li><li>/pkg</li><li>/vendor</li></ul></li><li>服务应用程序目录<ul><li>/api</li></ul></li><li>Web 应用程序目录<ul><li>/web</li></ul></li><li>通用的应用程序目录<ul><li>/configs</li><li>/init</li><li>/scripts</li><li>/build</li><li>/deployment</li><li>/test</li></ul></li><li>其他目录<ul><li>/docs</li><li>/tools</li><li>/examples</li><li>/third_party</li><li>/githooks</li><li>/assets</li><li>/website</li></ul></li><li>你不应该拥有的目录<ul><li>/src</li></ul></li></ul><h3 id="cmd"><a href="#cmd" class="headerlink" title="/cmd"></a><code>/cmd</code></h3><p>本项目的主干。</p><p>每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，<code>/cmd/myapp</code>)。</p><p>不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 <code>/pkg</code> 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 <code>/internal</code> 目录中。你会惊讶于别人会怎么做，所以要明确你的意图!</p><p>通常有一个小的 <code>main</code> 函数，从 <code>/internal</code> 和 <code>/pkg</code> 目录导入和调用代码，除此之外没有别的东西。</p><p>有关示例，请参阅 <a href="cmd/README.md"><code>/cmd</code></a> 目录。</p><h3 id="internal"><a href="#internal" class="headerlink" title="/internal"></a><code>/internal</code></h3><p>私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 <a href="https://golang.org/doc/go1.4#internalpackages"><code>release notes</code></a> 。注意，你并不局限于顶级 <code>internal</code> 目录。在项目树的任何级别上都可以有多个内部目录。</p><p>你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 <code>/internal/app</code> 目录下(例如 <code>/internal/app/myapp</code>)，这些应用程序共享的代码可以放在 <code>/internal/pkg</code> 目录下(例如 <code>/internal/pkg/myprivlib</code>)。</p><h3 id="pkg"><a href="#pkg" class="headerlink" title="/pkg"></a><code>/pkg</code></h3><p>外部应用程序可以使用的库代码(例如 <code>/pkg/mypubliclib</code>)。其他项目会导入这些库，希望它们能正常工作，所以在这里放东西之前要三思:-)注意，<code>internal</code> 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。<code>/pkg</code> 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。由 Travis Jeffery  撰写的 <a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/"><code>I&#39;ll take pkg over internal</code></a> 博客文章提供了 <code>pkg</code> 和 <code>internal</code> 目录的一个很好的概述，以及什么时候使用它们是有意义的。</p><p>当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易（正如在这些演讲中提到的那样: 来自 GopherCon EU 2018 的 <a href="https://www.youtube.com/watch?v=PTE4VJIdHPg"><code>Best Practices for Industrial Programming</code></a> , <a href="https://www.youtube.com/watch?v=oL6JBUk6tj0">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a> 和 <a href="https://www.youtube.com/watch?v=3gQa1LWwuzk">GoLab 2018 - Massimiliano Pippi - Project layout patterns in Go</a> ）。</p><p>如果你想查看哪个流行的 Go 存储库使用此项目布局模式，请查看 <a href="pkg/README.md"><code>/pkg</code></a> 目录。这是一种常见的布局模式，但并不是所有人都接受它，一些 Go 社区的人也不推荐它。</p><p>如果你的应用程序项目真的很小，并且额外的嵌套并不能增加多少价值(除非你真的想要:-)，那就不要使用它。当它变得足够大时，你的根目录会变得非常繁琐时(尤其是当你有很多非 Go 应用组件时)，请考虑一下。</p><h3 id="vendor"><a href="#vendor" class="headerlink" title="/vendor"></a><code>/vendor</code></h3><p>应用程序依赖项(手动管理或使用你喜欢的依赖项管理工具，如新的内置 <a href="https://github.com/golang/go/wiki/Modules"><code>Go Modules</code></a> 功能)。<code>go mod vendor</code> 命令将为你创建 <code>/vendor</code> 目录。请注意，如果未使用默认情况下处于启用状态的 Go 1.14，则可能需要在 <code>go build</code> 命令中添加 <code>-mod=vendor</code> 标志。</p><p>如果你正在构建一个库，那么不要提交你的应用程序依赖项。</p><p>注意，自从 <a href="https://golang.org/doc/go1.13#modules"><code>1.13</code></a> 以后，Go 还启用了模块代理功能(默认使用 <a href="https://proxy.golang.org/"><code>https://proxy.golang.org</code></a> 作为他们的模块代理服务器)。在<a href="https://blog.golang.org/module-mirror-launch"><code>here</code></a> 阅读更多关于它的信息，看看它是否符合你的所有需求和约束。如果需要，那么你根本不需要 <code>vendor</code> 目录。</p><p>国内模块代理功能默认是被墙的，七牛云有维护专门的的<a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md"><code>模块代理</code></a> 。</p><h2 id="服务应用程序目录"><a href="#服务应用程序目录" class="headerlink" title="服务应用程序目录"></a>服务应用程序目录</h2><h3 id="api"><a href="#api" class="headerlink" title="/api"></a><code>/api</code></h3><p>OpenAPI/Swagger 规范，JSON 模式文件，协议定义文件。</p><p>有关示例，请参见 <a href="api/README.md"><code>/api</code></a> 目录。</p><h2 id="Web-应用程序目录"><a href="#Web-应用程序目录" class="headerlink" title="Web 应用程序目录"></a>Web 应用程序目录</h2><h3 id="web"><a href="#web" class="headerlink" title="/web"></a><code>/web</code></h3><p>特定于 Web 应用程序的组件:静态 Web 资产、服务器端模板和 SPAs。</p><h2 id="通用应用目录"><a href="#通用应用目录" class="headerlink" title="通用应用目录"></a>通用应用目录</h2><h3 id="configs"><a href="#configs" class="headerlink" title="/configs"></a><code>/configs</code></h3><p>配置文件模板或默认配置。</p><p>将你的 <code>confd</code> 或 <code>consul-template</code> 模板文件放在这里。</p><h3 id="init"><a href="#init" class="headerlink" title="/init"></a><code>/init</code></h3><p>System init（systemd，upstart，sysv）和 process manager/supervisor（runit，supervisor）配置。</p><h3 id="scripts"><a href="#scripts" class="headerlink" title="/scripts"></a><code>/scripts</code></h3><p>执行各种构建、安装、分析等操作的脚本。</p><p>这些脚本保持了根级别的 Makefile 变得小而简单(例如， <a href="https://github.com/hashicorp/terraform/blob/master/Makefile"><code>https://github.com/hashicorp/terraform/blob/master/Makefile</code></a> )。</p><p>有关示例，请参见  <a href="scripts/README.md"><code>/scripts</code></a> 目录。</p><h3 id="build"><a href="#build" class="headerlink" title="/build"></a><code>/build</code></h3><p>打包和持续集成。</p><p>将你的云( AMI )、容器( Docker )、操作系统( deb、rpm、pkg )包配置和脚本放在 <code>/build/package</code> 目录下。</p><p>将你的 CI (travis、circle、drone)配置和脚本放在 <code>/build/ci</code> 目录中。请注意，有些 CI 工具(例如 Travis CI)对配置文件的位置非常挑剔。尝试将配置文件放在 <code>/build/ci</code> 目录中，将它们链接到 CI 工具期望它们的位置(如果可能的话)。</p><h3 id="deployments"><a href="#deployments" class="headerlink" title="/deployments"></a><code>/deployments</code></h3><p>IaaS、PaaS、系统和容器编排部署配置和模板(docker-compose、kubernetes/helm、mesos、terraform、bosh)。注意，在一些存储库中(特别是使用 kubernetes 部署的应用程序)，这个目录被称为 <code>/deploy</code>。</p><h3 id="test"><a href="#test" class="headerlink" title="/test"></a><code>/test</code></h3><p>额外的外部测试应用程序和测试数据。你可以随时根据需求构造 <code>/test</code> 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 <code>/test/data</code> 或 <code>/test/testdata</code> (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。</p><p>有关示例，请参见  <a href="test/README.md"><code>/test</code></a> 目录。</p><h2 id="其他目录"><a href="#其他目录" class="headerlink" title="其他目录"></a>其他目录</h2><h3 id="docs"><a href="#docs" class="headerlink" title="/docs"></a><code>/docs</code></h3><p>设计和用户文档(除了 godoc 生成的文档之外)。</p><p>有关示例，请参阅 <a href="docs/README.md"><code>/docs</code></a> 目录。</p><h3 id="tools"><a href="#tools" class="headerlink" title="/tools"></a><code>/tools</code></h3><p>这个项目的支持工具。注意，这些工具可以从 <code>/pkg</code> 和 <code>/internal</code> 目录导入代码。</p><p>有关示例，请参见 <a href="tools/README.md"><code>/tools</code></a> 目录。</p><h3 id="examples"><a href="#examples" class="headerlink" title="/examples"></a><code>/examples</code></h3><p>你的应用程序和/或公共库的示例。</p><p>有关示例，请参见 <a href="examples/README.md"><code>/examples</code></a> 目录。</p><h3 id="third-party"><a href="#third-party" class="headerlink" title="/third_party"></a><code>/third_party</code></h3><p>外部辅助工具，分叉代码和其他第三方工具(例如 Swagger UI)。</p><h3 id="githooks"><a href="#githooks" class="headerlink" title="/githooks"></a><code>/githooks</code></h3><p>Git hooks。</p><h3 id="assets"><a href="#assets" class="headerlink" title="/assets"></a><code>/assets</code></h3><p>与存储库一起使用的其他资产(图像、徽标等)。</p><h3 id="website"><a href="#website" class="headerlink" title="/website"></a><code>/website</code></h3><p>如果你不使用 Github 页面，则在这里放置项目的网站数据。</p><p>有关示例，请参见 <a href="website/README.md"><code>/website</code></a> 目录。</p><h2 id="你不应该拥有的目录"><a href="#你不应该拥有的目录" class="headerlink" title="你不应该拥有的目录"></a>你不应该拥有的目录</h2><h3 id="src"><a href="#src" class="headerlink" title="/src"></a><code>/src</code></h3><p>有些 Go 项目确实有一个 <code>src</code> 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。如果可以的话，尽量不要采用这种 Java 模式。你真的不希望你的 Go 代码或 Go 项目看起来像 Java:-)</p><p>不要将项目级别 <code>src</code> 目录与 Go 用于其工作空间的 <code>src</code> 目录(如 <a href="https://golang.org/doc/code.html"><code>How to Write Go Code</code></a> 中所述)混淆。<code>$GOPATH</code> 环境变量指向你的(当前)工作空间(默认情况下，它指向非 windows 系统上的 <code>$HOME/go</code>)。这个工作空间包括顶层 <code>/pkg</code>, <code>/bin</code> 和 <code>/src</code> 目录。你的实际项目最终是 <code>/src</code> 下的一个子目录，因此，如果你的项目中有 <code>/src</code> 目录，那么项目路径将是这样的: <code>/some/path/to/workspace/src/your_project/src/your_code.go</code>。注意，在 Go 1.11 中，可以将项目放在 <code>GOPATH</code> 之外，但这并不意味着使用这种布局模式是一个好主意。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">Standard Go Project Layout</a></li><li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a></li><li><a href="https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091">Structuring Applications in Go</a></li><li><a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1">Standard Package Layout</a></li><li><a href="https://jfeng45.github.io/posts/go_microservice_application_layout/">清晰架构（Clean Architecture）的Go微服务: 程序结构</a></li><li><a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go工程化(二) 项目目录结构</a></li><li><a href="https://go-kratos.dev/blog/go-project-layout/">Go工程化 - Project Layout 最佳实践</a></li><li><a href="https://programmingpercy.tech/blog/how-to-domain-driven-design-ddd-golang/">How To Implement Domain-Driven Design (DDD) in Golang</a></li><li><a href="https://tkstorm.com/posts-list/software-engineering/cloud-native/ddd-layer/">开发Go服务有关DDD分层架构思考与实践</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：代码组织是编写软件最难的部分之一，但是它很少得到应有的关注。&quot;&gt;&lt;a href=&quot;#摘要：代码组织是编写软件最难的部分之一，但是它很少得到应有的关注。&quot; class=&quot;headerlink&quot; title=&quot;摘要：代码组织是编写软件最难的部分之一，但是它很少得到应有的关注。&quot;&gt;&lt;/a&gt;摘要：代码组织是编写软件最难的部分之一，但是它很少得到应有的关注。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="工程化" scheme="https://www.blog.ajie39.top/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>git——清除所有历史提交记录</title>
    <link href="https://www.blog.ajie39.top/2022/06/19/git%E2%80%94%E2%80%94%E6%B8%85%E9%99%A4%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95/"/>
    <id>https://www.blog.ajie39.top/2022/06/19/git%E2%80%94%E2%80%94%E6%B8%85%E9%99%A4%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95/</id>
    <published>2022-06-19T05:41:36.475Z</published>
    <updated>2022-06-19T05:49:51.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：在不删除原仓库的前提下，清除原仓库的所有历史提交记录。"><a href="#摘要：在不删除原仓库的前提下，清除原仓库的所有历史提交记录。" class="headerlink" title="摘要：在不删除原仓库的前提下，清除原仓库的所有历史提交记录。"></a>摘要：在不删除原仓库的前提下，清除原仓库的所有历史提交记录。</h1><hr><span id="more"></span><h2 id="1-创建新分支"><a href="#1-创建新分支" class="headerlink" title="1.创建新分支"></a>1.创建新分支</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan &lt;new_branch&gt;</span><br></pre></td></tr></table></figure><p>使用 –orphan 选项，可创建1个”清洁”分支(无任何的提交历史，但是当前分支的内容一应俱全。但严格意义上说，这样创建的分支还不是一个真正的分支，因为HEAD指向的引用中没有commit值，只有在进行一次提交后，它才算得上真正的分支。</p><p>注意：</p><p>新的分支名可以随意命名，但不能和以前的分支名冲突。这儿特别强调是因为很多人习惯默认将分支名创建为 master.</p><p>本文以 latest_branch 作为新分支名，这个名称没有任何特殊含义，你可自定义，只要保证和以后的使用一致即可。</p><h2 id="2-添加所有文件"><a href="#2-添加所有文件" class="headerlink" title="2.添加所有文件"></a>2.添加所有文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">git add -A</span><br></pre></td></tr></table></figure><h2 id="3-commit代码"><a href="#3-commit代码" class="headerlink" title="3.commit代码"></a>3.commit代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;自定义提交说明&quot;</span><br></pre></td></tr></table></figure><h2 id="4-删除原来的主分支-master"><a href="#4-删除原来的主分支-master" class="headerlink" title="4.删除原来的主分支(master)"></a>4.删除原来的主分支(master)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D master</span><br></pre></td></tr></table></figure><p>一般仓库默认的主分支为 master 分支，如果原来的主分支不是 master, 用实际的主分支名代替。</p><h2 id="5-把当前分支重命名为-master"><a href="#5-把当前分支重命名为-master" class="headerlink" title="5.把当前分支重命名为 master"></a>5.把当前分支重命名为 master</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master</span><br></pre></td></tr></table></figure><h2 id="6-最后把代码推送到远程仓库"><a href="#6-最后把代码推送到远程仓库" class="headerlink" title="6.最后把代码推送到远程仓库"></a>6.最后把代码推送到远程仓库</h2><p>注意： 有些仓库有 master 分支保护，不允许强制 push，需要在远程仓库项目里暂时把项目保护关掉才能推送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><p>注意： 推送前 需要使用 git remote -v 查看关联的远程仓库的信息（主要是远程库的别名）。虽然远程库的别名默认是 origin ,但你可能设置过其他的别名（而非 origin）.</p><p>推送前，有的情况需要设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;master master。</span><br></pre></td></tr></table></figure><h2 id="7-从远程库拉取更新代码-测试"><a href="#7-从远程库拉取更新代码-测试" class="headerlink" title="7.从远程库拉取更新代码(测试)"></a>7.从远程库拉取更新代码(测试)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="8-确定清除历史记录的结果"><a href="#8-确定清除历史记录的结果" class="headerlink" title="8.确定清除历史记录的结果"></a>8.确定清除历史记录的结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、查看提交日志</span><br><span class="line">git log --pretty&#x3D;oneline</span><br><span class="line"></span><br><span class="line">2、列出所有本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">3、列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line">4、列出所有本地分支和远程分支</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">5、查看本地标签</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">6、查看远程标签</span><br><span class="line">git ls-remote --tags</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：在不删除原仓库的前提下，清除原仓库的所有历史提交记录。&quot;&gt;&lt;a href=&quot;#摘要：在不删除原仓库的前提下，清除原仓库的所有历史提交记录。&quot; class=&quot;headerlink&quot; title=&quot;摘要：在不删除原仓库的前提下，清除原仓库的所有历史提交记录。&quot;&gt;&lt;/a&gt;摘要：在不删除原仓库的前提下，清除原仓库的所有历史提交记录。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/categories/git/"/>
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>逗号 ok 模式与 defer 模式总结</title>
    <link href="https://www.blog.ajie39.top/2022/06/18/%E9%80%97%E5%8F%B7ok%E6%A8%A1%E5%BC%8F%E4%B8%8Edefer%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2022/06/18/%E9%80%97%E5%8F%B7ok%E6%A8%A1%E5%BC%8F%E4%B8%8Edefer%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-18T08:39:18.428Z</published>
    <updated>2022-06-18T08:54:07.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南。"><a href="#摘要：go入门相关内容，参考：Go入门指南。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>。</h1><hr><span id="more"></span><h2 id="一、逗号-ok-模式"><a href="#一、逗号-ok-模式" class="headerlink" title="一、逗号 ok 模式"></a>一、逗号 ok 模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">，ok</span><br></pre></td></tr></table></figure><p>第一个参数是一个值或者 nil，第二个参数是 true/false 或者一个错误 error。在一个需要赋值的 if 条件语句中，使用这种模式去检测第二个参数值会让代码显得优雅简洁。这种模式在 go 语言编码规范中非常重要。下面总结了所有使用这种模式的例子。</p><h3 id="1、在函数返回时检测错误"><a href="#1、在函数返回时检测错误" class="headerlink" title="1、在函数返回时检测错误"></a>1、在函数返回时检测错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">value, err :&#x3D; pack1.Func1(param1)</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Printf(“Error %s in pack1.Func1 with parameter %v”, err.Error(), param1)</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数Func1没有错误:</span><br><span class="line">Process(value)</span><br></pre></td></tr></table></figure><p>这段代码中的函数将错误返回给它的调用者，当函数执行成功时，返回的错误是 nil，所以使用这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func SomeFunc() error &#123;</span><br><span class="line">    …</span><br><span class="line">    if value, err :&#x3D; pack1.Func1(param1); err !&#x3D; nil &#123;</span><br><span class="line">        …</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式也常用于通过 defer 使程序从 panic 中恢复执行。</p><h3 id="2、检测映射中是否存在一个键值"><a href="#2、检测映射中是否存在一个键值" class="headerlink" title="2、检测映射中是否存在一个键值"></a>2、检测映射中是否存在一个键值</h3><p>key1 在映射 map1 中是否有值？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if value, isPresent &#x3D; map1[key1]; isPresent &#123;</span><br><span class="line">        Process(value)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; key1不存在</span><br><span class="line">…</span><br></pre></td></tr></table></figure><h3 id="3、检测一个接口类型变量-varI-是否包含了类型-T（类型断言）"><a href="#3、检测一个接口类型变量-varI-是否包含了类型-T（类型断言）" class="headerlink" title="3、检测一个接口类型变量 varI 是否包含了类型 T（类型断言）"></a>3、检测一个接口类型变量 varI 是否包含了类型 T（类型断言）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if value, ok :&#x3D; varI.(T); ok &#123;</span><br><span class="line">    Process(value)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 接口类型varI没有包含类型T</span><br></pre></td></tr></table></figure><h3 id="4、检测一个通道-ch-是否关闭"><a href="#4、检测一个通道-ch-是否关闭" class="headerlink" title="4、检测一个通道 ch 是否关闭"></a>4、检测一个通道 ch 是否关闭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for input :&#x3D; range ch &#123;</span><br><span class="line">     Process(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者:</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">  if input, open :&#x3D; &lt;-ch; !open &#123;</span><br><span class="line">    break &#x2F;&#x2F; 通道是关闭的</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Process(input)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、defer-模式"><a href="#二、defer-模式" class="headerlink" title="二、defer 模式"></a>二、defer 模式</h2><p>当资源不再被使用时，使用 defer 延迟调用其后的代码，确保资源能够被关闭或返回给连接池。其次最重要的是从 panic 中恢复程序运行。</p><p><strong>defer 仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。</strong></p><h3 id="1、关闭文件流"><a href="#1、关闭文件流" class="headerlink" title="1、关闭文件流"></a>1、关闭文件流</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; open a file f</span><br><span class="line"></span><br><span class="line">defer f.Close()</span><br></pre></td></tr></table></figure><h3 id="2、解锁一个已加锁的资源-a-mutex"><a href="#2、解锁一个已加锁的资源-a-mutex" class="headerlink" title="2、解锁一个已加锁的资源 (a mutex)"></a>2、解锁一个已加锁的资源 (a mutex)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mu.Lock()</span><br><span class="line"></span><br><span class="line">defer mu.Unlock()</span><br></pre></td></tr></table></figure><h3 id="3、关闭-channel-如果必要的话"><a href="#3、关闭-channel-如果必要的话" class="headerlink" title="3、关闭 channel (如果必要的话)"></a>3、关闭 channel (如果必要的话)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan float64)</span><br><span class="line"></span><br><span class="line">defer close(ch)</span><br></pre></td></tr></table></figure><h3 id="4、从-panic-中恢复"><a href="#4、从-panic-中恢复" class="headerlink" title="4、从 panic 中恢复"></a>4、从 panic 中恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">    if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">        log.Printf(“run time panic: %v”, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、停止一个-Ticker"><a href="#5、停止一个-Ticker" class="headerlink" title="5、停止一个 Ticker"></a>5、停止一个 Ticker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tick1 :&#x3D; time.NewTicker(updateInterval)</span><br><span class="line"></span><br><span class="line">defer tick1.Stop()</span><br></pre></td></tr></table></figure><h3 id="6、释放一个进程-p"><a href="#6、释放一个进程-p" class="headerlink" title="6、释放一个进程 p"></a>6、释放一个进程 p</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p, err :&#x3D; os.StartProcess(…, …, …)</span><br><span class="line"></span><br><span class="line">defer p.Release()</span><br></pre></td></tr></table></figure><h3 id="7、停止-CPU-分析并刷新信息"><a href="#7、停止-CPU-分析并刷新信息" class="headerlink" title="7、停止 CPU 分析并刷新信息"></a>7、停止 CPU 分析并刷新信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pprof.StartCPUProfile(f)</span><br><span class="line"></span><br><span class="line">defer pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://godoc.murphyyi.com/">《Go入门指南》</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go 中常见的陷阱与错误</title>
    <link href="https://www.blog.ajie39.top/2022/06/18/Go%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%B7%E9%98%B1%E4%B8%8E%E9%94%99%E8%AF%AF/"/>
    <id>https://www.blog.ajie39.top/2022/06/18/Go%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%B7%E9%98%B1%E4%B8%8E%E9%94%99%E8%AF%AF/</id>
    <published>2022-06-18T07:18:15.050Z</published>
    <updated>2022-06-18T08:10:38.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结一些在日常开发中容易遇到的陷阱、错误。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结一些在日常开发中容易遇到的陷阱、错误。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结一些在日常开发中容易遇到的陷阱、错误。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结一些在日常开发中容易遇到的陷阱、错误。</h1><hr><span id="more"></span><h2 id="一、一些常见的陷阱"><a href="#一、一些常见的陷阱" class="headerlink" title="一、一些常见的陷阱"></a>一、一些常见的陷阱</h2><ul><li>永远不要使用形如 var p*a 声明变量，这会混淆指针声明和乘法运算。</li><li>永远不要在 for 循环自身中改变计数器变量。</li><li>永远不要在 for-range 循环中使用一个值去改变自身的值。</li><li>永远不要将 goto 和前置标签一起使用。</li><li>永远不要忘记在函数名后加括号 ()，尤其调用一个对象的方法或者使用匿名函数启动一个协程时。</li><li>永远不要使用 new() 一个 map，一直使用 make。</li><li>当为一个类型定义一个 String () 方法时，不要使用 fmt.Print 或者类似的代码。</li><li>永远不要忘记当终止缓存写入时，使用 Flush 函数。</li><li>永远不要忽略错误提示，忽略错误会导致程序奔溃。</li><li>不要使用全局变量或者共享内存，这会使并发执行的代码变得不安全。</li><li>println 函数仅仅是用于调试的目的。</li></ul><p>最佳实践：对比以下使用方式：</p><ul><li>使用正确的方式初始化一个元素是切片的映射，例如 map[type]slice。</li><li>一直使用逗号，ok 或者 checked 形式作为类型断言。</li><li>使用一个工厂函数创建并初始化自己定义类型。</li><li>仅当一个结构体的方法想改变结构体时，使用结构体指针作为方法的接受者，否则使用一个结构体值类型。</li></ul><h2 id="二、误用短声明导致变量覆盖"><a href="#二、误用短声明导致变量覆盖" class="headerlink" title="二、误用短声明导致变量覆盖"></a>二、误用短声明导致变量覆盖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var remember bool &#x3D; false</span><br><span class="line">if something &#123;</span><br><span class="line">    remember :&#x3D; true &#x2F;&#x2F;错误</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 使用remember</span><br></pre></td></tr></table></figure><p>在此代码段中，remember 变量永远不会在 if 语句外面变成 true，如果 something 为 true，由于使用了短声明 :=，if 语句内部的新变量 remember 将覆盖外面的 remember 变量，并且该变量的值为 true，但是在 if 语句外面，变量 remember 的值变成了 false，所以正确的写法应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if something &#123;</span><br><span class="line">    remember &#x3D; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类错误也容易在 for 循环中出现，尤其当函数返回一个具名变量时难于察觉<br>，例如以下的代码段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func shadow() (err error) &#123;</span><br><span class="line">    x, err :&#x3D; check1() &#x2F;&#x2F; x是新创建变量，err是被赋值</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return &#x2F;&#x2F; 正确返回err</span><br><span class="line">    &#125;</span><br><span class="line">    if y, err :&#x3D; check2(x); err !&#x3D; nil &#123; &#x2F;&#x2F; y和if语句中err被创建</span><br><span class="line">        return &#x2F;&#x2F; if语句中的err覆盖外面的err，所以错误的返回nil！</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(y)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、误用字符串"><a href="#三、误用字符串" class="headerlink" title="三、误用字符串"></a>三、误用字符串</h2><p>当需要对一个字符串进行频繁的操作时，谨记在 go 语言中字符串是不可变的（类似 java 和 c#）。使用诸如 a += b 形式连接字符串效率低下，尤其在一个循环内部使用这种形式。这会导致大量的内存开销和拷贝。应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中。 例如以下的代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var b bytes.Buffer</span><br><span class="line">...</span><br><span class="line">for condition &#123;</span><br><span class="line">    b.WriteString(str) &#x2F;&#x2F; 将字符串str写入缓存buffer</span><br><span class="line">&#125;</span><br><span class="line">return b.String()</span><br></pre></td></tr></table></figure><p>注意：由于编译优化和依赖于使用缓存操作的字符串大小，当循环次数大于 15 时，效率才会更佳。</p><h2 id="四、发生错误时使用defer关闭一个文件"><a href="#四、发生错误时使用defer关闭一个文件" class="headerlink" title="四、发生错误时使用defer关闭一个文件"></a>四、发生错误时使用defer关闭一个文件</h2><p>如果你在一个 for 循环内部处理一系列文件，你需要使用 defer 确保文件在处理完毕后被关闭，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for _, file :&#x3D; range files &#123;</span><br><span class="line">    if f, err &#x3D; os.Open(file); err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 这是错误的方式，当循环结束时文件没有关闭</span><br><span class="line">    defer f.Close()</span><br><span class="line">    &#x2F;&#x2F; 对文件进行操作</span><br><span class="line">    f.Process(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在循环结尾处的 defer 没有执行，所以文件一直没有关闭！垃圾回收机制可能会自动关闭文件，但是这会产生一个错误，更好的做法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for _, file :&#x3D; range files &#123;</span><br><span class="line">    if f, err &#x3D; os.Open(file); err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对文件进行操作</span><br><span class="line">    f.Process(data)</span><br><span class="line">    &#x2F;&#x2F; 关闭文件</span><br><span class="line">    f.Close()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>defer 仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。</strong></p><h2 id="五、何时使用-new-和-make"><a href="#五、何时使用-new-和-make" class="headerlink" title="五、何时使用 new() 和 make()"></a>五、何时使用 new() 和 make()</h2><ul><li>切片、映射（Map）和通道（channel），使用 make</li><li>数组、结构体和所有的值类型，使用 new</li></ul><h2 id="六、不需要将一个指向切片的指针传递给函数"><a href="#六、不需要将一个指向切片的指针传递给函数" class="headerlink" title="六、不需要将一个指向切片的指针传递给函数"></a>六、不需要将一个指向切片的指针传递给函数</h2><p>切片实际是一个 <strong>指向潜在数组的指针</strong>。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。</p><p>因此应该这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func findBiggest(listOfNumbers []int) int &#123;&#125;</span><br></pre></td></tr></table></figure><p>而不是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func findBiggest(listOfNumbers *[]int) int &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>当切片作为参数传递时，切记不要解引用切片。</strong></p><h2 id="七、使用指针指向接口类型"><a href="#七、使用指针指向接口类型" class="headerlink" title="七、使用指针指向接口类型"></a>七、使用指针指向接口类型</h2><p>查看如下程序：</p><p>nexter 是一个接口类型，并且定义了一个 next() 方法读取下一字节。</p><p>函数 nextFew1 将 nexter 接口作为参数并读取接下来的 num 个字节，并返回一个切片：这是正确做法。</p><p>但是 nextFew2 使用一个指向 nexter 接口类型的指针作为参数传递给函数：当使用 next() 函数时，系统会给出一个编译错误：n.next undefined (type *nexter has no<br>field or method next)</p><p>例(不能通过编译):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    “fmt”</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type nexter interface &#123;</span><br><span class="line">    next() byte</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func nextFew1(n nexter, num int) []byte &#123;</span><br><span class="line">    var b []byte</span><br><span class="line">    for i:&#x3D;0; i &lt; num; i++ &#123;</span><br><span class="line">        b[i] &#x3D; n.next()</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func nextFew2(n *nexter, num int) []byte &#123;</span><br><span class="line">    var b []byte</span><br><span class="line">    for i:&#x3D;0; i &lt; num; i++ &#123;</span><br><span class="line">        b[i] &#x3D; n.next() &#x2F;&#x2F; 编译错误:n.next未定义（*nexter类型没有next成员或next方法）</span><br><span class="line">    &#125;</span><br><span class="line">    return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。</strong></p><h2 id="八、使用值类型时误用指针"><a href="#八、使用值类型时误用指针" class="headerlink" title="八、使用值类型时误用指针"></a>八、使用值类型时误用指针</h2><p>将一个值类型作为一个参数传递给函数或者作为一个方法的接收者，似乎是对内存的滥用，因为值类型一直是传递拷贝。</p><p>但是另一方面，<strong>值类型的内存是在栈上分配，内存分配快速且开销不大。</strong></p><p>如果你传递一个指针，而不是一个值类型，<strong>go 编译器大多数情况下会认为需要创建一个对象，并将对象移动到堆上</strong>，所以会导致 <strong>额外的内存分配</strong>：因此当使用指针代替值类型作为参数传递时，我们没有任何收获。</p><h2 id="九、误用协程和通道"><a href="#九、误用协程和通道" class="headerlink" title="九、误用协程和通道"></a>九、误用协程和通道</h2><p>在实际应用中，你不需要并发执行，或者你不需要关注协程和通道的开销，在大多数情况下，通过栈传递参数会更有效率。</p><p>但是，如果你使用 break、return 或者 panic 去跳出一个循环，很有可能会导致内存溢出，因为协程正处理某些事情而被阻塞。在实际代码中，通常仅需写一个简单的过程式循环即可。当且仅当代码中并发执行非常重要，才使用协程和通道。</p><h2 id="十、闭包和协程的使用"><a href="#十、闭包和协程的使用" class="headerlink" title="十、闭包和协程的使用"></a>十、闭包和协程的使用</h2><p>请看下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var values &#x3D; [5]int&#123;10, 11, 12, 13, 14&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 版本A:</span><br><span class="line">    for ix :&#x3D; range values &#123; &#x2F;&#x2F; ix是索引值</span><br><span class="line">        func() &#123;</span><br><span class="line">            fmt.Print(ix, &quot; &quot;)</span><br><span class="line">        &#125;() &#x2F;&#x2F; 调用闭包打印每个索引值</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    &#x2F;&#x2F; 版本B: 和A版本类似，但是通过调用闭包作为一个协程</span><br><span class="line">    for ix :&#x3D; range values &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            fmt.Print(ix, &quot; &quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    time.Sleep(5e9)</span><br><span class="line">    &#x2F;&#x2F; 版本C: 正确的处理方式</span><br><span class="line">    for ix :&#x3D; range values &#123;</span><br><span class="line">        go func(ix interface&#123;&#125;) &#123;</span><br><span class="line">            fmt.Print(ix, &quot; &quot;)</span><br><span class="line">        &#125;(ix)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    time.Sleep(5e9)</span><br><span class="line">    &#x2F;&#x2F; 版本D: 输出值:</span><br><span class="line">    for ix :&#x3D; range values &#123;</span><br><span class="line">        val :&#x3D; values[ix]</span><br><span class="line">        go func() &#123;</span><br><span class="line">            fmt.Print(val, &quot; &quot;)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">0 1 2 3 4</span><br><span class="line">4 4 4 4 4</span><br><span class="line">4 2 3 0 1</span><br><span class="line">12 10 13 14 11</span><br></pre></td></tr></table></figure><p>版本 A 调用闭包 5 次打印每个索引值。</p><p>版本 B 也做相同的事，但是通过协程调用每个闭包。按理说这将执行得更快，因为闭包是并发执行的。如果我们阻塞足够多的时间，让所有协程执行完毕，版本 B 的输出是：4 4 4 4 4。为什么会这样？在版本 B 的循环中，ix 变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，这是一个比较好的方式，当你运行这段代码时，你将看见每次循环都打印最后一个索引值 4，而不是每个元素的索引值。 <strong>因为协程可能在循环结束后还没有开始执行</strong> ，而此时 ix 值是 4。</p><p>版本 C 的循环写法才是正确的：调用每个闭包是将 ix 作为参数传递给闭包。 <strong>ix 在每次循环时都被重新赋值</strong>，并 <strong>将每个协程的 ix 放置在栈中</strong> ，所以当协程最终被执行时，每个索引值对协程都是可用的。注意这里的输出可能是 0 2 1 3 4 或者 0 3 1 2 4 或者其他类似的序列，<strong>这主要取决于每个协程何时开始被执行。</strong></p><p>在版本 D 中，我们输出这个数组的值，为什么版本 B 不能而版本 D 可以呢？ <strong>因为版本 D 中的变量声明是在循环体内部，所以在每次循环时，这些变量相互之间是不共享的，所以这些变量可以单独的被每个闭包使用。</strong></p><p>如果版本 D 改成下面这样，则就会出现和版本 B 类似的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 版本D: 输出值:</span><br><span class="line">for _, value :&#x3D; range values &#123;</span><br><span class="line">  go func() &#123;</span><br><span class="line">    fmt.Print(value, &quot; &quot;)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、糟糕的错误处理"><a href="#十一、糟糕的错误处理" class="headerlink" title="十一、糟糕的错误处理"></a>十一、糟糕的错误处理</h2><h3 id="1、不要使用布尔值："><a href="#1、不要使用布尔值：" class="headerlink" title="1、不要使用布尔值："></a>1、不要使用布尔值：</h3><p>像下面代码一样，创建一个布尔型变量用于测试错误条件是多余的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var good bool</span><br><span class="line">&#x2F;&#x2F; 测试一个错误，&#96;good&#96;被赋为&#96;true&#96;或者&#96;false&#96;</span><br><span class="line">if !good &#123;</span><br><span class="line">  return errors.New(&quot;things aren’t good&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立即检测一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... err1 :&#x3D; api.Func1()</span><br><span class="line">if err1 !&#x3D; nil &#123; … &#125;</span><br></pre></td></tr></table></figure><h3 id="2、避免错误检测使代码变得混乱"><a href="#2、避免错误检测使代码变得混乱" class="headerlink" title="2、避免错误检测使代码变得混乱"></a>2、避免错误检测使代码变得混乱</h3><p>避免写出这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">... err1 :&#x3D; api.Func1()</span><br><span class="line">if err1 !&#x3D; nil &#123;</span><br><span class="line">    fmt.Println(&quot;err: &quot; + err.Error())</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err2 :&#x3D; api.Func2()</span><br><span class="line">if err2 !&#x3D; nil &#123;</span><br><span class="line">    ...</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，包括在一个初始化的 if 语句中对函数的调用。但即使代码中到处都是以 if 语句的形式通知错误（通过打印错误信息）。通过这种方式，<strong>很难分辨什么是正常的程序逻辑，什么是错误检测或错误通知。</strong> 还需注意的是，大部分代码都是致力于错误的检测。通常解决此问题的好办法是 <strong>尽可能以闭包的形式封装你的错误检测</strong> ，例如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func httpRequestHandler(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">err :&#x3D; func() error &#123;</span><br><span class="line">if req.Method !&#x3D; &quot;GET&quot; &#123;</span><br><span class="line">return errors.New(&quot;expected GET&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if input :&#x3D; parseInput(req); input !&#x3D; &quot;command&quot; &#123;</span><br><span class="line">return errors.New(&quot;malformed command&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 可以在此进行其他的错误检测</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">w.WriteHeader(400)</span><br><span class="line">io.WriteString(w, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">doSomething() ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以很容易分辨出错误检测、错误通知和正常的程序逻辑。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://godoc.murphyyi.com/">《Go入门指南》</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结一些在日常开发中容易遇到的陷阱、错误。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结一些在日常开发中容易遇到的陷阱、错误。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结一些在日常开发中容易遇到的陷阱、错误。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结一些在日常开发中容易遇到的陷阱、错误。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>一个有意思的协程例子</title>
    <link href="https://www.blog.ajie39.top/2022/06/18/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90/"/>
    <id>https://www.blog.ajie39.top/2022/06/18/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%8D%8F%E7%A8%8B%E4%BE%8B%E5%AD%90/</id>
    <published>2022-06-18T07:02:39.862Z</published>
    <updated>2022-06-18T08:13:25.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这是一个有趣的协程例子，了解其中的原理，对于理解协程、channel非常有帮助。"><a href="#摘要：这是一个有趣的协程例子，了解其中的原理，对于理解协程、channel非常有帮助。" class="headerlink" title="摘要：这是一个有趣的协程例子，了解其中的原理，对于理解协程、channel非常有帮助。"></a>摘要：这是一个有趣的协程例子，了解其中的原理，对于理解协程、channel非常有帮助。</h1><hr><span id="more"></span><p>程序如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;flag&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ngoroutine &#x3D; flag.Int(&quot;n&quot;, 100000, &quot;how many goroutines&quot;)</span><br><span class="line"></span><br><span class="line">func f(left, right chan int) &#123;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(&quot;left:&quot;, left, &quot;    right:&quot;, right)</span><br><span class="line">left &lt;- 1 + &lt;-right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">flag.Parse()</span><br><span class="line">leftmost :&#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">var left, right chan int &#x3D; nil, leftmost</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; *ngoroutine; i++ &#123;</span><br><span class="line">left, right &#x3D; right, make(chan int)</span><br><span class="line">&#x2F;&#x2F;fmt.Println(&quot;left:&quot;, left, &quot;    right:&quot;, right)</span><br><span class="line">go f(left, right)</span><br><span class="line">&#125;</span><br><span class="line">right &lt;- 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; start the chaining 开始链接</span><br><span class="line">x :&#x3D; &lt;-leftmost &#x2F;&#x2F; wait for completion 等待完成</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 mian 函数的 for 循环中启动 100000 个协程。在循环之后，向 right 通道中插入 0，最后打印结果。</p><p>这里可以猜想一下，最后输出的结果是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">100000</span><br></pre></td></tr></table></figure><p>不知道你是否猜想正确了，反正我是错了。</p><p>在没有运行程序之前，我认为leftmost的结果为1，认为只在最初做了一次赋值，实际结果为100000（无缓存信道，具有同步阻塞的特性），这个是为什么呢？</p><ul><li>1.主线程的right &lt;- 0，right不是最初循环的那个right，而是最终循环的right</li><li>2.for循环中最初的go f(left, right)因为没有发送者一直处于等待状态</li><li>3.当主线程的right &lt;- 0执行时，类似于递归函数在最内层产生返回值一般</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://godoc.murphyyi.com/">《Go入门指南》</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这是一个有趣的协程例子，了解其中的原理，对于理解协程、channel非常有帮助。&quot;&gt;&lt;a href=&quot;#摘要：这是一个有趣的协程例子，了解其中的原理，对于理解协程、channel非常有帮助。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这是一个有趣的协程例子，了解其中的原理，对于理解协程、channel非常有帮助。&quot;&gt;&lt;/a&gt;摘要：这是一个有趣的协程例子，了解其中的原理，对于理解协程、channel非常有帮助。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="协程" scheme="https://www.blog.ajie39.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="channel" scheme="https://www.blog.ajie39.top/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go 协程与通道（channel）</title>
    <link href="https://www.blog.ajie39.top/2022/06/17/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88channel%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/06/17/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E9%80%9A%E9%81%93%EF%BC%88channel%EF%BC%89/</id>
    <published>2022-06-16T16:40:38.340Z</published>
    <updated>2022-06-18T08:10:16.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：协程与通道（channel）的内容。</h1><hr><span id="more"></span><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Go 语言为构建并发程序的基本代码块是协程 (goroutine) 与通道 (channel)。他们需要语言、编译器和 runtime 的支持。</p><p>Go 语言提供的垃圾回收器对并发编程至关重要。</p><p><strong>不要通过共享内存来通信，而通过通信来共享内存。</strong></p><p>通信强制协作。</p><h3 id="1、线程与进程"><a href="#1、线程与进程" class="headerlink" title="1、线程与进程"></a>1、线程与进程</h3><p><strong>进程</strong> 是对运行时程序的封装，是 <strong>系统进行资源调度和分配的的基本单位</strong>，实现了操作系统的并发。</p><p><strong>线程是进程的子任务</strong>，是 <strong>CPU调度和分派的基本单位</strong>，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。</p><p>每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。</p><p>每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p><p>进程是资源分配的最小单位，线程是CPU调度的最小单位；</p><h3 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h3><p>并发：并发（Concurrent）在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。在同一时间点，任务并不会同时运行。</p><p>并行（Parallel）：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。在同一时间点，任务一定是同时运行。</p><h3 id="3、go语言中的协程"><a href="#3、go语言中的协程" class="headerlink" title="3、go语言中的协程"></a>3、go语言中的协程</h3><p>在 Go 中，应用程序并发处理的部分被称作 goroutines（协程），它可以进行更有效的 <strong>并发运算</strong>。</p><p>在协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的；协程调度器在 Go 运行时很好的完成了这个工作。</p><p><strong>协程工作在相同的地址空间</strong>中，所以共享内存的方式一定是同步的；这个可以使用 sync 包来实现，不过我们很不鼓励这样做：Go 使用 channels 来同步协程。</p><p>当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。</p><p>协程是轻量的，比线程更轻。它们痕迹非常不明显（使用少量的内存和资源）：使用 4K 的栈内存就可以在堆中创建它们。并且它们<strong>对栈进行了分割</strong>，从而动态的增加（或缩减）内存的使用；<strong>栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。</strong></p><p>协程是通过使用 <strong>关键字 go 调用（或执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）</strong> 。</p><p>这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：go sum(bigArray)，在后台计算总和。</p><p>协程的栈会根据需要进行伸缩，不会出现栈溢出；开发者无需关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数也不会得到任何的返回值。</p><p>任何 Go 程序都必须有的 main() 函数也可以看做是一个协程，尽管它并没有通过 go 来启动。协程可以在程序初始化的过程中运行（在 init() 函数中）。</p><p>在一个协程中，比如它需要进行非常密集的运算，你可以在运算循环中周期的使用 runtime.Gosched()：这会让出处理器，允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。使用 Gosched() 可以使计算均匀分布，使通信不至于迟迟得不到响应。</p><p>在其他语言中，比如 C#，Lua 或者 Python 都有协程的概念。这个名字表明它和 Go 协程有些相似，不过有两点不同：</p><ul><li>Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的</li><li>Go 协程通过通道来通信；协程通过让出和恢复操作来通信</li></ul><p>一个简单的示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;In main()&quot;)</span><br><span class="line">    go longWait()</span><br><span class="line">    go shortWait()</span><br><span class="line">    fmt.Println(&quot;About to sleep in main()&quot;)</span><br><span class="line">    &#x2F;&#x2F; sleep works with a Duration in nanoseconds (ns) !</span><br><span class="line">    time.Sleep(10 * 1e9)</span><br><span class="line">    fmt.Println(&quot;At the end of main()&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func longWait() &#123;</span><br><span class="line">    fmt.Println(&quot;Beginning longWait()&quot;)</span><br><span class="line">    time.Sleep(5 * 1e9) &#x2F;&#x2F; sleep for 5 seconds</span><br><span class="line">    fmt.Println(&quot;End of longWait()&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func shortWait() &#123;</span><br><span class="line">    fmt.Println(&quot;Beginning shortWait()&quot;)</span><br><span class="line">    time.Sleep(2 * 1e9) &#x2F;&#x2F; sleep for 2 seconds</span><br><span class="line">    fmt.Println(&quot;End of shortWait()&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、协程间的信道"><a href="#二、协程间的信道" class="headerlink" title="二、协程间的信道"></a>二、协程间的信道</h2><p>Go 有一个特殊的类型，通道（channel），像是通道（管道），可以通过它们发送类型化的数据在协程之间通信，可以避开所有内存共享导致的坑；通道的通信方式保证了同步性。</p><p>同一时间只有一个协程可以访问数据，所以不会出现数据竞争。数据的归属（可以读写数据的能力）被传递。</p><p>通道服务于通信的两个目的：</p><ul><li>值的交换</li><li>同步的保证了两个计算（协程）任何时候都是可知状态。</li></ul><p>通常使用这样的格式来声明通道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier chan datatype</span><br></pre></td></tr></table></figure><p>未初始化的通道的值是 nil。</p><p>通道 <strong>只能传输一种类型的数据</strong>，比如 chan int 或者 chan string，所有的类型都可以用于通道，空接口 interface{} 也可以。甚至可以（有时非常有用）创建通道的通道。</p><p>通道实际上是类型化消息的队列：使数据得以传输。它是 <strong>先进先出（FIFO）</strong>* 的结构所以可以保证发送给他们的元素的顺序（有些人知道，通道可以比作 Unix shells 中的双向管道（two-way pipe））。</p><p>通道也是引用类型，所以我们使用 make() 函数来给它分配内存。这里先声明了一个字符串通道 ch1，然后创建了它（实例化）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ch1 chan string</span><br><span class="line">ch1 &#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">或者函数通道：funcChan :&#x3D; chan func()</span><br></pre></td></tr></table></figure><p>所以通道是对象的第一类型：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。</p><h3 id="1、通信操作符-lt"><a href="#1、通信操作符-lt" class="headerlink" title="1、通信操作符 &lt;-"></a>1、通信操作符 &lt;-</h3><p>这个操作符直观的标示了数据的传输：信息按照箭头的方向流动。</p><p>流向通道（发送）:</p><p>ch &lt;- int1 表示：用通道 ch 发送变量 int1（双目运算符，中缀 = 发送）</p><p>从通道流出（接收）：</p><p>int2 := &lt;- ch 表示：变量 int2 从通道 ch（一元运算的前缀操作符，前缀 = 接收）接收数据（获取新值）</p><p>&lt;- ch 可以单独调用获取通道的（下一个）值，当前值会被丢弃，但是可以用来验证，所以以下代码是合法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if &lt;-ch !&#x3D; 1000 &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道的命名通常以 ch 开头或者包含 chan。</p><p>简单示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch :&#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">    go sendData(ch)</span><br><span class="line">    go getData(ch)</span><br><span class="line"></span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sendData(ch chan string) &#123;</span><br><span class="line">    ch &lt;- &quot;Washington&quot;</span><br><span class="line">    ch &lt;- &quot;Tripoli&quot;</span><br><span class="line">    ch &lt;- &quot;London&quot;</span><br><span class="line">    ch &lt;- &quot;Beijing&quot;</span><br><span class="line">    ch &lt;- &quot;Tokio&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData(ch chan string) &#123;</span><br><span class="line">    var input string</span><br><span class="line">    &#x2F;&#x2F; time.Sleep(2e9)</span><br><span class="line">    for &#123;</span><br><span class="line">        input &#x3D; &lt;-ch</span><br><span class="line">        fmt.Printf(&quot;%s &quot;, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Washington Tripoli London Beijing Tokio</span><br></pre></td></tr></table></figure><p>如果注释掉 time.Sleep(1e9) , sendData() 会来不及输出。</p><p>我们发现协程之间的同步非常重要：</p><ul><li>main () 等待了 1 秒让两个协程完成，如果不这样，sendData () 就没有机会输出。</li><li>getData () 使用了无限循环：它随着 sendData () 的发送完成和 ch 变空也结束了。</li></ul><p>如果我们移除一个或所有 go 关键字，程序无法运行，Go 运行时会抛出 panic。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---- Error run E:&#x2F;Go&#x2F;Goboek&#x2F;code examples&#x2F;chapter 14&#x2F;goroutine2.exe with code Crashed</span><br><span class="line">---- Program exited with code -2147483645: panic: all goroutines are asleep-deadlock!</span><br></pre></td></tr></table></figure><p>为什么会这样呢？</p><p>因为运行时会检查所有的协程（也许只有一个是这种情况）是否在等待（可以读取或者写入某个通道），意味着程序无法处理。这是死锁（deadlock）形式，运行时可以检测到这种情况。</p><p>注意：<strong>不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。</strong></p><h3 id="2、通道阻塞"><a href="#2、通道阻塞" class="headerlink" title="2、通道阻塞"></a>2、通道阻塞</h3><p>默认情况下，通信是 <strong>同步且无缓冲</strong> 的：<strong>在有接收者接收数据之前，发送不会结束</strong>。</p><p>可以想象一个无缓冲的通道在没有空间来保存数据的时候：<strong>必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。</strong></p><p>所以通道的发送（接收）操作在对方准备好之前是 <strong>阻塞</strong> 的：</p><p>1）对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：<strong>新的输入无法在通道非空的情况下传入</strong> 。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。</p><p>2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：<strong>如果通道中没有数据，接收者就阻塞了</strong> 。</p><p>下面的例子验证了以上理论，一个协程在无限循环中给通道发送整数数据。不过因为没有接收者，只输出了一个数字 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch1 :&#x3D; make(chan int)</span><br><span class="line">    go pump(ch1)       &#x2F;&#x2F; pump hangs</span><br><span class="line">    fmt.Println(&lt;-ch1) &#x2F;&#x2F; prints only 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump(ch chan int) &#123;</span><br><span class="line">    for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为通道解除阻塞，可以定义 suck 函数来在无限循环中读取通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func suck(ch chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、通过一个（或多个）通道交换数据进行协程同步"><a href="#3、通过一个（或多个）通道交换数据进行协程同步" class="headerlink" title="3、通过一个（或多个）通道交换数据进行协程同步"></a>3、通过一个（或多个）通道交换数据进行协程同步</h3><p>通信是一种同步形式：通过通道，两个协程在通信（协程会和）中某刻同步交换数据。无缓冲通道成为了多个协程同步的完美工具。</p><p>甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态。Go 运行时会检查并 panic，停止程序。死锁几乎完全是由糟糕的设计导致的。</p><p>无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道。</p><p>解释为什么下边这个程序会导致 panic：所有的协程都休眠了 - 死锁！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func f1(in chan int) &#123;</span><br><span class="line">    fmt.Println(&lt;-in)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    out :&#x3D; make(chan int)</span><br><span class="line">    out &lt;- 2</span><br><span class="line">    go f1(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无缓冲的 channel 收发都是阻塞的，上面的代码在 main 方法里发送 2（out &lt;- 2），那么就会一直被阻塞着不往下进行。</p><p>解决办法有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一种：将 f1(out) 方法提前</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    out :&#x3D; make(chan int)</span><br><span class="line">    go f1(out)</span><br><span class="line">    out &lt;- 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种：out 使用带缓冲的 channel</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    out :&#x3D; make(chan int, 1)</span><br><span class="line">    out &lt;- 2</span><br><span class="line">    go f1(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、同步通道-使用带缓冲的通道"><a href="#4、同步通道-使用带缓冲的通道" class="headerlink" title="4、同步通道-使用带缓冲的通道"></a>4、同步通道-使用带缓冲的通道</h3><p>一个无缓冲通道只能包含 1 个元素，有时显得很局限。我们给通道提供了一个缓存，可以在扩展的 make 命令中设置它的容量，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf :&#x3D; 100</span><br><span class="line">ch1 :&#x3D; make(chan string, buf)</span><br></pre></td></tr></table></figure><p>buf 是通道可以同时容纳的元素（这里是 string）个数。</p><p>在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。</p><p>缓冲容量和类型无关，所以可以给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 cap 函数可以返回缓冲区的容量。</p><p>如果 <strong>容量大于 0</strong> ，通道就是 <strong>异步的</strong> 了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会 <strong>按照发送的顺序被接收</strong> 。如果 <strong>容量是 0 或者未设置</strong> ，通信仅在 <strong>收发双方准备好（同步）</strong> 的情况下才可以成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D;make(chan type, value)</span><br><span class="line"></span><br><span class="line">value &#x3D;&#x3D; 0 -&gt; synchronous, unbuffered (阻塞）</span><br><span class="line">value &gt; 0 -&gt; asynchronous, buffered（非阻塞）取决于 value 元素</span><br></pre></td></tr></table></figure><p>若使用通道的缓冲，你的程序会在“请求”激增的时候表现更好：更具弹性，专业术语叫：更具有伸缩性（scalable）。要在首要位置使用无缓冲通道来设计算法，只在不确定的情况下使用缓冲。</p><h3 id="5、协程中用通道输出结果"><a href="#5、协程中用通道输出结果" class="headerlink" title="5、协程中用通道输出结果"></a>5、协程中用通道输出结果</h3><p>为了知道计算何时完成，可以通过信道回报。在例子 go sum(bigArray) 中，要这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">go sum(bigArray, ch) &#x2F;&#x2F; bigArray puts the calculated sum on ch</span><br><span class="line">&#x2F;&#x2F; .. do something else for a while</span><br><span class="line">sum :&#x3D; &lt;- ch &#x2F;&#x2F; wait for, and retrieve the sum</span><br></pre></td></tr></table></figure><p>也可以使用通道来达到同步的目的，这个很有效的用法在传统计算机中称为信号量（semaphore）。 或者换个方式：通过通道发送信号告知处理已经完成（在协程中）。</p><p>在其他协程运行时让 main 程序无限阻塞的通常做法是在 main 函数的最后放置一个 {}。</p><p>也可以使用通道让 main 程序等待协程完成，就是所谓的信号量模式。</p><h3 id="6、信号量模式"><a href="#6、信号量模式" class="headerlink" title="6、信号量模式"></a>6、信号量模式</h3><p>下边的片段阐明：协程通过在通道 ch 中放置一个值来处理结束的信号。main 协程等待 &lt;-ch 直到从中获取到值。</p><p>我们期望从这个通道中获取返回的结果，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func compute(ch chan int)&#123;</span><br><span class="line">    ch &lt;- someComputation() &#x2F;&#x2F; when it completes, signal on the channel.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    ch :&#x3D; make(chan int)     &#x2F;&#x2F; allocate a channel.</span><br><span class="line">    go compute(ch)        &#x2F;&#x2F; stat something in a goroutines</span><br><span class="line">    doSomethingElseForAWhile()</span><br><span class="line">    result :&#x3D; &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个信号也可以是其他的，不返回结果，比如下面这个协程中的匿名函数（lambda）协程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">go func()&#123;</span><br><span class="line">    &#x2F;&#x2F; doSomething</span><br><span class="line">    ch &lt;- 1 &#x2F;&#x2F; Send a signal; value does not matter</span><br><span class="line">&#125;()</span><br><span class="line">doSomethingElseForAWhile()</span><br><span class="line">&lt;- ch    &#x2F;&#x2F; Wait for goroutine to finish; discard sent value.</span><br></pre></td></tr></table></figure><p>或者等待两个协程完成，每一个都会对切片 s 的一部分进行排序，片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">done :&#x3D; make(chan bool)</span><br><span class="line">&#x2F;&#x2F; doSort is a lambda function, so a closure which knows the channel done:</span><br><span class="line">doSort :&#x3D; func(s []int)&#123;</span><br><span class="line">    sort(s)</span><br><span class="line">    done &lt;- true</span><br><span class="line">&#125;</span><br><span class="line">i :&#x3D; pivot(s)</span><br><span class="line">go doSort(s[:i])</span><br><span class="line">go doSort(s[i:])</span><br><span class="line">&lt;-done</span><br><span class="line">&lt;-done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下边的代码，用完整的信号量模式对长度为 N 的 float64 切片进行了 N 个 doSomething() 计算并同时完成，通道 sem 分配了相同的长度（且包含空接口类型的元素），待所有的计算都完成后，发送信号（通过放入值）。 在循环中从通道 sem 不停的接收数据来等待所有的协程完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Empty interface &#123;&#125;</span><br><span class="line">var empty Empty</span><br><span class="line">...</span><br><span class="line">data :&#x3D; make([]float64, N)</span><br><span class="line">res :&#x3D; make([]float64, N)</span><br><span class="line">sem :&#x3D; make(chan Empty, N)</span><br><span class="line">...</span><br><span class="line">for i, xi :&#x3D; range data &#123;</span><br><span class="line">    go func (i int, xi float64) &#123;</span><br><span class="line">        res[i] &#x3D; doSomething(i, xi)</span><br><span class="line">        sem &lt;- empty</span><br><span class="line">    &#125; (i, xi)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; wait for goroutines to finish</span><br><span class="line">for i :&#x3D; 0; i &lt; N; i++ &#123; &lt;-sem &#125;</span><br></pre></td></tr></table></figure><p>注意闭合：i、xi 都是作为参数传入闭合函数的，从外层循环中隐藏了变量 i 和 xi。让每个协程有一份 i 和 xi 的拷贝；另外，for 循环的下一次迭代会更新所有协程中 i 和 xi 的值。切片 res 没有传入闭合函数，因为协程不需要单独拷贝一份。切片 res 也在闭合函数中但并不是参数。</p><h3 id="7、实现并行的-for-循环"><a href="#7、实现并行的-for-循环" class="headerlink" title="7、实现并行的 for 循环"></a>7、实现并行的 for 循环</h3><p>下面的代码中，for 循环的每一个迭代是并行完成的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i, v :&#x3D; range data &#123;</span><br><span class="line">    go func (i int, v float64) &#123;</span><br><span class="line">        doSomething(i, v)</span><br><span class="line">        ...</span><br><span class="line">    &#125; (i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for 循环中并行计算迭代可能带来很好的性能提升。不过所有的迭代都必须是独立完成的。有些语言比如 Fortress 或者其他并行框架以不同的结构实现了这种方式，在 Go 中用协程实现起来非常容易。</p><h3 id="8、用带缓冲通道实现一个信号量"><a href="#8、用带缓冲通道实现一个信号量" class="headerlink" title="8、用带缓冲通道实现一个信号量"></a>8、用带缓冲通道实现一个信号量</h3><p>信号量是实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题，比如没有实现信号量的 sync 的 Go 包，使用带缓冲的通道可以轻松实现：</p><ul><li>带缓冲通道的容量和要同步的资源容量相同</li><li>通道的长度（当前存放的元素个数）与当前资源被使用的数量相同</li><li>容量减去通道的长度就是未处理的资源个数（标准信号量的整数值）</li></ul><p>不用管通道中存放的是什么，只关注长度；因此我们创建了一个长度可变但容量为 0（字节）的通道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Empty interface &#123;&#125;</span><br><span class="line">type semaphore chan Empty</span><br></pre></td></tr></table></figure><p>将可用资源的数量 N 来初始化信号量 semaphore：sem = make(semaphore, N)</p><p>然后直接对信号量进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; acquire n resources</span><br><span class="line">func (s semaphore) P(n int) &#123;</span><br><span class="line">    e :&#x3D; new(Empty)</span><br><span class="line">    for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">        s &lt;- e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; release n resouces</span><br><span class="line">func (s semaphore) V(n int) &#123;</span><br><span class="line">    for i:&#x3D; 0; i &lt; n; i++&#123;</span><br><span class="line">        &lt;- s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用来实现一个互斥的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* mutexes *&#x2F;</span><br><span class="line">func (s semaphore) Lock() &#123;</span><br><span class="line">    s.P(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s semaphore) Unlock()&#123;</span><br><span class="line">    s.V(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* signal-wait *&#x2F;</span><br><span class="line">func (s semaphore) Wait(n int) &#123;</span><br><span class="line">    s.P(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s semaphore) Signal() &#123;</span><br><span class="line">    s.V(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="习惯用法：通道工厂模式"><a href="#习惯用法：通道工厂模式" class="headerlink" title="习惯用法：通道工厂模式"></a>习惯用法：通道工厂模式</h4><p>编程中常见的另外一种模式如下：不将通道作为参数传递给协程，而用函数来生成一个通道并返回（工厂角色）；函数内有个匿名函数被协程调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    stream :&#x3D; pump()</span><br><span class="line">    go suck(stream)</span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump() chan int &#123;</span><br><span class="line">    ch :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func suck(ch chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、给通道使用-for-循环"><a href="#10、给通道使用-for-循环" class="headerlink" title="10、给通道使用 for 循环"></a>10、给通道使用 for 循环</h3><p>for 循环的 range 语句可以用在通道 ch 上，便可以从通道中获取值，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for v :&#x3D; range ch &#123;</span><br><span class="line">    fmt.Printf(&quot;The value is %v\n&quot;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它从指定通道中读取数据直到通道关闭，才继续执行下边的代码。很明显，另外一个协程必须写入 ch（不然代码就阻塞在 for 循环了），而且必须在写入完成后才关闭。</p><p>完整代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    suck(pump())</span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump() chan int &#123;</span><br><span class="line">    ch :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func suck(ch chan int) &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for v :&#x3D; range ch &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="习惯用法：通道迭代模式"><a href="#习惯用法：通道迭代模式" class="headerlink" title="习惯用法：通道迭代模式"></a>习惯用法：通道迭代模式</h4><p>从包含了地址索引字段 items 的容器给通道填入元素。为容器的类型定义一个方法 Iter()，返回一个只读的通道 items，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (c *container) Iter () &lt;- chan items &#123;</span><br><span class="line">    ch :&#x3D; make(chan item)</span><br><span class="line">    go func () &#123;</span><br><span class="line">        for i:&#x3D; 0; i &lt; c.Len(); i++&#123;    &#x2F;&#x2F; or use a for-range loop</span><br><span class="line">            ch &lt;- c.items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在协程里，一个 for 循环迭代容器 c 中的元素（对于树或图的算法，这种简单的 for 循环可以替换为深度优先搜索）。</p><p>调用这个方法的代码可以这样迭代容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for x :&#x3D; range container.Iter() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>可以运行在自己的协程中，所以上边的迭代用到了一个通道和两个协程（可能运行在两个线程上）。就有了一个特殊的生产者-消费者模式。</p><p>如果程序在协程给通道写完值之前结束，协程不会被回收；设计如此。这种行为看起来是错误的，但是通道是一种线程安全的通信。</p><p>在这种情况下，协程尝试写入一个通道，而这个通道永远不会被读取，这可能是个 bug 而并非期望它被静默的回收。</p><h4 id="习惯用法：生产者消费者模式"><a href="#习惯用法：生产者消费者模式" class="headerlink" title="习惯用法：生产者消费者模式"></a>习惯用法：生产者消费者模式</h4><p>假设你有 Produce() 函数来产生 Consume 函数需要的值。它们都可以运行在独立的协程中，生产者在通道中放入给消费者读取的值。整个处理过程可以替换为无限循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    Consume(Produce())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、通道的方向"><a href="#11、通道的方向" class="headerlink" title="11、通道的方向"></a>11、通道的方向</h3><p>通道类型可以用注解来表示它只发送或者只接收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var send_only chan&lt;- int         &#x2F;&#x2F; channel can only receive data</span><br><span class="line">var recv_only &lt;-chan int        &#x2F;&#x2F; channel can only send data</span><br></pre></td></tr></table></figure><p>只接收的通道（&lt;-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。</p><p><strong>通道创建的时候都是双向的</strong> ，但也可以分配有方向的通道变量，就像以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var c &#x3D; make(chan int) &#x2F;&#x2F; bidirectional</span><br><span class="line">go source(c)</span><br><span class="line">go sink(c)</span><br><span class="line"></span><br><span class="line">func source(ch chan&lt;- int)&#123;</span><br><span class="line">    for &#123; ch &lt;- 1 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sink(ch &lt;-chan int) &#123;</span><br><span class="line">    for &#123; &lt;-ch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管道和选择器模式"><a href="#管道和选择器模式" class="headerlink" title="管道和选择器模式"></a>管道和选择器模式</h4><p>协程处理它从通道接收的数据并发送给输出通道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sendChan :&#x3D; make(chan int)</span><br><span class="line">reciveChan :&#x3D; make(chan string)</span><br><span class="line">go processChannel(sendChan, receiveChan)</span><br><span class="line"></span><br><span class="line">func processChannel(in &lt;-chan int, out chan&lt;- string) &#123;</span><br><span class="line">    for inValue :&#x3D; range in &#123;</span><br><span class="line">        result :&#x3D; ... &#x2F;&#x2F;&#x2F; processing inValue</span><br><span class="line">    out &lt;- result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用方向注解来限制协程对通道的操作。</p><h4 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h4><p>这里有一个来自 Go 指导的很赞的例子，打印了输出的素数，使用选择器（‘筛’）作为它的算法。每个 prime 都有一个选择器，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Copyright 2009 The Go Authors. All rights reserved.</span><br><span class="line">&#x2F;&#x2F; Use of this source code is governed by a BSD-style</span><br><span class="line">&#x2F;&#x2F; license that can be found in the LICENSE file.package main</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;.</span><br><span class="line">func generate(ch chan int) &#123;</span><br><span class="line">    for i :&#x3D; 2; ; i++ &#123;</span><br><span class="line">        ch &lt;- i &#x2F;&#x2F; Send &#39;i&#39; to channel &#39;ch&#39;.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Copy the values from channel &#39;in&#39; to channel &#39;out&#39;,</span><br><span class="line">&#x2F;&#x2F; removing those divisible by &#39;prime&#39;.</span><br><span class="line">func filter(in, out chan int, prime int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        i :&#x3D; &lt;-in &#x2F;&#x2F; Receive value of new variable &#39;i&#39; from &#39;in&#39;.</span><br><span class="line">        if i%prime !&#x3D; 0 &#123;</span><br><span class="line">            out &lt;- i &#x2F;&#x2F; Send &#39;i&#39; to channel &#39;out&#39;.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The prime sieve: Daisy-chain filter processes together.</span><br><span class="line">func main() &#123;</span><br><span class="line">    ch :&#x3D; make(chan int) &#x2F;&#x2F; Create a new channel.</span><br><span class="line">    go generate(ch)      &#x2F;&#x2F; Start generate() as a goroutine.</span><br><span class="line">    for &#123;</span><br><span class="line">        prime :&#x3D; &lt;-ch</span><br><span class="line">        fmt.Print(prime, &quot; &quot;)</span><br><span class="line">        ch1 :&#x3D; make(chan int)</span><br><span class="line">        go filter(ch, ch1, prime)</span><br><span class="line">        ch &#x3D; ch1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程 filter(in, out chan int, prime int) 拷贝整数到输出通道，丢弃掉可以被 prime 整除的数字。然后每个 prime 又开启了一个新的协程，生成器和选择器并发请求。</p><h4 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h4><p>第二个版本引入了上边的习惯用法：函数 sieve、generate 和 filter 都是工厂；它们创建通道并返回，而且使用了协程的 lambda 函数。main 函数现在短小清晰：它调用 sieve() 返回了包含素数的通道，然后通过 fmt.Println(&lt;-primes) 打印出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Copyright 2009 The Go Authors. All rights reserved.</span><br><span class="line">&#x2F;&#x2F; Use of this source code is governed by a BSD-style</span><br><span class="line">&#x2F;&#x2F; license that can be found in the LICENSE file.</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Send the sequence 2, 3, 4, ... to returned channel</span><br><span class="line">func generate() chan int &#123;</span><br><span class="line">    ch :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i :&#x3D; 2; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Filter out input values divisible by &#39;prime&#39;, send rest to returned channel</span><br><span class="line">func filter(in chan int, prime int) chan int &#123;</span><br><span class="line">    out :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            if i :&#x3D; &lt;-in; i%prime !&#x3D; 0 &#123;</span><br><span class="line">                out &lt;- i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sieve() chan int &#123;</span><br><span class="line">    out :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        ch :&#x3D; generate()</span><br><span class="line">        for &#123;</span><br><span class="line">            prime :&#x3D; &lt;-ch</span><br><span class="line">            ch &#x3D; filter(ch, prime)</span><br><span class="line">            out &lt;- prime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    primes :&#x3D; sieve()</span><br><span class="line">    for &#123;</span><br><span class="line">        fmt.Println(&lt;-primes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、协程的同步：关闭通道-测试阻塞的通道"><a href="#三、协程的同步：关闭通道-测试阻塞的通道" class="headerlink" title="三、协程的同步：关闭通道-测试阻塞的通道"></a>三、协程的同步：关闭通道-测试阻塞的通道</h2><p>通道可以被显式的关闭；尽管它们和文件不同：不必每次都关闭。只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道。</p><p>只有发送者需要关闭通道，接收者永远不会需要。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch :&#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">    go sendData(ch)</span><br><span class="line">    go getData(ch)</span><br><span class="line"></span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sendData(ch chan string) &#123;</span><br><span class="line">    ch &lt;- &quot;Washington&quot;</span><br><span class="line">    ch &lt;- &quot;Tripoli&quot;</span><br><span class="line">    ch &lt;- &quot;London&quot;</span><br><span class="line">    ch &lt;- &quot;Beijing&quot;</span><br><span class="line">    ch &lt;- &quot;Tokio&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData(ch chan string) &#123;</span><br><span class="line">    var input string</span><br><span class="line">    &#x2F;&#x2F; time.Sleep(2e9)</span><br><span class="line">    for &#123;</span><br><span class="line">        input &#x3D; &lt;-ch</span><br><span class="line">        fmt.Printf(&quot;%s &quot;, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如何在通道的 sendData() 完成的时候发送一个信号，getData() 又如何检测到通道是否关闭或阻塞？</p><p>第一个问题可以通过函数 close(ch) 来完成：这个将通道标记为无法通过发送操作 &lt;- 接受更多的值；给已经关闭的通道发送或者再次关闭都会导致运行时的 panic。在创建一个通道后使用 defer 语句是个不错的办法（类似这种情况）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan float64)</span><br><span class="line">defer close(ch)</span><br></pre></td></tr></table></figure><p>第二个问题可以使用逗号，ok 操作符：用来检测通道是否被关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">v, ok :&#x3D; &lt;-ch   &#x2F;&#x2F; ok is true if v received value</span><br><span class="line"></span><br><span class="line">通常和 if 语句一起使用：</span><br><span class="line"></span><br><span class="line">if v, ok :&#x3D; &lt;-ch; ok &#123;</span><br><span class="line">  process(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者在 for 循环中接收的时候，当关闭或者阻塞的时候使用 break：</span><br><span class="line"></span><br><span class="line">v, ok :&#x3D; &lt;-ch</span><br><span class="line">if !ok &#123;</span><br><span class="line">  break</span><br><span class="line">&#125;</span><br><span class="line">process(v)</span><br><span class="line"></span><br><span class="line">使用 for-range 语句来读取通道是更好的办法，因为这会自动检测通道是否关闭：</span><br><span class="line"></span><br><span class="line">for input :&#x3D; range ch &#123;</span><br><span class="line">    process(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、使用-select-切换协程"><a href="#四、使用-select-切换协程" class="headerlink" title="四、使用 select 切换协程"></a>四、使用 select 切换协程</h2><p>从不同的并发执行的协程中获取值可以通过关键字 select 来完成，它和 switch 控制语句非常相似也被称作通信开关；它的行为像是 “你准备好了吗” 的 <strong>轮询机制</strong>；select 监听进入通道的数据，也可以是用通道发送值的时候。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case u:&#x3D; &lt;- ch1:</span><br><span class="line">        ...</span><br><span class="line">case v:&#x3D; &lt;- ch2:</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">default: &#x2F;&#x2F; no value ready to be received</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default 语句是可选的；fallthrough 行为，和普通的 switch 相似，是不允许的。在任何一个 case 中执行 break 或者 return，select 就结束了。</span><br></pre></td></tr></table></figure><p>select 做的就是：选择处理列出的多个通信情况中的一个。</p><ul><li>如果都阻塞了，会等待直到其中一个可以处理</li><li>如果多个可以处理，随机选择一个</li><li>如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。</li><li>在 select 中使用发送操作并且有 default 可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞。</li></ul><p>在 select 中使用发送操作并且有 default 可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞。</p><p>select 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 break 语句使循环退出。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch1 :&#x3D; make(chan int)</span><br><span class="line">    ch2 :&#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">    go pump1(ch1)</span><br><span class="line">    go pump2(ch2)</span><br><span class="line">    go suck(ch1, ch2)</span><br><span class="line"></span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump1(ch chan int) &#123;</span><br><span class="line">    for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">        ch &lt;- i * 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump2(ch chan int) &#123;</span><br><span class="line">    for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">        ch &lt;- i + 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func suck(ch1, ch2 chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case v :&#x3D; &lt;-ch1:</span><br><span class="line">            fmt.Printf(&quot;Received on channel 1: %d\n&quot;, v)</span><br><span class="line">        case v :&#x3D; &lt;-ch2:</span><br><span class="line">            fmt.Printf(&quot;Received on channel 2: %d\n&quot;, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面例子中有 2 个通道 ch1 和 ch2，三个协程 pump1()、pump2() 和 suck()。 这是一个典型的生产者消费者模式。</p><p>在无限循环中，ch1 和 ch2 通过 pump1() 和 pump2() 填充整数；suck() 也是在无限循环中轮询输入的，通过 select 语句获取 ch1 和 ch2 的整数并输出。</p><p>选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。</p><h4 id="习惯用法：后台服务模式"><a href="#习惯用法：后台服务模式" class="headerlink" title="习惯用法：后台服务模式"></a>习惯用法：后台服务模式</h4><p>服务通常是用后台协程中的无限循环实现的，在循环中使用 select 获取并处理通道中的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Backend goroutine.</span><br><span class="line">func backend() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case cmd :&#x3D; &lt;-ch1:</span><br><span class="line">            &#x2F;&#x2F; Handle ...</span><br><span class="line">        case cmd :&#x3D; &lt;-ch2:</span><br><span class="line">            ...</span><br><span class="line">        case cmd :&#x3D; &lt;-chStop:</span><br><span class="line">            &#x2F;&#x2F; stop server</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序的其他地方给通道 ch1，ch2 发送数据，比如：通道 stop 用来清理结束服务程序。</p><p>另一种方式（但是不太灵活）就是（客户端）在 chRequest 上提交请求，后台协程循环这个通道，使用 switch 根据请求的行为来分别处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func backend() &#123;</span><br><span class="line">    for req :&#x3D; range chRequest &#123;</span><br><span class="line">        switch req.Subjext() &#123;</span><br><span class="line">            case A1:  &#x2F;&#x2F; Handle case ...</span><br><span class="line">            case A2:  &#x2F;&#x2F; Handle case ...</span><br><span class="line">            default:</span><br><span class="line">              &#x2F;&#x2F; Handle illegal request ..</span><br><span class="line">              &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、通道、超时和计时器（Ticker）"><a href="#五、通道、超时和计时器（Ticker）" class="headerlink" title="五、通道、超时和计时器（Ticker）"></a>五、通道、超时和计时器（Ticker）</h2><p>time 包中有一些有趣的功能可以和通道组合使用。</p><p>其中就包含了 time.Ticker 结构体，这个对象以指定的时间间隔重复的向通道 C 发送时间值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Ticker struct &#123;</span><br><span class="line">    C &lt;-chan Time &#x2F;&#x2F; the channel on which the ticks are delivered.</span><br><span class="line">    &#x2F;&#x2F; contains filtered or unexported fields</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间间隔的单位是 ns（纳秒，int64），在工厂函数 time.NewTicker 中以 Duration 类型的参数传入：func Newticker(dur) *Ticker。</p><p>在协程周期性的执行一些事情（打印状态日志，输出，计算等等）的时候非常有用。</p><p>调用 Stop() 使计时器停止，在 defer 语句中使用。这些都很好的适应 select 语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ticker :&#x3D; time.NewTicker(updateInterval)</span><br><span class="line">defer ticker.Stop()</span><br><span class="line">...</span><br><span class="line">select &#123;</span><br><span class="line">case u:&#x3D; &lt;-ch1:</span><br><span class="line">    ...</span><br><span class="line">case v:&#x3D; &lt;-ch2:</span><br><span class="line">    ...</span><br><span class="line">case &lt;-ticker.C:</span><br><span class="line">    logState(status) &#x2F;&#x2F; call some logging function logState</span><br><span class="line">default: &#x2F;&#x2F; no value ready to be received</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time.Tick() 函数声明为 Tick(d Duration) &lt;-chan Time，当你想返回一个通道而不必关闭它的时候这个函数非常有用：它以 d 为周期给返回的通道发送时间，d 是纳秒数。</p><p>如果需要像下边的代码一样，限制处理频率（函数 client.Call() 是一个 RPC 调用，这里暂不赘述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">rate_per_sec :&#x3D; 10</span><br><span class="line">var dur Duration &#x3D; 1e9 &#x2F; rate_per_sec</span><br><span class="line">chRate :&#x3D; time.Tick(dur) &#x2F;&#x2F; a tick every 1&#x2F;10th of a second</span><br><span class="line">for req :&#x3D; range requests &#123;</span><br><span class="line">    &lt;- chRate &#x2F;&#x2F; rate limit our Service.Method RPC calls</span><br><span class="line">    go client.Call(&quot;Service.Method&quot;, req, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器（Timer）结构体看上去和计时器（Ticker）结构体的确很像（构造为 NewTimer(d Duration)），但是它只发送一次时间，在 Dration d 之后。</p><p>还有 time.After(d) 函数，声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func After(d Duration) &lt;-chan Time</span><br></pre></td></tr></table></figure><p>在 Duration d 之后，当前时间被发到返回的通道；所以它和 NewTimer(d).C 是等价的；它类似 Tick()，但是 After() 只发送一次时间。</p><p>下边有个很具体的示例，很好的阐明了 select 中 default 的作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    tick :&#x3D; time.Tick(1e8)</span><br><span class="line">    boom :&#x3D; time.After(5e8)</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-tick:</span><br><span class="line">            fmt.Println(&quot;tick.&quot;)</span><br><span class="line">        case &lt;-boom:</span><br><span class="line">            fmt.Println(&quot;BOOM!&quot;)</span><br><span class="line">            return</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println(&quot;    .&quot;)</span><br><span class="line">            time.Sleep(5e7)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单超时模式"><a href="#简单超时模式" class="headerlink" title="简单超时模式"></a>简单超时模式</h3><h4 id="第一种形式"><a href="#第一种形式" class="headerlink" title="第一种形式"></a>第一种形式</h4><p>要从通道 ch 中接收数据，但是最多等待 1 秒。先创建一个信号通道，然后启动一个 lambda 协程，协程在给通道发送数据之前是休眠的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeout :&#x3D; make(chan bool, 1)</span><br><span class="line">go func() &#123;</span><br><span class="line">        time.Sleep(1e9) &#x2F;&#x2F; one second</span><br><span class="line">        timeout &lt;- true</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>然后使用 select 语句接收 ch 或者 timeout 的数据：如果 ch 在 1 秒内没有收到数据，就选择到了 timeout 分支并放弃了 ch 的读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">    case &lt;-ch:</span><br><span class="line">        &#x2F;&#x2F; a read from ch has occured</span><br><span class="line">    case &lt;-timeout:</span><br><span class="line">        &#x2F;&#x2F; the read from ch has timed out</span><br><span class="line">        break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种形式，取消耗时很长的同步调用"><a href="#第二种形式，取消耗时很长的同步调用" class="headerlink" title="第二种形式，取消耗时很长的同步调用"></a>第二种形式，取消耗时很长的同步调用</h4><p>也可以使用 time.After() 函数替换 timeout-channel。可以在 select 中通过 time.After() 发送的超时信号来停止协程的执行。</p><p>以下代码，在 timeoutNs 纳秒后执行 select 的 timeout 分支后，执行 client.Call 的协程也随之结束，不会给通道 ch 返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan error, 1)</span><br><span class="line">go func() &#123; ch &lt;- client.Call(&quot;Service.Method&quot;, args, &amp;reply) &#125; ()</span><br><span class="line">select &#123;</span><br><span class="line">case resp :&#x3D; &lt;-ch</span><br><span class="line">    &#x2F;&#x2F; use resp and reply</span><br><span class="line">case &lt;-time.After(timeoutNs):</span><br><span class="line">    &#x2F;&#x2F; call timed out</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意缓冲大小设置为 1 是必要的，可以避免协程死锁以及确保超时的通道可以被垃圾回收。</p><p>此外，需要注意在有多个 case 符合条件时，select 对 case 的选择是伪随机的。</p><p>如果上面的代码稍作修改如下，则 select 语句可能不会在定时器超时信号到来时立刻选中 time.After(timeoutNs) 对应的 case，因此协程可能不会严格按照定时器设置的时间结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int, 1)</span><br><span class="line">go func() &#123; for &#123; ch &lt;- 1 &#125; &#125; ()</span><br><span class="line">L:</span><br><span class="line">for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-ch:</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">    case &lt;-time.After(timeoutNs):</span><br><span class="line">        &#x2F;&#x2F; call timed out</span><br><span class="line">        break L</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三种形式，取消耗时很长的同步调用"><a href="#第三种形式，取消耗时很长的同步调用" class="headerlink" title="第三种形式，取消耗时很长的同步调用"></a>第三种形式，取消耗时很长的同步调用</h4><p>假设程序从多个复制的数据库同时读取。只需要一个答案，需要接收首先到达的答案，Query 函数获取数据库的连接切片并请求。</p><p>并行请求每一个数据库并返回收到的第一个响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Query(conns []conn, query string) Result &#123;</span><br><span class="line">    ch :&#x3D; make(chan Result, 1)</span><br><span class="line">    for _, conn :&#x3D; range conns &#123;</span><br><span class="line">        go func(c Conn) &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case ch &lt;- c.DoQuery(query):</span><br><span class="line">            default:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(conn)</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次声明，结果通道 ch 必须是带缓冲的：以保证第一个发送进来的数据有地方可以存放，确保放入的首个数据总会成功，所以第一个到达的值会被获取而与执行的顺序无关。</p><p>正在执行的协程总是可以使用 runtime.Goexit() 来停止。</p><h2 id="六、协程和恢复（recover）"><a href="#六、协程和恢复（recover）" class="headerlink" title="六、协程和恢复（recover）"></a>六、协程和恢复（recover）</h2><p>一个用到 recover 的程序，停掉了服务器内部一个失败的协程而不影响其他协程的工作。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func server(workChan &lt;-chan *Work) &#123;</span><br><span class="line">    for work :&#x3D; range workChan &#123;</span><br><span class="line">        go safelyDo(work)   &#x2F;&#x2F; start the goroutine for that work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func safelyDo(work *Work) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">            log.Printf(&quot;Work failed with %s in %v&quot;, err, work)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的代码，如果 do(work) 发生 panic，错误会被记录且协程会退出并释放，而其他协程不受影响。</p><h2 id="七、新旧模型对比：任务和worker"><a href="#七、新旧模型对比：任务和worker" class="headerlink" title="七、新旧模型对比：任务和worker"></a>七、新旧模型对比：任务和worker</h2><p>假设我们需要处理很多任务；一个 worker 处理一项任务。任务可以被定义为一个结构体（具体的细节在这里并不重要）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Task struct &#123;</span><br><span class="line">    &#x2F;&#x2F; some state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>旧模式：使用共享内存进行同步</p><p>由各个任务组成的任务池共享内存；为了同步各个 worker 以及避免资源竞争，我们需要对任务池进行加锁保护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Pool struct &#123;</span><br><span class="line">    Mu      sync.Mutex</span><br><span class="line">    Tasks   []Task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Mutex(是互斥锁：它用来在代码中保护临界区资源：同一时间只有一个 go 协程（goroutine）可以进入该临界区。</p><p>如果出现了同一时间多个 go 协程都进入了该临界区，则会产生竞争：Pool 结构就不能保证被正确更新。</p><p>在传统的模式中（经典的面向对象的语言中应用得比较多，比如 C++,JAVA,C#)，worker 代码可能这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func Worker(pool *Pool) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        pool.Mu.lock()</span><br><span class="line">        &#x2F;&#x2F; begin critical section:</span><br><span class="line">        task :&#x3D; pool.Task[0]        &#x2F;&#x2F; take the first task</span><br><span class="line">        pool.Tasks &#x3D; pool.Task[1:]  &#x2F;&#x2F; update the pool of tasks</span><br><span class="line">        &#x2F;&#x2F; end critical section</span><br><span class="line">        pool.Mu.Unlock()</span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这些 worker 有许多都可以并发执行；他们可以在 go 协程中启动。</span><br><span class="line"></span><br><span class="line">一个 worker 先将 pool 锁定，从 pool 获取第一项任务，再解锁和处理任务。</span><br><span class="line"></span><br><span class="line">加锁保证了同一时间只有一个 go 协程可以进入到 pool 中：一项任务有且只能被赋予一个 worker。</span><br><span class="line"></span><br><span class="line">如果不加锁，则工作协程可能会在 task:&#x3D;pool.Task[0] 发生切换，</span><br><span class="line">导致 pool.Tasks&#x3D;pool.Task[1:] 结果异常：一些 worker 获取不到任务，而一些任务可能被多个 worker 得到。</span><br><span class="line"></span><br><span class="line">加锁实现同步的方式在工作协程比较少时可以工作的很好，但是当工作协程数量很大，任务量也很多时，</span><br><span class="line">处理效率将会因为频繁的加锁（解锁）开销而降低。当工作协程数增加到一个阈值时，程序效率会急剧下降，这就成为了瓶颈。</span><br></pre></td></tr></table></figure><h3 id="使用通道进行同步"><a href="#使用通道进行同步" class="headerlink" title="使用通道进行同步"></a>使用通道进行同步</h3><p>使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker 在协程中启动，其数量 N 应该根据任务数量进行调整。</p><p>主线程扮演着 Master 节点角色，可能写成如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    pending, done :&#x3D; make(chan *Task), make(chan *Task)</span><br><span class="line">    go sendWork(pending)       &#x2F;&#x2F; put tasks with work on the channel</span><br><span class="line">    for i :&#x3D; 0; i &lt; N; i++ &#123;   &#x2F;&#x2F; start N goroutines to do work</span><br><span class="line">        go Worker(pending, done)</span><br><span class="line">    &#125;</span><br><span class="line">    consumeWork(done)          &#x2F;&#x2F; continue with the processed tasks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worker 的逻辑比较简单：从 pending 通道拿任务，处理后将其放到 done 通道中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func Worker(in, out chan *Task) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        t :&#x3D; &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并不使用锁：从通道得到新任务的过程没有任何竞争。</p><p>随着任务数量增加，worker 数量也应该相应增加，同时性能并不会像第一种方式那样下降明显。</p><p>在 pending 通道中存在一份任务的拷贝，第一个 worker 从 pending 通道中获得第一个任务并进行处理，这里并不存在竞争（对一个通道读数据和写数据的整个过程是原子性的)。</p><p>某一个任务会在哪一个 worker 中被执行是不可知的，反过来也是。</p><p>worker 数量的增多也会增加通信的开销，这会对性能有轻微的影响。</p><p>对于任何可以建模为 Master-Worker 范例的问题，一个类似于 worker 使用通道进行通信和交互、Master 进行整体协调的方案都能完美解决。</p><p>如果系统部署在多台机器上，各个机器上执行 Worker 协程，Master 和 Worker 之间使用 netchan 或者 RPC 进行通信。</p><h3 id="怎么选择是该使用锁还是通道？"><a href="#怎么选择是该使用锁还是通道？" class="headerlink" title="怎么选择是该使用锁还是通道？"></a>怎么选择是该使用锁还是通道？</h3><p>通道是一个较新的概念，本节我们着重强调了在 go 协程里通道的使用，但这并不意味着经典的锁方法就不能使用。</p><p>go 语言让你可以根据实际问题进行选择：创建一个优雅、简单、可读性强、在大多数场景性能表现都能很好的方案。如果你的问题适合使用锁，也不要忌讳使用它。</p><p>go 语言注重实用，什么方式最能解决你的问题就用什么方式，而不是强迫你使用一种编码风格。下面列出一个普遍的经验法则：</p><ul><li>使用锁的情景：<ul><li>访问共享数据结构中的缓存信息</li><li>保存应用程序上下文和状态信息数据</li></ul></li><li>使用通道的情景：<ul><li>与异步操作的结果进行交互</li><li>分发任务</li><li>传递数据所有权</li></ul></li></ul><p>当你发现你的锁使用规则变得很复杂时，可以反省使用通道会不会使问题变得简单些。</p><h2 id="八、惰性生成器的实现"><a href="#八、惰性生成器的实现" class="headerlink" title="八、惰性生成器的实现"></a>八、惰性生成器的实现</h2><p>生成器是指当被调用时返回一个序列中下一个值的函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generateInteger() &#x3D;&gt; 0</span><br><span class="line">generateInteger() &#x3D;&gt; 1</span><br><span class="line">generateInteger() &#x3D;&gt; 2</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>生成器每次返回的是序列中下一个值而非整个序列；这种特性也称之为惰性求值：只在你需要时进行求值，同时保留相关变量资源（内存和 cpu）：这是一项在需要时对表达式进行求值的技术。</p><p>例如，生成一个无限数量的偶数序列：要产生这样一个序列并且在一个一个的使用可能会很困难，而且内存会溢出！但是一个含有通道和 go 协程的函数能轻易实现这个需求。</p><p>通过巧妙地使用空接口、闭包和高阶函数，我们能实现一个通用的惰性生产器的工厂函数 BuildLazyEvaluator（这个应该放在一个工具包中实现）。</p><p>工厂函数需要一个函数和一个初始状态作为输入参数，返回一个无参、返回值是生成序列的函数。</p><p>传入的函数需要计算出下一个返回值以及下一个状态参数。在工厂函数中，创建一个通道和无限循环的 go 协程。 返回值被放到了该通道中，返回函数稍后被调用时从该通道中取得该返回值。每当取得一个值时，下一个值即被计算。</p><p>在下面的例子中，定义了一个 evenFunc 函数，其是一个惰性生成函数：在 main 函数中，我们创建了前 10 个偶数，每个都是通过调用 even() 函数取得下一个值的。</p><p>为此，我们需要在 BuildLazyIntEvaluator 函数中具体化我们的生成函数，然后我们能够基于此做出定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Any interface&#123;&#125;</span><br><span class="line">type EvalFunc func(Any) (Any, Any)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    evenFunc :&#x3D; func(state Any) (Any, Any) &#123;</span><br><span class="line">        os :&#x3D; state.(int)</span><br><span class="line">        ns :&#x3D; os + 2</span><br><span class="line">        return os, ns</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    even :&#x3D; BuildLazyIntEvaluator(evenFunc, 0)</span><br><span class="line"></span><br><span class="line">    for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%vth even: %v\n&quot;, i, even())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BuildLazyEvaluator(evalFunc EvalFunc, initState Any) func() Any &#123;</span><br><span class="line">    retValChan :&#x3D; make(chan Any)</span><br><span class="line">    loopFunc :&#x3D; func() &#123;</span><br><span class="line">        var actState Any &#x3D; initState</span><br><span class="line">        var retVal Any</span><br><span class="line">        for &#123;</span><br><span class="line">            retVal, actState &#x3D; evalFunc(actState)</span><br><span class="line">            retValChan &lt;- retVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    retFunc :&#x3D; func() Any &#123;</span><br><span class="line">        return &lt;- retValChan</span><br><span class="line">    &#125;</span><br><span class="line">    go loopFunc()</span><br><span class="line">    return retFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BuildLazyIntEvaluator(evalFunc EvalFunc, initState Any) func() int &#123;</span><br><span class="line">    ef :&#x3D; BuildLazyEvaluator(evalFunc, initState)</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        return ef().(int)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、实现-Futures-模式"><a href="#九、实现-Futures-模式" class="headerlink" title="九、实现 Futures 模式"></a>九、实现 Futures 模式</h2><p>所谓 Futures 就是指：有时候在你使用某一个值之前需要先对其进行计算。这种情况下，你就可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕了。</p><p>Futures 模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于 Futures 需要返回一个值。</p><p>假设我们有一个矩阵类型，我们需要计算两个矩阵 A 和 B 乘积的逆，首先我们通过函数 Inverse(M) 分别对其进行求逆运算，在将结果相乘。</p><p>如下函数 InverseProduct() 实现了如上过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func InverseProduct(a Matrix, b Matrix) &#123;</span><br><span class="line">    a_inv :&#x3D; Inverse(a)</span><br><span class="line">    b_inv :&#x3D; Inverse(b)</span><br><span class="line">    return Product(a_inv, b_inv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，a 和 b 的求逆矩阵需要先被计算。 那么为什么在计算 b 的逆矩阵时，需要等待 a 的逆计算完成呢？</p><p>显然不必要，这两个求逆运算其实可以并行执行的。换句话说，调用 Product 函数只需要等到 a_inv 和 b_inv 的计算完成。</p><p>如下代码实现了并行计算方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func InverseProduct(a Matrix, b Matrix) &#123;</span><br><span class="line">    a_inv_future :&#x3D; InverseFuture(a)   &#x2F;&#x2F; start as a goroutine</span><br><span class="line">    b_inv_future :&#x3D; InverseFuture(b)   &#x2F;&#x2F; start as a goroutine</span><br><span class="line">    a_inv :&#x3D; &lt;-a_inv_future</span><br><span class="line">    b_inv :&#x3D; &lt;-b_inv_future</span><br><span class="line">    return Product(a_inv, b_inv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InverseFuture 函数起了一个 goroutine 协程，在其执行闭包运算，该闭包会将矩阵求逆结果放入到 future 通道中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func InverseFuture(a Matrix) &#123;</span><br><span class="line">    future :&#x3D; make(chan Matrix)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        future &lt;- Inverse(a)</span><br><span class="line">    &#125;()</span><br><span class="line">    return future</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、客户端-服务端模式"><a href="#十、客户端-服务端模式" class="headerlink" title="十、客户端-服务端模式"></a>十、客户端-服务端模式</h2><p>Client-server 类的应用是协程（goroutine）和频道（channel）的大显身手的闪光点。</p><p>客户端可以是任何一种运行在任何设备上的，且需要来自服务端信息的一种程序，所以它需要发送请求。</p><p>服务端接收请求，做一些处理，然后把给客户端发送响应信息。在通常情况下，就是多个客户端（很多请求）对一个（或几个）服务端。</p><p>一个常见例子就是我们使用的发送网页请求的客户端浏览器。然后一个 web 服务器将响应网页发回给浏览器。</p><p>在 Go 中，服务端通常会在一个协程（goroutine）里操作对一个客户端的响应，所以协程和客户端请求是一一对应的。</p><p>一种典型的做法就是客户端请求本身包含了一个频道（channel），服务端可以用它来发送响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Request struct &#123;</span><br><span class="line">    a, b   int</span><br><span class="line">    replyc chan int &#x2F;&#x2F; 请求中的回复频道</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type binOp func(a, b int) int</span><br><span class="line"></span><br><span class="line">func run(op binOp, req *Request) &#123;</span><br><span class="line">    req.replyc &lt;- op(req.a, req.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func server(op binOp, service chan *Request) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        req :&#x3D; &lt;-service &#x2F;&#x2F; 请求到达这里</span><br><span class="line">        &#x2F;&#x2F; 开启请求的 Goroutine ：</span><br><span class="line">        go run(op, req) &#x2F;&#x2F; 不要等待 op</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startServer(op binOp) chan *Request &#123;</span><br><span class="line">    reqChan :&#x3D; make(chan *Request)</span><br><span class="line">    go server(op, reqChan)</span><br><span class="line">    return reqChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    adder :&#x3D; startServer(func(a, b int) int &#123; return a + b &#125;)</span><br><span class="line">    const N &#x3D; 100</span><br><span class="line">    var reqs [N]Request</span><br><span class="line"></span><br><span class="line">    for i :&#x3D; 0; i &lt; N; i++ &#123;</span><br><span class="line">        req :&#x3D; &amp;reqs[i]</span><br><span class="line">        req.a &#x3D; i</span><br><span class="line">        req.b &#x3D; i + N</span><br><span class="line">        req.replyc &#x3D; make(chan int)</span><br><span class="line">        adder &lt;- req</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 校验：</span><br><span class="line">    for i :&#x3D; N - 1; i &gt;&#x3D; 0; i-- &#123; &#x2F;&#x2F; 顺序无所谓</span><br><span class="line">        if &lt;-reqs[i].replyc !&#x3D; N+2*i &#123;</span><br><span class="line">            fmt.Println(&quot;fail at&quot;, i)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fmt.Println(&quot;Request &quot;, i, &quot;is ok!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;done&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、限制并发数"><a href="#十一、限制并发数" class="headerlink" title="十一、限制并发数"></a>十一、限制并发数</h2><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">&#x2F;&#x2F; 10 * 1024 * 1024</span><br><span class="line">AvailableMemory &#x3D; 10 &lt;&lt; 20</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 10 * 1024</span><br><span class="line">AverageMemoryPerRequest &#x3D; 10 &lt;&lt; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1024</span><br><span class="line">MAXREQS &#x3D; AvailableMemory &#x2F; AverageMemoryPerRequest</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var sem &#x3D; make(chan int, MAXREQS)</span><br><span class="line"></span><br><span class="line">type Request struct &#123;</span><br><span class="line">a, b   int</span><br><span class="line">replyc chan int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func process(r *Request) &#123;</span><br><span class="line">&#x2F;&#x2F; Do something 做任何事</span><br><span class="line">&#x2F;&#x2F; 可能需要很长时间并使用大量内存或CPU</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handle(r *Request) &#123;</span><br><span class="line">process(r)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 信号完成：开始启用下一个请求</span><br><span class="line">&#x2F;&#x2F; 将 sem 的缓冲区释放一个位置</span><br><span class="line">&lt;-sem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Server(queue chan *Request) &#123;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">sem &lt;- 1</span><br><span class="line">&#x2F;&#x2F; 当通道已满（1024 个请求被激活）的时候将被阻塞</span><br><span class="line">&#x2F;&#x2F; 所以停在这里等待，直到 sem 有容量（被释放），才能继续去处理请求</span><br><span class="line">&#x2F;&#x2F; (doesn’t matter what we put in it)</span><br><span class="line">request :&#x3D; &lt;-queue</span><br><span class="line">go handle(request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">queue :&#x3D; make(chan *Request)</span><br><span class="line"></span><br><span class="line">go Server(queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，程序中的协程通过使用缓冲通道（这个通道作为一个 semaphore 被使用）来调整资源的使用，实现了对内存等有限资源的优化。</p><h2 id="十二、链式操作（重点！！！！）"><a href="#十二、链式操作（重点！！！！）" class="headerlink" title="十二、链式操作（重点！！！！）"></a>十二、链式操作（重点！！！！）</h2><p>下面的程序演示了启动大量的协程是多么的容易。它发生在 mian 函数的 for 循环中。在循环之后，向 right 通道中插入 0，在不到 1.5s 的时间执行了 100000 个协程，并将结果 100000 打印。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;flag&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ngoroutine &#x3D; flag.Int(&quot;n&quot;, 100000, &quot;how many goroutines&quot;)</span><br><span class="line"></span><br><span class="line">func f(left, right chan int) &#123;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(&quot;left:&quot;, left, &quot;    right:&quot;, right)</span><br><span class="line">left &lt;- 1 + &lt;-right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">flag.Parse()</span><br><span class="line">leftmost :&#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">var left, right chan int &#x3D; nil, leftmost</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; *ngoroutine; i++ &#123;</span><br><span class="line">left, right &#x3D; right, make(chan int)</span><br><span class="line">&#x2F;&#x2F;fmt.Println(&quot;left:&quot;, left, &quot;    right:&quot;, right)</span><br><span class="line">go f(left, right)</span><br><span class="line">&#125;</span><br><span class="line">right &lt;- 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; start the chaining 开始链接</span><br><span class="line">x :&#x3D; &lt;-leftmost &#x2F;&#x2F; wait for completion 等待完成</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#x2F;&#x2F; 结果： 100000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个很有意思的点：在没有运行程序之前，我认为leftmost的结果为1，认为只在最初做了一次赋值，实际结果为100000（无缓存信道，具有同步阻塞的特性），这个是为什么呢？</p><ul><li>1.主线程的right &lt;- 0，right不是最初循环的那个right，而是最终循环的right</li><li>2.for循环中最初的go f(left, right)因为没有发送者一直处于等待状态</li><li>3.当主线程的right &lt;- 0执行时，类似于递归函数在最内层产生返回值一般</li></ul><h2 id="十三、多核运算"><a href="#十三、多核运算" class="headerlink" title="十三、多核运算"></a>十三、多核运算</h2><p>假设我们的 CPU 核数是 NCPU 个： const NCPU = 4 // 例如：4 代表 4 核处理器，我们将计算划分为 NCPU 部分，每部分与其他部分并行运行。</p><p>下面是一个简单的示例（我们忽略具体的参数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func DoAll() &#123;</span><br><span class="line">sem :&#x3D; make(chan int, NCPU)</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; NCPU; i++ &#123;</span><br><span class="line">&#x2F;&#x2F; Buffering optional but sensible. 合理的缓冲区选项（个人理解就是和 CPU 的核心数相同）</span><br><span class="line">go DoPart(sem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待 NCPU 任务完成，释放通道 sem 的缓冲区</span><br><span class="line">for i :&#x3D; 0; i &lt; NCPU; i++ &#123;</span><br><span class="line">&lt;-sem &#x2F;&#x2F; 等待一个任务完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全部完成。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DoPart(sem chan int) &#123;</span><br><span class="line">&#x2F;&#x2F; 进行计算的部分</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">sem &lt;- 1 &#x2F;&#x2F; 发送一个这部分已经完成的信号，用来释放 sem 的缓冲区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">runtime.GOMAXPROCS &#x3D; NCPU</span><br><span class="line">DoAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 DoAll() 生成一个通道 sem ，在此基础上完成每一个并行计算；在 for 循环中启动 NCPU 个协程，每一个协程执行全部工作的 1/NCPU 。通过 sem 发送每一个协程中 DoPart() 完成的信号。</p><p>DoAll() 中用一个 for 循环来等待所有（NCPU 个）协程完成计算： 通道 sem 的行为就像一个 semaphore（信号量）；这个代码展示了一个典型的信号量模式。</p><p>在当前的运行模式下，你还必须设置 GOMAXPROCS 为 NCPU。</p><h2 id="十四、多核运算处理大量数据"><a href="#十四、多核运算处理大量数据" class="headerlink" title="十四、多核运算处理大量数据"></a>十四、多核运算处理大量数据</h2><p>假设我们必须处理 <strong>大量的彼此独立的数据项</strong> ，通过一个输入通道进入，并且全部处理完成后放到一个输出通道，就像一个工厂的管道。每个数据项的处理也许会涉及多个步骤： 预处理 / 步骤 A / 步骤 B / … / 后期处理</p><p>一个典型的顺序 <strong>流水线算法</strong> 可以用来解决这个问题，下面示例展示了每一步执行的顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func SerialProcessData (in &lt;- chan *Data, out &lt;- chan *Data) &#123;</span><br><span class="line">    for data :&#x3D; range in &#123;</span><br><span class="line">        tmpA :&#x3D; PreprocessData(data)</span><br><span class="line">        tmpB :&#x3D; ProcessStepA(tmpA)</span><br><span class="line">        tmpC :&#x3D; ProcessStepB(tmpB)</span><br><span class="line">        out &lt;- PostProcessData(tmpC)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次只执行一步，并且每个项目按顺序处理：在第一个项目被处理完并将结果放到输出通道之前第二个项目不会开始。</p><p>如果你仔细想想，你很快就会意识到这样会非常的浪费时间。</p><p>一个更有效的计算是 <strong>让每一个步骤都作为一个协程独立工作</strong> 。每个步骤都从上一步的输出通道获取输入数据。这样可以尽可能的避免时间浪费，并且大部分时间所有的步骤都会繁忙的执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func ParallelProcessData (in &lt;- chan *Data, out &lt;- chan *Data) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; make channels:</span><br><span class="line"></span><br><span class="line">    preOut :&#x3D; make(chan *Data, 100)</span><br><span class="line">    stepAOut :&#x3D; make(chan *Data, 100)</span><br><span class="line">    stepBOut :&#x3D; make(chan *Data, 100)</span><br><span class="line">    stepCOut :&#x3D; make(chan *Data, 100)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; start parallel computations:</span><br><span class="line"></span><br><span class="line">    go PreprocessData(in, preOut)</span><br><span class="line">    go ProcessStepA(preOut, stepAOut)</span><br><span class="line">    go ProcessStepB(stepAOut, stepBOut)</span><br><span class="line">    go ProcessStepC(stepBOut, stepCOut)</span><br><span class="line">    go PostProcessData(stepCOut, out)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道缓冲区可以用于进一步优化整个过程。</p><h2 id="十五、使用-Channel-来并发读取对象"><a href="#十五、使用-Channel-来并发读取对象" class="headerlink" title="十五、使用 Channel 来并发读取对象"></a>十五、使用 Channel 来并发读取对象</h2><p>为了保护一个对象的并发修改，我们可以使用一个后台的协程来顺序执行一个匿名函数，而不是通过同步 互斥锁（Mutex） 进行锁定。</p><p>在下面的程序中，我们有一个 Person 类型，它包含了一个匿名函数类型的通道字段 chF。它在构造器方法 NewPerson 中初始化，用一个协程启动一个 backend() 方法。这个方法在一个无限 for 循环中执行所有被放到 chF 上的函数，有效的序列化他们，从而提供安全的并发访问。</p><p>改变和获取 salary 可以通过一个放在 chF 上的匿名函数来实现，backend() 会顺序执行它们。注意如何在 Salary 方法中的闭合（匿名）函数中去包含 fChan 通道。</p><p>这是一个简化的例子，并且它不应该在这种情况下应用，但是它展示了如何在更复杂的情况下解决问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">Name   string</span><br><span class="line">salary float64</span><br><span class="line">chF    chan func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewPerson(name string, salary float64) *Person &#123;</span><br><span class="line">p :&#x3D; &amp;Person&#123;name, salary, make(chan func())&#125;</span><br><span class="line">go p.backend()</span><br><span class="line">return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) backend() &#123;</span><br><span class="line">for f :&#x3D; range p.chF &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SetSalary 设置 salary.</span><br><span class="line">func (p *Person) SetSalary(sal float64) &#123;</span><br><span class="line">p.chF &lt;- func() &#123; p.salary &#x3D; sal &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Salary 取回 salary.</span><br><span class="line">func (p *Person) Salary() float64 &#123;</span><br><span class="line">fChan :&#x3D; make(chan float64)</span><br><span class="line">p.chF &lt;- func() &#123; fChan &lt;- p.salary &#125;</span><br><span class="line">return &lt;-fChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) String() string &#123;</span><br><span class="line">return &quot;Person - name is: &quot; + p.Name + &quot; - salary is: &quot; +</span><br><span class="line">strconv.FormatFloat(p.Salary(), &#39;f&#39;, 2, 64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">bs :&#x3D; NewPerson(&quot;Smith Bill&quot;, 2500.5)</span><br><span class="line">fmt.Println(bs)</span><br><span class="line"></span><br><span class="line">bs.SetSalary(4000.25)</span><br><span class="line">fmt.Println(&quot;Salary changed:&quot;)</span><br><span class="line">fmt.Println(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Person - name is: Smith Bill - salary is: 2500.50</span><br><span class="line"></span><br><span class="line">Salary changed:</span><br><span class="line"></span><br><span class="line">Person - name is: Smith Bill - salary is: 4000.25</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://godoc.murphyyi.com/">《Go入门指南》</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：协程与通道（channel）的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
    <category term="协程" scheme="https://www.blog.ajie39.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="channel" scheme="https://www.blog.ajie39.top/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go 入门总结（三）</title>
    <link href="https://www.blog.ajie39.top/2022/06/12/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/06/12/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-06-12T06:36:14.967Z</published>
    <updated>2022-06-18T08:10:36.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：十二到十三章的内容。</h1><hr><span id="more"></span><h2 id="一、读写数据"><a href="#一、读写数据" class="headerlink" title="一、读写数据"></a>一、读写数据</h2><h3 id="1、读取用户的输入"><a href="#1、读取用户的输入" class="headerlink" title="1、读取用户的输入"></a>1、读取用户的输入</h3><p>从键盘和标准输入 os.Stdin 读取输入，最简单的办法是使用 fmt 包提供的 Scan 和 Sscan 开头的函数。请看以下程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">firstName, lastName, s string</span><br><span class="line">i                      int</span><br><span class="line">f                      float32</span><br><span class="line">input                  &#x3D; &quot;56.12 &#x2F; 5212 &#x2F; Go&quot;</span><br><span class="line">format                 &#x3D; &quot;%f &#x2F; %d &#x2F; %s&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;Please enter your full name: &quot;)</span><br><span class="line">fmt.Scanln(&amp;firstName, &amp;lastName)</span><br><span class="line">&#x2F;&#x2F; fmt.Scanf(&quot;%s %s&quot;, &amp;firstName, &amp;lastName)</span><br><span class="line">fmt.Printf(&quot;Hi %s %s!\n&quot;, firstName, lastName) &#x2F;&#x2F; Hi Chris Naegels</span><br><span class="line">fmt.Sscanf(input, format, &amp;f, &amp;i, &amp;s)</span><br><span class="line">fmt.Println(&quot;From the string we read: &quot;, f, i, s)</span><br><span class="line">&#x2F;&#x2F; 输出结果: From the string we read: 56.12 5212 Go</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scanln 扫描来自 <strong>标准输入的文本</strong>，将空格分隔的值依次存放到后续的参数内，直到碰到换行。</p><p>Scanf 与其类似，除了 Scanf 的第一个参数用作格式字符串，用来决定如何读取。</p><p>Sscan 和以 Sscan 开头的函数则是 <strong>从字符串读取</strong>，除此之外，与 Scanf 相同。如果这些函数读取到的结果与您预想的不同，您可以检查成功读入数据的个数和返回的错误。</p><p>您也可以使用 bufio 包提供的缓冲读取（buffered reader）来读取数据。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var inputReader *bufio.Reader</span><br><span class="line">var input string</span><br><span class="line">var err error</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    inputReader &#x3D; bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println(&quot;Please enter some input: &quot;)</span><br><span class="line">    input, err &#x3D; inputReader.ReadString(&#39;\n&#39;)</span><br><span class="line">    if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;The input was: %s\n&quot;, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadString(delim byte)，该方法从输入中读取内容，直到碰到 delim 指定的字符，然后将读取到的内容连同 delim 字符一起放到缓冲区。</p><p>ReadString 返回读取到的字符串，如果碰到错误则返回 nil。如果它一直读到文件结束，则返回读取到的字符串和 io.EOF。如果读取过程中没有碰到 delim 字符，将返回错误 err != nil。</p><h3 id="2、文件读写"><a href="#2、文件读写" class="headerlink" title="2、文件读写"></a>2、文件读写</h3><p>在 Go 语言中，文件使用指向 os.File 类型的指针来表示的，也叫做 <strong>文件句柄</strong> 。</p><p>我们在前面使用到过标准输入 os.Stdin 和标准输出 os.Stdout，他们的类型都是 *os.File。</p><p>让我们来看看下面这个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">inputFile, inputError :&#x3D; os.Open(&quot;input.dat&quot;)</span><br><span class="line">if inputError !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;An error occurred on opening the inputfile\n&quot; +</span><br><span class="line">&quot;Does the file exist?\n&quot; +</span><br><span class="line">&quot;Have you got acces to it?\n&quot;)</span><br><span class="line">return &#x2F;&#x2F; exit the function on error</span><br><span class="line">&#125;</span><br><span class="line">defer inputFile.Close()</span><br><span class="line"></span><br><span class="line">inputReader :&#x3D; bufio.NewReader(inputFile)</span><br><span class="line">for &#123;</span><br><span class="line">inputString, readerError :&#x3D; inputReader.ReadString(&#39;\n&#39;)</span><br><span class="line">fmt.Printf(&quot;The input was: %s&quot;, inputString)</span><br><span class="line">if readerError &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">在之前的例子中，我们看到，Unix 和 Linux 的行结束符是 \n，而 Windows 的行结束符是 \r\n。</span><br><span class="line"></span><br><span class="line">在使用 ReadString 和 ReadBytes 方法的时候，我们不需要关心操作系统的类型，直接使用 \n 就可以了。</span><br><span class="line"></span><br><span class="line">另外，我们也可以使用 ReadLine() 方法来实现相同的功能。</span><br><span class="line"></span><br><span class="line">一旦读取到文件末尾，变量 readerError 的值将变成非空（事实上，常量 io.EOF 的值是 true），我们就会执行 return 语句从而退出循环。</span><br></pre></td></tr></table></figure><h4 id="1）将整个文件的内容读到一个字符串里"><a href="#1）将整个文件的内容读到一个字符串里" class="headerlink" title="1）将整个文件的内容读到一个字符串里"></a>1）将整个文件的内容读到一个字符串里</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&#x2F;ioutil&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">inputFile :&#x3D; &quot;products.txt&quot;</span><br><span class="line">outputFile :&#x3D; &quot;products_copy.txt&quot;</span><br><span class="line">buf, err :&#x3D; ioutil.ReadFile(inputFile)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, &quot;File Error: %s\n&quot;, err)</span><br><span class="line">&#x2F;&#x2F; panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, string(buf))</span><br><span class="line">err &#x3D; ioutil.WriteFile(outputFile, buf, 0644) &#x2F;&#x2F; oct, not hex</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）带缓冲的读取"><a href="#2）带缓冲的读取" class="headerlink" title="2）带缓冲的读取"></a>2）带缓冲的读取</h4><p>在很多情况下，文件的内容是 <strong>不按行划分的，或者干脆就是一个二进制文件</strong> 。在这种情况下，ReadString() 就无法使用了，我们可以使用 bufio.Reader 的 Read()，它只接收一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf :&#x3D; make([]byte, 1024)</span><br><span class="line">...</span><br><span class="line">n, err :&#x3D; inputReader.Read(buf)</span><br><span class="line">if (n &#x3D;&#x3D; 0) &#123; break&#125;</span><br><span class="line"></span><br><span class="line">变量 n 的值表示读取到的字节数。</span><br></pre></td></tr></table></figure><h4 id="3）按列读取文件中的数据"><a href="#3）按列读取文件中的数据" class="headerlink" title="3）按列读取文件中的数据"></a>3）按列读取文件中的数据</h4><p>如果数据是按列排列并用空格分隔的，你可以使用 fmt 包提供的以 FScan 开头的一系列函数来读取他们。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    file, err :&#x3D; os.Open(&quot;products2.txt&quot;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    var col1, col2, col3 []string</span><br><span class="line">    for &#123;</span><br><span class="line">        var v1, v2, v3 string</span><br><span class="line">        _, err :&#x3D; fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)</span><br><span class="line">        &#x2F;&#x2F; scans until newline</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        col1 &#x3D; append(col1, v1)</span><br><span class="line">        col2 &#x3D; append(col2, v2)</span><br><span class="line">        col3 &#x3D; append(col3, v3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(col1)</span><br><span class="line">    fmt.Println(col2)</span><br><span class="line">    fmt.Println(col3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* products2.txt</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">[1 4 7]</span><br><span class="line">[2 5 8]</span><br><span class="line">[3 6 9]</span><br></pre></td></tr></table></figure><h4 id="4）compress-包：读取压缩文件"><a href="#4）compress-包：读取压缩文件" class="headerlink" title="4）compress 包：读取压缩文件"></a>4）compress 包：读取压缩文件</h4><p>compress 包提供了读取压缩文件的功能，支持的压缩文件格式为：bzip2、flate、gzip、lzw 和 zlib。</p><p>下面的程序展示了如何读取一个 gzip 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;compress&#x2F;gzip&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fName :&#x3D; &quot;MyFile.gz&quot;</span><br><span class="line">    var r *bufio.Reader</span><br><span class="line">    fi, err :&#x3D; os.Open(fName)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, &quot;%v, Can&#39;t open %s: error: %s\n&quot;, os.Args[0], fName,</span><br><span class="line">            err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    &#125;</span><br><span class="line">    fz, err :&#x3D; gzip.NewReader(fi)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        r &#x3D; bufio.NewReader(fi)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        r &#x3D; bufio.NewReader(fz)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        line, err :&#x3D; r.ReadString(&#39;\n&#39;)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            fmt.Println(&quot;Done reading file&quot;)</span><br><span class="line">            os.Exit(0)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5）写文件"><a href="#5）写文件" class="headerlink" title="5）写文件"></a>5）写文件</h4><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main () &#123;</span><br><span class="line">    &#x2F;&#x2F; var outputWriter *bufio.Writer</span><br><span class="line">    &#x2F;&#x2F; var outputFile *os.File</span><br><span class="line">    &#x2F;&#x2F; var outputError os.Error</span><br><span class="line">    &#x2F;&#x2F; var outputString string</span><br><span class="line">    outputFile, outputError :&#x3D; os.OpenFile(&quot;output.dat&quot;, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line">    if outputError !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;An error occurred with file opening or creation\n&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer outputFile.Close()</span><br><span class="line"></span><br><span class="line">    outputWriter :&#x3D; bufio.NewWriter(outputFile)</span><br><span class="line">    outputString :&#x3D; &quot;hello world!\n&quot;</span><br><span class="line"></span><br><span class="line">    for i:&#x3D;0; i&lt;10; i++ &#123;</span><br><span class="line">        outputWriter.WriteString(outputString)</span><br><span class="line">    &#125;</span><br><span class="line">    outputWriter.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以只写模式打开文件 output.dat，如果文件不存在则自动创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">outputFile, outputError :&#x3D; os.OpenFile(“output.dat”, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line"></span><br><span class="line">可以看到，OpenFile 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符 “|” 连接），使用的文件权限。</span><br><span class="line"></span><br><span class="line">在读文件的时候，文件的权限是被忽略的，所以在使用 OpenFile 时传入的第三个参数可以用 0。</span><br><span class="line"></span><br><span class="line">而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。</span><br></pre></td></tr></table></figure><p>我们通常会用到以下标志：</p><ul><li>os.O_RDONLY：只读。</li><li>os.O_WRONLY：只写。</li><li>os.O_CREATE：创建：如果指定文件不存在，就创建该文件。</li><li>os.O_TRUNC：截断：如果指定文件已存在，就将该文件的长度截为 0。</li></ul><p>使用其他函数如何写文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    os.Stdout.WriteString(&quot;hello, world\n&quot;)</span><br><span class="line">    f, _ :&#x3D; os.OpenFile(&quot;test&quot;, os.O_CREATE|os.O_WRONLY, 0)</span><br><span class="line">    defer f.Close()</span><br><span class="line">    f.WriteString(&quot;hello, world in a file\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用 os.Stdout.WriteString(“hello, world\n”)，我们可以输出到屏幕。</span><br><span class="line"></span><br><span class="line">我们以只写模式创建或打开文件 “test”，并且忽略了可能发生的错误：f, _ :&#x3D; os.OpenFile(“test”, os.O_CREATE|os.O_WRONLY, 0)</span><br><span class="line"></span><br><span class="line">我们不使用缓冲区，直接将内容写入文件：f.WriteString()</span><br></pre></td></tr></table></figure><h3 id="3、文件拷贝"><a href="#3、文件拷贝" class="headerlink" title="3、文件拷贝"></a>3、文件拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    CopyFile(&quot;target.txt&quot;, &quot;source.txt&quot;)</span><br><span class="line">    fmt.Println(&quot;Copy done!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">    src, err :&#x3D; os.Open(srcName)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err :&#x3D; os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer dst.Close()</span><br><span class="line"></span><br><span class="line">    return io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 defer 的使用：当打开目标文件时发生了错误，那么 defer 仍然能够确保 src.Close() 执行。如果不这么做，文件会一直保持打开状态并占用资源。</p><h3 id="4、从命令行读取参数"><a href="#4、从命令行读取参数" class="headerlink" title="4、从命令行读取参数"></a>4、从命令行读取参数</h3><h4 id="1）os-包"><a href="#1）os-包" class="headerlink" title="1）os 包"></a>1）os 包</h4><p>os 包中有一个 string 类型的切片变量 os.Args，用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">who :&#x3D; &quot;Alice &quot;</span><br><span class="line">if len(os.Args) &gt; 1 &#123;</span><br><span class="line">who +&#x3D; strings.Join(os.Args[1:], &quot; &quot;)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(os.Args[:])</span><br><span class="line">fmt.Println(&quot;Good Morning&quot;, who)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 IDE 或编辑器中直接运行这个程序输出：Good Morning Alice</p><p>但是我们在命令行加入参数，像这样：os_args John Bill Marc Luke，将得到这样的输出：Good Morning Alice John Bill Marc Luke</p><p>这个命令行参数会放置在切片 os.Args[] 中（以空格分隔），从索引 1 开始（os.Args[0] 放的是程序本身的名字，在本例中是 os_args）。函数 strings.Join 以空格为间隔连接这些参数。</p><h4 id="2）flag-包"><a href="#2）flag-包" class="headerlink" title="2）flag 包"></a>2）flag 包</h4><p>flag 包有一个扩展功能用来解析命令行选项。但是通常被用来替换基本常量，例如，在某些情况下我们希望在命令行给常量一些不一样的值。</p><p>在 flag 包中一个 Flag 被定义成一个含有如下字段的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Flag struct &#123;</span><br><span class="line">    Name     string &#x2F;&#x2F; name as it appears on command line</span><br><span class="line">    Usage    string &#x2F;&#x2F; help message</span><br><span class="line">    Value    Value  &#x2F;&#x2F; value as set</span><br><span class="line">    DefValue string &#x2F;&#x2F; default value (as text); for usage message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的程序模拟了 Unix 的 echo 功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;flag&quot; &#x2F;&#x2F; command line option parser</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var NewLine &#x3D; flag.Bool(&quot;n&quot;, false, &quot;print newline&quot;) &#x2F;&#x2F; echo -n flag, of type *bool</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Space   &#x3D; &quot; &quot;</span><br><span class="line">    Newline &#x3D; &quot;\n&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.PrintDefaults()</span><br><span class="line">    flag.Parse() &#x2F;&#x2F; Scans the arg list and sets up flags</span><br><span class="line">    var s string &#x3D; &quot;&quot;</span><br><span class="line">    for i :&#x3D; 0; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        if i &gt; 0 &#123;</span><br><span class="line">            s +&#x3D; &quot; &quot;</span><br><span class="line">            if *NewLine &#123; &#x2F;&#x2F; -n is parsed, flag becomes true</span><br><span class="line">                s +&#x3D; Newline</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s +&#x3D; flag.Arg(i)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">添加参数：A B C</span><br><span class="line">输出：A B C</span><br><span class="line"></span><br><span class="line">添加参数：-n A B C</span><br><span class="line">输出：</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>方法说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag.Parse() 扫描参数列表（或者常量列表）并设置 flag, flag.Arg(i) 表示第 i 个参数。Parse() 之后 flag.Arg(i) 全部可用，flag.Arg(0) 就是第一个真实的 flag，而不是像 os.Args(0) 放置程序的名字。</span><br><span class="line"></span><br><span class="line">flag.Narg() 返回参数的数量。解析后 flag 或常量就可用了。</span><br><span class="line"></span><br><span class="line">flag.Bool() 定义了一个默认值是 false 的 flag：当在命令行出现了第一个参数（这里是 “n”），flag 被设置成 true（NewLine 是 *bool 类型）。flag 被解引用到 *NewLine，所以当值是 true 时将添加一个 newline（”\n”）。</span><br><span class="line"></span><br><span class="line">flag.PrintDefaults() 打印 flag 的使用帮助信息。</span><br><span class="line"></span><br><span class="line">flag.VisitAll(fn func(*Flag)) 是另一个有用的功能：按照字典顺序遍历 flag，并且对每个标签调用 fn。</span><br></pre></td></tr></table></figure><h3 id="5、用-buffer-读取文件"><a href="#5、用-buffer-读取文件" class="headerlink" title="5、用 buffer 读取文件"></a>5、用 buffer 读取文件</h3><p>在下面的例子中，我们结合使用了缓冲读取文件和命令行 flag 解析这两项技术。</p><p>如果不加参数，那么你输入什么屏幕就打印什么。</p><p>参数被认为是文件名，如果文件存在的话就打印文件内容到屏幕。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func cat(r *bufio.Reader) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        buf, err :&#x3D; r.ReadBytes(&#39;\n&#39;)</span><br><span class="line">        if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    if flag.NArg() &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        cat(bufio.NewReader(os.Stdin))</span><br><span class="line">    &#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err :&#x3D; os.Open(flag.Arg(i))</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, &quot;%s:error reading from %s: %s\n&quot;, os.Args[0], flag.Arg(i), err.Error())</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        cat(bufio.NewReader(f))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、用切片读写文件"><a href="#6、用切片读写文件" class="headerlink" title="6、用切片读写文件"></a>6、用切片读写文件</h3><p>切片提供了 Go 中处理 I/O 缓冲的标准方式，下面 cat 函数中，在一个切片缓冲内使用无限 for 循环（直到文件尾部 EOF）读取文件，并写入到标准输出（os.Stdout）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func cat(f *os.File) &#123;</span><br><span class="line">    const NBUF &#x3D; 512</span><br><span class="line">    var buf [NBUF]byte</span><br><span class="line">    for &#123;</span><br><span class="line">        switch nr, err :&#x3D; f.Read(buf[:]); true &#123;</span><br><span class="line">        case nr &lt; 0:</span><br><span class="line">            fmt.Fprintf(os.Stderr, &quot;cat: error reading: %s\n&quot;, err.Error())</span><br><span class="line">            os.Exit(1)</span><br><span class="line">        case nr &#x3D;&#x3D; 0: &#x2F;&#x2F; EOF</span><br><span class="line">            return</span><br><span class="line">        case nr &gt; 0:</span><br><span class="line">            if nw, ew :&#x3D; os.Stdout.Write(buf[0:nr]); nw !&#x3D; nr &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, &quot;cat: error writing: %s\n&quot;, ew.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.Parse() &#x2F;&#x2F; Scans the arg list and sets up flags</span><br><span class="line">    if flag.NArg() &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        cat(os.Stdin)</span><br><span class="line">    &#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err :&#x3D; os.Open(flag.Arg(i))</span><br><span class="line">        if f &#x3D;&#x3D; nil &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, &quot;cat: can&#39;t open %s: error %s\n&quot;, flag.Arg(i), err)</span><br><span class="line">            os.Exit(1)</span><br><span class="line">        &#125;</span><br><span class="line">        cat(f)</span><br><span class="line">        f.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、使用接口的实际例子：fmt-Fprintf"><a href="#7、使用接口的实际例子：fmt-Fprintf" class="headerlink" title="7、使用接口的实际例子：fmt.Fprintf"></a>7、使用接口的实际例子：fmt.Fprintf</h3><p>下面例子很好的阐述了 io 包中的接口概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; unbuffered</span><br><span class="line">    fmt.Fprintf(os.Stdout, &quot;%s\n&quot;, &quot;hello world! - unbuffered&quot;)</span><br><span class="line">    &#x2F;&#x2F; buffered: os.Stdout implements io.Writer</span><br><span class="line">    buf :&#x3D; bufio.NewWriter(os.Stdout)</span><br><span class="line">    &#x2F;&#x2F; and now so does buf.</span><br><span class="line">    fmt.Fprintf(buf, &quot;%s\n&quot;, &quot;hello world! - buffered&quot;)</span><br><span class="line">    buf.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">hello world! - unbuffered</span><br><span class="line">hello world! - buffered</span><br></pre></td></tr></table></figure><p>下面是 fmt.Fprintf() 函数的实际签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><p>其不是写入一个文件，而是写入一个 io.Writer 接口类型的变量，下面是 Writer 接口在 io 包中的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface &#123;</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fmt.Fprintf() 依据指定的格式向第一个参数内写入字符串，第一参数必须实现了 io.Writer 接口。</p><p>Fprintf() 能够写入任何类型，只要其实现了 Write 方法，包括 os.Stdout, 文件（例如 os.File），管道，网络连接，通道等等，<br>同样的也可以使用 bufio 包中缓冲写入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bufio 包中定义了 type Writer struct&#123;...&#125;</span><br><span class="line"></span><br><span class="line">bufio.Writer 实现了 Write 方法：</span><br><span class="line"></span><br><span class="line">func (b *Writer) Write(p []byte) (nn int, err error)</span><br><span class="line"></span><br><span class="line">它还有一个工厂函数：传给它一个 io.Writer 类型的参数，它会返回一个缓冲的 bufio.Writer 类型的 io.Writer:</span><br><span class="line"></span><br><span class="line">func NewWriter(wr io.Writer) (b *Writer)</span><br><span class="line"></span><br><span class="line">其适合任何形式的缓冲写入。</span><br></pre></td></tr></table></figure><p>在缓冲写入的最后千万 **不要忘了使用 Flush()**，否则最后的输出不会被写入。</p><h3 id="8、JSON-数据格式"><a href="#8、JSON-数据格式" class="headerlink" title="8、JSON 数据格式"></a>8、JSON 数据格式</h3><p>通过把数据转换成纯文本，使用命名的字段来标注，让其具有可读性。这样的数据格式可以通过网络传输，而且是与平台无关的，任何类型的应用都能够读取和输出，不与操作系统和编程语言的类型相关。</p><p>下面是一些术语说明：</p><ul><li>数据结构 –&gt; 指定格式 = 序列化 或 编码（传输之前）</li><li>指定格式 –&gt; 数据格式 = 反序列化 或 解码（传输之后）</li></ul><p>序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure）</p><p>编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。</p><h4 id="1）序列化"><a href="#1）序列化" class="headerlink" title="1）序列化"></a>1）序列化</h4><p>Go 语言的 json 包可以让你在程序中方便的读取和写入 JSON 数据。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Address struct &#123;</span><br><span class="line">Type    string</span><br><span class="line">City    string</span><br><span class="line">Country string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type VCard struct &#123;</span><br><span class="line">FirstName string</span><br><span class="line">LastName  string</span><br><span class="line">Addresses []*Address</span><br><span class="line">Remark    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">pa :&#x3D; &amp;Address&#123;&quot;private&quot;, &quot;Aartselaar&quot;, &quot;Belgium&quot;&#125;</span><br><span class="line">wa :&#x3D; &amp;Address&#123;&quot;work&quot;, &quot;Boom&quot;, &quot;Belgium&quot;&#125;</span><br><span class="line">vc :&#x3D; VCard&#123;&quot;Jan&quot;, &quot;Kersschot&quot;, []*Address&#123;pa, wa&#125;, &quot;none&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; fmt.Printf(&quot;%v: \n&quot;, vc) &#x2F;&#x2F; &#123;Jan Kersschot [0x126d2b80 0x126d2be0] none&#125;:</span><br><span class="line">&#x2F;&#x2F; JSON format:</span><br><span class="line">js, _ :&#x3D; json.Marshal(vc)</span><br><span class="line">fmt.Printf(&quot;JSON format: %s&quot;, js)</span><br><span class="line">&#x2F;&#x2F; using an encoder:</span><br><span class="line">file, _ :&#x3D; os.OpenFile(&quot;vcard.json&quot;, os.O_CREATE|os.O_WRONLY, 0666)</span><br><span class="line">defer file.Close()</span><br><span class="line">enc :&#x3D; json.NewEncoder(file)</span><br><span class="line">err :&#x3D; enc.Encode(vc)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">log.Println(&quot;Error in encoding json&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json.Marshal() 的函数签名是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Marshal(v interface&#123;&#125;) ([]byte, error)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">出于安全考虑，在 web 应用中最好使用 json.MarshalforHTML() 函数，其对数据执行 HTML 转码，所以文本可以被安全地嵌在 HTML &lt;script&gt; 标签中。</span><br><span class="line"></span><br><span class="line">json.NewEncoder() 的函数签名是 func NewEncoder(w io.Writer) *Encoder，返回的 Encoder 类型的指针可调用方法 Encode(v interface&#123;&#125;)，将数据对象 v 的 json 编码写入 io.Writer w 中。</span><br></pre></td></tr></table></figure><p>JSON 与 Go 类型对应如下：</p><ul><li>bool 对应 JSON 的 booleans</li><li>float64 对应 JSON 的 numbers</li><li>string 对应 JSON 的 strings</li><li>nil 对应 JSON 的 null</li></ul><p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：</p><ul><li>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map [string] T（T 是 json 包中支持的任何类型）</li><li>Channel，复杂类型和函数类型不能被编码</li><li>不支持循环数据结构；它将引起序列化进入一个无限循环</li><li>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</li></ul><h4 id="2）反序列化"><a href="#2）反序列化" class="headerlink" title="2）反序列化"></a>2）反序列化</h4><p>UnMarshal() 的函数签名是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Unmarshal(data []byte, v interface&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">把 JSON 解码为数据结构</span><br></pre></td></tr></table></figure><p>上面的例子编码后的数据为 Json ，对其解码时，我们首先创建结构 VCard 用来保存解码的数据：var v VCard 并调用 json.Unmarshal(js, &amp;v)，解析 [] byte 中的 JSON 数据并将结果存入指针 &amp;v 指向的值。</p><p>虽然反射能够让 JSON 字段去尝试匹配目标结构字段；但是只有真正匹配上的字段才会填充数据。字段没有匹配不会报错，而是直接忽略掉。</p><h5 id="解码任意的数据"><a href="#解码任意的数据" class="headerlink" title="解码任意的数据"></a>解码任意的数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json 包使用 map[string]interface&#123;&#125; 和 []interface&#123;&#125; 储存任意的 JSON 对象和数组。</span><br><span class="line"></span><br><span class="line">其可以被反序列化为任何的 JSON blob 存储到接口值中。</span><br></pre></td></tr></table></figure><p>来看这个 JSON 数据，被存储在变量 b 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b :&#x3D; []byte(&#96;&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;&#96;)</span><br></pre></td></tr></table></figure><p>不用理解这个数据的结构，我们可以直接使用 Unmarshal 把这个数据编码并保存在接口值中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f interface&#123;&#125;</span><br><span class="line">err :&#x3D; json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure><p>f 指向的值是一个 map，key 是一个字符串，value 是自身存储作为空接口类型的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map[string]interface&#123;&#125; &#123;</span><br><span class="line">    &quot;Name&quot;: &quot;Wednesday&quot;,</span><br><span class="line">    &quot;Age&quot;:  6,</span><br><span class="line">    &quot;Parents&quot;: []interface&#123;&#125; &#123;</span><br><span class="line">        &quot;Gomez&quot;,</span><br><span class="line">        &quot;Morticia&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要访问这个数据，我们可以使用类型断言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m :&#x3D; f.(map[string]interface&#123;&#125;)</span><br></pre></td></tr></table></figure><p>我们可以通过 for range 语法和 type switch 来访问其实际类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for k, v :&#x3D; range m &#123;</span><br><span class="line">    switch vv :&#x3D; v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println(k, &quot;is string&quot;, vv)</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println(k, &quot;is int&quot;, vv)</span><br><span class="line"></span><br><span class="line">    case []interface&#123;&#125;:</span><br><span class="line">        fmt.Println(k, &quot;is an array:&quot;)</span><br><span class="line">        for i, u :&#x3D; range vv &#123;</span><br><span class="line">            fmt.Println(i, u)</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(k, &quot;is of a type I don’t know how to handle&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，你可以处理未知的 JSON 数据，同时可以确保类型安全。完整代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b :&#x3D; []byte(&#96;&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;&#96;)</span><br><span class="line"></span><br><span class="line">var f interface&#123;&#125;</span><br><span class="line">err :&#x3D; json.Unmarshal(b, &amp;f)</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;err：&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m :&#x3D; f.(map[string]interface&#123;&#125;)</span><br><span class="line"></span><br><span class="line">for k, v :&#x3D; range m &#123;</span><br><span class="line">switch vv :&#x3D; v.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">fmt.Println(k, &quot;is string&quot;, vv)</span><br><span class="line">case int:</span><br><span class="line">fmt.Println(k, &quot;is int&quot;, vv)</span><br><span class="line">case float64:</span><br><span class="line">fmt.Println(k, &quot;is float64&quot;, vv)</span><br><span class="line">case []interface&#123;&#125;:</span><br><span class="line">fmt.Println(k, &quot;is an array:&quot;)</span><br><span class="line">for i, u :&#x3D; range vv &#123;</span><br><span class="line">fmt.Println(i, u)</span><br><span class="line">&#125;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(k, &quot;is of a type I don’t know how to handle&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： <strong>如果反序列化不指定结构体类型或者变量类型，则JSON中的数字类型，默认被反序列化成float64类型。</strong></p><h5 id="解码数据到结构"><a href="#解码数据到结构" class="headerlink" title="解码数据到结构"></a>解码数据到结构</h5><p>如果我们事先知道 JSON 数据，我们可以定义一个适当的结构并对 JSON 数据反序列化。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type FamilyMember struct &#123;</span><br><span class="line">Name    string</span><br><span class="line">Age     int</span><br><span class="line">Parents []string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b :&#x3D; []byte(&#96;&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;&#96;)</span><br><span class="line"></span><br><span class="line">var m FamilyMember</span><br><span class="line">err :&#x3D; json.Unmarshal(b, &amp;m)</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;err：&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）编码和解码流"><a href="#3）编码和解码流" class="headerlink" title="3）编码和解码流"></a>3）编码和解码流</h4><p>json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func NewDecoder(r io.Reader) *Decoder</span><br><span class="line">func NewEncoder(w io.Writer) *Encoder</span><br></pre></td></tr></table></figure><p>要想把 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件（或者任何实现 io.Writer 的类型），并调用 Encode ()；反过来与其对应的是使用 json.Decoder 和 Decode () 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func NewDecoder(r io.Reader) *Decoder</span><br><span class="line">func (dec *Decoder) Decode(v interface&#123;&#125;) error</span><br></pre></td></tr></table></figure><p>来看下接口是如何对实现进行抽象的：</p><ul><li>数据结构可以是任何类型，只要其实现了某种接口，目标或源数据要能够被编码就必须实现 io.Writer 或 io.Reader 接口。</li><li>由于 Go 语言中到处都实现了 Reader 和 Writer，因此 Encoder 和 Decoder 可被应用的场景非常广泛，例如读取或写入 HTTP 连接、websockets 或文件。</li></ul><h3 id="9、XML-数据格式"><a href="#9、XML-数据格式" class="headerlink" title="9、XML 数据格式"></a>9、XML 数据格式</h3><p>如同 json 包一样，XML 也有 Marshal() 和 UnMarshal() 从 XML 中编码和解码数据。</p><p>和 JSON 的方式一样，XML 数据可以序列化为结构，或者从结构反序列化为 XML 数据。</p><p>encoding/xml 包实现了一个简单的 XML 解析器（SAX），用来解析 XML 数据内容。例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;xml&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var t, token xml.Token</span><br><span class="line">var err error</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">input :&#x3D; &quot;&lt;Person&gt;&lt;FirstName&gt;Laura&lt;&#x2F;FirstName&gt;&lt;LastName&gt;Lynn&lt;&#x2F;LastName&gt;&lt;&#x2F;Person&gt;&quot;</span><br><span class="line">inputReader :&#x3D; strings.NewReader(input)</span><br><span class="line">p :&#x3D; xml.NewDecoder(inputReader)</span><br><span class="line"></span><br><span class="line">for t, err &#x3D; p.Token(); err &#x3D;&#x3D; nil; t, err &#x3D; p.Token() &#123;</span><br><span class="line">switch token :&#x3D; t.(type) &#123;</span><br><span class="line">case xml.StartElement:</span><br><span class="line">name :&#x3D; token.Name.Local</span><br><span class="line">fmt.Printf(&quot;Token name: %s\n&quot;, name)</span><br><span class="line">for _, attr :&#x3D; range token.Attr &#123;</span><br><span class="line">attrName :&#x3D; attr.Name.Local</span><br><span class="line">attrValue :&#x3D; attr.Value</span><br><span class="line">fmt.Printf(&quot;An attribute is: %s %s\n&quot;, attrName, attrValue)</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">case xml.EndElement:</span><br><span class="line">fmt.Println(&quot;End of token&quot;)</span><br><span class="line">case xml.CharData:</span><br><span class="line">content :&#x3D; string([]byte(token))</span><br><span class="line">fmt.Printf(&quot;This is the content: %v\n&quot;, content)</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">default:</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Token name: Person</span><br><span class="line">Token name: FirstName</span><br><span class="line">This is the content: Laura</span><br><span class="line">End of token</span><br><span class="line">Token name: LastName</span><br><span class="line">This is the content: Lynn</span><br><span class="line">End of token</span><br><span class="line">End of token</span><br></pre></td></tr></table></figure><p>包中定义了若干 XML 标签类型：StartElement，Chardata（这是从开始标签到结束标签之间的实际文本），EndElement，Comment，Directive 或 ProcInst。</p><p>包中同样定义了一个结构解析器：</p><ul><li>NewParser 方法持有一个 io.Reader（这里具体类型是 strings.NewReader）并生成一个解析器类型的对象。</li><li>Token() 方法返回输入流里的下一个 XML token。在输入流的结尾处，会返回（nil，io.EOF）。</li></ul><p>XML 文本被循环处理直到 Token() 返回一个错误，因为已经到达文件尾部，再没有内容可供处理了。通过一个 type-switch 可以根据一些 XML 标签进一步处理。Chardata 中的内容只是一个 [] byte，通过字符串转换让其变得可读性强一些。</p><h3 id="10、用-Gob-传输数据"><a href="#10、用-Gob-传输数据" class="headerlink" title="10、用 Gob 传输数据"></a>10、用 Gob 传输数据</h3><p>Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；可以在 encoding 包中找到。这种格式的数据简称为 Gob （即 Go binary 的缩写）。类似于 Python 的 “pickle” 和 Java 的 “Serialization”。</p><p>Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。</p><p>它和 JSON 或 XML 有什么不同呢？</p><ul><li>Gob 特定地用于纯 Go 的环境中，例如，两个用 Go 写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。</li><li>Gob 不是可外部定义，语言无关的编码方式。因此它的首选格式是二进制，而不是像 JSON 和 XML 那样的文本格式。</li><li>Gob 并不是一种不同于 Go 的语言，而是在编码和解码过程中用到了 Go 的反射。</li><li>Gob 文件或流是完全自描述的：里面包含的所有类型都有一个对应的描述，并且总是可以用 Go 解码，而不需要了解文件的内容。</li><li>只有可导出的字段会被编码，零值会被忽略。</li><li>在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。</li><li>当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作：解码客户端会继续识别以前存在的字段。</li><li>提供了很大的灵活性，比如在发送者看来，整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。</li></ul><p>假如在发送者这边有一个有结构 T：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type T struct &#123; X, Y, Z int &#125;</span><br><span class="line">var t &#x3D; T&#123;X: 7, Y: 0, Z: 8&#125;</span><br></pre></td></tr></table></figure><p>而在接收者这边可以用一个结构体 U 类型的变量 u 来接收这个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type U struct &#123; X, Y *int8 &#125;</span><br><span class="line">var u U</span><br></pre></td></tr></table></figure><p>在接收者中，X 的值是 7，Y 的值是 0（Y 的值并没有从 t 中传递过来，因为它是零值）。</p><p>和 JSON 的使用方式一样，Gob 使用通用的 io.Writer 接口，通过 NewEncoder() 函数创建 Encoder 对象并调用 Encode()；相反的过程使用通用的 io.Reader 接口，通过 NewDecoder() 函数创建 Decoder 对象并调用 Decode。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bytes&quot;</span><br><span class="line">&quot;encoding&#x2F;gob&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type P struct &#123;</span><br><span class="line">X, Y, Z int</span><br><span class="line">Name    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Q struct &#123;</span><br><span class="line">X, Y *int32</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; Initialize the encoder and decoder.  Normally enc and dec would be</span><br><span class="line">&#x2F;&#x2F; bound to network connections and the encoder and decoder would</span><br><span class="line">&#x2F;&#x2F; run in different processes.</span><br><span class="line">var network bytes.Buffer        &#x2F;&#x2F; Stand-in for a network connection</span><br><span class="line">enc :&#x3D; gob.NewEncoder(&amp;network) &#x2F;&#x2F; Will write to network.</span><br><span class="line">dec :&#x3D; gob.NewDecoder(&amp;network) &#x2F;&#x2F; Will read from network.</span><br><span class="line">&#x2F;&#x2F; Encode (send) the value.</span><br><span class="line">err :&#x3D; enc.Encode(P&#123;3, 4, 5, &quot;Pythagoras&quot;&#125;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">log.Fatal(&quot;encode error:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Decode (receive) the value.</span><br><span class="line">var q Q</span><br><span class="line">err &#x3D; dec.Decode(&amp;q)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">log.Fatal(&quot;decode error:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%q: &#123;%d,%d&#125;\n&quot;, q.Name, *q.X, *q.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&quot;Pythagoras&quot;: &#123;3,4&#125;</span><br></pre></td></tr></table></figure><h3 id="11、Go-中的密码学"><a href="#11、Go-中的密码学" class="headerlink" title="11、Go 中的密码学"></a>11、Go 中的密码学</h3><ul><li>hash 包：实现了 adler32、crc32、crc64 和 fnv 校验。</li><li>crypto 包：实现了其它的 hash 算法，比如 md4、md5、sha1 等。以及完整地实现了 aes、blowfish、rc4、rsa、xtea 等加密算法。</li></ul><p>使用 sha1 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;crypto&#x2F;sha1&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">hasher :&#x3D; sha1.New()</span><br><span class="line">io.WriteString(hasher, &quot;test&quot;)</span><br><span class="line">b :&#x3D; []byte&#123;&#125;</span><br><span class="line">fmt.Printf(&quot;Result: %x\n&quot;, hasher.Sum(b))</span><br><span class="line">fmt.Printf(&quot;Result: %d\n&quot;, hasher.Sum(b))</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">hasher.Reset()</span><br><span class="line">data :&#x3D; []byte(&quot;We shall overcome!&quot;)</span><br><span class="line">n, err :&#x3D; hasher.Write(data)</span><br><span class="line">if n !&#x3D; len(data) || err !&#x3D; nil &#123;</span><br><span class="line">log.Printf(&quot;Hash write error: %v &#x2F; %v&quot;, n, err)</span><br><span class="line">&#125;</span><br><span class="line">checksum :&#x3D; hasher.Sum(b)</span><br><span class="line">fmt.Printf(&quot;Result: %x\n&quot;, checksum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Result: a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</span><br><span class="line">Result: [169 74 143 229 204 177 155 166 28 76 8 115 211 145 233 135 152 47 187 211]</span><br><span class="line">Result: e2222bfc59850bbb00a722e764a555603bb59b2a</span><br></pre></td></tr></table></figure><p>通过调用 sha1.New() 创建了一个新的 hash.Hash 对象，用来计算 SHA1 校验值。</p><h2 id="二、错误处理与测试"><a href="#二、错误处理与测试" class="headerlink" title="二、错误处理与测试"></a>二、错误处理与测试</h2><p>Go 没有像 Java 和 .NET 那样的 try/catch 异常机制：不能执行抛异常操作。但是有一套 defer-panic-and-recover 机制。</p><p>Go 通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值 —— 如果返回 nil，则没有错误发生 —— 并且主调（calling）函数总是应该检查收到的错误。</p><p><strong>永远不要忽略错误，否则可能会导致程序崩溃！！</strong></p><p>处理错误并且在函数发生错误的地方给用户返回错误信息：照这样处理就算真的出了问题，你的程序也能继续运行并且通知给用户。</p><p><strong>panic and recover 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</strong></p><p>在前面的章节中我们了解了 Go 检查和报告错误条件的惯有方式：</p><ul><li>产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 nil 就是成功，非 nil 就是发生了错误。</li><li>为了防止发生错误时正在执行的函数（如果有必要的话甚至会是整个程序）被中止，在调用函数后必须检查错误。</li></ul><h3 id="1、错误处理"><a href="#1、错误处理" class="headerlink" title="1、错误处理"></a>1、错误处理</h3><p>Go 有一个预先定义的 error 接口类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误值用来表示异常状态。errors 包中有一个 errorString 结构体实现了 error 接口。当程序处于错误状态时可以用 os.Exit(1) 来中止运行。</p><p><strong>命名规范：错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。</strong></p><h4 id="1）定义错误"><a href="#1）定义错误" class="headerlink" title="1）定义错误"></a>1）定义错误</h4><p>任何时候当你需要一个新的错误类型，都可以用 errors（必须先 import）包的 errors.New 函数接收合适的错误信息来创建，像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err :&#x3D; errors.New(&quot;math - square root of negative number&quot;)</span><br></pre></td></tr></table></figure><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var errNotFound &#x3D; errors.New(&quot;Not found error&quot;)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;error: %v&quot;, errNotFound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Not found error</span><br></pre></td></tr></table></figure><p>在大部分情况下自定义错误结构类型很有意义的，可以包含除了（低层级的）错误信息以外的其它有用信息，例如，正在进行的操作（打开文件等），全路径或名字。看下面例子中 os.Open 操作触发的 PathError 错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PathError records an error and the operation and file path that caused it.</span><br><span class="line">type PathError struct &#123;</span><br><span class="line">    Op string    &#x2F;&#x2F; &quot;open&quot;, &quot;unlink&quot;, etc.</span><br><span class="line">    Path string  &#x2F;&#x2F; The associated file.</span><br><span class="line">    Err error  &#x2F;&#x2F; Returned by the system call.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *PathError) String() string &#123;</span><br><span class="line">    return e.Op + &quot; &quot; + e.Path + &quot;: &quot;+ e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有不同错误条件可能发生，那么对实际的错误使用类型断言或类型判断（type-switch）是很有用的，并且可以根据错误场景做一些补救和恢复操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  err !&#x3D; nil</span><br><span class="line">if e, ok :&#x3D; err.(*os.PathError); ok &#123;</span><br><span class="line">    &#x2F;&#x2F; remedy situation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line">switch err :&#x3D; err.(type) &#123;</span><br><span class="line">    case ParseError:</span><br><span class="line">        PrintParseError(err)</span><br><span class="line">    case PathError:</span><br><span class="line">        PrintPathError(err)</span><br><span class="line">    ...</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;Not a special error, just %s\n&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）用-fmt-创建错误对象"><a href="#2）用-fmt-创建错误对象" class="headerlink" title="2）用 fmt 创建错误对象"></a>2）用 fmt 创建错误对象</h4><p>通常你想要返回包含错误参数的更有信息量的字符串，例如：可以用 fmt.Errorf() 来实现：它和 fmt.Printf () 完全一样，接收有一个或多个格式占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func testFmt(f int) (int, error) &#123;</span><br><span class="line">if f &lt; 0 &#123;</span><br><span class="line">return 0, fmt.Errorf(&quot;math: square root of negative number %g&quot;, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return f, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">_, err :&#x3D; testFmt(-1)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、运行时异常和-panic"><a href="#2、运行时异常和-panic" class="headerlink" title="2、运行时异常和 panic"></a>2、运行时异常和 panic</h3><p>当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时 panic，伴随着程序的崩溃抛出一个 runtime.Error 接口类型的值。这个错误值有个 RuntimeError() 方法用于区别普通错误。</p><p>panic 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 panic 函数产生一个中止程序的运行时错误。panic 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Starting the program&quot;)</span><br><span class="line">    panic(&quot;A severe error occurred: stopping the program!&quot;)</span><br><span class="line">    fmt.Println(&quot;Ending the program&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go panicking：</p><p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，<strong>所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者</strong>。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 panicking。</p><p>标准库中有许多包含 Must 前缀的函数，像 regexp.MustComplie 和 template.Must；当正则表达式或模板中转入的转换字符串导致错误时，这些函数会 panic。</p><h3 id="3、从-panic-中恢复（Recover）"><a href="#3、从-panic-中恢复（Recover）" class="headerlink" title="3、从 panic 中恢复（Recover）"></a>3、从 panic 中恢复（Recover）</h3><p>正如名字一样，这个（recover）内建函数被用于从 panic 或 错误场景中恢复：<strong>让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行</strong>。</p><p>recover <strong>只能在 defer 修饰的函数中使用</strong>：用于取得 panic 调用中传递过来的错误值，<strong>如果是正常执行，调用 recover 会返回 nil，且没有其它效果。</strong></p><p>总结：<strong>panic 会导致栈被展开直到 defer 修饰的 recover () 被调用或者程序中止。</strong></p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func protect(g func()) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">log.Println(&quot;done&quot;)</span><br><span class="line">&#x2F;&#x2F; Println executes normally even if there is a panic</span><br><span class="line">if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">log.Printf(&quot;run time panic: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">log.Println(&quot;start&quot;)</span><br><span class="line">g() &#x2F;&#x2F;   possible runtime-error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">protect(func() &#123;</span><br><span class="line">panic(&quot;run error&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defer-panic-recover机制"><a href="#defer-panic-recover机制" class="headerlink" title="defer-panic-recover机制"></a>defer-panic-recover机制</h4><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func badCall() &#123;</span><br><span class="line">panic(&quot;bad end&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if e :&#x3D; recover(); e !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;Panicing %s\r\n&quot;, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">badCall()</span><br><span class="line">fmt.Printf(&quot;After bad call\r\n&quot;) &#x2F;&#x2F; &lt;-- wordt niet bereikt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;Calling test\r\n&quot;)</span><br><span class="line">test()</span><br><span class="line">fmt.Printf(&quot;Test completed\r\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer-panic-recover 在某种意义上也是一种像 if，for 这样的控制流机制。</p><p>Go 标准库中许多地方都用了这个机制，例如，json 包中的解码和 regexp 包中的 Complie 函数。Go 库的原则是即使在包的内部使用了 panic，在它的对外接口（API）中也必须用 recover 处理成返回显式的错误。</p><h3 id="4、自定义包中的错误处理和-panicking"><a href="#4、自定义包中的错误处理和-panicking" class="headerlink" title="4、自定义包中的错误处理和 panicking"></a>4、自定义包中的错误处理和 panicking</h3><p>这是所有自定义包实现者应该遵守的最佳实践：</p><ul><li>1）在包内部，总是应该从 panic 中 recover：不允许显式的超出包范围的 panic ()</li><li>2）向包的调用者返回错误值（而不是 panic）。</li></ul><p>我们有一个简单的 parse 包用来把输入的字符串解析为整数切片；这个包有自己特殊的 ParseError。当没有东西需要转换或者转换成整数失败时，这个包会 panic（在函数 fields2numbers 中）。但是可导出的 Parse 函数会从 panic 中 recover 并用所有这些信息返回一个错误给调用者。</p><p>为了演示这个过程，在 panic_recover.go 中 调用了 parse 包；不可解析的字符串会导致错误并被打印出来。</p><p>parse.go 代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; parse.go</span><br><span class="line">package parse</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A ParseError indicates an error in converting a word into an integer.</span><br><span class="line">type ParseError struct &#123;</span><br><span class="line">    Index int      &#x2F;&#x2F; The index into the space-separated list of words.</span><br><span class="line">    Word  string   &#x2F;&#x2F; The word that generated the parse error.</span><br><span class="line">    Err error &#x2F;&#x2F; The raw error that precipitated this error, if any.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String returns a human-readable error message.</span><br><span class="line">func (e *ParseError) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;pkg parse: error parsing %q as int&quot;, e.Word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Parse parses the space-separated words in in put as integers.</span><br><span class="line">func Parse(input string) (numbers []int, err error) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if r :&#x3D; recover(); r !&#x3D; nil &#123;</span><br><span class="line">            var ok bool</span><br><span class="line">            err, ok &#x3D; r.(error)</span><br><span class="line">            if !ok &#123;</span><br><span class="line">                err &#x3D; fmt.Errorf(&quot;pkg: %v&quot;, r)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fields :&#x3D; strings.Fields(input)</span><br><span class="line">    numbers &#x3D; fields2numbers(fields)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fields2numbers(fields []string) (numbers []int) &#123;</span><br><span class="line">    if len(fields) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        panic(&quot;no words to parse&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    for idx, field :&#x3D; range fields &#123;</span><br><span class="line">        num, err :&#x3D; strconv.Atoi(field)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            panic(&amp;ParseError&#123;idx, field, err&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        numbers &#x3D; append(numbers, num)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic_package.go 代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; panic_package.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;.&#x2F;parse&#x2F;parse&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var examples &#x3D; []string&#123;</span><br><span class="line">            &quot;1 2 3 4 5&quot;,</span><br><span class="line">            &quot;100 50 25 12.5 6.25&quot;,</span><br><span class="line">            &quot;2 + 2 &#x3D; 4&quot;,</span><br><span class="line">            &quot;1st class&quot;,</span><br><span class="line">            &quot;&quot;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for _, ex :&#x3D; range examples &#123;</span><br><span class="line">        fmt.Printf(&quot;Parsing %q:\n  &quot;, ex)</span><br><span class="line">        nums, err :&#x3D; parse.Parse(ex)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            fmt.Println(err) &#x2F;&#x2F; here String() method from ParseError is used</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(nums)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Parsing &quot;1 2 3 4 5&quot;:</span><br><span class="line">  [1 2 3 4 5]</span><br><span class="line">Parsing &quot;100 50 25 12.5 6.25&quot;:</span><br><span class="line">  pkg parse: error parsing &quot;12.5&quot; as int</span><br><span class="line">Parsing &quot;2 + 2 &#x3D; 4&quot;:</span><br><span class="line">  pkg parse: error parsing &quot;+&quot; as int</span><br><span class="line">Parsing &quot;1st class&quot;:</span><br><span class="line">  pkg parse: error parsing &quot;1st&quot; as int</span><br><span class="line">Parsing &quot;&quot;:</span><br><span class="line">  pkg: no words to parse</span><br></pre></td></tr></table></figure><h3 id="5、一种用闭包处理错误的模式"><a href="#5、一种用闭包处理错误的模式" class="headerlink" title="5、一种用闭包处理错误的模式"></a>5、一种用闭包处理错误的模式</h3><p>每当函数返回时，我们应该检查是否有错误发生：但是这会导致重复乏味的代码。</p><p>结合 defer/panic/recover 机制和闭包可以得到一个我们马上要讨论的更加优雅的模式。不过这个模式只有当所有的函数都是同一种签名时可用，这样就有相当大的限制。</p><p>一个很好的使用它的例子是 web 应用，所有的处理函数都是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func handler1(w http.ResponseWriter, r *http.Request) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>假设所有的函数都有这样的签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func f(a type1, b type2)</span><br></pre></td></tr></table></figure><p>参数的数量和类型是不相关的。</p><p>我们给这个类型一个名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fType1 &#x3D; func f(a type1, b type2)</span><br></pre></td></tr></table></figure><p>在我们的模式中使用了两个帮助函数：</p><p>1）check：这是用来检查是否有错误和 panic 发生的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func check(err error) &#123; if err !&#x3D; nil &#123; panic(err) &#125; &#125;</span><br></pre></td></tr></table></figure><p>2）errorhandler：这是一个包装函数。接收一个 fType1 类型的函数 fn 并返回一个调用 fn 的函数。里面就包含有 defer/recover 机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func errorHandler(fn fType1) fType1 &#123;</span><br><span class="line">    return func(a type1, b type2) &#123;</span><br><span class="line">        defer func() &#123;</span><br><span class="line">            if err, ok :&#x3D; recover().(error); ok &#123;</span><br><span class="line">                log.Printf(“run time panic: %v”, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        fn(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当错误发生时会 recover 并打印在日志中；除了简单的打印，应用也可以用 template 包为用户生成自定义的输出。check () 函数会在所有的被调函数中调用，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func f1(a type1, b type2) &#123;</span><br><span class="line">    ...</span><br><span class="line">    f, _, err :&#x3D; &#x2F;&#x2F; call function&#x2F;method</span><br><span class="line">    check(err)</span><br><span class="line">    t, err :&#x3D; &#x2F;&#x2F; call function&#x2F;method</span><br><span class="line">    check(err)</span><br><span class="line">    _, err2 :&#x3D; &#x2F;&#x2F; call function&#x2F;method</span><br><span class="line">    check(err2)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种机制，所有的错误都会被 recover，并且调用函数后的错误检查代码也被简化为调用 check (err) 即可。</p><p>在这种模式下，不同的错误处理必须对应不同的函数类型；它们（错误处理）可能被隐藏在错误处理包内部。</p><p>可选的更加通用的方式是用一个空接口类型的切片作为参数和返回值。</p><h3 id="6、启动外部命令和程序"><a href="#6、启动外部命令和程序" class="headerlink" title="6、启动外部命令和程序"></a>6、启动外部命令和程序</h3><p>os 包有一个 StartProcess 函数可以调用或启动外部系统命令和二进制可执行文件；它的第一个参数是要运行的进程，第二个参数用来传递选项或参数，第三个参数是含有系统环境基本信息的结构体。</p><p>这个函数返回被启动进程的 id（pid），或者启动失败返回错误。</p><p>exec 包中也有同样功能的更简单的结构体和函数；主要是 exec.Command(name string, arg …string) 和 Run()。首先需要用系统命令或可执行文件的名字创建一个 Command 对象，然后用这个对象作为接收者调用 Run()。</p><p>下面的程序（因为是执行 Linux 命令，只能在 Linux 下面运行）演示了它们的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 1) os.StartProcess &#x2F;&#x2F;</span><br><span class="line">&#x2F;*********************&#x2F;</span><br><span class="line">&#x2F;* Linux: *&#x2F;</span><br><span class="line">env :&#x3D; os.Environ()</span><br><span class="line">procAttr :&#x3D; &amp;os.ProcAttr&#123;</span><br><span class="line">Env: env,</span><br><span class="line">Files: []*os.File&#123;</span><br><span class="line">os.Stdin,</span><br><span class="line">os.Stdout,</span><br><span class="line">os.Stderr,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1st example: list files</span><br><span class="line">pid, err :&#x3D; os.StartProcess(&quot;&#x2F;bin&#x2F;ls&quot;, []string&#123;&quot;ls&quot;, &quot;-l&quot;&#125;, procAttr)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;Error %v starting process!&quot;, err) &#x2F;&#x2F;</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;The process id is %v&quot;, pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The process id is &amp;&#123;2054 0&#125;total 2056</span><br><span class="line">-rwxr-xr-x 1 ivo ivo 1157555 2011-07-04 16:48 Mieken_exec</span><br><span class="line">-rw-r--r-- 1 ivo ivo    2124 2011-07-04 16:48 Mieken_exec.go</span><br><span class="line">-rw-r--r-- 1 ivo ivo   18528 2011-07-04 16:48 Mieken_exec_go_.6</span><br><span class="line">-rwxr-xr-x 1 ivo ivo  913920 2011-06-03 16:13 panic.exe</span><br><span class="line">-rw-r--r-- 1 ivo ivo     180 2011-04-11 20:39 panic.go</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2nd example: show all processes</span><br><span class="line">pid, err &#x3D; os.StartProcess(&quot;&#x2F;bin&#x2F;ps&quot;, []string&#123;&quot;-e&quot;, &quot;-opid,ppid,comm&quot;&#125;, procAttr)</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;Error %v starting process!&quot;, err)  &#x2F;&#x2F;</span><br><span class="line">        os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;The process id is %v&quot;, pid)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2) exec.Run &#x2F;&#x2F;</span><br><span class="line">&#x2F;***************&#x2F;</span><br><span class="line">&#x2F;&#x2F; Linux:  OK, but not for ls ?</span><br><span class="line">&#x2F;&#x2F; cmd :&#x3D; exec.Command(&quot;ls&quot;, &quot;-l&quot;)  &#x2F;&#x2F; no error, but doesn&#39;t show anything ?</span><br><span class="line">&#x2F;&#x2F; cmd :&#x3D; exec.Command(&quot;ls&quot;)        &#x2F;&#x2F; no error, but doesn&#39;t show anything ?</span><br><span class="line">    cmd :&#x3D; exec.Command(&quot;gedit&quot;)  &#x2F;&#x2F; this opens a gedit-window</span><br><span class="line">    err &#x3D; cmd.Run()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;Error %v executing command!&quot;, err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;The command is %v&quot;, cmd)</span><br><span class="line">&#x2F;&#x2F; The command is &amp;&#123;&#x2F;bin&#x2F;ls [ls -l] []  &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; 0xf840000210 &lt;nil&gt; true [0xf84000ea50 0xf84000e9f0 0xf84000e9c0] [0xf84000ea50 0xf84000e9f0 0xf84000e9c0] [] [] 0xf8400128c0&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; in Windows: uitvoering: Error fork&#x2F;exec &#x2F;bin&#x2F;ls: The system cannot find the path specified. starting process!</span><br></pre></td></tr></table></figure><h3 id="7、Go-中的单元测试和基准测试"><a href="#7、Go-中的单元测试和基准测试" class="headerlink" title="7、Go 中的单元测试和基准测试"></a>7、Go 中的单元测试和基准测试</h3><p>首先所有的包都应该有一定的必要文档，然后同样重要的是对包的测试。</p><p>名为 testing 的包被专门用来进行自动化测试，日志和错误报告。并且还包含一些基准测试函数的功能。</p><p>备注：gotest 是 Unix bash 脚本，所以在 Windows 下你需要配置 MINGW 环境（参见 2.5 节）；在 Windows 环境下把所有的 pkg/linux_amd64 替换成 pkg/windows。</p><p>对一个包做（单元）测试，需要写一些可以频繁（每次更新后）执行的小块测试单元来检查代码的正确性。</p><p>于是我们必须写一些 Go 源文件来测试代码。测试程序必须属于被测试的包，并且文件名满足这种形式 *_test.go，所以测试代码和包中的业务代码是分开的。</p><p>_test 程序不会被普通的 Go 编译器编译，所以当放应用部署到生产环境时它们不会被部署；只有 gotest 会编译所有的程序：普通程序和测试程序。</p><p>测试文件中必须导入 “testing” 包，并写一些名字以 TestZzz 打头的全局函数，这里的 Zzz 是被测试函数的字母描述，如 TestFmtInterface，TestPayEmployees 等。</p><p>测试函数必须有这种形式的头部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func TestAbcde(t *testing.T)</span><br></pre></td></tr></table></figure><p>T 是传给测试函数的结构类型，用来管理测试状态，支持格式化测试日志，如 t.Log，t.Error，t.ErrorF 等。</p><p>在函数的结尾把输出跟想要的结果对比，如果不等就打印一个错误。成功的测试则直接返回。</p><p>用下面这些函数来通知测试失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）func (t *T) Fail()</span><br><span class="line">  标记测试函数为失败，然后继续执行（剩下的测试）。</span><br><span class="line">2）func (t *T) FailNow()</span><br><span class="line">  标记测试函数为失败并中止执行；文件中别的测试也被略过，继续执行下一个文件。</span><br><span class="line">3）func (t *T) Log(args ...interface&#123;&#125;)</span><br><span class="line">  args 被用默认的格式格式化并打印到错误日志中。</span><br><span class="line">4）func (t *T) Fatal(args ...interface&#123;&#125;)</span><br><span class="line">  结合 先执行 3），然后执行 2）的效果。</span><br></pre></td></tr></table></figure><p>运行 go test 来编译测试程序，并执行程序中所有的 TestZZZ 函数。如果所有的测试都通过会打印出 PASS。</p><p>gotest 可以接收一个或多个函数程序作为参数，并指定一些选项。</p><p>结合 –chatty 或 -v 选项，每个执行的测试函数以及测试状态会被打印。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go test fmt_test.go --chatty</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN fmt.TestFlagParser</span><br><span class="line">--- PASS: fmt.TestFlagParser</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN fmt.TestArrayPrinter</span><br><span class="line">--- PASS: fmt.TestArrayPrinter</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>testing 包中有一些类型和函数可以用来做简单的基准测试；测试代码中必须包含以 BenchmarkZzz 打头的函数并接收一个 *testing.B 类型的参数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkReverse(b *testing.B) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令 go test –test.bench=.* 会运行所有的基准测试函数。代码中的函数会被调用 N 次（N 是非常大的数，如 N = 1000000），并展示 N 的值和函数执行的平均时间，单位为 ns（纳秒，ns/op）。</p><p>如果是用 testing.Benchmark 调用这些函数，直接运行程序即可。</p><p>测试用例至少应该包括：</p><ul><li>正常的用例</li><li>反面的用例（错误的输入，如用负数或字母代替数字，没有输入等）</li><li>边界检查用例（如果参数的取值范围是 0 到 1000，检查 0 和 1000 的情况）</li></ul><h4 id="测试的具体例子"><a href="#测试的具体例子" class="headerlink" title="测试的具体例子"></a>测试的具体例子</h4><p>even_main.go 的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;even&#x2F;even&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i:&#x3D;0; i&lt;&#x3D;100; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;Is the integer %d even? %v\n&quot;, i, even.Even(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>even/even.go 的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package even</span><br><span class="line"></span><br><span class="line">func Even(i int) bool &#123;     &#x2F;&#x2F; Exported function</span><br><span class="line">    return i%2 &#x3D;&#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Odd(i int) bool &#123;      &#x2F;&#x2F; Exported function</span><br><span class="line">    return i%2 !&#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>oddeven_test.go 的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package even</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestEven(t *testing.T) &#123;</span><br><span class="line">    if !Even(10) &#123;</span><br><span class="line">        t.Log(&quot; 10 must be even!&quot;)</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">    if Even(7) &#123;</span><br><span class="line">        t.Log(&quot; 7 is not even!&quot;)</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestOdd(t *testing.T) &#123;</span><br><span class="line">    if !Odd(11) &#123;</span><br><span class="line">        t.Log(&quot; 11 must be odd!&quot;)</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">    if Odd(10) &#123;</span><br><span class="line">        t.Log(&quot; 10 is not odd!&quot;)</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://learnku.com/docs/the-way-to-go">Go 入门指南</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：十二到十三章的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go 入门总结（二）</title>
    <link href="https://www.blog.ajie39.top/2022/05/07/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/05/07/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-05-07T07:10:19.400Z</published>
    <updated>2022-06-12T06:29:56.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：六到十一章的内容。</h1><hr><span id="more"></span><h2 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h2><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><h4 id="1）特性"><a href="#1）特性" class="headerlink" title="1）特性"></a>1）特性</h4><ul><li>函数是基本的代码块。</li><li>Go 是编译型语言，所以函数编写的顺序是无关紧要的。</li><li>最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。</li><li>DRY 原则：即不要重复你自己（Don’t Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次。</li><li>当函数执行到代码块最后一行（} 之前）或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数。</li><li>函数可以将其他函数调用作为它的参数，只要这个被调用函数的返回值个数、返回值类型和返回值的顺序与调用函数所需求的实参是一致的，例如：f1(f2(a, b))。</li><li>Go不允许函数重载。</li></ul><h4 id="2）不同类型的函数"><a href="#2）不同类型的函数" class="headerlink" title="2）不同类型的函数"></a>2）不同类型的函数</h4><p>Go 里面有三种类型的函数：</p><ul><li>普通的带有名字的函数</li><li>匿名函数或者 lambda 函数</li><li>方法</li></ul><p>除了 main ()、init () 函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为<strong>函数签名</strong>。</p><h4 id="3）语法"><a href="#3）语法" class="headerlink" title="3）语法"></a>3）语法</h4><p>函数基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数被调用的基本格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pack1.Function(arg1, arg2, …, argn)</span><br></pre></td></tr></table></figure><p>Function 是 pack1 包里面的一个函数，括号里的是被调用函数的 <strong>实参</strong>（argument）：这些值被传递给被调用函数的 <strong>形参</strong>。函数被调用的时候，这些实参将被复制（简单而言）然后传递给被调用函数。</p><p>函数一般是在其他函数里面被调用的，这个其他函数被称为调用函数（calling function）。函数能多次调用其他函数，这些被调用函数按顺序（简单而言）执行，理论上，函数调用其他函数的次数是无限制的（直到函数调用栈被耗尽）。</p><h4 id="4）方法"><a href="#4）方法" class="headerlink" title="4）方法"></a>4）方法</h4><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><p>Go语言中的 ​​方法（Method）​​ 是一种作用于特定类型变量的函数。这种特定类型变量叫做 ​​接收者（Receiver）​​。接收者的概念就类似于其他语言中的 ​​this​​ 或者 ​​self​​。</p><p>方法的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">  &#x2F;&#x2F; 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在go语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接受者的函数，<strong>方法和函数的写法只有一个区别</strong>，那就是 <strong>方法在 func 和标识符之间多了一个参数——接受者定义在func关键字和函数名之间</strong>。</p><p>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</p><p>方法的接收者什么时候适合指向结构体的指针而不是结构体值？</p><p>以C语言为例，我们知道在C中如果对一个指针变量进行修改，那么它的“副本”们也都会被修改。所以在Go中，如果你的方法是需要对结构体本身修改的，请使用指针作为接收器。否则，以值为接收器，改动将无效（类似slice，map特殊结构体）。你的结构体很大，用一个指针传递，会节约资源。为统一起见，如果你的大多方法以指针为接收器，请把其他方法也优先以指针作为接收器，不然调用时可能会提示该方法不属于某结构体的乌龙错误。</p><h4 id="5）函数类型"><a href="#5）函数类型" class="headerlink" title="5）函数类型"></a>5）函数类型</h4><p>函数也可以以申明的方式被使用，作为一个函数类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明 Greeting 函数类型</span><br><span class="line">type Greeting func(name string) string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义方法</span><br><span class="line">func (g Greeting) say(n string) &#123;</span><br><span class="line">fmt.Println(g(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO 是类C语言，也就是面向过程语言。<a href="https://go.dev/doc/faq#ancestors">见此</a><br>以C语言为例，它是没有类这种概念的，只有结构体。<br>在C中，编写一个结构体的方法，我们通常采用以下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func(s *Student, id int)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把第一个参数做为该方法的 <strong>“类对象”</strong>，也称为 <strong>接受者</strong>，receiver。<br>而 <strong>Go只是把C语言中的第一个参数放到方法前面</strong> 而已，所以它并不是用来类型转换的，而是一个接收者，<strong>说明该方法属于哪个结构体</strong>。</p><h3 id="2、传递变长参数"><a href="#2、传递变长参数" class="headerlink" title="2、传递变长参数"></a>2、传递变长参数</h3><p>如果函数的最后一个参数是采用 …type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变长函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func myFunc(a, b, arg ...int) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受一个类似某个类型的 slice 的参数，该参数可以通过 for 循环结构迭代。</p><p>如果参数被存储在一个 slice 类型的变量 slice 中，则可以通过 slice… 的形式来传递参数调用变参函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    x :&#x3D; min(1, 3, 2, 0)</span><br><span class="line">    fmt.Printf(&quot;The minimum is: %d\n&quot;, x)</span><br><span class="line">    slice :&#x3D; []int&#123;7,9,3,5,1&#125;</span><br><span class="line">    x &#x3D; min(slice...)</span><br><span class="line">    fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(s ...int) int &#123;</span><br><span class="line">    if len(s)&#x3D;&#x3D;0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    min :&#x3D; s[0]</span><br><span class="line">    for _, v :&#x3D; range s &#123;</span><br><span class="line">        if v &lt; min &#123;</span><br><span class="line">            min &#x3D; v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、defer-和追踪"><a href="#3、defer-和追踪" class="headerlink" title="3、defer 和追踪"></a>3、defer 和追踪</h3><p>关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。</p><p>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    function1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func function1() &#123;</span><br><span class="line">    fmt.Printf(&quot;In function1 at the top\n&quot;)</span><br><span class="line">    defer function2()</span><br><span class="line">    fmt.Printf(&quot;In function1 at the bottom!\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func function2() &#123;</span><br><span class="line">    fmt.Printf(&quot;function2: Deferred until the end of the calling function!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">In Function1 at the top</span><br><span class="line">In Function1 at the bottom!</span><br><span class="line">Function2: Deferred until the end of the calling function!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 defer 的语句同样可以接受参数，下面这个例子就会在执行 defer 语句时打印 0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">    i :&#x3D; 0</span><br><span class="line">    defer fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func f() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">        defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">4 3 2 1 0</span><br></pre></td></tr></table></figure><h4 id="1）使用-defer-语句实现代码追踪"><a href="#1）使用-defer-语句实现代码追踪" class="headerlink" title="1）使用 defer 语句实现代码追踪"></a>1）使用 defer 语句实现代码追踪</h4><p>一个基础但十分实用的实现代码执行追踪的方案就是在进入和离开某个函数打印相关的消息，即可以提炼为下面两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func trace(s string) &#123; fmt.Println(&quot;entering:&quot;, s) &#125;</span><br><span class="line">func untrace(s string) &#123; fmt.Println(&quot;leaving:&quot;, s) &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func trace(s string)   &#123; fmt.Println(&quot;entering:&quot;, s) &#125;</span><br><span class="line">func untrace(s string) &#123; fmt.Println(&quot;leaving:&quot;, s) &#125;</span><br><span class="line"></span><br><span class="line">func a() &#123;</span><br><span class="line">    trace(&quot;a&quot;)</span><br><span class="line">    defer untrace(&quot;a&quot;)</span><br><span class="line">    fmt.Println(&quot;in a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func b() &#123;</span><br><span class="line">    trace(&quot;b&quot;)</span><br><span class="line">    defer untrace(&quot;b&quot;)</span><br><span class="line">    fmt.Println(&quot;in b&quot;)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）使用-defer-语句来记录函数的参数与返回值"><a href="#2）使用-defer-语句来记录函数的参数与返回值" class="headerlink" title="2）使用 defer 语句来记录函数的参数与返回值"></a>2）使用 defer 语句来记录函数的参数与返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func func1(s string) (n int, err error) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        log.Printf(&quot;func1(%q) &#x3D; %d, %v&quot;, s, n, err)</span><br><span class="line">    &#125;()</span><br><span class="line">    return 7, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    func1(&quot;Go&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Output: 2011&#x2F;10&#x2F;04 10:46:11 func1(&quot;Go&quot;) &#x3D; 7, EOF</span><br></pre></td></tr></table></figure><h3 id="4、内置函数"><a href="#4、内置函数" class="headerlink" title="4、内置函数"></a>4、内置函数</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td>new、make</td><td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new (type)、make (type)。new (T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make (T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作 new () 是一个函数，不要忘记它的括号</td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数，在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real、imag</td><td>用于创建和操作复数</td></tr></tbody></table><h3 id="5、将函数作为参数"><a href="#5、将函数作为参数" class="headerlink" title="5、将函数作为参数"></a>5、将函数作为参数</h3><p>函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    callback(1, Add)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) &#123;</span><br><span class="line">    fmt.Printf(&quot;The sum of %d and %d is: %d\n&quot;, a, b, a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func callback(y int, f func(int, int)) &#123;</span><br><span class="line">    f(y, 2) &#x2F;&#x2F; this becomes Add(1, 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The sum of 1 and 2 is: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、匿名函数（闭包，函数式语言的术语）"><a href="#6、匿名函数（闭包，函数式语言的术语）" class="headerlink" title="6、匿名函数（闭包，函数式语言的术语）"></a>6、匿名函数（闭包，函数式语言的术语）</h3><p>当我们不希望给函数起名字的时候，可以使用匿名函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func(x, y int) int &#123; return x + y &#125;。</span><br><span class="line"></span><br><span class="line">这样的一个函数不能够独立存在（编译器会返回错误：non-declaration statement outside function body），但可以被赋值于某个变量，即保存函数的地址到变量中：</span><br><span class="line"></span><br><span class="line">fplus :&#x3D; func(x, y int) int &#123; return x + y &#125;</span><br><span class="line"></span><br><span class="line">然后通过变量名对函数进行调用：fplus(3,4)。</span><br></pre></td></tr></table></figure><p>当然，也可以直接对匿名函数进行调用：func(x, y int) int { return x + y } (3, 4)。</p><p>具体语法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func() &#123;</span><br><span class="line">    sum :&#x3D; 0</span><br><span class="line">    for i :&#x3D; 1; i &lt;&#x3D; 1e6; i++ &#123;</span><br><span class="line">        sum +&#x3D; i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>表示参数列表的第一对括号必须紧挨着关键字 func，因为匿名函数没有名称。花括号 {} 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。</p><p>具体例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line">func f() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 4; i++ &#123;</span><br><span class="line">        g :&#x3D; func(i int) &#123; fmt.Printf(&quot;%d &quot;, i) &#125; &#x2F;&#x2F;此例子中只是为了演示匿名函数可分配不同的内存地址，在现实开发中，不应该把该部分信息放置到循环中。</span><br><span class="line">        g(i)</span><br><span class="line">        fmt.Printf(&quot; - g is of type %T and has value %v\n&quot;, g, g)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到变量 g 代表的是 func(int)，变量的值是一个内存地址。</p><p>所以我们实际上拥有的是一个函数值：匿名函数可以被赋值给变量并作为值使用。</p><h2 id="二、数组与切片"><a href="#二、数组与切片" class="headerlink" title="二、数组与切片"></a>二、数组与切片</h2><h3 id="1、数组（概念和java相同，略过）"><a href="#1、数组（概念和java相同，略过）" class="headerlink" title="1、数组（概念和java相同，略过）"></a>1、数组（概念和java相同，略过）</h3><p>Go 语言中的数组是一种 值类型（不像 C/C++ 中是指向首元素的指针），所以可以通过 new() 来创建： var arr1 = new([5]int)。</p><p>那么这种方式和 var arr2 [5]int 的区别是什么呢？arr1 的类型是 *[5]int，而 arr2 的类型是 [5]int。</p><p>这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 :&#x3D; *arr1</span><br><span class="line">arr2[2] &#x3D; 100</span><br></pre></td></tr></table></figure><p>这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效。</p><p>所以在函数中数组作为参数传入时，如 func1(arr2)，会产生一次数组拷贝，func1 方法不会修改原始的数组 arr2。</p><p>如果你想修改原数组，那么 arr2 必须通过 &amp; 操作符以引用方式传过来，例如 func1 (&amp;arr2），例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func f(a [3]int) &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">a[0] &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fp(a *[3]int) &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">a[0] &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var ar [3]int</span><br><span class="line">f(ar)   &#x2F;&#x2F; passes a copy of ar</span><br><span class="line">fp(&amp;ar) &#x2F;&#x2F; passes a pointer to ar</span><br><span class="line">fmt.Println(ar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1）数组初始化"><a href="#1）数组初始化" class="headerlink" title="1）数组初始化"></a>1）数组初始化</h4><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; var arrAge &#x3D; [5]int&#123;18, 20, 15, 22, 16&#125;</span><br><span class="line">&#x2F;&#x2F; var arrLazy &#x3D; [...]int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="line">&#x2F;&#x2F; var arrLazy &#x3D; []int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="line">var arrKeyValue &#x3D; [5]string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; var arrKeyValue &#x3D; []string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; len(arrKeyValue); i++ &#123;</span><br><span class="line">fmt.Printf(&quot;Person at %d is %s\n&quot;, i, arrKeyValue[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）将数组传递给函数"><a href="#2）将数组传递给函数" class="headerlink" title="2）将数组传递给函数"></a>2）将数组传递给函数</h4><p>把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象：</p><ul><li>传递数组的指针</li><li>使用数组的切片</li></ul><h5 id="传递数组的指针"><a href="#传递数组的指针" class="headerlink" title="传递数组的指针"></a>传递数组的指针</h5><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">array :&#x3D; [3]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; Sum(&amp;array) &#x2F;&#x2F; Note the explicit address-of operator</span><br><span class="line">&#x2F;&#x2F; to pass a pointer to the array</span><br><span class="line">fmt.Printf(&quot;The sum of the array is: %f&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Sum(a *[3]float64) (sum float64) &#123;</span><br><span class="line">for _, v :&#x3D; range *a &#123; &#x2F;&#x2F; derefencing *a to get back to the array is not necessary!</span><br><span class="line">sum +&#x3D; v</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">The sum of the array is: 24.600000</span><br></pre></td></tr></table></figure><p>但这在 Go 中并不常用，通常使用切片。</p><h5 id="使用数组的切片"><a href="#使用数组的切片" class="headerlink" title="使用数组的切片"></a>使用数组的切片</h5><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">array :&#x3D; [3]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; sum(array[:])</span><br><span class="line">fmt.Printf(&quot;The sum of the array is: %f&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sum(a []float64) float64 &#123;</span><br><span class="line">s :&#x3D; 0.0</span><br><span class="line">for i :&#x3D; 0; i &lt; len(a); i++ &#123;</span><br><span class="line">s +&#x3D; a[i]</span><br><span class="line">&#125;</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、切片"><a href="#2、切片" class="headerlink" title="2、切片"></a>2、切片</h3><h4 id="1）概念"><a href="#1）概念" class="headerlink" title="1）概念"></a>1）概念</h4><p>切片（slice）是对数组一个 <strong>连续片段的引用（该数组我们称之为相关数组，通常是匿名的）</strong>，所以 <strong>切片是一个引用类型</strong>（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。</p><p>特点如下所示：</p><ul><li>切片是一个引用类型</li><li>切片是可索引的，并且可以由 len() 函数获取长度。</li><li>给定项的切片索引可能比相关数组的相同元素的索引小。</li><li>和数组不同的是，切片的长度可以在运行时修改，最小为 0 ，最大为相关数组的长度：切片是一个长度可变的数组。</li><li>切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少：它等于切片从第一个元素开始，到相关数组末尾的元素个数。对于 切片 s 来说该不等式永远成立：0 &lt;= len(s) &lt;= cap(s)。</li><li>多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</li></ul><p>声明切片的格式，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier []type（不需要说明长度）</span><br></pre></td></tr></table></figure><p>一个切片在未初始化之前默认为 nil，长度为 0。</p><p>切片的初始化格式，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var slice1 []type &#x3D; arr1[start:end]</span><br></pre></td></tr></table></figure><p>这表示 slice1 是由数组 arr1 从 start 索引到 end-1 索引之间的元素构成的子集（切分数组，start:end 被称为 slice 表达式）。所以 slice1[0] 就等于 arr1[start]。这可以在 arr1 被填充前就定义好。</p><p>如果某个人写：var slice1 []type = arr1[:] 那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 arr1[0:len(arr1)] 的一种缩写）。另外一种表述方式是：slice1 = &amp;arr1。</p><p>arr1[2:] 和 arr1[2:len(arr1)] 相同，都包含了数组从第三个到最后的所有元素。</p><p>arr1[:3] 和 arr1[0:3] 相同，包含了从第一个到第三个元素（不包括第四个 / 不包含下标为三的元素）。</p><p>如果你想去掉 slice1 的最后一个元素，只要 slice1 = slice1[:len(slice1)-1]。</p><p>一个由数字 1、2、3 组成的切片可以这么生成：s := [3]int{1,2,3}[:] 甚至更简单的 s := []int{1,2,3}。</p><p>s2 := s[:] 是用切片组成的切片，拥有相同的元素，但是 <strong>仍然指向相同的相关数组</strong>。</p><p>一个切片 s 可以这样扩展到它的大小上限：s = s[:cap(s)]，如果再扩大的话就会导致运行时错误。</p><p>切片也可以用类似数组的方式初始化：var x = []int{2, 3, 5, 7, 11}。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。</p><h4 id="2）切片的内存结构"><a href="#2）切片的内存结构" class="headerlink" title="2）切片的内存结构"></a>2）切片的内存结构</h4><p>切片在内存中的组织方式实际上是一个有 3 个域的结构体：</p><ul><li>指向相关数组的指针</li><li>切片长度：切片的长度就是它所包含的元素个数。</li><li>切片容量：切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</li></ul><p>一个长度为 2，容量为 4 的切片 y，如下所示：</p><p><img src="/img/image/blog/20220604/%E5%88%87%E7%89%87%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="切片内存结构"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[0] &#x3D; 3 且 y[1] &#x3D; 5。</span><br></pre></td></tr></table></figure><p>切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。</p><p>注意: <strong>绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针！！</strong></p><h4 id="3）创建切片"><a href="#3）创建切片" class="headerlink" title="3）创建切片"></a>3）创建切片</h4><p>当相关数组还没有定义时，我们可以使用 make () 函数来创建一个切片 同时创建好相关数组：var slice1 []type = make([]type, len)。</p><p>也可以简写为 slice1 := make([]type, len)，这里 len 是数组的长度并且也是 slice 的初始长度。</p><p>所以定义 s2 := make([]int, 10)，那么 cap(s2) == len(s2) == 10。</p><p>make 接受 2 个参数：元素的类型以及切片的元素个数。</p><p>如果你想创建一个 slice1，它不占用整个数组，而只是占用以 len 为个数个项，那么只要：slice1 := make([]type, len, cap)。</p><p>make 的使用方式是：func make([]T, len, cap)，其中 cap 是可选参数。</p><p>所以下面两种方法可以生成相同的切片:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make([]int, 50, 100)</span><br><span class="line">new([100]int)[0:50]</span><br></pre></td></tr></table></figure><p>使用 make 方法生成的切片的内存结构，如下图所示：</p><p><img src="/img/image/blog/20220604/make%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90%E7%9A%84%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="make方法生成的切片的内存结构"></p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var slice1 []int &#x3D; make([]int, 10)</span><br><span class="line">    &#x2F;&#x2F; load the array&#x2F;slice:</span><br><span class="line">    for i :&#x3D; 0; i &lt; len(slice1); i++ &#123;</span><br><span class="line">        slice1[i] &#x3D; 5 * i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; print the slice:</span><br><span class="line">    for i :&#x3D; 0; i &lt; len(slice1); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;Slice at %d is %d\n&quot;, i, slice1[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;\nThe length of slice1 is %d\n&quot;, len(slice1))</span><br><span class="line">    fmt.Printf(&quot;The capacity of slice1 is %d\n&quot;, cap(slice1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）new-和-make-的区别"><a href="#4）new-和-make-的区别" class="headerlink" title="4）new () 和 make () 的区别"></a>4）new () 和 make () 的区别</h4><p>看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</p><ul><li>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T{}。</li><li>make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel。</li></ul><p>换言之，new 函数分配内存，make 函数初始化；下图给出了区别：</p><p><img src="/img/image/blog/20220604/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="new和make的区别"></p><h4 id="5）多维切片"><a href="#5）多维切片" class="headerlink" title="5）多维切片"></a>5）多维切片</h4><p>Go语言中同样允许使用多维切片，声明一个多维数组的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sliceName [][]...[]sliceType</span><br></pre></td></tr></table></figure><p>下面以二维切片为例，声明一个二维切片并赋值，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明一个二维切片</span><br><span class="line">var slice [][]int</span><br><span class="line">&#x2F;&#x2F;为二维切片赋值</span><br><span class="line">slice &#x3D; [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125;</span><br><span class="line">上面的代码也可以简写为下面的样子。</span><br><span class="line">&#x2F;&#x2F; 声明一个二维整型切片并赋值</span><br><span class="line">slice :&#x3D; [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; 为第一个切片追加值为 20 的元素</span><br><span class="line">slice[0] &#x3D; append(slice[0], 20)</span><br></pre></td></tr></table></figure><h4 id="6）遍历切片"><a href="#6）遍历切片" class="headerlink" title="6）遍历切片"></a>6）遍历切片</h4><p>语法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ix, value :&#x3D; range slice1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var slice1 []int &#x3D; make([]int, 4)</span><br><span class="line"></span><br><span class="line">    slice1[0] &#x3D; 1</span><br><span class="line">    slice1[1] &#x3D; 2</span><br><span class="line">    slice1[2] &#x3D; 3</span><br><span class="line">    slice1[3] &#x3D; 4</span><br><span class="line"></span><br><span class="line">    for ix, value :&#x3D; range slice1 &#123;</span><br><span class="line">        fmt.Printf(&quot;Slice at %d is: %d\n&quot;, ix, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果你只需要索引，你可以忽略第二个变量</span><br><span class="line">    for ix :&#x3D; range slice1 &#123;</span><br><span class="line">        fmt.Printf(&quot;%d&quot;, ix)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历多维切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for row :&#x3D; range screen &#123;</span><br><span class="line">    for column :&#x3D; range screen[row] &#123;</span><br><span class="line">        screen[row][column] &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7）切片的追加"><a href="#7）切片的追加" class="headerlink" title="7）切片的追加"></a>7）切片的追加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func append(s[]T, x ...T) []T</span><br></pre></td></tr></table></figure><p>其中 append 方法将 0 个或多个具有相同类型 s 的元素追加到切片后面并且返回新的切片；追加的元素必须和原切片的元素同类型。如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。</p><p>如果你想将切片 y 追加到切片 x 后面，只要将第二个参数扩展成一个列表即可：x = append(x, y…)。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">sl3 :&#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line">sl3 &#x3D; append(sl3, 4, 5, 6)</span><br><span class="line">fmt.Println(sl3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8）切片的复制"><a href="#8）切片的复制" class="headerlink" title="8）切片的复制"></a>8）切片的复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func copy(dst, src []T) int</span><br></pre></td></tr></table></figure><p>copy 方法将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数。</p><p>源地址和目标地址可能会有重叠。拷贝个数是 src 和 dst 的长度最小值。如果 src 是字符串那么元素类型就是 byte。如果你还想继续使用 src，在拷贝结束后执行 src = dst。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">sl_from :&#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line">sl_to :&#x3D; make([]int, 10)</span><br><span class="line"></span><br><span class="line">n :&#x3D; copy(sl_to, sl_from)</span><br><span class="line">fmt.Println(sl_to)</span><br><span class="line">fmt.Printf(&quot;Copied %d elements\n&quot;, n) &#x2F;&#x2F; n &#x3D;&#x3D; 3</span><br><span class="line"></span><br><span class="line">st :&#x3D; &quot;stest&quot;</span><br><span class="line">st_arr :&#x3D; make([]byte, 100)</span><br><span class="line">copy(st_arr, st)</span><br><span class="line"></span><br><span class="line">test :&#x3D; string(st_arr)</span><br><span class="line">fmt.Println(test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、Map"><a href="#三、Map" class="headerlink" title="三、Map"></a>三、Map</h2><p>map 是引用类型，可以使用如下声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map1 map[keytype]valuetype</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">var map1 map[string]int</span><br></pre></td></tr></table></figure><ul><li>在声明的时候不需要知道 map 的长度，map 是可以动态增长的。</li><li>未初始化的 map 的值是 nil。</li><li>key 可以是任意可以用 == 或者！= 操作符比较的类型，比如 string、int、float。</li><li>切片和结构体不能作为 key (译者注：含有数组切片的结构体不能作为 key，只包含内建类型的 struct 是可以作为 key 的，但是指针和接口类型可以。)</li><li>value 可以是任意类型的；通过使用空接口类型，我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言。</li><li>map 传递给函数的代价很小：在 32 位机器上占 4 个字节，64 位机器上占 8 个字节，无论实际上存储了多少数据。</li><li>map 也可以用函数作为自己的值，这样就可以用来做分支结构：key 用来选择要执行的函数。</li></ul><h3 id="1）map初始化"><a href="#1）map初始化" class="headerlink" title="1）map初始化"></a>1）map初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var map1 &#x3D; make(map[keytype]valuetype)</span><br><span class="line"></span><br><span class="line">或者简写为：map1 :&#x3D; make(map[keytype]valuetype)</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">mapCreated :&#x3D; make(map[string]float32)</span><br><span class="line"></span><br><span class="line">相当于：mapCreated :&#x3D; map[string]float32&#123;&#125;。</span><br></pre></td></tr></table></figure><p>注意：<strong>不要使用 new，永远用 make 来构造 map</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果你错误的使用 new () 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：</span><br><span class="line"></span><br><span class="line">mapCreated :&#x3D; new(map[string]float32)</span><br><span class="line"></span><br><span class="line">接下来当我们调用：mapCreated[&quot;key1&quot;] &#x3D; 4.5 的时候，编译器会报错：</span><br><span class="line"></span><br><span class="line">invalid operation: mapCreated[&quot;key1&quot;] (index of type *map[string]float32).</span><br></pre></td></tr></table></figure><h3 id="2）map容量"><a href="#2）map容量" class="headerlink" title="2）map容量"></a>2）map容量</h3><p>和数组不同，map 可以根据新增的 key-value 对动态的伸缩，因此它不存在固定长度或者最大限制。</p><p>但是你也可以选择标明 map 的初始容量 capacity，就像这样：make(map[keytype]valuetype, cap)。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map2 :&#x3D; make(map[string]float32, 100)</span><br></pre></td></tr></table></figure><p>当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明</p><h3 id="3）用切片作为-map-的值"><a href="#3）用切片作为-map-的值" class="headerlink" title="3）用切片作为 map 的值"></a>3）用切片作为 map 的值</h3><p>既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理 unix 机器上的所有进程，以父进程（pid 为整型）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为 value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp1 :&#x3D; make(map[int][]int)</span><br><span class="line">mp2 :&#x3D; make(map[int]*[]int)</span><br></pre></td></tr></table></figure><h3 id="4）测试键值对是否存在及删除元素"><a href="#4）测试键值对是否存在及删除元素" class="headerlink" title="4）测试键值对是否存在及删除元素"></a>4）测试键值对是否存在及删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val1, isPresent &#x3D; map1[key1]</span><br></pre></td></tr></table></figure><p>isPresent 返回一个 bool 值：如果 key1 存在于 map1，val1 就是 key1 对应的 value 值，并且 isPresent 为 true；如果 key1 不存在，val1 就是一个空值，并且 isPresent 会返回 false。</p><p>如果你只是想判断某个 key 是否存在而不关心它对应的值到底是多少，你可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, ok :&#x3D; map1[key1] &#x2F;&#x2F; 如果key1存在则ok &#x3D;&#x3D; true，否则ok为false</span><br></pre></td></tr></table></figure><p>或者和 if 混合使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if _, ok :&#x3D; map1[key1]; ok &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 map1 中删除 key1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(map1, key1)</span><br></pre></td></tr></table></figure><p>如果 key1 不存在，该操作不会产生错误。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var value int</span><br><span class="line">    var isPresent bool</span><br><span class="line"></span><br><span class="line">    map1 :&#x3D; make(map[string]int)</span><br><span class="line">    map1[&quot;New Delhi&quot;] &#x3D; 55</span><br><span class="line">    map1[&quot;Beijing&quot;] &#x3D; 20</span><br><span class="line">    map1[&quot;Washington&quot;] &#x3D; 25</span><br><span class="line">    value, isPresent &#x3D; map1[&quot;Beijing&quot;]</span><br><span class="line">    if isPresent &#123;</span><br><span class="line">        fmt.Printf(&quot;The value of \&quot;Beijing\&quot; in map1 is: %d\n&quot;, value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Printf(&quot;map1 does not contain Beijing&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value, isPresent &#x3D; map1[&quot;Paris&quot;]</span><br><span class="line">    fmt.Printf(&quot;Is \&quot;Paris\&quot; in map1 ?: %t\n&quot;, isPresent)</span><br><span class="line">    fmt.Printf(&quot;Value is: %d\n&quot;, value)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; delete an item:</span><br><span class="line">    delete(map1, &quot;Washington&quot;)</span><br><span class="line">    value, isPresent &#x3D; map1[&quot;Washington&quot;]</span><br><span class="line">    if isPresent &#123;</span><br><span class="line">        fmt.Printf(&quot;The value of \&quot;Washington\&quot; in map1 is: %d\n&quot;, value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;map1 does not contain Washington&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">The value of &quot;Beijing&quot; in map1 is: 20</span><br><span class="line">Is &quot;Paris&quot; in map1 ?: false</span><br><span class="line">Value is: 0</span><br><span class="line">map1 does not contain Washington</span><br></pre></td></tr></table></figure><h3 id="5）for-range-的配套用法"><a href="#5）for-range-的配套用法" class="headerlink" title="5）for-range 的配套用法"></a>5）for-range 的配套用法</h3><p>遍历 map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value :&#x3D; range map1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个返回值 key 是 map 中的 key 值，第二个返回值则是该 key 对应的 value 值；<strong>这两个都是仅 for 循环内部可见的局部变量</strong>。其中第一个返回值 key 值是一个可选元素。如果你只关心值，可以这么使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, value :&#x3D; range map1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只想获取 key，你可以这么使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key :&#x3D; range map1 &#123;</span><br><span class="line">    fmt.Printf(&quot;key is: %d\n&quot;, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    map1 :&#x3D; make(map[int]float32)</span><br><span class="line">    map1[1] &#x3D; 1.0</span><br><span class="line">    map1[2] &#x3D; 2.0</span><br><span class="line">    map1[3] &#x3D; 3.0</span><br><span class="line">    map1[4] &#x3D; 4.0</span><br><span class="line">    for key, value :&#x3D; range map1 &#123;</span><br><span class="line">        fmt.Printf(&quot;key is: %d - value is: %f\n&quot;, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">key is: 3 - value is: 3.000000</span><br><span class="line">key is: 1 - value is: 1.000000</span><br><span class="line">key is: 4 - value is: 4.000000</span><br><span class="line">key is: 2 - value is: 2.000000</span><br></pre></td></tr></table></figure><p>注意：<strong>map 不是按照 key 的顺序排列的，也不是按照 value 的序排列的。</strong></p><h3 id="6）map-的排序"><a href="#6）map-的排序" class="headerlink" title="6）map 的排序"></a>6）map 的排序</h3><p>map 默认是无序的，不管是按照 key 还是按照 value 默认都不排序。</p><p>如果你想为 map 排序，需要将 key（或者 value）拷贝到一个切片，再对切片排序，然后可以使用切片的 for-range 方法打印出所有的 key 和 value。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    barVal &#x3D; map[string]int&#123;&quot;alpha&quot;: 34, &quot;bravo&quot;: 56, &quot;charlie&quot;: 23,</span><br><span class="line">                            &quot;delta&quot;: 87, &quot;echo&quot;: 56, &quot;foxtrot&quot;: 12,</span><br><span class="line">                            &quot;golf&quot;: 34, &quot;hotel&quot;: 16, &quot;indio&quot;: 87,</span><br><span class="line">                            &quot;juliet&quot;: 65, &quot;kili&quot;: 43, &quot;lima&quot;: 98&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;unsorted:&quot;)</span><br><span class="line">    for k, v :&#x3D; range barVal &#123;</span><br><span class="line">        fmt.Printf(&quot;Key: %v, Value: %v &#x2F; &quot;, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    keys :&#x3D; make([]string, len(barVal))</span><br><span class="line">    i :&#x3D; 0</span><br><span class="line">    for k, _ :&#x3D; range barVal &#123;</span><br><span class="line">        keys[i] &#x3D; k</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(keys)</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(&quot;sorted:&quot;)</span><br><span class="line">    for _, k :&#x3D; range keys &#123;</span><br><span class="line">        fmt.Printf(&quot;Key: %v, Value: %v &#x2F; &quot;, k, barVal[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">unsorted:</span><br><span class="line">Key: bravo, Value: 56 &#x2F; Key: echo, Value: 56 &#x2F; Key: indio, Value: 87 &#x2F; Key: juliet, Value: 65 &#x2F; Key: alpha, Value: 34 &#x2F; Key: charlie, Value: 23 &#x2F; Key: delta, Value: 87 &#x2F; Key: foxtrot, Value: 12 &#x2F; Key: golf, Value: 34 &#x2F; Key: hotel, Value: 16 &#x2F; Key: kili, Value: 43 &#x2F; Key: lima, Value: 98 &#x2F;</span><br><span class="line">sorted:</span><br><span class="line">Key: alpha, Value: 34 &#x2F; Key: bravo, Value: 56 &#x2F; Key: charlie, Value: 23 &#x2F; Key: delta, Value: 87 &#x2F; Key: echo, Value: 56 &#x2F; Key: foxtrot, Value: 12 &#x2F; Key: golf, Value: 34 &#x2F; Key: hotel, Value: 16 &#x2F; Key: indio, Value: 87 &#x2F; Key: juliet, Value: 65 &#x2F; Key: kili, Value: 43 &#x2F; Key: lima, Value: 98 &#x2F;</span><br></pre></td></tr></table></figure><h3 id="7）map-类型的切片"><a href="#7）map-类型的切片" class="headerlink" title="7）map 类型的切片"></a>7）map 类型的切片</h3><p>假设我们想获取一个 map 类型的切片，我们必须使用两次 make() 函数，第一次分配切片，第二次分配 切片中每个 map 元素。例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; Version A:</span><br><span class="line">    items :&#x3D; make([]map[int]int, 5)</span><br><span class="line">    for i:&#x3D; range items &#123;</span><br><span class="line">        items[i] &#x3D; make(map[int]int, 1)</span><br><span class="line">        items[i][1] &#x3D; 2</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;Version A: Value of items: %v\n&quot;, items)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Version B: NOT GOOD!</span><br><span class="line">    items2 :&#x3D; make([]map[int]int, 5)</span><br><span class="line">    for _, item :&#x3D; range items2 &#123;</span><br><span class="line">        item &#x3D; make(map[int]int, 1) &#x2F;&#x2F; item 只是切片元素的副本。</span><br><span class="line">        item[1] &#x3D; 2 &#x2F;&#x2F; 这个“项目”将在下一次迭代中丢失。</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;Version B: Value of items: %v\n&quot;, items2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、结构体"><a href="#四、结构体" class="headerlink" title="四、结构体"></a>四、结构体</h2><p>结构体定义的一般方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type identifier struct &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 new 创建一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">var t *T &#x3D; new(T)</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">var t *T</span><br><span class="line">t &#x3D; new(T)</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">t :&#x3D; new(T)</span><br></pre></td></tr></table></figure><p>上面的语句表示，变量 t 是一个指向 T 的指针，此时结构体字段的值是它们所属类型的零值。</p><p>声明 var t T 也会给 t 分配内存，并零值化内存，但是这个时候 t 是类型 T。在这几种方式中，t 通常被称做类型 T 的一个实例（instance）或对象（object）。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type struct1 struct &#123;</span><br><span class="line">    i1  int</span><br><span class="line">    f1  float32</span><br><span class="line">    str string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ms :&#x3D; new(struct1)</span><br><span class="line">    ms.i1 &#x3D; 10</span><br><span class="line">    ms.f1 &#x3D; 15.5</span><br><span class="line">    ms.str&#x3D; &quot;Chris&quot;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;The int is: %d\n&quot;, ms.i1)</span><br><span class="line">    fmt.Printf(&quot;The float is: %f\n&quot;, ms.f1)</span><br><span class="line">    fmt.Printf(&quot;The string is: %s\n&quot;, ms.str)</span><br><span class="line">    fmt.Println(ms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The int is: 10</span><br><span class="line">The float is: 15.500000</span><br><span class="line">The string is: Chris</span><br><span class="line">&amp;&#123;10 15.5 Chris&#125;</span><br></pre></td></tr></table></figure><p>就像在面向对象语言所作的那样，可以使用点号符给字段赋值：structname.fieldname = value。</p><p>同样的，使用点号符可以获取结构体字段的值：structname.fieldname。</p><p>在 Go 语言中这叫 选择器（selector）。无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的 <strong>选择器符（selector-notation）</strong> 来引用结构体的字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type myStruct struct &#123; i int &#125;</span><br><span class="line">var v myStruct    &#x2F;&#x2F; v是结构体类型变量</span><br><span class="line">var p *myStruct   &#x2F;&#x2F; p是指向一个结构体类型变量的指针</span><br><span class="line">v.i</span><br><span class="line">p.i</span><br></pre></td></tr></table></figure><h3 id="1）初始化一个结构体"><a href="#1）初始化一个结构体" class="headerlink" title="1）初始化一个结构体"></a>1）初始化一个结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此时ms的类型是 *struct1</span><br><span class="line">ms :&#x3D; &amp;struct1&#123;10, 15.5, &quot;Chris&quot;&#125;</span><br><span class="line"></span><br><span class="line">var ms struct1</span><br><span class="line">ms &#x3D; struct1&#123;10, 15.5, &quot;Chris&quot;&#125;</span><br></pre></td></tr></table></figure><p>混合字面量语法（composite literal syntax）&amp;struct1{a, b, c} 是一种简写，底层仍然会调用 new ()，这里值的顺序必须按照字段顺序来写。</p><p>表达式 new(Type) 和 &amp;Type{} 是等价的。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Interval struct &#123;</span><br><span class="line">    start int</span><br><span class="line">    end   int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">初始化方式：</span><br><span class="line"></span><br><span class="line">intr :&#x3D; Interval&#123;0, 3&#125;            (A)</span><br><span class="line">intr :&#x3D; Interval&#123;end:5, start:1&#125;  (B)</span><br><span class="line">intr :&#x3D; Interval&#123;end:5&#125;           (C)</span><br></pre></td></tr></table></figure><h3 id="2）结构体类型的内存布局"><a href="#2）结构体类型的内存布局" class="headerlink" title="2）结构体类型的内存布局"></a>2）结构体类型的内存布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Point struct &#123; x, y int &#125;</span><br></pre></td></tr></table></figure><p>使用 new 初始化：</p><p><img src="/img/image/blog/20220604/%E4%BD%BF%E7%94%A8new%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="使用new初始化"></p><p>作为结构体字面量初始化：</p><p><img src="/img/image/blog/20220604/%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="作为结构体字面量初始化"></p><h4 id="3）三种不同的调用方式"><a href="#3）三种不同的调用方式" class="headerlink" title="3）三种不同的调用方式"></a>3）三种不同的调用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    firstName   string</span><br><span class="line">    lastName    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func upPerson(p *Person) &#123;</span><br><span class="line">    p.firstName &#x3D; strings.ToUpper(p.firstName)</span><br><span class="line">    p.lastName &#x3D; strings.ToUpper(p.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1-struct as a value type:</span><br><span class="line">    var pers1 Person</span><br><span class="line">    pers1.firstName &#x3D; &quot;Chris&quot;</span><br><span class="line">    pers1.lastName &#x3D; &quot;Woodward&quot;</span><br><span class="line">    upPerson(&amp;pers1)</span><br><span class="line">    fmt.Printf(&quot;The name of the person is %s %s\n&quot;, pers1.firstName, pers1.lastName)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2—struct as a pointer:</span><br><span class="line">    pers2 :&#x3D; new(Person)</span><br><span class="line">    pers2.firstName &#x3D; &quot;Chris&quot;</span><br><span class="line">    pers2.lastName &#x3D; &quot;Woodward&quot;</span><br><span class="line">    (*pers2).lastName &#x3D; &quot;Woodward&quot;  &#x2F;&#x2F; 这是合法的</span><br><span class="line">    upPerson(pers2)</span><br><span class="line">    fmt.Printf(&quot;The name of the person is %s %s\n&quot;, pers2.firstName, pers2.lastName)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3—struct as a literal:</span><br><span class="line">    pers3 :&#x3D; &amp;Person&#123;&quot;Chris&quot;,&quot;Woodward&quot;&#125;</span><br><span class="line">    upPerson(pers3)</span><br><span class="line">    fmt.Printf(&quot;The name of the person is %s %s\n&quot;, pers3.firstName, pers3.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">The name of the person is CHRIS WOODWARD</span><br><span class="line">The name of the person is CHRIS WOODWARD</span><br><span class="line">The name of the person is CHRIS WOODWARD</span><br></pre></td></tr></table></figure><h3 id="4）结构体转换"><a href="#4）结构体转换" class="headerlink" title="4）结构体转换"></a>4）结构体转换</h3><p>Go 中的类型转换遵循严格的规则。当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型，它们可以互相转换，同时需要注意其中非法赋值或转换引起的编译错误。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type number struct &#123;</span><br><span class="line">    f float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type nr number   &#x2F;&#x2F; alias type</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a :&#x3D; number&#123;5.0&#125;</span><br><span class="line">    b :&#x3D; nr&#123;5.0&#125;</span><br><span class="line">    &#x2F;&#x2F; var i float32 &#x3D; b   &#x2F;&#x2F; compile-error: cannot use b (type nr) as type float32 in assignment</span><br><span class="line">    &#x2F;&#x2F; var i &#x3D; float32(b)  &#x2F;&#x2F; compile-error: cannot convert b (type nr) to type float32</span><br><span class="line">    &#x2F;&#x2F; var c number &#x3D; b    &#x2F;&#x2F; compile-error: cannot use b (type nr) as type number in assignment</span><br><span class="line">    &#x2F;&#x2F; needs a conversion:</span><br><span class="line">    var c &#x3D; number(b)</span><br><span class="line">    fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123;5&#125; &#123;5&#125; &#123;5&#125;</span><br></pre></td></tr></table></figure><h3 id="5）使用工厂方法创建结构体实例"><a href="#5）使用工厂方法创建结构体实例" class="headerlink" title="5）使用工厂方法创建结构体实例"></a>5）使用工厂方法创建结构体实例</h3><p>Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂” 方法。为了方便通常会为类型定义一个工厂，按惯例，工厂的名字以 new 或 New 开头。假设定义了如下的 File 结构体类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type File struct &#123;</span><br><span class="line">    fd      int     &#x2F;&#x2F; 文件描述符</span><br><span class="line">    name    string  &#x2F;&#x2F; 文件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是这个结构体类型对应的工厂方法，它返回一个指向结构体实例的指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func NewFile(fd int, name string) *File &#123;</span><br><span class="line">    if fd &lt; 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &amp;File&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这样调用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f :&#x3D; NewFile(10, &quot;.&#x2F;test.txt&quot;)</span><br></pre></td></tr></table></figure><p>在 Go 语言中常常像上面这样在工厂方法里使用初始化来简便的实现构造函数。</p><p>如果 File 是一个结构体类型，那么表达式 new(File) 和 &amp;File{} 是等价的。</p><p>我们可以说是工厂实例化了类型的一个对象，就像在基于类的 OOP 语言中那样。</p><p>如果想知道结构体类型 T 的一个实例占用了多少内存，可以使用：size := unsafe.Sizeof(T{})。</p><h3 id="5）如何强制使用工厂方法"><a href="#5）如何强制使用工厂方法" class="headerlink" title="5）如何强制使用工厂方法"></a>5）如何强制使用工厂方法</h3><p>通过应用可见性规则就可以禁止使用 new 函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package factory</span><br><span class="line"></span><br><span class="line">type matrix struct &#123;</span><br><span class="line">id   int</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMatrix(id int, name string) *matrix &#123;</span><br><span class="line">m :&#x3D; matrix&#123;id, name&#125;</span><br><span class="line">return &amp;m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在其他包里使用工厂方法：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;test1&#x2F;main&#x2F;factory&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F;wrong :&#x3D; new(matrix.matrix)     &#x2F;&#x2F; 编译失败（matrix 是私有的）</span><br><span class="line">right :&#x3D; factory.NewMatrix(1, &quot;tst&quot;) &#x2F;&#x2F; 实例化 matrix 的唯一方式</span><br><span class="line"></span><br><span class="line">fmt.Println(right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面的例子说明了在映射上使用 new 和 make 的区别以及可能发生的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Foo map[string]string</span><br><span class="line">type Bar struct &#123;</span><br><span class="line">    thingOne string</span><br><span class="line">    thingTwo int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; OK</span><br><span class="line">    y :&#x3D; new(Bar)</span><br><span class="line">    (*y).thingOne &#x3D; &quot;hello&quot;</span><br><span class="line">    (*y).thingTwo &#x3D; 1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; NOT OK</span><br><span class="line">    z :&#x3D; make(Bar) &#x2F;&#x2F; 编译错误：cannot make type Bar</span><br><span class="line">    (*z).thingOne &#x3D; &quot;hello&quot;</span><br><span class="line">    (*z).thingTwo &#x3D; 1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; OK</span><br><span class="line">    x :&#x3D; make(Foo)</span><br><span class="line">    x[&quot;x&quot;] &#x3D; &quot;goodbye&quot;</span><br><span class="line">    x[&quot;y&quot;] &#x3D; &quot;world&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; NOT OK</span><br><span class="line">    u :&#x3D; new(Foo)</span><br><span class="line">    (*u)[&quot;x&quot;] &#x3D; &quot;goodbye&quot; &#x2F;&#x2F; 运行时错误!! panic: assignment to entry in nil map</span><br><span class="line">    (*u)[&quot;y&quot;] &#x3D; &quot;world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试图 make() 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 new() 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 new(Foo) 返回的是一个指向 nil 的指针，它尚未被分配内存。所以在使用 map 时要特别谨慎。</p><h3 id="6）带标签的结构体"><a href="#6）带标签的结构体" class="headerlink" title="6）带标签的结构体"></a>6）带标签的结构体</h3><p>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type TagType struct &#123; &#x2F;&#x2F; tags</span><br><span class="line">    field1 bool   &quot;An important answer&quot;</span><br><span class="line">    field2 string &quot;The name of the thing&quot;</span><br><span class="line">    field3 int    &quot;How much there are&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    tt :&#x3D; TagType&#123;true, &quot;Barak Obama&quot;, 1&#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 3; i++ &#123;</span><br><span class="line">        refTag(tt, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func refTag(tt TagType, ix int) &#123;</span><br><span class="line">    ttType :&#x3D; reflect.TypeOf(tt)</span><br><span class="line">    ixField :&#x3D; ttType.Field(ix)</span><br><span class="line">    fmt.Printf(&quot;%v\n&quot;, ixField.Tag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">An important answer</span><br><span class="line">The name of the thing</span><br><span class="line">How much there are</span><br></pre></td></tr></table></figure><h3 id="7）匿名字段和内嵌结构体"><a href="#7）匿名字段和内嵌结构体" class="headerlink" title="7）匿名字段和内嵌结构体"></a>7）匿名字段和内嵌结构体</h3><p>结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type innerS struct &#123;</span><br><span class="line">in1 int</span><br><span class="line">in2 int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type outerS struct &#123;</span><br><span class="line">b      int</span><br><span class="line">c      float32</span><br><span class="line">int    &#x2F;&#x2F; anonymous field</span><br><span class="line">innerS &#x2F;&#x2F;anonymous field</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">outer :&#x3D; new(outerS)</span><br><span class="line">outer.b &#x3D; 6</span><br><span class="line">outer.c &#x3D; 7.5</span><br><span class="line">outer.int &#x3D; 60</span><br><span class="line">outer.in1 &#x3D; 5</span><br><span class="line">outer.in2 &#x3D; 10</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;outer.b is: %d\n&quot;, outer.b)</span><br><span class="line">fmt.Printf(&quot;outer.c is: %f\n&quot;, outer.c)</span><br><span class="line">fmt.Printf(&quot;outer.int is: %d\n&quot;, outer.int)</span><br><span class="line">fmt.Printf(&quot;outer.in1 is: %d\n&quot;, outer.in1)</span><br><span class="line">fmt.Printf(&quot;outer.in2 is: %d\n&quot;, outer.in2)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用结构体字面量</span><br><span class="line">outer2 :&#x3D; outerS&#123;6, 7.5, 60, innerS&#123;5, 10&#125;&#125;</span><br><span class="line">fmt.Println(&quot;outer2 is:&quot;, outer2)</span><br><span class="line">fmt.Println(&quot;outer2.innerS is:&quot;, outer2.innerS)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">outer.b is: 6</span><br><span class="line">outer.c is: 7.500000</span><br><span class="line">outer.int is: 60</span><br><span class="line">outer.in1 is: 5</span><br><span class="line">outer.in2 is: 10</span><br><span class="line">outer2 is: &#123;6 7.5 60 &#123;5 10&#125;&#125;</span><br><span class="line">outer2.innerS is: &#123;5 10&#125;</span><br></pre></td></tr></table></figure><p>通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：<strong>在一个结构体中对于每一种数据类型只能有一个匿名字段。</strong></p><h3 id="8）命名冲突"><a href="#8）命名冲突" class="headerlink" title="8）命名冲突"></a>8）命名冲突</h3><p>当两个字段拥有相同的名字（可能是继承来的名字）时该怎么办呢？</p><ul><li>外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；</li><li>如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。</li></ul><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type A struct&#123; a int &#125;</span><br><span class="line">type B struct&#123; a, b int &#125;</span><br><span class="line">type D struct &#123;</span><br><span class="line">B</span><br><span class="line">b int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type C struct &#123;</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c :&#x3D; C&#123;A&#123;1&#125;, B&#123;2, 3&#125;&#125;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(c.a) &#x2F;&#x2F; ambiguous selector c.a 编译错误</span><br><span class="line">fmt.Println(c.A.a)</span><br><span class="line">d :&#x3D; D&#123;B&#123;1, 3&#125;, 2&#125;</span><br><span class="line">fmt.Println(d.b) &#x2F;&#x2F; 这个是允许的，会加载 D.b</span><br><span class="line">fmt.Println(d.B.b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h2><p>Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。</p><p>定义方法的一般格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (recv receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">recv 就像是面向对象语言中的 this 或 self，但是 Go 中并没有这两个关键字。随个人喜好，你可以使用 this 或 self 作为 receiver 的名字。</span><br></pre></td></tr></table></figure><p>接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。</p><p>但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：invalid receiver type…。</p><p>最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。</p><p><strong>一个类型加上它的方法等价于面向对象中的一个类。</strong></p><p>一个重要的区别是：在 Go 中，<strong>类型的代码</strong> 和绑定在它上面的 <strong>方法的代码</strong> 可以不放置在一起，它们 <strong>可以存在在不同的源文件</strong>，唯一的要求是： <strong>它们必须是同一个包的。</strong></p><p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (a *denseMatrix) Add(b Matrix) Matrix</span><br><span class="line">func (a *sparseMatrix) Add(b Matrix) Matrix</span><br></pre></td></tr></table></figure><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type TwoInts struct &#123;</span><br><span class="line">a int</span><br><span class="line">b int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AddThem 结构体上的简单方法的例子</span><br><span class="line">func (tn *TwoInts) AddThem() int &#123;</span><br><span class="line">return tn.a + tn.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AddToParam 结构体上的简单方法的例子</span><br><span class="line">func (tn *TwoInts) AddToParam(param int) int &#123;</span><br><span class="line">return tn.a + tn.b + param</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IntVector []int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sum 非结构体类型上方法的例子</span><br><span class="line">func (v IntVector) Sum() (s int) &#123;</span><br><span class="line">for _, x :&#x3D; range v &#123;</span><br><span class="line">s +&#x3D; x</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">two1 :&#x3D; new(TwoInts)</span><br><span class="line">two1.a &#x3D; 12</span><br><span class="line">two1.b &#x3D; 10</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;The sum is: %d\n&quot;, two1.AddThem())</span><br><span class="line">fmt.Printf(&quot;Add them to the param: %d\n&quot;, two1.AddToParam(20))</span><br><span class="line"></span><br><span class="line">two2 :&#x3D; TwoInts&#123;3, 4&#125;</span><br><span class="line">fmt.Printf(&quot;The sum is: %d\n&quot;, two2.AddThem())</span><br><span class="line"></span><br><span class="line">fmt.Println(IntVector&#123;1, 2, 3&#125;.Sum()) &#x2F;&#x2F; 输出是6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;container&#x2F;list&quot;</span><br><span class="line"></span><br><span class="line">func (p *list.List) Iter() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    lst :&#x3D; new(list.List)</span><br><span class="line">    for _&#x3D; range lst.Iter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译错误：cannot define new methods on non-local type list.List</span><br></pre></td></tr></table></figure><p><strong>类型和作用在它上面定义的方法必须在同一个包里定义，这就是为什么不能在 int、float 或类似这些的类型上定义方法。</strong></p><p>但是有一个间接的方式：可以先定义该类型（比如：int 或 float）的别名类型，然后再为别名类型定义方法。或者像下面这样将它作为匿名类型嵌入在一个新的结构体中。当然方法只在这个别名类型上有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type myTime struct &#123;</span><br><span class="line">time.Time &#x2F;&#x2F;anonymous field</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t myTime) first3Chars() string &#123;</span><br><span class="line">return t.Time.String()[0:3]</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">m :&#x3D; myTime&#123;time.Now()&#125;</span><br><span class="line">&#x2F;&#x2F; 调用匿名Time上的String方法</span><br><span class="line">fmt.Println(&quot;Full time now:&quot;, m.String())</span><br><span class="line">&#x2F;&#x2F; 调用myTime.first3Chars</span><br><span class="line">fmt.Println(&quot;First 3 chars:&quot;, m.first3Chars())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Full time now: 2022-06-09 14:09:56.3957554 +0800 CST m&#x3D;+0.025340201</span><br><span class="line">First 3 chars: 202</span><br></pre></td></tr></table></figure><h3 id="1）函数和方法的区别"><a href="#1）函数和方法的区别" class="headerlink" title="1）函数和方法的区别"></a>1）函数和方法的区别</h3><p>函数将变量作为参数：Function1(recv)</p><p>方法在变量上被调用：recv.Method1()</p><p>在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。</p><p>不要忘记 Method1 后边的括号 ()，否则会引发编译器错误：method recv.Method1 is not an expression, must be called</p><p>接收者必须有一个显式的名字，这个名字必须在方法中被使用。</p><p>receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。</p><p>在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。</p><p>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</p><h3 id="2）指针或值作为接收者"><a href="#2）指针或值作为接收者" class="headerlink" title="2）指针或值作为接收者"></a>2）指针或值作为接收者</h3><p>鉴于性能的原因，recv 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。</p><p>如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type B struct &#123;</span><br><span class="line">    thing int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *B) change() &#123; b.thing &#x3D; 1 &#125;</span><br><span class="line"></span><br><span class="line">func (b B) write() string &#123; return fmt.Sprint(b) &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var b1 B &#x2F;&#x2F; b1是值</span><br><span class="line">    b1.change()</span><br><span class="line">    fmt.Println(b1.write())</span><br><span class="line"></span><br><span class="line">    b2 :&#x3D; new(B) &#x2F;&#x2F; b2是指针</span><br><span class="line">    b2.change()</span><br><span class="line">    fmt.Println(b2.write())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&#123;1&#125;</span><br><span class="line">&#123;1&#125;</span><br></pre></td></tr></table></figure><p>指针方法和值方法都可以在指针或非指针上被调用。</p><p>如下面程序所示，类型 List 在值上有一个方法 Len()，在指针上有一个方法 Append()，但是可以看到两个方法都可以在两种类型的变量上被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type List []int</span><br><span class="line"></span><br><span class="line">func (l List) Len() int        &#123; return len(l) &#125;</span><br><span class="line">func (l *List) Append(val int) &#123; *l &#x3D; append(*l, val) &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    var lst List</span><br><span class="line">    lst.Append(1)</span><br><span class="line">    fmt.Printf(&quot;%v (len: %d)&quot;, lst, lst.Len()) &#x2F;&#x2F; [1] (len: 1)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针</span><br><span class="line">    plst :&#x3D; new(List)</span><br><span class="line">    plst.Append(2)</span><br><span class="line">    fmt.Printf(&quot;%v (len: %d)&quot;, plst, plst.Len()) &#x2F;&#x2F; &amp;[2] (len: 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）方法和未导出字段"><a href="#3）方法和未导出字段" class="headerlink" title="3）方法和未导出字段"></a>3）方法和未导出字段</h3><p>如果类型 Person 被明确的导出了，但是它的字段没有被导出。则 p.firstName 就是错误的。该如何在另一个程序中修改或者只是读取一个 Person 的名字呢？</p><p>这可以通过面向对象语言一个众所周知的技术来完成：提供 getter 和 setter 方法。对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名。</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package person</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    firstName string</span><br><span class="line">    lastName  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) FirstName() string &#123;</span><br><span class="line">    return p.firstName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) SetFirstName(newName string) &#123;</span><br><span class="line">    p.firstName &#x3D; newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;.&#x2F;person&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p :&#x3D; new(person.Person)</span><br><span class="line">    &#x2F;&#x2F; p.firstName undefined</span><br><span class="line">    &#x2F;&#x2F; (cannot refer to unexported field or method firstName)</span><br><span class="line">    &#x2F;&#x2F; p.firstName &#x3D; &quot;Eric&quot;</span><br><span class="line">    p.SetFirstName(&quot;Eric&quot;)</span><br><span class="line">    fmt.Println(p.FirstName()) &#x2F;&#x2F; Output: Eric</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）内嵌类型的方法和继承"><a href="#4）内嵌类型的方法和继承" class="headerlink" title="4）内嵌类型的方法和继承"></a>4）内嵌类型的方法和继承</h3><p>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法：将父类型放在子类型中来实现亚型。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果，也类似 Ruby 中的混入（mixin）。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Point struct &#123;</span><br><span class="line">    x, y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Point) Abs() float64 &#123;</span><br><span class="line">    return math.Sqrt(p.x*p.x + p.y*p.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type NamedPoint struct &#123;</span><br><span class="line">    Point</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    n :&#x3D; &amp;NamedPoint&#123;Point&#123;3, 4&#125;, &quot;Pythagoras&quot;&#125;</span><br><span class="line">    fmt.Println(n.Abs()) &#x2F;&#x2F; 打印5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法 “晋升” 成为了外层类型的方法。</p><p>当然类型可以有只作用于本身实例而不作用于内嵌 “父” 类型上的方法，可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。</p><p>基于上面的代码，加上如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (n *NamedPoint) Abs() float64 &#123;</span><br><span class="line">    return n.Point.Abs() * 100.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在 fmt.Println(n.Abs()) 会打印 500。</span><br></pre></td></tr></table></figure><p><strong>结构体内嵌和自己在同一个包中的结构体时，可以彼此访问对方所有的字段和方法。</strong></p><h3 id="5）如何在类型中嵌入功能"><a href="#5）如何在类型中嵌入功能" class="headerlink" title="5）如何在类型中嵌入功能"></a>5）如何在类型中嵌入功能</h3><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Log struct &#123;</span><br><span class="line">msg string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Customer struct &#123;</span><br><span class="line">Name string</span><br><span class="line">log  *Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; shorter</span><br><span class="line">c :&#x3D; &amp;Customer&#123;&quot;Barak Obama&quot;, &amp;Log&#123;&quot;1 - Yes we can!&quot;&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; fmt.Println(c) &amp;&#123;Barak Obama 1 - Yes we can!&#125;</span><br><span class="line">c.Log().Add(&quot;2 - After me the world will be a better place!&quot;)</span><br><span class="line">&#x2F;&#x2F;fmt.Println(c.log)</span><br><span class="line">fmt.Println(c.Log())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *Log) Add(s string) &#123;</span><br><span class="line">l.msg +&#x3D; &quot;\n&quot; + s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *Log) String() string &#123;</span><br><span class="line">return l.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Customer) Log() *Log &#123;</span><br><span class="line">return c.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">1 - Yes we can!</span><br><span class="line">2 - After me the world will be a better place!</span><br></pre></td></tr></table></figure><h3 id="6）多重继承"><a href="#6）多重继承" class="headerlink" title="6）多重继承"></a>6）多重继承</h3><p>多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++ 和 Python 例外）。</p><p>因为在类继承层次中，多重继承会给编译器引入额外的复杂度。</p><p>但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。</p><p>作为一个例子，假设有一个类型 CameraPhone，通过它可以 Call()，也可以 TakeAPicture()，但是第一个方法属于类型 Phone，第二个方法属于类型 Camera。</p><p>只要嵌入这两个类型就可以解决问题，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Camera struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c *Camera) TakeAPicture() string &#123;</span><br><span class="line">    return &quot;Click&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Phone struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (p *Phone) Call() string &#123;</span><br><span class="line">    return &quot;Ring Ring&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CameraPhone struct &#123;</span><br><span class="line">    Camera</span><br><span class="line">    Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    cp :&#x3D; new(CameraPhone)</span><br><span class="line">    fmt.Println(&quot;Our new CameraPhone exhibits multiple behaviors...&quot;)</span><br><span class="line">    fmt.Println(&quot;It exhibits behavior of a Camera: &quot;, cp.TakeAPicture())</span><br><span class="line">    fmt.Println(&quot;It works like a Phone too: &quot;, cp.Call())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Our new CameraPhone exhibits multiple behaviors...</span><br><span class="line">It exhibits behavior of a Camera:  Click</span><br><span class="line">It works like a Phone too:  Ring Ring</span><br></pre></td></tr></table></figure><h3 id="7）类型的-String-方法和格式化描述符"><a href="#7）类型的-String-方法和格式化描述符" class="headerlink" title="7）类型的 String() 方法和格式化描述符"></a>7）类型的 String() 方法和格式化描述符</h3><p>如果类型定义了 String() 方法，它会被用在 fmt.Printf() 中生成默认的输出：等同于使用格式化描述符 %v 产生的输出。还有 fmt.Print() 和 fmt.Println() 也会自动使用 String() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type TwoInts struct &#123;</span><br><span class="line">    a int</span><br><span class="line">    b int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    two1 :&#x3D; new(TwoInts)</span><br><span class="line">    two1.a &#x3D; 12</span><br><span class="line">    two1.b &#x3D; 10</span><br><span class="line">    fmt.Printf(&quot;two1 is: %v\n&quot;, two1)</span><br><span class="line">    fmt.Println(&quot;two1 is:&quot;, two1)</span><br><span class="line">    fmt.Printf(&quot;two1 is: %T\n&quot;, two1)</span><br><span class="line">    fmt.Printf(&quot;two1 is: %#v\n&quot;, two1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (tn *TwoInts) String() string &#123;</span><br><span class="line">    return &quot;(&quot; + strconv.Itoa(tn.a) + &quot;&#x2F;&quot; + strconv.Itoa(tn.b) + &quot;)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">two1 is: (12&#x2F;10)</span><br><span class="line">two1 is: (12&#x2F;10)</span><br><span class="line">two1 is: *main.TwoInts</span><br><span class="line">two1 is: &amp;main.TwoInts&#123;a:12, b:10&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子也可以看到，格式化描述符 %T 会给出类型的完全规格，%#v 会给出实例的完整输出，包括它的字段。</p><p>注意：<strong>不要在 String() 方法里面调用涉及 String() 方法的方法，它会导致意料之外的错误</strong></p><p>比如下面的例子，它导致了一个无限迭代（递归）调用（TT.String() 调用 fmt.Sprintf，而 fmt.Sprintf 又会反过来调用 TT.String()…），很快就会导致内存溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type TT float64</span><br><span class="line"></span><br><span class="line">func (t TT) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;%v&quot;, t)</span><br><span class="line">&#125;</span><br><span class="line">t. String()</span><br></pre></td></tr></table></figure><h3 id="8）垃圾回收和-SetFinalizer"><a href="#8）垃圾回收和-SetFinalizer" class="headerlink" title="8）垃圾回收和 SetFinalizer"></a>8）垃圾回收和 SetFinalizer</h3><p>Go 开发者不需要写代码来释放程序中不再使用的变量和结构占用的内存，在 Go 运行时中有一个独立的进程，即垃圾收集器（GC），会处理这些事情，它搜索不再使用的变量然后释放它们的内存。</p><p>通过调用 runtime.GC() 函数可以显式的触发 GC，但这只在某些罕见的场景下才有用，比如当内存资源不足时调用 runtime.GC()，它会在此函数执行的点上立即释放一大片内存，此时程序可能会有短时的性能下降（因为 GC 进程在执行）。</p><p>如果想知道当前的内存状态，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;m)</span><br><span class="line">fmt.Printf(&quot;%d Kb\n&quot;, m.Alloc &#x2F; 1024)</span><br></pre></td></tr></table></figure><p>如果需要在一个对象 obj 被从内存移除前执行一些特殊操作，比如写到日志文件中，可以通过如下方式调用函数来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.SetFinalizer(obj, func(obj *typeObj))</span><br></pre></td></tr></table></figure><h2 id="六、接口"><a href="#六、接口" class="headerlink" title="六、接口"></a>六、接口</h2><p>接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。</p><p>通过如下格式定义接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Namer interface &#123;</span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点如下：</p><ul><li>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。</li><li>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</li><li>一个类型可以实现多个接口。</li><li>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</li></ul><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Shaper interface &#123;</span><br><span class="line">    Area() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">    side float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sq *Square) Area() float32 &#123;</span><br><span class="line">    return sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    sq1 :&#x3D; new(Square)</span><br><span class="line">    sq1.side &#x3D; 5</span><br><span class="line"></span><br><span class="line">    var areaIntf Shaper</span><br><span class="line">    areaIntf &#x3D; sq1</span><br><span class="line">    &#x2F;&#x2F; shorter,without separate declaration:</span><br><span class="line">    &#x2F;&#x2F; areaIntf :&#x3D; Shaper(sq1)</span><br><span class="line">    &#x2F;&#x2F; or even:</span><br><span class="line">    &#x2F;&#x2F; areaIntf :&#x3D; sq1</span><br><span class="line">    fmt.Printf(&quot;The square has area: %f\n&quot;, areaIntf.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The square has area: 25.000000</span><br></pre></td></tr></table></figure><p>现在接口变量包含一个指向 Square 变量的引用，通过它可以调用 Square 上的方法 Area()。</p><p>当然也可以直接在 Square 的实例上调用此方法，但是在接口实例上调用此方法更令人兴奋，它使此方法更具有一般性。接口变量里包含了接收者实例的值和指向对应方法表的指针。</p><p>如果 Square 没有实现 Area() 方法，编译器将会给出清晰的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use sq1 (type *Square) as type Shaper in assignment:</span><br><span class="line">*Square does not implement Shaper (missing Area method)</span><br></pre></td></tr></table></figure><p>如果 Shaper 有另外一个方法 Perimeter()，但是 Square 没有实现它，即使没有人在 Square 实例上调用这个方法，编译器也会给出上面同样的错误。</p><h3 id="1）接口命名"><a href="#1）接口命名" class="headerlink" title="1）接口命名"></a>1）接口命名</h3><p>接口的名字由方法名加 er 后缀组成，例如 Printer、Reader、Writer、Logger、Converter 等等。</p><p>还有一些不常用的方式（当后缀 er 不合适时），比如 Recoverable，此时接口名以 able 结尾，或者以 I 开头（像 .NET 或 Java 中那样）。</p><h3 id="2）接口值"><a href="#2）接口值" class="headerlink" title="2）接口值"></a>2）接口值</h3><p>不像大多数面向对象编程语言，在 Go 语言中接口可以有值，一个接口类型的变量或一个接口值 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ai Namer</span><br><span class="line"></span><br><span class="line">ai 是一个多字（multiword）数据结构，它的值是 nil。它本质上是一个指针。</span><br><span class="line"></span><br><span class="line">指向接口值的指针是非法的，它们不仅一点用也没有，还会导致代码错误。</span><br></pre></td></tr></table></figure><h3 id="3）多态"><a href="#3）多态" class="headerlink" title="3）多态"></a>3）多态</h3><p>多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Shaper interface &#123;</span><br><span class="line">Area() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">side float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sq *Square) Area() float32 &#123;</span><br><span class="line">return sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">length, width float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Rectangle) Area() float32 &#123;</span><br><span class="line">return r.length * r.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">rectangle :&#x3D; Rectangle&#123;3, 5&#125;</span><br><span class="line">square :&#x3D; &amp;Square&#123;5&#125;</span><br><span class="line"></span><br><span class="line">shapers :&#x3D; []Shaper&#123;rectangle, square&#125;</span><br><span class="line"></span><br><span class="line">for _, shaper :&#x3D; range shapers &#123;</span><br><span class="line">fmt.Println(&quot;Shape details:&quot;, shaper)</span><br><span class="line">fmt.Println(&quot;Area of this shape is:&quot;, shaper.Area())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Shape details: &#123;3 5&#125;</span><br><span class="line">Area of this shape is: 15</span><br><span class="line">Shape details: &amp;&#123;5&#125;</span><br><span class="line">Area of this shape is: 25</span><br></pre></td></tr></table></figure><h3 id="4）接口嵌套接口"><a href="#4）接口嵌套接口" class="headerlink" title="4）接口嵌套接口"></a>4）接口嵌套接口</h3><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type ReadWrite interface &#123;</span><br><span class="line">    Read(b Buffer) bool</span><br><span class="line">    Write(b Buffer) bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Lock interface &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type File interface &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）类型断言：如何检测和转换接口变量的类型"><a href="#5）类型断言：如何检测和转换接口变量的类型" class="headerlink" title="5）类型断言：如何检测和转换接口变量的类型"></a>5）类型断言：如何检测和转换接口变量的类型</h3><p>一个接口类型的变量 varI 中可以包含任何类型的值，必须有一种方式来检测它的 <strong>动态</strong> 类型，即运行时在变量中存储的值的实际类型。</p><p>通常我们可以使用 类型断言 来测试在某个时刻 varI 是否包含类型 T 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v :&#x3D; varI.(T)       &#x2F;&#x2F; unchecked type assertion</span><br><span class="line"></span><br><span class="line">if v, ok :&#x3D; varI.(T); ok &#123;  &#x2F;&#x2F; checked type assertion</span><br><span class="line">    Process(v)</span><br><span class="line">    return</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; varI is not of type T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>varI 必须是一个接口变量，否则编译器会报错：invalid type assertion: varI.(T) (non-interface type (type of varI) on left) 。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Shaper interface &#123;</span><br><span class="line">Area() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">side float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Circle struct &#123;</span><br><span class="line">radius float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sq *Square) Area() float32 &#123;</span><br><span class="line">return sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ci *Circle) Area() float32 &#123;</span><br><span class="line">return ci.radius * ci.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var areaIntf Shaper</span><br><span class="line">sq1 :&#x3D; new(Square)</span><br><span class="line">sq1.side &#x3D; 5</span><br><span class="line"></span><br><span class="line">areaIntf &#x3D; sq1</span><br><span class="line">&#x2F;&#x2F; Is Square the type of areaIntf?</span><br><span class="line">if t, ok :&#x3D; areaIntf.(*Square); ok &#123;</span><br><span class="line">fmt.Printf(&quot;The type of areaIntf is: %T\n&quot;, t)</span><br><span class="line">&#125;</span><br><span class="line">if u, ok :&#x3D; areaIntf.(*Circle); ok &#123;</span><br><span class="line">fmt.Printf(&quot;The type of areaIntf is: %T\n&quot;, u)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;areaIntf does not contain a variable of type Circle&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The type of areaIntf is: *main.Square</span><br><span class="line">areaIntf does not contain a variable of type Circle</span><br></pre></td></tr></table></figure><h3 id="5）类型判断：type-switch"><a href="#5）类型判断：type-switch" class="headerlink" title="5）类型判断：type-switch"></a>5）类型判断：type-switch</h3><p>接口变量的类型也可以使用一种特殊形式的 switch 来检测：type-switch。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func classifier(items ...interface&#123;&#125;) &#123;</span><br><span class="line">for i, x :&#x3D; range items &#123;</span><br><span class="line">switch x.(type) &#123;</span><br><span class="line">case bool:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a bool\n&quot;, i)</span><br><span class="line">case float64:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a float64\n&quot;, i)</span><br><span class="line">case int, int64:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a int\n&quot;, i)</span><br><span class="line">case nil:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a nil\n&quot;, i)</span><br><span class="line">case string:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a string\n&quot;, i)</span><br><span class="line">default:</span><br><span class="line">fmt.Printf(&quot;Param #%d is unknown\n&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">classifier(13, -14.3, &quot;BELGIUM&quot;, complex(1, 2), nil, false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6）测试一个值是否实现了某个接口"><a href="#6）测试一个值是否实现了某个接口" class="headerlink" title="6）测试一个值是否实现了某个接口"></a>6）测试一个值是否实现了某个接口</h3><p>假定 v 是一个值，然后我们想测试它是否实现了 Stringer 接口，可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Stringer interface &#123;</span><br><span class="line">String() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">st string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *Square) String() string &#123;</span><br><span class="line">return s.st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var v Stringer &#x3D; &amp;Square&#123;&quot;value&quot;&#125;</span><br><span class="line">if sv, ok :&#x3D; v.(Stringer); ok &#123;</span><br><span class="line">fmt.Printf(&quot;v implements String(): %s\n&quot;, sv.String()) &#x2F;&#x2F; note: sv, not v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7）使用方法集与接口"><a href="#7）使用方法集与接口" class="headerlink" title="7）使用方法集与接口"></a>7）使用方法集与接口</h3><p>作用于变量上的方法实际上是不区分变量到底是指针还是值的。</p><p>当碰到接口类型值时，这会变得有点复杂，原因是接口变量中存储的具体值是不可寻址的。</p><p>参考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type List []int</span><br><span class="line"></span><br><span class="line">func (l List) Len() int &#123;</span><br><span class="line">return len(l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *List) Append(val int) &#123;</span><br><span class="line">*l &#x3D; append(*l, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Appender interface &#123;</span><br><span class="line">Append(int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CountInto(a Appender, start, end int) &#123;</span><br><span class="line">for i :&#x3D; start; i &lt;&#x3D; end; i++ &#123;</span><br><span class="line">a.Append(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Lener interface &#123;</span><br><span class="line">Len() int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func LongEnough(l Lener) bool &#123;</span><br><span class="line">return l.Len()*10 &gt; 42</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; A bare value</span><br><span class="line">var lst List</span><br><span class="line">&#x2F;&#x2F; compiler error:</span><br><span class="line">&#x2F;&#x2F; cannot use lst (type List) as type Appender in argument to CountInto:</span><br><span class="line">&#x2F;&#x2F;       List does not implement Appender (Append method has pointer receiver)</span><br><span class="line">&#x2F;&#x2F; CountInto(lst, 1, 10)</span><br><span class="line">if LongEnough(lst) &#123; &#x2F;&#x2F; VALID:Identical receiver type</span><br><span class="line">fmt.Printf(&quot;- lst is long enough\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A pointer value</span><br><span class="line">plst :&#x3D; new(List)</span><br><span class="line">CountInto(plst, 1, 10) &#x2F;&#x2F;VALID:Identical receiver type</span><br><span class="line">if LongEnough(plst) &#123;</span><br><span class="line">&#x2F;&#x2F; VALID: a *List can be dereferenced for the receiver</span><br><span class="line">fmt.Printf(&quot;- plst is long enough\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 lst 上调用 CountInto 时会导致一个编译器错误，因为 CountInto 需要一个 Appender，而它的方法 Append 只定义在指针上。 在 lst 上调用 LongEnough 是可以的因为 ‘Len’ 定义在值上。</p><p>在 plst 上调用 CountInto 是可以的，因为 CountInto 需要一个 Appender，并且它的方法 Append 定义在指针上。 在 plst 上调用 LongEnough 也是可以的，因为指针会被自动解引用。</p><p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p><p>总结：</p><p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的：</p><ul><li>指针方法可以通过指针调用</li><li>值方法可以通过值调用</li><li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul><p>Go 语言规范定义了接口方法集的调用规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</span><br><span class="line">类型 T 的可调用方法集包含接受者为 T 的所有方法</span><br><span class="line">类型 T 的可调用方法集不包含接受者为 *T 的方法</span><br></pre></td></tr></table></figure><h3 id="8）相同方法集的接口"><a href="#8）相同方法集的接口" class="headerlink" title="8）相同方法集的接口"></a>8）相同方法集的接口</h3><p>如果有多个接口，且这些接口里的方法定义相同，则类型可以互相转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type day struct &#123;</span><br><span class="line">num       int</span><br><span class="line">shortName string</span><br><span class="line">longName  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type dayArray struct &#123;</span><br><span class="line">data []*day</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *dayArray) Len() int           &#123; return len(p.data) &#125;</span><br><span class="line">func (p *dayArray) Less(i, j int) bool &#123; return p.data[i].num &lt; p.data[j].num &#125;</span><br><span class="line">func (p *dayArray) Swap(i, j int)      &#123; p.data[i], p.data[j] &#x3D; p.data[j], p.data[i] &#125;</span><br><span class="line"></span><br><span class="line">type Sorter interface &#123;</span><br><span class="line">Len() int</span><br><span class="line">Less(i, j int) bool</span><br><span class="line">Swap(i, j int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var c sort.Interface &#x3D; new(dayArray)</span><br><span class="line"></span><br><span class="line">if _, ok :&#x3D; c.(sort.Interface); ok &#123;</span><br><span class="line">fmt.Println(&quot;c implements sort.Interface&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if _, ok :&#x3D; c.(Sorter); ok &#123;</span><br><span class="line">fmt.Println(&quot;c implements Sorter&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">c implements sort.Interface</span><br><span class="line">c implements Sorter</span><br></pre></td></tr></table></figure><h3 id="9）使用-sort-Interface-接口排序"><a href="#9）使用-sort-Interface-接口排序" class="headerlink" title="9）使用 sort.Interface 接口排序"></a>9）使用 sort.Interface 接口排序</h3><p>一个很好的例子是来自标准库的 sort 包，要对一组数字或字符串排序，只需要实现三个方法：</p><ul><li>反映元素个数的 Len() 方法</li><li>比较第 i 和 j 个元素的 Less(i, j) 方法</li><li>交换第 i 和 j 个元素的 Swap(i, j) 方法</li></ul><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type day struct &#123;</span><br><span class="line">num       int</span><br><span class="line">shortName string</span><br><span class="line">longName  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type dayArray struct &#123;</span><br><span class="line">data []*day</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *dayArray) Len() int           &#123; return len(p.data) &#125;</span><br><span class="line">func (p *dayArray) Less(i, j int) bool &#123; return p.data[i].num &lt; p.data[j].num &#125;</span><br><span class="line">func (p *dayArray) Swap(i, j int)      &#123; p.data[i], p.data[j] &#x3D; p.data[j], p.data[i] &#125;</span><br><span class="line"></span><br><span class="line">func days() &#123;</span><br><span class="line">Sunday :&#x3D; day&#123;0, &quot;SUN&quot;, &quot;Sunday&quot;&#125;</span><br><span class="line">Monday :&#x3D; day&#123;1, &quot;MON&quot;, &quot;Monday&quot;&#125;</span><br><span class="line">Tuesday :&#x3D; day&#123;2, &quot;TUE&quot;, &quot;Tuesday&quot;&#125;</span><br><span class="line">Wednesday :&#x3D; day&#123;3, &quot;WED&quot;, &quot;Wednesday&quot;&#125;</span><br><span class="line">Thursday :&#x3D; day&#123;4, &quot;THU&quot;, &quot;Thursday&quot;&#125;</span><br><span class="line">Friday :&#x3D; day&#123;5, &quot;FRI&quot;, &quot;Friday&quot;&#125;</span><br><span class="line">Saturday :&#x3D; day&#123;6, &quot;SAT&quot;, &quot;Saturday&quot;&#125;</span><br><span class="line">data :&#x3D; []*day&#123;&amp;Tuesday, &amp;Thursday, &amp;Wednesday, &amp;Sunday, &amp;Monday, &amp;Friday, &amp;Saturday&#125;</span><br><span class="line">a :&#x3D; dayArray&#123;data&#125;</span><br><span class="line">sort.Sort(&amp;a)</span><br><span class="line">if !sort.IsSorted(&amp;a) &#123;</span><br><span class="line">panic(&quot;fail&quot;)</span><br><span class="line">&#125;</span><br><span class="line">for _, d :&#x3D; range data &#123;</span><br><span class="line">fmt.Printf(&quot;%s &quot;, d.longName)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">days()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10）Go-中的面向对象"><a href="#10）Go-中的面向对象" class="headerlink" title="10）Go 中的面向对象"></a>10）Go 中的面向对象</h3><p>我们总结一下前面看到的：Go 没有类，而是松耦合的类型、方法对接口的实现。</p><p>OO(面向对象) 语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？</p><h4 id="封装（数据隐藏）"><a href="#封装（数据隐藏）" class="headerlink" title="封装（数据隐藏）"></a>封装（数据隐藏）</h4><p>Go 和别的 OO(面向对象) 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层（Go可见性规则）:</p><ul><li><p>1）包范围内的：通过标识符首字母小写，对象只在它所在的包内可见</p></li><li><p>2）可导出的：通过标识符首字母大写，对象对所在包以外也可见</p></li></ul><h4 id="类型只拥有自己所在包中定义的方法"><a href="#类型只拥有自己所在包中定义的方法" class="headerlink" title="类型只拥有自己所在包中定义的方法"></a>类型只拥有自己所在包中定义的方法</h4><ul><li>继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现</li><li>多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且：接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。</li></ul><h3 id="11）接口与动态类型"><a href="#11）接口与动态类型" class="headerlink" title="11）接口与动态类型"></a>11）接口与动态类型</h3><p>在经典的面向对象语言（像 C++，Java 和 C#）中数据和方法被封装为 类 的概念：类包含它们两者，并且不能剥离。</p><p>Go 没有类：数据（结构体或更一般的类型）和方法是一种松耦合的正交关系。</p><p>Go 中的接口跟 Java/C# 类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：<strong>任何提供了接口方法实现代码的类型都隐式地实现了该接口，而不用显式地声明。</strong></p><p>和其它语言相比，Go 是唯一结合了接口值，<strong>静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。</strong> 该特性允许我们在不改变已有的代码的情况下定义和使用新接口。</p><p>接收一个（或多个）接口类型作为参数的函数，其实参数可以是任何实现了该接口的类型。<strong>实现了某个接口的类型可以被传给任何以此接口为参数的函数。</strong></p><p>类似于 Python 和 Ruby 这类动态语言中的 动态类型（duck typing）；这意味着对象可以根据提供的方法被处理（例如，作为参数传递给函数），而忽略它们的实际类型：<strong>它们能做什么比它们是什么更重要。</strong></p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type IDuck interface &#123;</span><br><span class="line">Quack()</span><br><span class="line">Walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DuckDance(duck IDuck) &#123;</span><br><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 3; i++ &#123;</span><br><span class="line">duck.Quack()</span><br><span class="line">duck.Walk()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Bird struct &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Bird) Quack() &#123;</span><br><span class="line">fmt.Println(&quot;I am quacking!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Bird) Walk() &#123;</span><br><span class="line">fmt.Println(&quot;I am walking!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b :&#x3D; new(Bird)</span><br><span class="line">DuckDance(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">I am quacking!</span><br><span class="line">I am walking!</span><br><span class="line">I am quacking!</span><br><span class="line">I am walking!</span><br><span class="line">I am quacking!</span><br><span class="line">I am walking!</span><br></pre></td></tr></table></figure><h4 id="动态方法调用"><a href="#动态方法调用" class="headerlink" title="动态方法调用"></a>动态方法调用</h4><p>像 Python，Ruby 这类语言，动态类型是延迟绑定的（在运行时进行）：<strong>方法只是用参数和变量简单地调用，然后在运行时才解析</strong>（它们很可能有像 responds_to 这样的方法来检查对象是否可以响应某个方法，但是这也意味着更大的编码量和更多的测试工作）。</p><p>Go 的实现与此相反，通常需要编译器静态检查的支持：<strong>当变量被赋值给一个接口类型的变量时，编译器会检查其是否实现了该接口的所有函数。</strong> 如果方法调用作用于像 interface{} 这样的 “泛型” 上，你可以通过类型断言来检查变量是否实现了相应接口。</p><p>例如，你用不同的类型表示 XML 输出流中的不同实体。然后我们为 XML 定义一个如下的 “写” 接口（甚至可以把它定义为私有接口）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type xmlWriter interface &#123;</span><br><span class="line">    WriteXML(w io.Writer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以实现适用于该流类型的任何变量的 StreamXML 函数，并用类型断言检查传入的变量是否实现了该接口；如果没有，我们就调用内建的 encodeToXML 来完成相应工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Exported XML streaming function.</span><br><span class="line">func StreamXML(v interface&#123;&#125;, w io.Writer) error &#123;</span><br><span class="line">    if xw, ok :&#x3D; v.(xmlWriter); ok &#123;</span><br><span class="line">        &#x2F;&#x2F; It’s an  xmlWriter, use method of asserted type.</span><br><span class="line">        return xw.WriteXML(w)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; No implementation, so we have to use our own function (with perhaps reflection):</span><br><span class="line">    return encodeToXML(v, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Internal XML encoding function.</span><br><span class="line">func encodeToXML(v interface&#123;&#125;, w io.Writer) error &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 Go 提供了动态语言的优点，却没有其他动态语言在运行时可能发生错误的缺点。</p><h4 id="接口的提取"><a href="#接口的提取" class="headerlink" title="接口的提取"></a>接口的提取</h4><p>提取接口 是非常有用的设计模式，可以减少需要的类型和方法数量，而且不需要像传统的基于类的面向对象语言那样维护整个的类层次结构。</p><p>Go 接口可以让开发者找出自己写的程序中的类型。假设有一些拥有共同行为的对象，并且开发者想要抽象出这些行为，这时就可以创建一个接口来使用。</p><p>所以你不用提前设计出所有的接口；<strong>整个设计可以持续演进，而不用废弃之前的决定。类型要实现某个接口，它本身不用改变，你只需要在这个类型上实现新的方法。</strong></p><h4 id="显式地指明类型实现了某个接口"><a href="#显式地指明类型实现了某个接口" class="headerlink" title="显式地指明类型实现了某个接口"></a>显式地指明类型实现了某个接口</h4><p>如果你希望满足某个接口的类型显式地声明它们实现了这个接口，你可以向接口的方法集中添加一个具有描述性名字的方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Fooer interface &#123;</span><br><span class="line">    Foo()</span><br><span class="line">    ImplementsFooer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型 Bar 必须实现 ImplementsFooer 方法来满足 Footer 接口，以清楚地记录这个事实。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Bar struct&#123;&#125;</span><br><span class="line">func (b Bar) ImplementsFooer() &#123;&#125;</span><br><span class="line">func (b Bar) Foo() &#123;&#125;</span><br></pre></td></tr></table></figure><p>大部分代码并不使用这样的约束，因为它限制了接口的实用性。</p><p>但是有些时候，这样的约束在大量相似的接口中被用来解决歧义。</p><h4 id="空接口和函数重载"><a href="#空接口和函数重载" class="headerlink" title="空接口和函数重载"></a>空接口和函数重载</h4><p>在之前的学习中，我们看到函数重载是不被允许的。在 Go 语言中函数重载可以用 可变参数 …T 作为函数 <strong>最后一个参数</strong> 来实现。</p><p>如果我们把 T 换为空接口，那么可以知道任何类型的变量都是满足 T (空接口）类型的，这样就允许我们传递任何数量任何类型的参数给函数，即重载的实际含义。</p><p>函数 fmt.Printf 就是这样做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(format string, a ...interface&#123;&#125;) (n int, errno error)</span><br><span class="line"></span><br><span class="line">这个函数通过枚举 slice 类型的实参动态确定所有参数的类型。并查看每个类型是否实现了 String() 方法，如果是就用于产生输出信息。</span><br></pre></td></tr></table></figure><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Task struct &#123;</span><br><span class="line">    Command string</span><br><span class="line">    *log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类型的工厂方法像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func NewTask(command string, logger *log.Logger) *Task &#123;</span><br><span class="line">    return &amp;Task&#123;command, logger&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 log.Logger 实现了 Log() 方法后，Task 的实例 task 就可以调用该方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task.Log()</span><br></pre></td></tr></table></figure><p>类型可以通过继承多个接口来提供像 多重继承 一样的特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ReaderWriter struct &#123;</span><br><span class="line">    *io.Reader</span><br><span class="line">    *io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面概述的原理被应用于整个 Go 包，多态用得越多，代码就相对越少。这被认为是 Go 编程中的重要的最佳实践。</p><p>有用的接口可以在开发的过程中被归纳出来。添加新接口非常容易，因为已有的类型不用变动（仅仅需要实现新接口的方法）。</p><h2 id="七、空接口"><a href="#七、空接口" class="headerlink" title="七、空接口"></a>七、空接口</h2><p>空接口或者最小接口 不包含任何方法，它对实现不做任何要求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Any interface &#123;&#125;</span><br></pre></td></tr></table></figure><p>任何其他类型都实现了空接口（它不仅仅像 Java/C# 中 Object 引用类型），any 或 Any 是空接口一个很好的别名或缩写。</p><p>空接口类似 Java/C# 中所有类的基类： Object 类，二者的目标也很相近。</p><p>可以给一个空接口类型的变量 var val interface {} 赋任何类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var i &#x3D; 5</span><br><span class="line">var str &#x3D; &quot;ABC&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Any interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var val Any</span><br><span class="line">    val &#x3D; 5</span><br><span class="line">    fmt.Printf(&quot;val has the value: %v\n&quot;, val)</span><br><span class="line">    val &#x3D; str</span><br><span class="line">    fmt.Printf(&quot;val has the value: %v\n&quot;, val)</span><br><span class="line">    pers1 :&#x3D; new(Person)</span><br><span class="line">    pers1.name &#x3D; &quot;Rob Pike&quot;</span><br><span class="line">    pers1.age &#x3D; 55</span><br><span class="line">    val &#x3D; pers1</span><br><span class="line">    fmt.Printf(&quot;val has the value: %v\n&quot;, val)</span><br><span class="line">    switch t :&#x3D; val.(type) &#123;</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Printf(&quot;Type int %T\n&quot;, t)</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Printf(&quot;Type string %T\n&quot;, t)</span><br><span class="line">    case bool:</span><br><span class="line">        fmt.Printf(&quot;Type boolean %T\n&quot;, t)</span><br><span class="line">    case *Person:</span><br><span class="line">        fmt.Printf(&quot;Type pointer to Person %T\n&quot;, t)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;Unexpected type %T&quot;, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">val has the value: 5</span><br><span class="line">val has the value: ABC</span><br><span class="line">val has the value: &amp;&#123;Rob Pike 55&#125;</span><br><span class="line">Type pointer to Person *main.Person</span><br></pre></td></tr></table></figure><p>在上面的例子中，接口变量 val 被依次赋予一个 int，string 和 Person 实例的值，然后使用 type-switch 来测试它的实际类型。</p><p>每个 interface {} 变量在内存中占据两个字长：</p><ul><li>一个用来存储它包含的类型。</li><li>另一个用来存储它包含的数据或者指向数据的指针。</li></ul><h3 id="1）构建通用类型或包含不同类型变量的数组"><a href="#1）构建通用类型或包含不同类型变量的数组" class="headerlink" title="1）构建通用类型或包含不同类型变量的数组"></a>1）构建通用类型或包含不同类型变量的数组</h3><p>在之前的例子中我们看到了能被搜索和排序的 int 数组、float 数组以及 string 数组，那么对于其他类型的数组呢，是不是我们必须得自己编程实现它们？</p><p>现在我们知道该怎么做了，就是通过使用空接口。让我们给空接口定一个别名类型 Element：type Element interface{}</p><p>然后定义一个容器类型的结构体 Vector，它包含一个 Element 类型元素的切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Element interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">type Vector struct &#123;</span><br><span class="line">    a []Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector 里能放任何类型的变量，因为任何类型都实现了空接口，实际上 Vector 里放的每个元素可以是不同类型的变量。我们为它定义一个 At() 方法用于返回第 i 个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p *Vector) At(i int) Element &#123;</span><br><span class="line">    return p.a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定一个 Set() 方法用于设置第 i 个元素的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p *Vector) Set(i int, e Element) &#123;</span><br><span class="line">    p.a[i] &#x3D; e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector 中存储的所有元素都是 Element 类型，要得到它们的原始类型（unboxing：拆箱）需要用到类型断言。</p><p>注意：<strong>The compiler rejects assertions guaranteed to fail，类型断言总是在运行时才执行，因此它会产生运行时错误。</strong></p><p>练习：创建一个 Miner 接口并实现一些必要的操作。函数 Min 接受一个 Miner 类型变量的集合，然后计算并返回集合中最小的元素。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Element interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">type Miner interface &#123;</span><br><span class="line">Len() int</span><br><span class="line">ElemIx(ix int) Element</span><br><span class="line">Less(i, j int) bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IntArray []int</span><br><span class="line"></span><br><span class="line">func (p IntArray) Len() int              &#123; return len(p) &#125;</span><br><span class="line">func (p IntArray) ElemIx(ix int) Element &#123; return p[ix] &#125;</span><br><span class="line">func (p IntArray) Less(i, j int) bool    &#123; return p[i] &lt; p[j] &#125;</span><br><span class="line"></span><br><span class="line">func Min(data Miner) Element &#123;</span><br><span class="line">min :&#x3D; data.ElemIx(0)</span><br><span class="line">for i :&#x3D; 1; i &lt; data.Len(); i++ &#123;</span><br><span class="line">if data.Less(i, i-1) &#123;</span><br><span class="line">min &#x3D; data.ElemIx(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">intarr :&#x3D; IntArray&#123;1, 2, 3, 5, -1&#125;</span><br><span class="line">fmt.Println(Min(intarr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）复制数据切片至空接口切片"><a href="#2）复制数据切片至空接口切片" class="headerlink" title="2）复制数据切片至空接口切片"></a>2）复制数据切片至空接口切片</h3><p>假设你有一个 myType 类型的数据切片，你想将切片中的数据复制到一个空接口切片中，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataSlice []myType &#x3D; FuncReturnSlice()</span><br><span class="line">var interfaceSlice []interface&#123;&#125; &#x3D; dataSlice</span><br></pre></td></tr></table></figure><p>可惜不能这么做，编译时会出错：cannot use dataSlice (type []myType) as type []interface { } in assignment。</p><p><strong>原因是它们俩在内存中的布局是不一样的。</strong></p><p>必须使用 for-range 语句来一个一个显式地复制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var dataSlice []myType &#x3D; FuncReturnSlice()</span><br><span class="line">var interfaceSlice []interface&#123;&#125; &#x3D; make([]interface&#123;&#125;, len(dataSlice))</span><br><span class="line">for i, d :&#x3D; range dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] &#x3D; d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）通用类型的节点数据结构"><a href="#3）通用类型的节点数据结构" class="headerlink" title="3）通用类型的节点数据结构"></a>3）通用类型的节点数据结构</h3><p>列表和树这样的数据结构，在它们的定义中使用了一种叫节点的递归结构体类型，节点包含一个某种类型的数据字段。现在可以使用空接口作为数据字段的类型，这样我们就能写出通用的代码。</p><p>下面是实现一个二叉树的部分代码：通用定义、用于创建空节点的 NewNode 方法，及设置数据的 SetData 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Node struct &#123;</span><br><span class="line">le   *Node</span><br><span class="line">data interface&#123;&#125;</span><br><span class="line">ri   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewNode(left, right *Node) *Node &#123;</span><br><span class="line">return &amp;Node&#123;left, nil, right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *Node) SetData(data interface&#123;&#125;) &#123;</span><br><span class="line">n.data &#x3D; data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">root :&#x3D; NewNode(nil, nil)</span><br><span class="line">root.SetData(&quot;root node&quot;)</span><br><span class="line">&#x2F;&#x2F; make child (leaf) nodes:</span><br><span class="line">a :&#x3D; NewNode(nil, nil)</span><br><span class="line">a.SetData(&quot;left node&quot;)</span><br><span class="line">b :&#x3D; NewNode(nil, nil)</span><br><span class="line">b.SetData(&quot;right node&quot;)</span><br><span class="line">root.le &#x3D; a</span><br><span class="line">root.ri &#x3D; b</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）接口到接口"><a href="#3）接口到接口" class="headerlink" title="3）接口到接口"></a>3）接口到接口</h3><p>一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法。</p><p>这个转换是在运行时进行检查的，转换失败会导致一个运行时错误：这是 ‘Go’ 语言动态的一面，可以拿它和 Ruby 和 Python 这些动态语言相比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type AbsInterface interface &#123;</span><br><span class="line">Abs() interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SqrInterface interface &#123;</span><br><span class="line">Sqr() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Point struct &#123;</span><br><span class="line">value int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Point) Abs() interface&#123;&#125; &#123;</span><br><span class="line">return math.Abs(float64(p.value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Point) Sqr() float32 &#123;</span><br><span class="line">return float32(p.value * p.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var ai AbsInterface</span><br><span class="line">var si SqrInterface</span><br><span class="line"></span><br><span class="line">pp :&#x3D; new(Point) &#x2F;&#x2F; say *Point implements Abs, Sqr</span><br><span class="line">pp.value &#x3D; -5</span><br><span class="line">var empty interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">empty &#x3D; pp &#x2F;&#x2F; everything satisfies empty</span><br><span class="line">fmt.Println(empty)</span><br><span class="line">ai &#x3D; empty.(AbsInterface) &#x2F;&#x2F; underlying value pp implements Abs()</span><br><span class="line">fmt.Println(ai.Abs())</span><br><span class="line">&#x2F;&#x2F; (runtime failure otherwise)</span><br><span class="line">si &#x3D; ai.(SqrInterface) &#x2F;&#x2F; *Point has Sqr() even though AbsInterface doesn’t</span><br><span class="line">fmt.Println(si.Sqr())</span><br><span class="line">empty &#x3D; si &#x2F;&#x2F; *Point implements empty set</span><br><span class="line">fmt.Println(empty)</span><br><span class="line">&#x2F;&#x2F; Note: statically checkable so type assertion not necessary.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&amp;&#123;-5&#125;</span><br><span class="line">5</span><br><span class="line">25</span><br><span class="line">&amp;&#123;-5&#125;</span><br></pre></td></tr></table></figure><h2 id="八、反射"><a href="#八、反射" class="headerlink" title="八、反射"></a>八、反射</h2><p>反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。</p><p>反射可以在运行时检查类型和变量，例如它的大小、方法和 动态的调用这些方法。这对于没有源代码的包尤其有用。</p><p>变量的最基本信息就是类型和值：反射包的 Type 用来表示一个 Go 类型，反射包的 Value 为 Go 值提供了反射接口。</p><p>两个简单的函数，reflect.TypeOf 和 reflect.ValueOf，返回被检查对象的类型和值。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x 被定义为</span><br><span class="line">var x float64 &#x3D; 3.4</span><br><span class="line"></span><br><span class="line">reflect.TypeOf(x) 返回 float64</span><br><span class="line"></span><br><span class="line">reflect.ValueOf(x) 返回 &lt;float64 Value&gt;</span><br></pre></td></tr></table></figure><p>实际上，反射是通过检查一个接口的值，变量首先被转换成空接口。这从下面两个函数签名能够很明显的看出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func TypeOf(i interface&#123;&#125;) Type</span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value</span><br></pre></td></tr></table></figure><p>接口的值包含一个 type 和 value。</p><p>反射可以从接口值反射到对象，也可以从对象反射回接口值。</p><p>reflect.Type 和 reflect.Value 都有许多方法用于检查和操作它们。一个重要的例子是 Value 有一个 Type 方法返回 reflect.Value 的 Type。另一个是 Type 和 Value 都有 Kind 方法返回一个常量来表示类型：Uint、Float64、Slice 等等。同样 Value 有叫做 Int 和 Float 的方法可以获取存储在内部的值（跟 int64 和 float64 一样）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Invalid Kind &#x3D; iota</span><br><span class="line">Bool</span><br><span class="line">Int</span><br><span class="line">Int8</span><br><span class="line">Int16</span><br><span class="line">Int32</span><br><span class="line">Int64</span><br><span class="line">Uint</span><br><span class="line">Uint8</span><br><span class="line">Uint16</span><br><span class="line">Uint32</span><br><span class="line">Uint64</span><br><span class="line">Uintptr</span><br><span class="line">Float32</span><br><span class="line">Float64</span><br><span class="line">Complex64</span><br><span class="line">Complex128</span><br><span class="line">Array</span><br><span class="line">Chan</span><br><span class="line">Func</span><br><span class="line">Interface</span><br><span class="line">Map</span><br><span class="line">Ptr</span><br><span class="line">Slice</span><br><span class="line">String</span><br><span class="line">Struct</span><br><span class="line">UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于 float64 类型的变量 x，如果 v:=reflect.ValueOf(x)，那么 v.Kind() 返回 reflect.Float64 ，所以下面的表达式是 true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.Kind() &#x3D;&#x3D; reflect.Float64</span><br></pre></td></tr></table></figure><p>Kind 总是返回底层类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line">var m MyInt &#x3D; 5</span><br><span class="line">v :&#x3D; reflect.ValueOf(m)</span><br><span class="line"></span><br><span class="line">方法 v.Kind() 返回 reflect.Int。</span><br><span class="line">变量 v 的 Interface() 方法可以得到还原（接口）值，所以可以这样打印 v 的值：fmt.Println(v.Interface())</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var x float64 &#x3D; 3.4</span><br><span class="line">    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))</span><br><span class="line">    v :&#x3D; reflect.ValueOf(x)</span><br><span class="line">    fmt.Println(&quot;value:&quot;, v)</span><br><span class="line">    fmt.Println(&quot;type:&quot;, v.Type())</span><br><span class="line">    fmt.Println(&quot;kind:&quot;, v.Kind())</span><br><span class="line">    fmt.Println(&quot;value:&quot;, v.Float())</span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Printf(&quot;value is %5.2e\n&quot;, v.Interface())</span><br><span class="line">    y :&#x3D; v.Interface().(float64)</span><br><span class="line">    fmt.Println(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">type: float64</span><br><span class="line">value: 3.4</span><br><span class="line">type: float64</span><br><span class="line">kind: float64</span><br><span class="line">value: 3.4</span><br><span class="line">3.4</span><br><span class="line">value is 3.40e+00</span><br><span class="line">3.4</span><br></pre></td></tr></table></figure><h3 id="1）通过反射修改-设置-值"><a href="#1）通过反射修改-设置-值" class="headerlink" title="1）通过反射修改 (设置) 值"></a>1）通过反射修改 (设置) 值</h3><p>假设我们要把 x 的值改为 3.1415。Value 有一些方法可以完成这个任务，但是必须小心使用：v.SetFloat(3.1415)。</p><p>这将产生一个错误：reflect.Value.SetFloat using unaddressable value。</p><p>为什么会这样呢？问题的原因是 v 不是可设置的（这里并不是说值不可寻址）。是否可设置是 Value 的一个属性，并且不是所有的反射值都有这个属性：可以使用 CanSet() 方法测试是否可设置。</p><p>在例子中我们看到 v.CanSet() 返回 false： settability of v: false</p><p>当 v := reflect.ValueOf(x) 函数通过传递一个 x 拷贝创建了 v，那么 v 的改变并不能更改原始的 x。要想 v 的更改能作用到 x，那就必须传递 x 的地址 v = reflect.ValueOf(&amp;x)。</p><p>通过 Type () 我们看到 v 现在的类型是 *float64 并且仍然是不可设置的。</p><p>要想让其可设置我们需要使用 Elem() 函数，这间接的使用指针：v = v.Elem()</p><p>现在 v.CanSet() 返回 true 并且 v.SetFloat(3.1415) 设置成功了！</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var x float64 &#x3D; 3.4</span><br><span class="line">    v :&#x3D; reflect.ValueOf(x)</span><br><span class="line">    &#x2F;&#x2F; setting a value:</span><br><span class="line">    &#x2F;&#x2F; v.SetFloat(3.1415) &#x2F;&#x2F; Error: will panic: reflect.Value.SetFloat using unaddressable value</span><br><span class="line">    fmt.Println(&quot;settability of v:&quot;, v.CanSet())</span><br><span class="line">    v &#x3D; reflect.ValueOf(&amp;x) &#x2F;&#x2F; Note: take the address of x.</span><br><span class="line">    fmt.Println(&quot;type of v:&quot;, v.Type())</span><br><span class="line">    fmt.Println(&quot;settability of v:&quot;, v.CanSet())</span><br><span class="line">    v &#x3D; v.Elem()</span><br><span class="line">    fmt.Println(&quot;The Elem of v is: &quot;, v)</span><br><span class="line">    fmt.Println(&quot;settability of v:&quot;, v.CanSet())</span><br><span class="line">    v.SetFloat(3.1415) &#x2F;&#x2F; this works!</span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">settability of v: false</span><br><span class="line">type of v: *float64</span><br><span class="line">settability of v: false</span><br><span class="line">The Elem of v is:  &lt;float64 Value&gt;</span><br><span class="line">settability of v: true</span><br><span class="line">3.1415</span><br><span class="line">&lt;float64 Value&gt;</span><br></pre></td></tr></table></figure><h3 id="2）反射结构体"><a href="#2）反射结构体" class="headerlink" title="2）反射结构体"></a>2）反射结构体</h3><p>NumField() 方法返回结构体内的字段数量；通过一个 for 循环用索引取得每个字段的值 Field(i)。</p><p>我们同样能够调用签名在结构体上的方法，例如，使用索引 n 来调用：Method(n).Call(nil)。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type NotknownType struct &#123;</span><br><span class="line">    s1, s2, s3 string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n NotknownType) String() string &#123;</span><br><span class="line">    return n.s1 + &quot; - &quot; + n.s2 + &quot; - &quot; + n.s3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; variable to investigate:</span><br><span class="line">var secret interface&#123;&#125; &#x3D; NotknownType&#123;&quot;Ada&quot;, &quot;Go&quot;, &quot;Oberon&quot;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    value :&#x3D; reflect.ValueOf(secret) &#x2F;&#x2F; &lt;main.NotknownType Value&gt;</span><br><span class="line">    typ :&#x3D; reflect.TypeOf(secret)    &#x2F;&#x2F; main.NotknownType</span><br><span class="line">    &#x2F;&#x2F; alternative:</span><br><span class="line">    &#x2F;&#x2F;typ :&#x3D; value.Type()  &#x2F;&#x2F; main.NotknownType</span><br><span class="line">    fmt.Println(typ)</span><br><span class="line">    knd :&#x3D; value.Kind() &#x2F;&#x2F; struct</span><br><span class="line">    fmt.Println(knd)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; iterate through the fields of the struct:</span><br><span class="line">    for i :&#x3D; 0; i &lt; value.NumField(); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;Field %d: %v\n&quot;, i, value.Field(i))</span><br><span class="line">        &#x2F;&#x2F; error: panic: reflect.Value.SetString using value obtained using unexported field</span><br><span class="line">        &#x2F;&#x2F;value.Field(i).SetString(&quot;C#&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; call the first method, which is String():</span><br><span class="line">    results :&#x3D; value.Method(0).Call(nil)</span><br><span class="line">    fmt.Println(results) &#x2F;&#x2F; [Ada - Go - Oberon]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">main.NotknownType</span><br><span class="line">struct</span><br><span class="line">Field 0: Ada</span><br><span class="line">Field 1: Go</span><br><span class="line">Field 2: Oberon</span><br><span class="line">[Ada - Go - Oberon]</span><br></pre></td></tr></table></figure><p>但是如果尝试更改一个值，会得到一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect.Value.SetString using value obtained using unexported field</span><br></pre></td></tr></table></figure><p>这是因为结构体中 <strong>只有被导出字段（首字母大写）才是可设置的。</strong></p><p>来看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">    A int</span><br><span class="line">    B string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    t :&#x3D; T&#123;23, &quot;skidoo&quot;&#125;</span><br><span class="line">    s :&#x3D; reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    typeOfT :&#x3D; s.Type()</span><br><span class="line">    for i :&#x3D; 0; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">        f :&#x3D; s.Field(i)</span><br><span class="line">        fmt.Printf(&quot;%d: %s %s &#x3D; %v\n&quot;, i,</span><br><span class="line">            typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">    &#125;</span><br><span class="line">    s.Field(0).SetInt(77)</span><br><span class="line">    s.Field(1).SetString(&quot;Sunset Strip&quot;)</span><br><span class="line">    fmt.Println(&quot;t is now&quot;, t)</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">0: A int &#x3D; 23</span><br><span class="line">1: B string &#x3D; skidoo</span><br><span class="line">t is now &#123;77 Sunset Strip&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://learnku.com/docs/the-way-to-go">Go 入门指南</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：六到十一章的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go 入门总结（一）</title>
    <link href="https://www.blog.ajie39.top/2022/03/06/Go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/03/06/Go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-03-06T06:50:08.425Z</published>
    <updated>2022-05-07T07:24:49.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：一到五章的内容。</h1><hr><span id="more"></span><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1、包相关"><a href="#1、包相关" class="headerlink" title="1、包相关"></a>1、包相关</h3><p>①第一种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;; import &quot;os&quot;</span><br></pre></td></tr></table></figure><p>②第二种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (&quot;fmt&quot;; &quot;os&quot;)</span><br></pre></td></tr></table></figure><h3 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h3><ul><li>布尔类型：bool</li><li>整数：int、int8、int16、int32、int64</li><li>无符号整数：uint、uint8、uint16、uint32、uint64</li><li>字节：byte(和 uint8 等价)</li><li>Unicode：rune(和 int32 等价)</li><li>整数指针：uintptr(存储 uint32、uint64 的指针)</li><li>浮点数：float32、float64</li><li>复数：complex64、complex128</li><li>字符串类型：string</li><li>值类型：array(数组)、struct(结构化变量)</li><li>引用类型：slice(动态数组)、map、channel(管道)</li><li>接口：interface</li><li>函数：function</li></ul><h3 id="3、函数相关"><a href="#3、函数相关" class="headerlink" title="3、函数相关"></a>3、函数相关</h3><p>函数执行顺序：init —》main</p><p>测试代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;demo&#x2F;com.th3ee9ine&#x2F;servic&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">&#x2F;&#x2F; 先执行</span><br><span class="line">fmt.Println(&quot;初始化.....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">  主函数</span><br><span class="line">*&#x2F;</span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 后执行</span><br><span class="line">fmt.Println(&quot;主函数......&quot;)</span><br><span class="line">fmt.Println(&quot;加法&quot;)</span><br><span class="line">fmt.Println(servic.Add(1, 2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、类型转换"><a href="#4、类型转换" class="headerlink" title="4、类型转换"></a>4、类型转换</h3><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOfTypeB &#x3D; typeB(valueOfTypeA)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 5.0</span><br><span class="line">var b &#x3D; int(a)</span><br></pre></td></tr></table></figure><h3 id="5、Go-程序的一般结构"><a href="#5、Go-程序的一般结构" class="headerlink" title="5、Go 程序的一般结构"></a>5、Go 程序的一般结构</h3><p>一般结构如下：</p><ul><li>在完成包的 import 之后，开始对常量、变量和类型的定义或声明。</li><li>如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li><li>如果当前包是 main 包，则定义 main 函数。</li><li>然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const c &#x3D; &quot;C&quot;</span><br><span class="line"></span><br><span class="line">var v int &#x3D; 5</span><br><span class="line"></span><br><span class="line">type T struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123; &#x2F;&#x2F; initialization of package</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var a int</span><br><span class="line">   Func1()</span><br><span class="line">   &#x2F;&#x2F; ...</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t T) Method1() &#123;</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Func1() &#123; &#x2F;&#x2F; exported function Func1</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、常量、变量"><a href="#6、常量、变量" class="headerlink" title="6、常量、变量"></a>6、常量、变量</h3><h4 id="①常量"><a href="#①常量" class="headerlink" title="①常量"></a>①常量</h4><p>常量使用关键字 const 定义，用于存储不会改变的数据。</p><p>存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const identifier [type] &#x3D; value</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">const PI &#x3D; 3.14159</span><br><span class="line">const NAME string &#x3D; &quot;张三&quot;</span><br><span class="line">const beef, two, c &#x3D; &quot;eat&quot;, 2, &quot;veg&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>②常量枚举</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Unknown &#x3D; 0</span><br><span class="line">    Female &#x3D; 1</span><br><span class="line">    Male &#x3D; 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota 可以被用作枚举值，第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1，例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b &#x3D; iota</span><br><span class="line">    c &#x3D; iota</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="②变量"><a href="#②变量" class="headerlink" title="②变量"></a>②变量</h4><p>声明变量的一般形式是使用 var 关键字，例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var identifier type</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">var a int &#x3D; 15</span><br><span class="line">var i &#x3D; 5</span><br><span class="line">var b bool &#x3D; false</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    a &#x3D; 15</span><br><span class="line">    b &#x3D; false</span><br><span class="line">    city string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">简短形式，使用 :&#x3D; 赋值操作符，例如：</span><br><span class="line"></span><br><span class="line">a, b, c :&#x3D; 5, 7, &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。</span><br><span class="line"></span><br><span class="line">同个变量不可以多次使用 :&#x3D; 赋值操作符。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、运算符"><a href="#7、运算符" class="headerlink" title="7、运算符"></a>7、运算符</h3><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优先级     运算符</span><br><span class="line"> 7      ^ !</span><br><span class="line"> 6      * &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^</span><br><span class="line"> 5      + - | ^</span><br><span class="line"> 4      &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt;&#x3D; &gt;</span><br><span class="line"> 3      &lt;-</span><br><span class="line"> 2      &amp;&amp;</span><br><span class="line"> 1      ||</span><br></pre></td></tr></table></figure><h3 id="8、字符串"><a href="#8、字符串" class="headerlink" title="8、字符串"></a>8、字符串</h3><p>字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。</p><p>Go 支持以下 2 种形式的字面值：</p><p>解释字符串：</p><p>该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\n：换行符</span><br><span class="line">\r：回车符</span><br><span class="line">\t：tab 键</span><br><span class="line">\u 或 \U：Unicode 字符</span><br><span class="line">\\：反斜杠自身</span><br></pre></td></tr></table></figure><p>非解释字符串：</p><p>该类字符串使用反引号括起来，支持换行，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;This is a raw string \n&#96; 中的 &#96;\n\&#96; 会被原样输出。</span><br></pre></td></tr></table></figure><h3 id="9、时间和日期"><a href="#9、时间和日期" class="headerlink" title="9、时间和日期"></a>9、时间和日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var week time.Duration</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">t :&#x3D; time.Now()</span><br><span class="line">fmt.Println(t) &#x2F;&#x2F; e.g. Wed Dec 21 09:52:14 +0100 RST 2011</span><br><span class="line">fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</span><br><span class="line">&#x2F;&#x2F; 21.12.2011</span><br><span class="line">t &#x3D; time.Now().UTC()</span><br><span class="line">fmt.Println(t)          &#x2F;&#x2F; Wed Dec 21 08:52:14 +0000 UTC 2011</span><br><span class="line">fmt.Println(time.Now()) &#x2F;&#x2F; Wed Dec 21 09:52:14 +0100 RST 2011</span><br><span class="line">&#x2F;&#x2F; calculating times:</span><br><span class="line">week &#x3D; 60 * 60 * 24 * 7 * 1e9 &#x2F;&#x2F; must be in nanosec</span><br><span class="line">weekFromNow :&#x3D; t.Add(week)</span><br><span class="line">fmt.Println(weekFromNow) &#x2F;&#x2F; Wed Dec 28 08:52:14 +0000 UTC 2011</span><br><span class="line">&#x2F;&#x2F; formatting times:</span><br><span class="line">fmt.Println(t.Format(time.RFC822))         &#x2F;&#x2F; 21 Dec 11 0852 UTC</span><br><span class="line">fmt.Println(t.Format(time.ANSIC))          &#x2F;&#x2F; Wed Dec 21 08:56:34 2011</span><br><span class="line">fmt.Println(t.Format(&quot;21 Dec 2011 08:52&quot;)) &#x2F;&#x2F; 21 Dec 2011 08:52</span><br><span class="line">s :&#x3D; t.Format(&quot;20060102&quot;)</span><br><span class="line">fmt.Println(t, &quot;&#x3D;&gt;&quot;, s)</span><br><span class="line">&#x2F;&#x2F; Wed Dec 21 08:52:14 +0000 UTC 2011 &#x3D;&gt; 20111221</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、指针"><a href="#10、指针" class="headerlink" title="10、指针"></a>10、指针</h3><p>Go 语言为程序员提供了控制数据结构的指针的能力；但是，你不能进行指针运算。</p><p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i1 &#x3D; 5</span><br><span class="line">fmt.Printf(&quot;An integer: %d, it&#39;s location in memory: %p\n&quot;, i1, &amp;i1)</span><br></pre></td></tr></table></figure><p>Go 语言的存地址符是 *，放到一个变量前使用就会返回相应变量的内存地址。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var intP *int &#x3D; &amp;i1</span><br><span class="line"></span><br><span class="line">使用 intP &#x3D; &amp;i1 是合法的，此时 intP 指向 i1。</span><br><span class="line">intP 存储了 i1 的内存地址；它指向了 i1 的位置，它引用了变量 i1。</span><br><span class="line">指针的格式化标识符为 %p。</span><br></pre></td></tr></table></figure><p>一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。</p><p>当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；你可以在指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。</p><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><p>一个指针变量通常缩写为 ptr。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、在书写表达式类似 var p *type 时，切记在 * 号和指针名称间留有一个空格.</span><br><span class="line">因为 var p*type 是语法正确的，但是在更复杂的表达式中，它容易被误认为是一个乘法表达式！</span><br><span class="line"></span><br><span class="line">2、符号 * 可以放在一个指针前，如 *intP，那么它将得到这个指针指向地址上所存储的值；</span><br><span class="line">这被称为反引用（或者内容或者间接引用）操作符；另一种说法是指针转移。</span><br><span class="line"></span><br><span class="line">对于任何一个变量 var， 如下表达式都是正确的：var &#x3D;&#x3D; *(&amp;var)</span><br><span class="line"></span><br><span class="line">3、不能得到一个文字或常量的地址，例如：</span><br><span class="line">const i &#x3D; 5</span><br><span class="line">ptr :&#x3D; &amp;i &#x2F;&#x2F;error: cannot take the address of i</span><br><span class="line">ptr2 :&#x3D; &amp;10 &#x2F;&#x2F;error: cannot take the address of 10</span><br></pre></td></tr></table></figure><p>例子一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var i1 &#x3D; 5</span><br><span class="line">    fmt.Printf(&quot;An integer: %d, its location in memory: %p\n&quot;, i1, &amp;i1)</span><br><span class="line">    var intP *int</span><br><span class="line">    intP &#x3D; &amp;i1</span><br><span class="line">    fmt.Printf(&quot;The value at memory location %p is %d\n&quot;, intP, *intP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    s :&#x3D; &quot;good bye&quot;</span><br><span class="line">    var p *string &#x3D; &amp;s</span><br><span class="line">    *p &#x3D; &quot;ciao&quot;</span><br><span class="line">    fmt.Printf(&quot;Here is the pointer p: %p\n&quot;, p) &#x2F;&#x2F; prints address</span><br><span class="line">    fmt.Printf(&quot;Here is the string *p: %s\n&quot;, *p) &#x2F;&#x2F; prints string</span><br><span class="line">    fmt.Printf(&quot;Here is the string s: %s\n&quot;, s) &#x2F;&#x2F; prints same string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子三：</p><p>对一个空指针的反向引用是不合法的，并且会使程序崩溃：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var p *int &#x3D; nil</span><br><span class="line">*p &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; in Windows: stops only with: &lt;exit code&#x3D;&quot;-1073741819&quot; msg&#x3D;&quot;process crashed&quot;&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; runtime error: invalid memory address or nil pointer dereference</span><br></pre></td></tr></table></figure><h2 id="二、控制结构"><a href="#二、控制结构" class="headerlink" title="二、控制结构"></a>二、控制结构</h2><ul><li>if-else 结构</li><li>多返回值函数</li><li>switch 结构</li><li>for (range) 结构</li><li>标签与 goto</li><li>select 结构，用于 channel 的选择</li></ul><h3 id="1、if-else-结构"><a href="#1、if-else-结构" class="headerlink" title="1、if-else 结构"></a>1、if-else 结构</h3><p>关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 } 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition1 &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125; else if condition2 &#123;</span><br><span class="line">    &#x2F;&#x2F; do something else</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; catch-all or default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 可以包含一个初始化语句（如：给一个变量赋值）。这种写法具有固定的格式（在初始化语句后方必须加上分号）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if initialization; condition &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line">if val :&#x3D; 10; val &gt; max &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但要注意的是，使用简短方式 := 声明的变量的作用域只存在于 if 结构中（在 if 结构的大括号之间，如果使用 if-else 结构则在 else 代码块中变量也会存在）。</p><p>如果变量在 if 结构之前就已经存在，那么在 if 结构中，该变量原来的值会被隐藏。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var first int &#x3D; 10</span><br><span class="line">    var cond int</span><br><span class="line"></span><br><span class="line">    if first &lt;&#x3D; 0 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is less than or equal to 0\n&quot;)</span><br><span class="line">    &#125; else if first &gt; 0 &amp;&amp; first &lt; 5 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is between 0 and 5\n&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is 5 or greater\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if cond &#x3D; 5; cond &gt; 10 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;cond is greater than 10\n&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;cond is not greater than 10\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、多返回值函数"><a href="#2、多返回值函数" class="headerlink" title="2、多返回值函数"></a>2、多返回值函数</h3><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var orig string &#x3D; &quot;ABC&quot;</span><br><span class="line">    &#x2F;&#x2F; var an int</span><br><span class="line">    var newS string</span><br><span class="line">    &#x2F;&#x2F; var err error</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;The size of ints is: %d\n&quot;, strconv.IntSize)</span><br><span class="line">    &#x2F;&#x2F; anInt, err &#x3D; strconv.Atoi(origStr)</span><br><span class="line">    an, err :&#x3D; strconv.Atoi(orig)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;orig %s is not an integer - exiting with error\n&quot;, orig)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;The integer is %d\n&quot;, an)</span><br><span class="line">    an &#x3D; an + 5</span><br><span class="line">    newS &#x3D; strconv.Itoa(an)</span><br><span class="line">    fmt.Printf(&quot;The new string is: %s\n&quot;, newS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>习惯用法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, err :&#x3D; pack1.Function1(param1)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Printf(&quot;An error occured in pack1.Function1 with parameter %v&quot;, param1)</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 未发生错误，继续执行：</span><br></pre></td></tr></table></figure><p>由于本例的函数调用者属于 main 函数，所以程序会直接停止运行。</p><p>如果我们想要在错误发生的同时终止程序的运行，我们可以使用 os 包的 Exit 函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Program stopping with error %v&quot;, err)</span><br><span class="line">    os.Exit(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者将 ok-pattern 的获取放置在 if 语句的初始化部分，然后进行判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if value, ok :&#x3D; readData(); ok &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、switch-结构"><a href="#3、switch-结构" class="headerlink" title="3、switch 结构"></a>3、switch 结构</h3><p>Go 语言中的 switch 结构使用上更加灵活。它接受任意形式的表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    case val1:</span><br><span class="line">        ...</span><br><span class="line">    case val2:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 switch 关键字在同一行。</p><p>一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，也就是说您不需要特别使用 break 语句来表示结束。</p><p>因此，程序也不会自动地去执行下一个分支的代码。如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch i &#123;</span><br><span class="line">    case 0: &#x2F;&#x2F; 空分支，只有当 i &#x3D;&#x3D; 0 时才会进入分支</span><br><span class="line">    case 1:</span><br><span class="line">        f() &#x2F;&#x2F; 当 i &#x3D;&#x3D; 0 时函数不会被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch i &#123;</span><br><span class="line">    case 0: fallthrough</span><br><span class="line">    case 1:</span><br><span class="line">        f() &#x2F;&#x2F; 当 i &#x3D;&#x3D; 0 时函数也会被调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">例一：</span><br><span class="line">var num1 int &#x3D; 100</span><br><span class="line"></span><br><span class="line">switch num1 &#123;</span><br><span class="line">case 98, 99:</span><br><span class="line">fmt.Println(&quot;It&#39;s equal to 98&quot;)</span><br><span class="line">case 100:</span><br><span class="line">fmt.Println(&quot;It&#39;s equal to 100&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;It&#39;s not equal to 98 or 100&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例二：</span><br><span class="line">var num1 int &#x3D; 7</span><br><span class="line"></span><br><span class="line">switch &#123;</span><br><span class="line">case num1 &lt; 0:</span><br><span class="line">fmt.Println(&quot;Number is negative&quot;)</span><br><span class="line">case num1 &gt; 0 &amp;&amp; num1 &lt; 10:</span><br><span class="line">fmt.Println(&quot;Number is between 0 and 10&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;Number is 10 or greater&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例三:</span><br><span class="line">switch a, b :&#x3D; x[i], y[j]; &#123;</span><br><span class="line">    case a &lt; b: t &#x3D; -1</span><br><span class="line">    case a &#x3D;&#x3D; b: t &#x3D; 0</span><br><span class="line">    case a &gt; b: t &#x3D; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、for-range-结构"><a href="#4、for-range-结构" class="headerlink" title="4、for (range) 结构"></a>4、for (range) 结构</h3><h4 id="第一种形式"><a href="#第一种形式" class="headerlink" title="第一种形式"></a>第一种形式</h4><p>基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for 初始化语句; 条件语句; 修饰语句 &#123;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;This is the %d iteration\n&quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种形式"><a href="#第二种形式" class="headerlink" title="第二种形式"></a>第二种形式</h4><p>基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for 条件语句 &#123;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i int &#x3D; 5</span><br><span class="line"></span><br><span class="line">    for i &gt;&#x3D; 0 &#123;</span><br><span class="line">        i &#x3D; i - 1</span><br><span class="line">        fmt.Printf(&quot;The variable i is now: %d\n&quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三种形式"><a href="#第三种形式" class="headerlink" title="第三种形式"></a>第三种形式</h4><p>无限循环，基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="第四种形式"><a href="#第四种形式" class="headerlink" title="第四种形式"></a>第四种形式</h4><p>for-range 结构，一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ix, val :&#x3D; range coll &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（译者注：如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）。</p><p>一个字符串是 Unicode 编码的字符（或称之为 rune）集合，因此您也可以用它迭代字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    str :&#x3D; &quot;Go is a beautiful language!&quot;</span><br><span class="line">    fmt.Printf(&quot;The length of str is: %d\n&quot;, len(str))</span><br><span class="line">    for pos, char :&#x3D; range str &#123;</span><br><span class="line">        fmt.Printf(&quot;Character on position %d is: %c \n&quot;, pos, char)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    str2 :&#x3D; &quot;Chinese: 日本語&quot;</span><br><span class="line">    fmt.Printf(&quot;The length of str2 is: %d\n&quot;, len(str2))</span><br><span class="line">    for pos, char :&#x3D; range str2 &#123;</span><br><span class="line">        fmt.Printf(&quot;character %c starts at byte position %d\n&quot;, char, pos)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(&quot;index int(rune) rune    char bytes&quot;)</span><br><span class="line">    for index, rune :&#x3D; range str2 &#123;</span><br><span class="line">        fmt.Printf(&quot;%-2d      %d      %U &#39;%c&#39; % X\n&quot;, index, rune, rune, rune, []byte(string(rune)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、标签与-goto"><a href="#5、标签与-goto" class="headerlink" title="5、标签与 goto"></a>5、标签与 goto</h3><p>for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词（gofmt 会将后续代码自动移至下一行）。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">LABEL1:</span><br><span class="line">    for i :&#x3D; 0; i &lt;&#x3D; 5; i++ &#123;</span><br><span class="line">        for j :&#x3D; 0; j &lt;&#x3D; 5; j++ &#123;</span><br><span class="line">            if j &#x3D;&#x3D; 4 &#123;</span><br><span class="line">                continue LABEL1</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;i is: %d, and j is: %d\n&quot;, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continue 语句指向 LABEL1，当执行到该语句的时候，就会跳转到 LABEL1 标签的位置。</p><p>您可以看到当 j==4 和 j==5 的时候，没有任何输出：标签的作用对象为外部循环，因此 i 会直接变成下一个循环的值，而此时 j 的值就被重设为 0，即它的初始值。</p><p>如果将 continue 改为 break，则不会只退出内层循环，而是直接退出外层循环了。</p><p>注意：</p><ul><li>标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母</li></ul><p>例子二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">i :&#x3D; 0</span><br><span class="line">HERE:</span><br><span class="line">print(i)</span><br><span class="line">i++</span><br><span class="line">if i &#x3D;&#x3D; 5 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">goto HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：一到五章的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>git--Fork代码更新与同步</title>
    <link href="https://www.blog.ajie39.top/2022/02/02/git----Fork%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>https://www.blog.ajie39.top/2022/02/02/git----Fork%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%90%8C%E6%AD%A5/</id>
    <published>2022-02-02T13:20:12.729Z</published>
    <updated>2022-02-02T13:39:28.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：记录使用git–Fork代码更新与同步"><a href="#摘要：记录使用git–Fork代码更新与同步" class="headerlink" title="摘要：记录使用git–Fork代码更新与同步"></a>摘要：记录使用git–Fork代码更新与同步</h1><hr><span id="more"></span><h2 id="一、clone-fork的代码"><a href="#一、clone-fork的代码" class="headerlink" title="一、clone fork的代码"></a>一、clone fork的代码</h2><p>git clone xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git clone <a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#46;&#x70;&#112;&#x64;&#97;&#x69;&#x63;&#111;&#x72;&#112;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#46;&#x70;&#112;&#x64;&#97;&#x69;&#x63;&#111;&#x72;&#112;&#x2e;&#99;&#x6f;&#x6d;</a>:cs-global/phl/cschannel.git</p><h2 id="二、把主仓库加入-remote"><a href="#二、把主仓库加入-remote" class="headerlink" title="二、把主仓库加入 remote"></a>二、把主仓库加入 remote</h2><p>未加入前：</p><p>执行 git remote 则只会有一个仓库</p><p><img src="/img/image/blog/20220202/remote1.png" alt="remote1"></p><p>执行命令，加入主仓库</p><p>git remote add xxxxxname（自定义名字） xxxxxxxxxxxx（主仓库地址）</p><p>例如：</p><p>git remote add main <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#46;&#x70;&#112;&#x64;&#97;&#105;&#99;&#111;&#114;&#112;&#46;&#99;&#111;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#46;&#x70;&#112;&#x64;&#97;&#105;&#99;&#111;&#114;&#112;&#46;&#99;&#111;&#x6d;</a>:cs-global/cschannel.git</p><p>再次执行 git remote 命令，则会出现两个选项</p><p><img src="/img/image/blog/20220202/remote2.png" alt="remote2"></p><h2 id="三、同步主仓库分支至本地"><a href="#三、同步主仓库分支至本地" class="headerlink" title="三、同步主仓库分支至本地"></a>三、同步主仓库分支至本地</h2><p>命令：</p><p>git fetch xxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git fetch main</p><h2 id="四、同步主分支代码"><a href="#四、同步主分支代码" class="headerlink" title="四、同步主分支代码"></a>四、同步主分支代码</h2><p>基于 origin/master 分支创建一个临时分支</p><p>例如：</p><p>git branch origin/temp</p><p>然后将 main 分支的代码合并到 origin/temp</p><p>例如：</p><p>git merge main/master<br>解决冲突后，提交代码即可</p><p>注意：</p><p>如果出现如下报错，则需要强制合并</p><p>refusing to merge unrelated histories</p><p>强制合并命令：</p><p>git merge xxxxxxxxxxxxxxxxxxxxxx –allow-unrelated-histories</p><p>例如：</p><p>git merge main/master –allow-unrelated-histories</p><h2 id="五、移除远程分支"><a href="#五、移除远程分支" class="headerlink" title="五、移除远程分支"></a>五、移除远程分支</h2><p>git remote remove xxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git remote remove main</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：记录使用git–Fork代码更新与同步&quot;&gt;&lt;a href=&quot;#摘要：记录使用git–Fork代码更新与同步&quot; class=&quot;headerlink&quot; title=&quot;摘要：记录使用git–Fork代码更新与同步&quot;&gt;&lt;/a&gt;摘要：记录使用git–Fork代码更新与同步&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/categories/git/"/>
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>重写TreeMap的比较器(Comparator)引发的问题（源码分析）</title>
    <link href="https://www.blog.ajie39.top/2022/01/16/%E9%87%8D%E5%86%99TreeMap%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8(Comparator)%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98(%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/"/>
    <id>https://www.blog.ajie39.top/2022/01/16/%E9%87%8D%E5%86%99TreeMap%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8(Comparator)%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98(%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/</id>
    <published>2022-01-16T06:58:04.646Z</published>
    <updated>2022-01-17T12:49:26.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。"><a href="#摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。" class="headerlink" title="摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。"></a>摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。</h1><hr><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>1、给一个无序的map，按照value的值进行排序，value值越小，排在越前面。<br>2、key和value都不为null<br>3、value可能相同<br>4、返回结果为一个相同的有序map</p><p>代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，key=商品id，value=商品剩余库存</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1L</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2L</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="number">3L</span>, <span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，大家可以先想想，如果是你会怎么解决？</p><span id="more"></span><h2 id="我的解决思路"><a href="#我的解决思路" class="headerlink" title="我的解决思路"></a>我的解决思路</h2><p>1、使用TreeMap，因为TreeMap可以对元素进行排序<br>2、重写TreeMap的比较器</p><p>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 承接上面的代码</span></span><br><span class="line"><span class="comment">// 按照 value 排序</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap1 = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long o1, Long o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、如果v1等于v2，则值为0</span></span><br><span class="line">        <span class="comment">// 2、如果v1小于v2，则值为-1</span></span><br><span class="line">        <span class="comment">// 3、如果v1等于v2，则值为1</span></span><br><span class="line">        Integer value1 = map.get(o1);</span><br><span class="line">        Integer value2 = map.get(o2);</span><br><span class="line">        <span class="keyword">return</span> value1.compareTo(value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap1.putAll(map);</span><br><span class="line">System.out.println(treeMap1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>what？为什么我们添加了3个元素，结果少了一个呢？</p><p><img src="/img/image/blog/20220116/%E7%96%91%E9%97%AE.jpg" alt="疑问"></p><h2 id="TreeMap-putAll源码分析"><a href="#TreeMap-putAll源码分析" class="headerlink" title="TreeMap putAll源码分析"></a>TreeMap putAll源码分析</h2><p>让我们来看看 putAll 的具体过程</p><h3 id="1、分析-TreeMap-putAll"><a href="#1、分析-TreeMap-putAll" class="headerlink" title="1、分析 TreeMap.putAll"></a>1、分析 TreeMap.putAll</h3><p>源码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、获取待添加的map的大小</span></span><br><span class="line">    <span class="keyword">int</span> mapSize = map.size();</span><br><span class="line">    <span class="comment">// 二、当前的size大小等于0 且 待添加的map的大小不等于0 且 待添加的map是SortedMap的实现类，则执行以下逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span> &amp;&amp; mapSize!=<span class="number">0</span> &amp;&amp; map <span class="keyword">instanceof</span> SortedMap) &#123;</span><br><span class="line">        <span class="comment">// 1、获取待添加的map的比较器</span></span><br><span class="line">        Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator();</span><br><span class="line">        <span class="comment">// 2、如果两个比较器相同，则执行以下逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (c == comparator || (c != <span class="keyword">null</span> &amp;&amp; c.equals(comparator))) &#123;</span><br><span class="line">            <span class="comment">// 3、修改次数+1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4、基于排序数据的线性时间树构建算法，进行build</span></span><br><span class="line">                buildFromSorted(mapSize, map.entrySet().iterator(),</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三、如果不符合上面的条件，则执行父类的 putAll 方法</span></span><br><span class="line">    <span class="keyword">super</span>.putAll(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面源码，不难看出，我们的数据符合 流程二，但是不符合 流程二-2，所以我们会执行父类的 putAll 方法，即流程三。</p><h3 id="2、分析-AbstractMap-putAll"><a href="#2、分析-AbstractMap-putAll" class="headerlink" title="2、分析 AbstractMap.putAll"></a>2、分析 AbstractMap.putAll</h3><p>TreeMap 继承 AbstractMap，所以 super.putAll(map)，执行的 putAll 为 AbstractMap 的 putAll 方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 m map，将它所有的值，使用put方法，全部添加到当前的map中</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码简单，就是一个遍历添加元素的。</p><p>但是有一个问题，这里的 put 方法执行的是谁的 put 方法呢？</p><ul><li>1、AbstractMap.put</li><li>2、TreeMap.put</li></ul><p>这里大家可以先思考1分钟，然后再继续往下看。</p><p>答案是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行的是 TreeMap.put</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回答错误 or 不知道真实原因的小伙伴，可以去网上搜搜答案，这里是一个很重要的基础知识点哦。</p><h3 id="3、分析-TreeMap-put"><a href="#3、分析-TreeMap-put" class="headerlink" title="3、分析 TreeMap.put"></a>3、分析 TreeMap.put</h3><p>源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、获取根节点</span></span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">// 二、判断跟节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 类型检查 and null 检查</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> TreeMap.Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 三、如果比较器不为空，则执行一下逻辑，即自定义比较器执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 1、将t节点赋值给parent</span></span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 2、比较t节点的key是否与待添加的key相等</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="comment">// 3、如果返回值小于0，则将左子树赋值给t节点，即后续遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="comment">// 4、如果返回值大于0，则将右子树赋值给t节点，即后续遍历右子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 5、如果返回值为0，则覆盖原来的值</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四、如果比较器为空，则执行以下逻辑，即默认执行逻辑</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这部分逻辑，先忽略</span></span><br><span class="line">    &#125;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; e = <span class="keyword">new</span> TreeMap.Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们结合上面的源码和我们自定义的排序器，就可以发现以下问题：</p><p>1、我们比较的是两个 value 的大小，而 value 可能是一样的。</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A81.jpg" alt="比较器1"></p><p>这种情况下，就会覆盖原来的值，这个就是我们执行 putAll 后，元素缺失的原因了。</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A82.jpg" alt="比较器2"></p><p>好了既然问题找到了，那如何解决这个问题呢？</p><p>如果是你，你会怎么解决呢？可以花一分钟时间思考一下，再看后面的内容。</p><h3 id="4、解决-TreeMap-putAll，元素缺失的问题"><a href="#4、解决-TreeMap-putAll，元素缺失的问题" class="headerlink" title="4、解决 TreeMap.putAll，元素缺失的问题"></a>4、解决 TreeMap.putAll，元素缺失的问题</h3><p>我当时想到最直接的方案就是，在 value 相等的情况下，不返回 0，返回1 or -1，这样就可以最简单、最快捷的解决这个问题了。</p><p>修改后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里换了一种写法，是java8的特性，简化了代码（为了偷懒）</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap2 = <span class="keyword">new</span> TreeMap&lt;&gt;((key1, key2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 1、如果v1等于v2，则值为0</span></span><br><span class="line">    <span class="comment">// 2、如果v1小于v2，则值为-1</span></span><br><span class="line">    <span class="comment">// 3、如果v1等于v2，则值为1</span></span><br><span class="line">    Integer value1 = map.get(key1);</span><br><span class="line">    Integer value2 = map.get(key2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value1.compareTo(value2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">treeMap2.putAll(map);</span><br><span class="line">System.out.println(treeMap2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>=<span class="number">10</span>, <span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以发现，3个值都有了，并且是有序的，完美符合需求！好了，关机下班！</p><p><img src="/img/image/blog/20220116/%E5%85%B3%E6%9C%BA%E4%B8%8B%E7%8F%AD.webp" alt="关机下班"></p><p>然而事情并没有结束<strong>（大家可以想一下，这样写会有什么问题呢？）</strong>！</p><h2 id="新的问题出现"><a href="#新的问题出现" class="headerlink" title="新的问题出现"></a>新的问题出现</h2><p>第二天，高高兴兴的写着业务代码、调试逻辑，突然一个<strong>空指针</strong>的报错，出现了。这也太常见了吧，3分钟内解决！</p><p><img src="/img/image/blog/20220116/2000%E5%B9%B4%E4%B9%8B%E5%90%8E.jpeg" alt="2000年之后"></p><p>排查了半天，发现又回到了昨天的修改的那段逻辑了。</p><h3 id="1、TreeMap-get-获取不到值"><a href="#1、TreeMap-get-获取不到值" class="headerlink" title="1、TreeMap.get 获取不到值"></a>1、TreeMap.get 获取不到值</h3><p>简化版代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，key=商品id，value=商品剩余库存</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1L</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2L</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="number">3L</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap2 = <span class="keyword">new</span> TreeMap&lt;&gt;((key1, key2) -&gt; &#123;</span><br><span class="line">    Integer value1 = map.get(key1);</span><br><span class="line">    Integer value2 = map.get(key2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value1.compareTo(value2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap2.putAll(map);</span><br><span class="line">System.out.println(treeMap2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取商品1的剩余数量</span></span><br><span class="line">Integer quantity = treeMap2.get(<span class="number">1L</span>);</span><br><span class="line">System.out.println(quantity);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>=<span class="number">10</span>, <span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个结果令我百思不得其解，只能看看源码咯。</p><h3 id="2、分析-TreeMap-get"><a href="#2、分析-TreeMap-get" class="headerlink" title="2、分析 TreeMap.get"></a>2、分析 TreeMap.get</h3><p>源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据key获取节点</span></span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="comment">// 节点为空则返回null，否则返回节点的 value 值</span></span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、如果比较器不为空，则执行一下逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 1、使用自定义比较器取出key对应的节点</span></span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// 二、如果比较器为空，且key为null，则抛空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">// 三、取出key对应的节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码，我们可以发现，问题肯定就是出现在 getEntryUsingComparator 方法里了。</p><h3 id="2、分析-TreeMap-getEntryUsingComparator"><a href="#2、分析-TreeMap-getEntryUsingComparator" class="headerlink" title="2、分析 TreeMap.getEntryUsingComparator"></a>2、分析 TreeMap.getEntryUsingComparator</h3><p>源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、将key转换成对应的类型</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    K k = (K) key;</span><br><span class="line">    <span class="comment">// 二、获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 三、判断比较器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、遍历map，取出key对应的节点对象</span></span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="comment">// 2、如果小于0，则将左节点的值赋值给p</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="comment">// 3、如果大于0，则将右节点的值赋值给p</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 4、如果等于0，则返回p节点</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合上面的源码，和我们之前自定义的比较器，我们不难发现问题出现在哪里：</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A83.jpg" alt="比较器3"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自定义比较器，没有返回0的情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题找到了，解决吧！<br>加班中，今天到此结束！<br>啊杰，在这里谢谢大家的观看，下次再见。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot;&gt;&lt;a href=&quot;#摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot; class=&quot;headerlink&quot; title=&quot;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot;&gt;&lt;/a&gt;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;1、给一个无序的map，按照value的值进行排序，value值越小，排在越前面。&lt;br&gt;2、key和value都不为null&lt;br&gt;3、value可能相同&lt;br&gt;4、返回结果为一个相同的有序map&lt;/p&gt;
&lt;p&gt;代码如下所示:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 假设，key=商品id，value=商品剩余库存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Map&amp;lt;Long, Integer&amp;gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;2L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;3L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;到这里，大家可以先想想，如果是你会怎么解决？&lt;/p&gt;</summary>
    
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    <category term="Map" scheme="https://www.blog.ajie39.top/tags/Map/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="源码分析" scheme="https://www.blog.ajie39.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Jackson序列化时间类型的数据导致的相关问题</title>
    <link href="https://www.blog.ajie39.top/2021/12/03/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://www.blog.ajie39.top/2021/12/03/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-02T17:17:52.573Z</published>
    <updated>2022-02-04T15:03:56.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。"><a href="#前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。" class="headerlink" title="前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。"></a>前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。</h1><hr><span id="more"></span><h2 id="1、现象"><a href="#1、现象" class="headerlink" title="1、现象"></a>1、现象</h2><p>在开发国际化项目中发现，数据库取出的时间和对象拿到的时间都是一致的，但是通过 postman 调用接口展示的时候，时间和数据库的时间相差8小时。</p><h2 id="2、原因"><a href="#2、原因" class="headerlink" title="2、原因"></a>2、原因</h2><p>SpringBoot 默认使用 Jackson 为序列化工具，Jackson 在没有指定序列化和反序列化形式的情况下，会采用默认的序列化方式。</p><p>其中 date 类型的数据，默认的序列化格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ</span><br><span class="line">例如：</span><br><span class="line"> 2021-06-08T05:43:28.000+0000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中时间的默认时区为UTC+0，在传输的过程中，会以字符串的形式按照上面的格式进行序列化。而国内的时区是 UTC+8，所以最终时间会相差 8小时。</p><p>各个符号解释：</p><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>YYYY</td><td>is the decimal digits of the year 0000 to 9999 in the Gregorian calendar.</td></tr><tr><td>-</td><td>“-“ (hyphen) appears literally twice in the string.</td></tr><tr><td>MM</td><td>is the month of the year from 01 (January) to 12 (December).</td></tr><tr><td>DD</td><td>is the day of the month from 01 to 31.</td></tr><tr><td>T</td><td>“T” appears literally in the string, to indicate the beginning of the time element.</td></tr><tr><td>HH</td><td>is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.</td></tr><tr><td>:</td><td>“:” (colon) appears literally twice in the string.</td></tr><tr><td>mm</td><td>is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.</td></tr><tr><td>ss</td><td>is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.</td></tr><tr><td>.</td><td>“.” (dot) appears literally in the string.</td></tr><tr><td>sss</td><td>is the number of complete milliseconds since the start of the second as three decimal digits.</td></tr><tr><td>Z</td><td>is the time zone offset specified as “Z” (for UTC) or either “+” or “-“ followed by a time expression HH:mm</td></tr></tbody></table><h2 id="3、解决"><a href="#3、解决" class="headerlink" title="3、解决"></a>3、解决</h2><h3 id="①前端拿到这样的数据的时候，需要做如下处理："><a href="#①前端拿到这样的数据的时候，需要做如下处理：" class="headerlink" title="①前端拿到这样的数据的时候，需要做如下处理："></a>①前端拿到这样的数据的时候，需要做如下处理：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Date(&#39;2021-06-08T05:43:28.000+0000&#39;)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">moment(date).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化前后的区别：</p><p><img src="/img/image/blog/20220204/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt="格式化后的效果"></p><h3 id="②如果使用-Fegin-Client"><a href="#②如果使用-Fegin-Client" class="headerlink" title="②如果使用 Fegin Client"></a>②如果使用 Fegin Client</h3><p>需要确认服务端的时间格式，如果没有指定格式，则使用默认格式。</p><p>具体使用：在对应字段加上 @JsonFormat 注解即可，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING, pattern &#x3D; &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;)</span><br><span class="line">private Date inserttime;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="③SpringBoot-全局配置-JsonFormat-date的序列化方式"><a href="#③SpringBoot-全局配置-JsonFormat-date的序列化方式" class="headerlink" title="③SpringBoot 全局配置 JsonFormat date的序列化方式"></a>③SpringBoot 全局配置 JsonFormat date的序列化方式</h3><p>在 application.yml 文件加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ssZ</span><br><span class="line">  mvc:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ssZ</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、其他问题"><a href="#4、其他问题" class="headerlink" title="4、其他问题"></a>4、其他问题</h2><p>①支持 Java 8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-datatype-jsr310&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在添加 JSR-310 模块后, 让 jackson 能够识别出 Java 8 的日期 &amp; 时间类型(pom.xml)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/aerchi/article/details/78717232">https://blog.csdn.net/aerchi/article/details/78717232</a></p><p><a href="https://xiaoym.gitee.io/2021/03/26/spring-boot-code-action-jackson/">https://xiaoym.gitee.io/2021/03/26/spring-boot-code-action-jackson/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。&quot;&gt;&lt;a href=&quot;#前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。&quot; class=&quot;headerlink&quot; title=&quot;前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。&quot;&gt;&lt;/a&gt;前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Jackson" scheme="https://www.blog.ajie39.top/tags/Jackson/"/>
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
