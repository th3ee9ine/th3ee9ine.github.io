<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教练，我想学技术!</title>
  
  <subtitle>开局一双手，升级全靠苟，拼一拼，搏一搏，单车变摩托。</subtitle>
  <link href="https://www.blog.ajie39.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.ajie39.top/"/>
  <updated>2021-05-05T08:16:35.704Z</updated>
  <id>https://www.blog.ajie39.top/</id>
  
  <author>
    <name>th3ee9ine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 之从面试题到原理（拓展篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:16:46.258Z</published>
    <updated>2021-05-05T08:16:35.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？<br>2、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>3、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？<br>4、Redis 常见性能问题和解决方案？</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（基础篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:16:46.257Z</published>
    <updated>2021-05-05T08:16:25.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、说说 Redis 哈希槽的概念？<br>2、Redis 的同步机制了解么？<br>3、是否使用过 Redis 集群，集群的原理是什么？<br>4、Redis 集群方案什么情况下会导致整个集群不可<br>5、Redis 集群的主从复制模型是怎样的？<br>6、Redis 集群会有写操作丢失吗？为什么？<br>7、Redis 集群之间是如何复制的？<br>8、Redis 集群最大节点个数是多少？<br>9、Redis 集群如何选择数据库？<br>10、如何实现集群中的 session 共享存储？</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（基础篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T07:39:46.014Z</published>
    <updated>2021-05-05T08:16:30.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、Redis 是什么?<br>2、Redis 的数据类型？<br>3、使用 Redis 有哪些好处？<br>4、Redis 是单进程单线程的？<br>5、Redis 是单线程的，如何提高多核 CPU 的利用率？<br>6、一个字符串类型的值能存储最大容量是多少？<br>7、Redis 的持久化机制是什么？各自的优缺点？<br>8、Redis 常见性能问题和解决方案：<br>9、Redis 过期键的删除策略？<br>10、Redis 的回收策略（淘汰策略）?<br>11、为什么 Redis 需要把所有数据放到内存中？<br>12、Redis 支持的 Java 客户端都有哪些？<br>13、Jedis 与 Redisson 对比有什么优缺点？<br>14、Redis 如何设置密码及验证密码？<br>15、Pipeline 有什么好处，为什么要用 pipeline？<br>16、怎么理解 Redis 事务？<br>17、Redis 事务相关的命令有哪几个？<br>18、Redis key 的过期时间和永久有效分别怎么设置？<br>19、Redis 如何做内存优化？<br>20、Redis 回收进程如何工作的？<br>21、都有哪些办法可以降低 Redis 的内存使用情况呢？<br>22、Redis 的内存用完了会发生什么？<br>23、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？<br>24、查看 Redis 使用情况及状态信息用什么命令？<br>25、怎么测试 Redis 的连通性？<br>26、Redis 提供了哪几种持久化方式？<br>27、如何选择合适的持久化方式？<br>28、修改配置不重启 Redis 会实时生效吗？<br>29、使用过 Redis 分布式锁么，它是什么回事？<br>30、使用过 Redis 做异步队列么，你是怎么用的？<br>31、Redis 最适合的场景？</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁原理分析与应用</title>
    <link href="https://www.blog.ajie39.top/2021/04/30/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://www.blog.ajie39.top/2021/04/30/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-04-30T13:53:06.943Z</published>
    <updated>2021-05-05T07:54:48.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是介绍分布式锁相关的内容。"><a href="#摘要：这篇文章主要是介绍分布式锁相关的内容。" class="headerlink" title="摘要：这篇文章主要是介绍分布式锁相关的内容。"></a>摘要：这篇文章主要是介绍分布式锁相关的内容。</h1><hr><h1 id="前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"><a href="#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。" class="headerlink" title="前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"></a>前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。</h1><hr><span id="more"></span><h2 id="分布式锁的使用场景"><a href="#分布式锁的使用场景" class="headerlink" title="分布式锁的使用场景"></a>分布式锁的使用场景</h2><ul><li><p>效率性:使用分布式锁可以避免不同节点重复相同的工作。</p></li><li><p>正确性:分布式锁可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</p></li></ul><h2 id="分布式锁的几种特性"><a href="#分布式锁的几种特性" class="headerlink" title="分布式锁的几种特性"></a>分布式锁的几种特性</h2><ul><li><p>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</p></li><li><p>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</p></li><li><p>锁超时:和本地锁一样支持锁超时，防止死锁。</p></li><li><p>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</p></li><li><p>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</p></li><li><p>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。</p></li></ul><h2 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h2><p>分布式锁有以下几个方式:</p><ul><li>MySql</li><li>Zk</li><li>Redis</li><li>一些自研的分布式锁(Chubby)</li></ul><h3 id="一、基于-Mysql-实现分布式锁"><a href="#一、基于-Mysql-实现分布式锁" class="headerlink" title="一、基于 Mysql 实现分布式锁"></a>一、基于 Mysql 实现分布式锁</h3><p>1、首先，我们需要创建一个锁表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &#96;resource_lock&#96; (</span><br><span class="line">    &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;resource_name&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;资源名称&#39;,</span><br><span class="line">    &#39;node_info&#39; varchar(128) DEFAULT &#39;0&#39; COMMENT &#39;节点信息&#39;,</span><br><span class="line">    &#39;count&#39; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT  &#39;锁的次数，统计可重入锁&#39;,</span><br><span class="line">    &#39;desc&#39; varchar(128) DEFAULT NULL COMMENT &#39;额外的描述信息&#39;,</span><br><span class="line">    &#96;create_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">    &#96;update_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,</span><br><span class="line">    PRIMARY KEY (&#39;id&#39;),</span><br><span class="line">    UNIQUE KEY &#39;un_resource_name&#39; (&#39;resource_name&#39;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、lock</p><p>先进行查询，如果有值，那么需要比较 node_info 是否一致，这里的 node_info 可以用机器 IP 和线程名字来表示，如果一致那么就加可重入锁 count 的值，如果不一致那么就返回 false 。如果没有值那么直接插入一条数据。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加事务，原子性</span><br><span class="line">@Transaction</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断节点信息是否一致</span><br><span class="line">        if (currentNodeInfo &#x3D;&#x3D; resultNodeInfo) &#123;</span><br><span class="line">            &#x2F;&#x2F; 保住锁的可重入性</span><br><span class="line">            update resource_lock set count &#x3D; count + 1 where resource_name &#x3D; &#39;xxx&#39;;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 插入新数据</span><br><span class="line">        insert into resourceLock;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、tryLock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean tryLock(long timeOut) &#123;</span><br><span class="line">    long stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    long endTimeOut &#x3D; stTime + timeOut;</span><br><span class="line"></span><br><span class="line">    while (endTimeOut &gt; stTime) &#123;</span><br><span class="line">        if (mysqlLock.lock()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 休眠3s后重试</span><br><span class="line">        LockSupport.parkNanos(1000 * 1000 * 1000 * 1);</span><br><span class="line">        stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、unlock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Transaction</span><br><span class="line">public boolean unlock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 查询是否有数据</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; count为1那么可以删除，如果大于1那么需要减去1。</span><br><span class="line">        if (count &gt; 1) &#123;</span><br><span class="line">            update count &#x3D; count - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、定时清理因为机器宕机导致的锁未被释放的问题</p><p>启动一个定时任务，当这个锁远超过任务的执行时间，没有被释放我们就可以认定是节点挂了然后将其直接释放。</p><h3 id="二、基于单Redis节点的分布式锁"><a href="#二、基于单Redis节点的分布式锁" class="headerlink" title="二、基于单Redis节点的分布式锁"></a>二、基于单Redis节点的分布式锁</h3><p>首先，Redis客户端为了获取锁，向Redis节点发送如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SET resource_name my_random_value NX PX 30000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。</p><p>注意，在上面的SET命令中：</p><ul><li>my_random_value是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。</li><li>NX表示只有当resource_name对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</li><li>PX 30000表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。</li></ul><p>最后，当客户端完成了对共享资源的操作之后，执行下面的Redis Lua脚本来释放锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">     return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line"> else</span><br><span class="line">     return 0</span><br><span class="line"> end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段Lua脚本在执行的时候要把前面的my_random_value作为 ARGV[1] 的值传进去，把 resource_name 作为 KEYS[1] 的值传进去。</p><p>至此，基于单Redis节点的分布式锁的算法就描述完了。</p><h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><h5 id="第一点：过期时间"><a href="#第一点：过期时间" class="headerlink" title="第一点：过期时间"></a>第一点：过期时间</h5><p>首先第一个问题，这个锁必须要设置一个过期时间。<br>否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了，而且把这个过期时间称为锁的有效时间(lock validity time)。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p><h5 id="第二点：获取锁"><a href="#第二点：获取锁" class="headerlink" title="第二点：获取锁"></a>第二点：获取锁</h5><p>第二个问题，第一步获取锁的操作，网上不少文章把它实现成了两个Redis命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SETNX resource_name my_random_value</span><br><span class="line">EXPIRE resource_name 30</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然这两个命令和前面算法描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。</p><h5 id="第三点：my-random-value"><a href="#第三点：my-random-value" class="headerlink" title="第三点：my_random_value"></a>第三点：my_random_value</h5><p>第三个问题，设置一个随机字符串 my_random_value 是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。</p><p>假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1在某个操作上阻塞了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</li><li>之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。</li></ul><h5 id="第四点：Lua脚本"><a href="#第四点：Lua脚本" class="headerlink" title="第四点：Lua脚本"></a>第四点：Lua脚本</h5><p>第四个问题，释放锁的操作必须使用Lua脚本来实现。释放锁其实包含三步操作：获取、判断和删除，用Lua脚本来实现能保证这三步的原子性。</p><p>否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面第三个问题类似的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1访问共享资源。</li><li>客户端1为了释放锁，先执行’GET’操作获取随机字符串的值。</li><li>客户端1判断随机字符串的值，与预期的值相等。</li><li>客户端1由于某个原因阻塞住了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</li></ul><p>实际上，在上述第三个问题和第四个问题的分析中，如果不是客户端阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。</p><p>这四个问题，只要实现分布式锁的时候加以注意，就都能够被正确处理。</p><p>但除此之外，还有一个问题，是由 failover（故障转移） 引起的，却是基于单Redis节点的分布式锁无法解决的。正是这个问题催生了Redlock的出现。</p><h5 id="多个Redis节点的情况下会产生的问题"><a href="#多个Redis节点的情况下会产生的问题" class="headerlink" title="多个Redis节点的情况下会产生的问题"></a>多个Redis节点的情况下会产生的问题</h5><p>这个问题是这样的。假如Redis节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。</p><p>例如下面的执行序列：</p><ul><li>客户端1从Master获取了锁。</li><li>Master宕机了，存储锁的key还没有来得及同步到Slave上。</li><li>Slave升级为Master。</li><li>客户端2从新的Master获取到了对应同一个资源的锁。</li></ul><p>于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。</p><h4 id="三、分布式锁-Redlock"><a href="#三、分布式锁-Redlock" class="headerlink" title="三、分布式锁 Redlock"></a>三、分布式锁 Redlock</h4><p>前面介绍的基于单Redis节点的分布式锁在failover的时候会产生解决不了的安全性问题，因此antirez提出了新的分布式锁的算法Redlock，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p><p>运行Redlock算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p><p>1、获取当前时间（毫秒数）。</p><p>2、按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</p><p>3、计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p><p>4、如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p><p>5、如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p><p>上面描述的只是获取锁的过程，而释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p><p>由于N个Redis节点中的大多数能正常工作就能保证Redlock正常工作，因此理论上它的可用性更高。我们前面讨论的单Redis节点的分布式锁在failover的时候锁失效的问题，在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟Redis对数据的持久化程度有关。</p><h5 id="节点崩溃可能导致的问题"><a href="#节点崩溃可能导致的问题" class="headerlink" title="节点崩溃可能导致的问题"></a>节点崩溃可能导致的问题</h5><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><p>1、客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</p><p>2、节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</p><p>3、节点C重启后，客户端2锁住了C, D, E，获取锁成功。</p><p>4、这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p>在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez又提出了延迟重启(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><h5 id="客户端应该向所有Redis节点发起释放锁的操作？"><a href="#客户端应该向所有Redis节点发起释放锁的操作？" class="headerlink" title="客户端应该向所有Redis节点发起释放锁的操作？"></a>客户端应该向所有Redis节点发起释放锁的操作？</h5><p>在最后释放锁的时候，antirez在算法描述中特别强调，客户端应该向所有Redis节点发起释放锁的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？</p><p>设想这样一种情况，客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p><h3 id="四、基于zk实现分布式锁"><a href="#四、基于zk实现分布式锁" class="headerlink" title="四、基于zk实现分布式锁"></a>四、基于zk实现分布式锁</h3><p>ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。Zk的数据节点和文件目录类似，所以我们可以用此特性实现分布式锁。</p><p>基本实现步骤如下：</p><p>1、客户端尝试创建一个znode节点，比如/lock。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode已存在），获取锁失败。</p><p>2、持有锁的客户端访问共享资源完成后，将znode删掉，这样其它客户端接下来就能来获取锁了。</p><p>注意：<br>  这里的znode应该被创建成ephemeral的（临时节点）。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除。这保证了锁一定会被释放。</p><h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><p>看起来这个锁相当完美，没有Redlock过期时间的问题，而且能在需要的时候让锁自动释放。但其实也存在这其中也存在问题。</p><p>ZooKeeper是怎么检测出某个客户端已经崩溃了呢？实际上，每个客户端都与ZooKeeper的某台服务器维护着一个Session，这个Session依赖定期的心跳(heartbeat)来维持。如果ZooKeeper长时间收不到客户端的心跳（这个时间称为Sesion的过期时间），那么它就认为Session过期了，通过这个Session所创建的所有的ephemeral类型的znode节点都会被自动删除。</p><p>假如按照下面的顺序执行：</p><p>1、客户端1创建了znode节点/lock，获得了锁。</p><p>2、客户端1进入了长时间的GC pause。</p><p>3、客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。</p><p>4、客户端2创建了znode节点/lock，从而获得了锁。</p><p>5、客户端1从GC pause中恢复过来，它仍然认为自己持有锁。</p><p>由上面的执行顺序，可以发现最后客户端1和客户端2都认为自己持有了锁，冲突了。所以说，用ZooKeeper实现的分布式锁也不一定就是安全的，该有的问题它还是有。</p><h4 id="zk的watch机制"><a href="#zk的watch机制" class="headerlink" title="zk的watch机制"></a>zk的watch机制</h4><p>ZooKeeper有个很特殊的机制–watch机制。这个机制可以这样来使用，比如当客户端试图创建 /lock 节点的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6844903688088059912">https://juejin.cn/post/6844903688088059912</a></li><li>Redlock的算法：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></li><li><a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></li><li>linux的同步IO操作函数: sync、fsync与fdatasync：<a href="https://my.oschina.net/u/1377774/blog/529847">https://my.oschina.net/u/1377774/blog/529847</a></li><li><a href="https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w">https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是介绍分布式锁相关的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是介绍分布式锁相关的内容。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;a href=&quot;#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;/a&gt;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://www.blog.ajie39.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
    <category term="分布式锁" scheme="https://www.blog.ajie39.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>面试基础题之《面向对象》</title>
    <link href="https://www.blog.ajie39.top/2020/08/16/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B/"/>
    <id>https://www.blog.ajie39.top/2020/08/16/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B/</id>
    <published>2020-08-16T09:46:55.312Z</published>
    <updated>2021-05-05T04:24:11.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。"><a href="#摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。" class="headerlink" title="摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。"></a>摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。</h1><hr><h1 id="前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。"><a href="#前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。" class="headerlink" title="前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。"></a>前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。</h1><hr><span id="more"></span><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>抽象方法必须使用abstract关键字进行修饰。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中无具体实现的方法，所以不能用抽象类创建对象。</p><p>在《JAVA编程思想》一书中，将抽象类定义为 <strong>“包含抽象方法的类”</strong> ，但是如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。例如下面的两个类，都是抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">        System.out.println(st);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">        System.out.println(st);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><p>包含抽象方法的类称为抽象类(但是抽象类不一定要拥有抽象方法)，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p><ol><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li><li>抽象类不能用来创建对象；</li><li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口中可以含有变量和方法。</p><ul><li><p>接口中的变量会被隐式地指定为 public static final 变量（并且只能是 public static final变量，用 private 修饰会报编译错误）。</p></li><li><p>方法会被隐式地指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、 final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现（Java8以后，接口中可以提供方法的默认实现），也就是说，接口中的方法必须都是抽象方法。</p></li></ul><p>从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加”抽象”，并且一般情况下不在接口中定义变量。在 Java 中，定一个接口如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p>1、语法层面上的区别</p><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><p>2、设计层面上的区别</p><p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。也就是说接口中的方法，必须是这一类事物共有的特征，不能拥有属于自己的个性特征。但是抽象类拥有这一类事物共有的特征，并且还拥有自己特有的属性、方法。举个例子：动物共有的特征：交流、进食。但是每种动物又有用自己的特征，比如鸟会飞、鱼会游泳、壁虎会爬。所以如果以动物维度进行接口设计的话，则这里只能吧交流、进食等所有动物都 <strong>共有</strong> 的特征设计成接口中的方法，如果是某一类动物特有的特征，则只能设计成 <strong>更小的接口</strong> 或者 <strong>抽象方法</strong>;</p><h2 id="面向对象的四大特性：抽象、封装、继承、多态"><a href="#面向对象的四大特性：抽象、封装、继承、多态" class="headerlink" title="面向对象的四大特性：抽象、封装、继承、多态"></a>面向对象的四大特性：抽象、封装、继承、多态</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>通常认为封装是把<strong>数据</strong>和<strong>操作数据的方法</strong>绑定起来，对数据的访问<strong>只能通过已定义的接口</strong>。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是<strong>隐藏一切可隐藏的东西</strong>，只向外界<strong>提供最简单的编程接口</strong>。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是<strong>从已有类得到继承信息创建新类的过程</strong>。提供继承信息的类被称为 <strong>父类（超类、基类）</strong>；得到继承信息的类被称为 <strong>子类（派生类）</strong>。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（桥梁模式）。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态性是指允许<strong>不同类型的对象对同一消息作出不同的响应</strong>。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为<strong>编译时的多态性</strong>和<strong>运行时的多态性</strong>。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。 <strong>方法重载（overload）</strong> 实现的是 <strong>编译时的多态性</strong>（也称为前绑定），而 <strong>方法重写（override）</strong> 实现的是 <strong>运行时的多态性</strong>（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><ol><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）。</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ol><p>总结：</p><ol><li><p>在同一个方法中，这种由于参数类型不同而导致执行效果各异的现象就是多态。</p></li><li><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><ul><li><strong>继承</strong>：在多态中必须存在有继承关系的子类和父类。</li><li><strong>重写</strong>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li><strong>向上转型</strong>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul></li><li><p>指向子类的父类引用由于向上转型了，<strong>它只能访问父类中拥有的方法和属性</strong>，而对于<strong>子类中存在而父类中不存在的方法，该引用是不能使用的</strong>，尽管是重载该方法。<strong>若子类重写了父类中的某些方法</strong>，在调用该些方法的时候，<strong>必定是使用子类中定义的这些方法（动态连接、动态调用）</strong>。</p></li><li><p>instanceof可以判断一个对象是否为某个类（或接口）的实例或者子类实例。<br>语法格式：对象（或者对象引用变量） instanceof 类（或接口）</p></li><li><p>JAVA运行过程：编译，类的加载，类的执行。</p></li><li><p>多态机制遵循的原则概括为：当超类对象引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：<strong>this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</strong></p></li><li><p>只有方法具有多态性，变量不具有多态性。</p></li></ol><p><strong>以上概念，可以参考下面的代码，进行理解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(D obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;A and D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;A and A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">110</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;B and B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;B and A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> B();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        System.out.println(<span class="string">&quot;1--&quot;</span> + a1.show(b));</span><br><span class="line">        System.out.println(<span class="string">&quot;2--&quot;</span> + a1.show(c));</span><br><span class="line">        System.out.println(<span class="string">&quot;3--&quot;</span> + a1.show(d));</span><br><span class="line">        System.out.println(<span class="string">&quot;4--&quot;</span> + a2.show(b) + <span class="string">&quot; &quot;</span> + a2.s);</span><br><span class="line">        System.out.println(<span class="string">&quot;5--&quot;</span> + a2.show(c));</span><br><span class="line">        System.out.println(<span class="string">&quot;6--&quot;</span> + a2.show(d));</span><br><span class="line">        System.out.println(<span class="string">&quot;7--&quot;</span> + b.show(b));</span><br><span class="line">        System.out.println(<span class="string">&quot;8--&quot;</span> + b.show(c));</span><br><span class="line">        System.out.println(<span class="string">&quot;9--&quot;</span> + b.show(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span>--A and A</span><br><span class="line"><span class="number">2</span>--A and A</span><br><span class="line"><span class="number">3</span>--A and D</span><br><span class="line"><span class="number">4</span>--B and A <span class="number">10</span></span><br><span class="line"><span class="number">5</span>--B and A</span><br><span class="line"><span class="number">6</span>--A and D</span><br><span class="line"><span class="number">7</span>--B and B</span><br><span class="line"><span class="number">8</span>--B and B</span><br><span class="line"><span class="number">9</span>--A and D</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="问题时刻"><a href="#问题时刻" class="headerlink" title="问题时刻"></a>问题时刻</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Father father = <span class="keyword">new</span> Son();</span><br><span class="line">        father.show(map);</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.show(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Map map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father执行......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(HashMap map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son执行......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请给出上面代码的运行结果，并思考上面代码存在的问题。</p><p>答：<br>运行结果为：<br>Father执行……<br>Son执行……</p><p>存在的问题：Son类实际上是重载了show方法，而不是重写。Son类没有遵循里氏替换原则。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。&quot;&gt;&lt;a href=&quot;#摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。&quot; class=&quot;headerlink&quot; title=&quot;摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。&quot;&gt;&lt;/a&gt;摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。&quot;&gt;&lt;a href=&quot;#前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。&quot; class=&quot;headerlink&quot; title=&quot;前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。&quot;&gt;&lt;/a&gt;前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面试题目总结</title>
    <link href="https://www.blog.ajie39.top/2020/08/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2020/08/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-15T06:54:53.062Z</published>
    <updated>2021-05-05T04:24:19.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。"><a href="#摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。" class="headerlink" title="摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。"></a>摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。</h1><hr><h1 id="前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。"><a href="#前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。" class="headerlink" title="前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。"></a>前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。</h1><hr><span id="more"></span><h2 id="一、基础问题"><a href="#一、基础问题" class="headerlink" title="一、基础问题"></a>一、基础问题</h2><ol><li><p>volatile相关:<br><a href="https://www.blog.ajie.xin/2020/08/15/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8Avolatile%E3%80%8B/">面试基础题之《Volatile》</a></p></li><li><p>接口和抽象类的区别<br><a href="https://www.blog.ajie.xin/2020/08/16/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B">面试基础题之《面向对象》</a></p></li><li><p>面向对象四大特性：继承、封装、多态、抽象<br><a href="https://www.blog.ajie.xin/2020/08/16/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B">面试基础题之《面向对象》</a></p></li><li><p>HashMap的数据结构、查询时间复杂度、是否线程安全</p></li><li><p>数组和链表的差异，优缺点，使用场景</p></li><li><p>请给出你记忆的基本的数据结构有哪些？他们分别有什么特征？对应Java里面的哪些类？</p></li><li><p>线程池 ThreadPoolExecutor 类构造函数的参数有哪些，分别代表什么意思</p></li><li><p>针对候选人说Mysql熟悉的，询问候选人Mysql 聚簇索引的概念</p></li><li><p>针对候选人说Mysql熟悉的，询问候选人建表时，建索引有哪些原则或优化技巧</p></li><li><p>如何解决慢查询</p></li><li><p>说出几种设计模式，并针对其中一种做详细解释，包括使用场景，实现方法，好处</p></li><li><p>针对候选人说Redis熟悉的，询问候选人redis有哪些数据结构，每种数据结构有哪些使用场景</p></li><li><p>针对用Redis做过分布式锁的，询问候选人Redis可以做分布式锁的原因，怎样做分布式锁，有哪些步骤，需要注意什么</p></li></ol><h2 id="二、进阶问题"><a href="#二、进阶问题" class="headerlink" title="二、进阶问题"></a>二、进阶问题</h2><ol><li>ConcurrentHashMap 线程安全的实现原理</li><li>如何判断一个类的内部实现是线程安全的，有哪些原则？怎样将一个类改造后变成线程安全的类？</li><li>数组和链表在存储海量数据时，各有什么问题？</li><li>CAS的原理，作用，什么是乐观锁，悲观锁？Java中哪些类使用到了CAS</li><li>volatile的底层原理(能答出内存栅栏即可)，产生内存可见性问题的原因(cpu cache和主存)</li><li>jdk1.8新增哪些新功能？函数式编程的优缺点？</li><li>为什么jdk8在接口里增加defalut实现，目的是为了什么？</li><li>HashMap在jdk8中用到了红黑树，作用是什么？为什么不是别的树而是红黑树？红黑树还在哪个类中被用到了？</li><li>线程池ThreadPoolExecutor在超过核心线程数时，是先放进队列里还是先扩充线程到最大线程数？有哪些拒绝策略可以使用？如果要自定义线程池创建的线程名要怎么做?</li><li>Jvm中有哪些垃圾回收器？或有哪些垃圾回收算法？如何识别一个对象是可被回收的？</li><li>如何排查频繁GC的问题？如何排查OOM？</li><li>针对候选人说Redis熟悉的，询问候选人redis的io模型或单线程为何也可以保持较快并发。并进一步询问操作系统支持的5种io模型(阻塞，非阻塞，多路复用，信号驱动，异步io)。询问java中，nio使用的是哪一种</li><li>针对候选人说Redis熟悉的，询问候选人redis如何做持久化，如果答上rdb和aof两种模式，询问两种模式的优缺点，使用场景</li><li>如何理解微服务？微服务架构解决什么问题？如何划分微服务？</li><li>如果要设计一个RPC框架，需要考虑哪些问题？</li><li>熔断和限流的概念？他们之间有什么区别？如何做限流？什么是令牌桶？如何做熔断？什么是线程隔离？</li><li>Redis做缓存，缓存的更新策略有哪些？什么是缓存雪崩？什么是缓存穿透？如何解决？</li><li>Redis如何做分布式集群？什么是一致性哈希算法？redis cluster使用的是什么算法？</li><li>注册中心zk等，和redis有什么区别？为什么它们可以用来做注册中心？原理是什么？</li><li>zk是否可以做分布式锁？原理是什么？它和redis做分布式锁有什么优缺点？</li><li>zk还可以做什么？</li><li>Java中的类加载模型是什么？为什么要有双亲委派模型？有哪些类加载器？</li><li>如何保证分布式的数据一致性？什么是分布式事务？两段式提交有什么缺点？什么是最终一致性？BASE原则？CAP理论？</li><li>如果候选人有秒杀场景基础，或高并发经验，询问候选人如何设计一个健壮的秒杀系统？</li><li>询问候选人Https的原理，为什么Https相比Http是安全的，过程是怎样的？</li><li>Java中Collections.sort或List.sort，即默认提供的排序，底层的排序算法是什么？(timsort，一种归并排序)</li><li>请列举所有你知道的排序算法，以及他们的时间复杂度？快速排序的缺点是什么？</li></ol><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><ol><li>Java是编译型语言还是解释型语言？还是两者都有？谈谈你的看法</li><li>如果候选人还写过别的语言，询问候选人你觉得Java和其他语言有什么区别？有什么优缺点？主要观察候选人对编程语言的思考</li><li>如果候选人提起zk的一致性算法，进一步询问分布式一致性领域的两军问题，拜占庭将军问题，prxos算法和raft算法，观察候选人是否理解透彻</li><li>针对一个代码老旧但是又非常核心的系统，如何做重构？谈谈你的想法？</li><li>你是如何学习新的知识的？比如如果现在让你学习Guice，你会怎么做？</li></ol><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><ol><li>作为JDK的作者，实现Java中Integer.valueOf(String s)这个函数<br>（本题考查编程功底，主干代码需要对char转int也就是ascii码有所认知和了解，经过提示还不能写出主干代码的，基本上都是野路子非科班出身，编程功底会非常差，可能会连二进制转十进制都不会算(此时可以考察候选人是否会算2进制转10进制)。<br>本题边界条件非常多，一上来就对String做null处理的加分，知道处理负数的加分，知道处理int最大值的加分，能一上来就写对完全版的给高分，不知道int最大值是多少的扣印象分）</li><li>实现一个线程死锁的代码，两个线程相互等待对方<br>（本题考察候选人多线程编程功底，有些人连怎么new一个线程出来都不知道，这道题就会写不出，如果对线程死锁理解不透彻，也会写出有问题的代码而不能真的产生死锁）</li><li>如果观察到候选人数据结构和算法能力较差，为了进一步确认这一点，会让候选人写出冒泡排序的实现，并给出一个数列来演算冒泡排序。并会询问，冒泡排序内层循环一轮之后，效果是什么(实际就是冒一个泡)？</li><li>偶尔会出到的考题：用两个栈实现一个队列、判断一个链表是否为循环链表、二叉树的中序遍历（递归写法和非递归写法）</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。&quot;&gt;&lt;a href=&quot;#摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。&quot;&gt;&lt;/a&gt;摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。&quot;&gt;&lt;a href=&quot;#前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。&quot; class=&quot;headerlink&quot; title=&quot;前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。&quot;&gt;&lt;/a&gt;前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面试基础题之《volatile》</title>
    <link href="https://www.blog.ajie39.top/2020/08/15/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8Avolatile%E3%80%8B/"/>
    <id>https://www.blog.ajie39.top/2020/08/15/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8Avolatile%E3%80%8B/</id>
    <published>2020-08-15T06:17:48.561Z</published>
    <updated>2021-05-05T04:24:15.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。"><a href="#摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。" class="headerlink" title="摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。"></a>摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。</h1><hr><h1 id="前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。"><a href="#前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。" class="headerlink" title="前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。"></a>前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。</h1><hr><span id="more"></span><h2 id="volatile关键字基本介绍"><a href="#volatile关键字基本介绍" class="headerlink" title="volatile关键字基本介绍"></a>volatile关键字基本介绍</h2><p>volatile可以看成是synchronized的一种轻量级的实现，但volatile并不能完全代替synchronized，volatile有synchronized可见性的特性，但没有synchronized原子性的特性。可见性即用volatile关键字修饰的成员变量表明该变量不存在工作线程的副本，线程每次直接都从主内存中读取，每次读取的都是最新的值，这也就保证了变量对其他线程的可见性。另外，使用volatile还能确保变量不能被重排序，保证了有序性。</p><ul><li><p>当一个变量定义为volatile之后，它将具备两种特性：</p><ul><li>保证此变量对所有线程的<strong>可见性</strong></li><li>禁止指令重排序优化</li></ul></li><li><p>volatile与synchronized的区别：</p><ul><li>1、volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</li><li>2、volatile保证数据的可见性，但是不保证原子性; 而synchronized是一种排他(互斥)的机制，既保证可见性，又保证原子性。</li><li>3、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>4、volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。</li></ul></li></ul><h2 id="保证此变量对所有线程的可见性："><a href="#保证此变量对所有线程的可见性：" class="headerlink" title="保证此变量对所有线程的可见性："></a>保证此变量对所有线程的<strong>可见性</strong>：</h2><p>当一条线程修改了这个变量的值，新值对于其他线程可以说是可以立即得知的。Java内存模型规定了所有的变量都存储在主内存，每条线程还有自己的工作内存，线程的工作内存保存了该线程使用到的变量在主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读取主内存中的变量。</p><p>知识拓展：<strong>内存可见性</strong>：</p><ul><li>概念：JVM内存模型：<strong>主内存</strong> 和 线程独立的 <strong>工作内存</strong>。Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存（比如CPU的寄存器），线程只能访问自己的工作内存，不可以访问其它线程的工作内存。工作内存中保存了主内存共享变量的副本，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。</li><li>如何保证多个线程操作主内存的数据完整性是一个难题，Java内存模型也规定了工作内存与主内存之间交互的协议，定义了8种原子操作：<ul><li>(1) lock:将主内存中的变量锁定，为一个线程所独占。</li><li>(2) unclock:将lock加的锁定解除，此时其它的线程可以有机会访问此变量。</li><li>(3) read:将主内存中的变量值读到工作内存当中。</li><li>(4) load:将read读取的值保存到工作内存中的变量副本中。</li><li>(5) use:将值传递给线程的代码执行引擎。</li><li>(6) assign:将执行引擎处理返回的值重新赋值给变量副本。</li><li>(7) store:将变量副本的值存储到主内存中。</li><li>(8) write:将store存储的值写入到主内存的共享变量当中。</li></ul></li></ul><p>  通过上面Java内存模型的概述，我们会注意到这么一个问题，每个线程在获取锁之后会在自己的工作内存来操作共享变量，操作完成之后将工作内存中的副本回写到主内存，并且在其它线程从主内存将变量同步回自己的工作内存之前，共享变量的改变对其是不可见的。即其他线程的本地内存中的变量已经是过时的，并不是更新后的值。volatile保证可见性的原理是在每次访问变量时都会进行一次刷新，因此每次访问都是主内存中最新的版本。所以volatile关键字的作用之一就是保证变量修改的实时可见性。</p><p>  即，volatile的特殊规则就是：</p><ul><li>read、load、use动作必须连续出现。</li><li>assign、store、write动作必须连续出现。</li></ul><p>  所以，使用volatile变量能够保证:</p><ul><li>每次读取前必须先从主内存刷新最新的值。</li><li>每次写入后必须立即同步回主内存当中。</li></ul><p>  也就是说，volatile关键字修饰的变量看到的是自己的最新值。线程1中对变量v的最新修改，对线程2是可见的。</p><h2 id="禁止指令重排序优化："><a href="#禁止指令重排序优化：" class="headerlink" title="禁止指令重排序优化："></a>禁止指令重排序优化：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean isOK &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;假设以下代码在线程A执行</span><br><span class="line">A.init();</span><br><span class="line">isOK&#x3D;true;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;假设以下代码在线程B执行</span><br><span class="line">while(!isOK)&#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line">B.init();</span><br></pre></td></tr></table></figure><p>A线程在初始化的时候，B线程处于睡眠状态，等待A线程完成初始化的时候才能够进行自己的初始化。这里的先后关系依赖于isOK这个变量。如果没有volatile修饰isOK这个变量，那么isOK的赋值就可能出现在A.init()之前（指令重排序,Java虚拟机的一种优化措施），此时A没有初始化，而B的初始化就破坏了它们之前形成的那种依赖关系，可能就会出错。</p><p>知识拓展：<strong>指令重排序</strong>：</p><ul><li>概念：指令重排序是JVM为了优化指令，提高程序运行效率，在不影响 <strong>单线程程序</strong> 执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序带来问题。</li></ul><p>  不同的指令间可能存在数据依赖。比如下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int l &#x3D; 3; &#x2F;&#x2F; (1)</span><br><span class="line">int w &#x3D; 4; &#x2F;&#x2F; (2)</span><br><span class="line">int s &#x3D; l * w; &#x2F;&#x2F; (3)</span><br></pre></td></tr></table></figure><p>面积的计算依赖于l与w两个变量的赋值指令。而l与w无依赖关系。</p><p>重排序会遵守两个规则：</p><ul><li><strong>as-if-serial规则</strong>：as-if-serial规则是指不管如何重排序（编译器与处理器为了提高并行度），（单线程）程序的结果不能被改变。这是编译器、Runtime、处理器必须遵守的语义。</li><li><strong>happens-before规则</strong>：<ul><li>概念：前一个操作的结果可以被后续的操作获取。讲直白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。</li><li>happens-before（先行发生）规则如下：<ul><li>程序顺序规则：一个线程中的每个操作，happens-before于线程中的任意后续操作。</li><li>监视器锁规则：一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果（A）happens-before（B），且（B）happens-before（C），那么（A）happens-before（C）。</li><li>线程start()规则：主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。也就是start() happens-before 线程B中的操作。</li><li>线程join()规则：主线程A等待子线程B完成，当子线程B执行完毕后，主线程A可以看到线程B的所有操作。也就是说，子线程B中的任意操作，happens-before join()的返回。</li><li>中断规则：一个线程调用另一个线程的interrupt，happens-before于被中断的线程发现中断。</li><li>终结规则：一个对象的构造函数的结束，happens-before于这个对象finalizer的开始。</li></ul></li></ul></li></ul><p>虽然，（1）-happensbefore -&gt;（2）,（2）-happens before-&gt;（3），但是计算顺序(1)(2)(3)与(2)(1)(3)对于l、w、area变量的结果并无区别。编译器、Runtime在优化时可以根据情况重排序（1）与（2），而丝毫不影响程序的结果。</p><ul><li>volatile使用场景：<ul><li>如果正确使用volatile的话，必须依赖下以下种条件：<ul><li>1、对变量的写操作不依赖当前变量的值。</li><li>2、该变量没有包含在其他变量的不变式中。</li></ul></li></ul></li></ul><p>也可以这样理解，就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（i++）看上去类似一个单独操作，实际上它是一个由（读取－修改－写入）操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 i 的值在操作期间保持不变，而 volatile 变量无法实现这点。</p><ul><li>在以下两种情况下都必须使用volatile：<ul><li>1、状态的改变。</li><li>2、读多写少的情况。</li></ul></li></ul><p>具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 场景一：状态改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查（DCL）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sun</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Sun sunInstance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Sun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sun <span class="title">getSunInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sunInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Sun.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sunInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">          sunInstance = <span class="keyword">new</span> Sun();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sunInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景二：读多写少</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作，没有synchronized，提高性能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作，必须synchronized。因为x++不是原子操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="问题来了volatile是如何防止指令重排序优化的呢？"><a href="#问题来了volatile是如何防止指令重排序优化的呢？" class="headerlink" title="问题来了volatile是如何防止指令重排序优化的呢？"></a>问题来了volatile是如何防止指令重排序优化的呢？</h2><p>答：</p><p>volatile关键字通过 <strong>“内存屏障”</strong> 的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。大多数的处理器都支持内存屏障的指令。</p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>知识拓展：<strong>内存屏障</strong>：</p><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br>    内存屏障可以被分为以下几种类型：<br>    - LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br>    - StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br>    - LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br>    - StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。&quot;&gt;&lt;a href=&quot;#摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。&quot; class=&quot;headerlink&quot; title=&quot;摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。&quot;&gt;&lt;/a&gt;摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。&quot;&gt;&lt;a href=&quot;#前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。&quot; class=&quot;headerlink&quot; title=&quot;前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。&quot;&gt;&lt;/a&gt;前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>如何保证类线程安全</title>
    <link href="https://www.blog.ajie39.top/2020/06/21/%E4%BF%9D%E8%AF%81%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>https://www.blog.ajie39.top/2020/06/21/%E4%BF%9D%E8%AF%81%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-06-20T17:02:22.886Z</published>
    <updated>2021-05-05T04:23:43.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：主要总结了一下如何保证类线程安全。"><a href="#摘要：主要总结了一下如何保证类线程安全。" class="headerlink" title="摘要：主要总结了一下如何保证类线程安全。"></a>摘要：主要总结了一下如何保证类线程安全。</h1><hr><h1 id="前言：总结了一下如何保证类线程安全。"><a href="#前言：总结了一下如何保证类线程安全。" class="headerlink" title="前言：总结了一下如何保证类线程安全。"></a>前言：总结了一下如何保证类线程安全。</h1><hr><span id="more"></span><h2 id="保证类线程安全的措施"><a href="#保证类线程安全的措施" class="headerlink" title="保证类线程安全的措施"></a>保证类线程安全的措施</h2><ul><li>不共享线程间的变量；</li><li>设置属性变量为不可变变量；</li><li>每个共享的可变变量都使用一个确定的锁保护。</li></ul><h2 id="保证线程安全的思路"><a href="#保证线程安全的思路" class="headerlink" title="保证线程安全的思路"></a>保证线程安全的思路</h2><h3 id="1-通过架构设计"><a href="#1-通过架构设计" class="headerlink" title="1. 通过架构设计"></a>1. 通过架构设计</h3><p>通过上层的架构设计和业务分析来避免并发场景。比如需要用多线程或分布式集群统计一堆用户的相关统计值，由于用户的统计值是共享数据，因此需要保证线程安全。</p><p>从业务上分析出用户之间的数据并不共享，因此可以设计一个规则来保证一个用户的计算工作和数据访问只被一个线程或一台机器完成，这样从设计上避免了接下来可能的并发问题。</p><h3 id="2-保证类无状态"><a href="#2-保证类无状态" class="headerlink" title="2. 保证类无状态"></a>2. 保证类无状态</h3><p>有状态会限制横向扩展能力，也可能产生并发问题。如果类是无状态的，那它永远是线程安全的。因此在设计阶段尽可能用无状态的类来满足业务需求。</p><h3 id="3-区别原子操作和复合操作"><a href="#3-区别原子操作和复合操作" class="headerlink" title="3. 区别原子操作和复合操作"></a>3. 区别原子操作和复合操作</h3><p>常见的复合操作包括check-then-act, i++等。虽然check-then-act从表面上看很简单，但却普遍存在与我们日常的开发中，特别是在数据库存取这一块。比如我们需要在数据库里存一个客户的统计值，当统计值不存在时初始化，当存在时就去更新。如果不把这组逻辑设计为原子性的就很有可能产生出两条这个客户的统计值。</p><p>在单机环境下处理这个问题还算容易，通过锁或者同步来把这组复合操作变为原子操作，但在分布式环境下就不适用了。一般情况下是通过在数据库端做文章，比如通过唯一性索引或者悲观锁来保障其数据一致性。当然任何方案都是有代价的，这就需要具体情况下来权衡。</p><h3 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h3><p>使用锁应注意：</p><ul><li>每个共享变量必须由一个确定的锁保护。</li><li>使用锁会有性能损失。</li><li>锁不能解决在分布式环境共享变量的并发问题。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：主要总结了一下如何保证类线程安全。&quot;&gt;&lt;a href=&quot;#摘要：主要总结了一下如何保证类线程安全。&quot; class=&quot;headerlink&quot; title=&quot;摘要：主要总结了一下如何保证类线程安全。&quot;&gt;&lt;/a&gt;摘要：主要总结了一下如何保证类线程安全。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：总结了一下如何保证类线程安全。&quot;&gt;&lt;a href=&quot;#前言：总结了一下如何保证类线程安全。&quot; class=&quot;headerlink&quot; title=&quot;前言：总结了一下如何保证类线程安全。&quot;&gt;&lt;/a&gt;前言：总结了一下如何保证类线程安全。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java依赖注入详解</title>
    <link href="https://www.blog.ajie39.top/2020/06/13/Java%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.blog.ajie39.top/2020/06/13/Java%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-06-13T07:05:22.573Z</published>
    <updated>2021-05-05T04:26:12.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。"><a href="#摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。" class="headerlink" title="摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。"></a>摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。</h1><hr><h1 id="前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。"><a href="#前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。" class="headerlink" title="前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。"></a>前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。</h1><hr><span id="more"></span><h2 id="依赖注入的方法"><a href="#依赖注入的方法" class="headerlink" title="依赖注入的方法"></a>依赖注入的方法</h2><p>注：下面例子主要以spring为例。</p><h3 id="1、setter注入"><a href="#1、setter注入" class="headerlink" title="1、setter注入"></a>1、setter注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFooService</span><span class="params">(FooService fooService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fooService = fooService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这种注入方式是在Spring3.x刚推出的时候，推荐使用的注入方式。</p><h3 id="2、field注入"><a href="#2、field注入" class="headerlink" title="2、field注入"></a>2、field注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Foo&gt; <span class="title">listFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fooService.list();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种注入方式非常简单，只要加入要注入的字段，附上@Autowired，即可完成。</p><h3 id="3、构造器注入"><a href="#3、构造器注入" class="headerlink" title="3、构造器注入"></a>3、构造器注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooController</span><span class="params">(FooService fooService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fooService = fooService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这种注入方式是在Spring4.x版本中推荐使用的注入方式。</p><p>使用构造器注入的优点：</p><ol><li>能够保证注入的组件不可变。</li><li>确保需要的依赖不为空。</li><li>构造器注入的依赖总是能够保证完全初始化的状态。</li></ol><h2 id="为什么推荐使用构造器注入？"><a href="#为什么推荐使用构造器注入？" class="headerlink" title="为什么推荐使用构造器注入？"></a>为什么推荐使用构造器注入？</h2><ol><li><p>field注入<br>优点：注入简单。简洁明了。<br>缺点：循环依赖、重名依赖、依赖为空。</p></li><li><p>构造器注入<br>优点：初始化、不可变性、数据检查、依赖不为空。<br>缺点：循环依赖、注入的一多就非常的臃肿。</p></li><li><p>setter注入<br>优点：通过调用，可以让代码控制类依赖的顺序，解决循环依赖。<br>缺点：注入的一多就非常的臃肿、依赖可变性，不够安全。</p></li></ol><p>构造器注入和field注入的循环依赖的报错提示也有点不同，前者编译时就报错，后者使用时报错。</p><p>所以说为什么使用构造器注入呢，主要是因为：</p><ol><li>保证依赖不可变（final关键字）。</li><li>保证依赖不为空（省去了我们对其检查）。</li><li>保证返回客户端（调用）的代码的时候是完全初始化的状态。</li><li>如果产生了循环依赖的问题，可以在编译是就知道，这样可以及时解决（尽量把错误在编译时就发现才是最好的开发习惯！机器的可信度远高于人类！）。</li></ol><p>来自spring官方的解释：</p><p>We usually advise people to use constructor injection for all mandatory collaborators and setter injection for all other properties. Again, constructor injection ensures all mandatory properties have been satisfied, and it is simply not possible to instantiate an object in an invalid state (not having passed its collaborators). In other words, when using constructor injection you do not have to use a dedicated mechanism to ensure required properties are set (other than normal Java mechanisms).</p><p>具体详情可以参考一下这篇文章：<a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/</a></p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><h3 id="1、什么是循环依赖？"><a href="#1、什么是循环依赖？" class="headerlink" title="1、什么是循环依赖？"></a>1、什么是循环依赖？</h3><p>循环依赖其实就是循环引用，也就是两个或者两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：</p><p><img src="/blog/24/1.png" alt="循环依赖图"></p><p>注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p><p>循环依赖场景有：</p><ol><li>构造器的循环依赖。</li><li>field属性的循环依赖。</li></ol><p>其中，构造器的循环依赖问题无法通过框架自动去解决，但是它会在编译时就报错，我们可以人为的解决它。在解决属性循环依赖时，Spring通过将实例化后的对象提前暴露给Spring容器中的singletonFactories，解决了循环依赖的问题。</p><h3 id="2、Spring怎么解决循环依赖"><a href="#2、Spring怎么解决循环依赖" class="headerlink" title="2、Spring怎么解决循环依赖"></a>2、Spring怎么解决循环依赖</h3><p>Spring的循环依赖的理论依据基于Java的引用传递，当获得对象的引用时，对象的属性是可以延后设置的（但是构造器必须是在获取引用之前）。</p><p>Spring的单例对象的初始化主要分为三步：</p><p><img src="/blog/24/2.png" alt="单例对象的初始化三步骤"></p><ol><li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象。</li><li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充。</li><li>initializeBean：初始化，调用spring xml中的init 方法。</li></ol><p>从上面单例bean的初始化可以知道：循环依赖主要发生在第一、二步，也就是构造器循环依赖和field循环依赖。那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>三级缓存分别指：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三级缓存主要指：</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ol><li>singletonFactories：单例对象工厂的cache。</li><li>earlySingletonObjects：提前暴光的单例对象的Cache。</li><li>singletonObjects：单例对象的cache。</li></ol><ul><li>在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。</li><li>如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。</li><li>如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()获取，如果获取到了则从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</li></ul><p>从上面三级缓存的分析中，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory。这里就是解决循环依赖的关键，发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况：</p><p>A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存 earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p><p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p><p><img src="/blog/24/3.png" alt="DEBUG流程图"></p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://www.zhihu.com/question/27053548">https://www.zhihu.com/question/27053548</a></p><p><a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/</a></p><p><a href="https://www.cnblogs.com/zzq6032010/p/11406405.html">https://www.cnblogs.com/zzq6032010/p/11406405.html</a></p><p><a href="https://blog.csdn.net/qq_33808244/article/details/102453052">https://blog.csdn.net/qq_33808244/article/details/102453052</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。&quot;&gt;&lt;a href=&quot;#前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。&quot; class=&quot;headerlink&quot; title=&quot;前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。&quot;&gt;&lt;/a&gt;前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>flagr入门</title>
    <link href="https://www.blog.ajie39.top/2020/05/05/Flagr%E5%85%A5%E9%97%A8/"/>
    <id>https://www.blog.ajie39.top/2020/05/05/Flagr%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-05T08:38:55.675Z</published>
    <updated>2021-05-05T04:24:45.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要介绍一个A-B测试的中间件–flagr"><a href="#摘要：这篇文章主要介绍一个A-B测试的中间件–flagr" class="headerlink" title="摘要：这篇文章主要介绍一个A/B测试的中间件–flagr"></a>摘要：这篇文章主要介绍一个A/B测试的中间件–flagr</h1><hr><h1 id="前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。-它提供功能标记，实验（A-B测试）和动态配置。-它具有用于标志管理和标志评估的清晰的REST-API。"><a href="#前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。-它提供功能标记，实验（A-B测试）和动态配置。-它具有用于标志管理和标志评估的清晰的REST-API。" class="headerlink" title="前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。 它提供功能标记，实验（A / B测试）和动态配置。 它具有用于标志管理和标志评估的清晰的REST API。"></a>前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。 它提供功能标记，实验（A / B测试）和动态配置。 它具有用于标志管理和标志评估的清晰的REST API。</h1><hr><span id="more"></span><h2 id="flagr是什么？"><a href="#flagr是什么？" class="headerlink" title="flagr是什么？"></a>flagr是什么？</h2><p>在介绍flagr之前，我们先要明白什么是A/B测试，什么是灰度测试，这样可以让我们更好的理解flagr。</p><h3 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h3><p>A/B测试指的是系统测试通过并发布后，同一个软件功能不同的用户会看到不同的实现方式，收集每个用户的反馈。本质上是上线后的测试，收集用户的反馈。即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p><h3 id="灰度测试"><a href="#灰度测试" class="headerlink" title="灰度测试"></a>灰度测试</h3><p>灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B测试。</p><p>灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。系统集成测试通过后，将测试版本发布到线上环境，替换部分的线上服务器代码进行预测试。当灰度测试结束后，线上版本实现会统一。本质上是上线前的测试，收集用户的反馈。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p>灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。</p><h4 id="灰度测试的意义"><a href="#灰度测试的意义" class="headerlink" title="灰度测试的意义"></a>灰度测试的意义</h4><p>灰度测试能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。</p><h4 id="灰度发布步骤"><a href="#灰度发布步骤" class="headerlink" title="灰度发布步骤"></a>灰度发布步骤</h4><ol><li>定义目标。</li><li>选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等。</li><li>筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等。</li><li>部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调。</li><li>发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表。</li><li>产品完善。</li><li>新一轮灰度发布或完整发布。</li></ol><h3 id="flagr是什么？可以用来做什么？"><a href="#flagr是什么？可以用来做什么？" class="headerlink" title="flagr是什么？可以用来做什么？"></a>flagr是什么？可以用来做什么？</h3><p>Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。它提供功能标记，A/B测试和动态配置。它具有用于标志管理和标志评估的清晰的REST API。</p><p>我们可以利用flagr进行A/B测试和灰度发布，通过它完善产品。</p><h3 id="flagr中的一些专业术语解释"><a href="#flagr中的一些专业术语解释" class="headerlink" title="flagr中的一些专业术语解释"></a>flagr中的一些专业术语解释</h3><ul><li>Flag. It can be a feature flag, an experiment, or a configuration.（它可以是功能标记，实验或配置。）</li><li>Variant represents the possible variation of a flag. For example, control/treatment, green/yellow/red, etc.（变体表示标志的可能变体。 例如，控制/处理，绿色/黄色/红色等。）</li><li>Variant Attachment represents the dynamic configuration of a variant. For example, if you have a variant for the green button, you can dynamically control what’s the hex color of green you want to use (e.g. {“hex_color”: “#42b983”}).（变体附件表示变体的动态配置。 例如，如果您有绿色按钮的变体，则可以动态控制要使用的绿色的十六进制颜色（例如{“ hex_color”：“＃42b983”}）。）</li><li>Segment represents the segmentation, i.e. the set of audience we want to target. Segment is the smallest unit of a component we can analyze in Flagr Metrics.（细分表示分区，即我们要定位的受众群体。 细分是我们可以在Flagr指标中分析的组件的最小单位。）</li><li>Constraint represents rules that we can use to define the audience of the segment. In other words, the audience in the segment is defined by a set of constraints. Specifically, in Flagr, the constraints are connected with AND in a segment.（约束表示可以用来定义细分受众群的规则。 换句话说，细分受众群是由一组约束定义的。 具体而言，在Flagr中，约束与细分中的AND连接。）</li><li>Distribution represents the distribution of variants in a segment.（分布表示细分中变体的分布。）</li><li>Entity represents the context of what we are going to assign the variant on. Usually, Flagr expects the context coming with the entity, so that one can define constraints based on the context of the entity.（实体表示我们要为其分配变量的上下文。 通常，Flagr期望上下文随实体一起提供，以便人们可以基于实体的上下文定义约束。）</li><li>Rollout and deterministic random logic. The goal here is to ensure deterministic and persistent evaluation result for entities. Steps to evaluating a flag given an entity context:（推出和确定性随机逻辑。 此处的目的是确保对实体的确定性和持久性评估结果。 在给定实体上下文的情况下评估标志的步骤：）<ul><li>Take the unique ID from the entity, hash it using a hash function that has a uniform distribution (e.g. CRC32, MD5).（从实体中获取唯一ID，然后使用具有均匀分布的哈希函数（例如CRC32，MD5）对其进行哈希处理。）</li><li>Take the hash value (base 10) and mod 1000. 1000 is the total number of buckets used in Flagr.（取哈希值（以10为底）和mod1000。1000是Flagr中使用的存储桶总数。）</li><li>Consider the distribution. For example, 50/50 split for control and treatment means 0-499 for control and 500-999 for treatment.（考虑分布。 例如，控制和治疗的50/50分割意味着控制的0-499和治疗的500-999。）</li><li>Consider the rollout percentage. For example, 10% rollout means only the first 10% of the control buckets (again, use the previous step example, 0-49 out of 0-499 will be rolled out to control experience).（考虑部署百分比。 例如，推出10％表示仅控制桶的前10％（同样，使用上一个步骤示例，将推出0-499中的0-49以控制体验）。）</li></ul></li></ul><h2 id="flagr提供的http接口"><a href="#flagr提供的http接口" class="headerlink" title="flagr提供的http接口"></a>flagr提供的http接口</h2><p>几个专业术语的解释：<br>Flag：标志<br>Segment：<br>官方英文解释：Segment defines the audience of the flag, it’s the user segmentation.<br>中文翻译：分割区定义了标志的受众群体，即对用户细分。<br>Constraint：<br>官方英文解释：Constraint is the unit of defining a small subset of users.<br>中文翻译：约束是定义一小部分用户的单位。<br>Distribution：<br>官方英文解释：Distribution is the percent distribution of variants within that segment.<br>中文翻译：分布是该细分中变体的百分比分布。<br>Variant：<br>官方英文解释：Variants are the possible outcomes of flag evaluation.<br>中文翻译：变体是标志评估的可能结果。<br>Evaluation：<br>官方英文解释：Evaluation is the process of evaluating a flag given the entity context.<br>中文翻译：评估是在给定实体上下文的情况下评估标志的过程<br>Health：<br>官方英文解释：Check if Flagr is healthy.<br>中文翻译：检查Flagr是否健康。</p><table><thead><tr><th>Class</th><th>Method</th><th>HTTP</th><th>request</th><th>Description</th></tr></thead><tbody><tr><td>Jsflagr.ConstraintApi</td><td>createConstraint</td><td>POST</td><td>/flags/{flagID}/segments/{segmentID}/constraints</td><td>创建约束</td></tr><tr><td>Jsflagr.ConstraintApi</td><td>deleteConstraint</td><td>DELETE</td><td>/flags/{flagID}/segments/{segmentID}/constraints/{constraintID}</td><td>删除约束</td></tr><tr><td>Jsflagr.ConstraintApi</td><td>findConstraints</td><td>GET</td><td>/flags/{flagID}/segments/{segmentID}/constraints</td><td>查找约束</td></tr><tr><td>Jsflagr.ConstraintApi</td><td>putConstraint</td><td>PUT</td><td>/flags/{flagID}/segments/{segmentID}/constraints/{constraintID}</td><td>更新约束</td></tr><tr><td>Jsflagr.DistributionApi</td><td>findDistributions</td><td>GET</td><td>/flags/{flagID}/segments/{segmentID}/distributions</td><td>查找分布</td></tr><tr><td>Jsflagr.DistributionApi</td><td>putDistributions</td><td>PUT</td><td>/flags/{flagID}/segments/{segmentID}/distributions</td><td>更新分布</td></tr><tr><td>Jsflagr.EvaluationApi</td><td>postEvaluation</td><td>POST</td><td>/evaluation</td><td>更新某个评估</td></tr><tr><td>Jsflagr.EvaluationApi</td><td>postEvaluationBatch</td><td>POST</td><td>/evaluation/batch</td><td>批量更新评估</td></tr><tr><td>Jsflagr.ExportApi</td><td>getExportSQLite</td><td>GET</td><td>/export/sqlite</td><td>导出数据库转储的sqlite3格式，该格式是从主数据库转换而来的。</td></tr><tr><td>Jsflagr.FlagApi</td><td>createFlag</td><td>POST</td><td>/flags</td><td>创建标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>deleteFlag</td><td>DELETE</td><td>/flags/{flagID}</td><td>删除标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>findFlags</td><td>GET</td><td>/flags</td><td>查找所有的标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>getFlag</td><td>GET</td><td>/flags/{flagID}</td><td>查找某个标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>getFlagEntityTypes</td><td>GET</td><td>/flags/entity_types</td><td>获取标志实体的类型</td></tr><tr><td>Jsflagr.FlagApi</td><td>getFlagSnapshots</td><td>GET</td><td>/flags/{flagID}/snapshots</td><td>获取标志快照</td></tr><tr><td>Jsflagr.FlagApi</td><td>putFlag</td><td>PUT</td><td>/flags/{flagID}</td><td>更新标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>setFlagEnabled</td><td>PUT</td><td>/flags/{flagID}/enabled</td><td>启用标志</td></tr><tr><td>Jsflagr.HealthApi</td><td>getHealth</td><td>GET</td><td>/health</td><td>获取健康指标</td></tr><tr><td>Jsflagr.SegmentApi</td><td>createSegment</td><td>POST</td><td>/flags/{flagID}/segments</td><td>创建分割区</td></tr><tr><td>Jsflagr.SegmentApi</td><td>deleteSegment</td><td>DELETE</td><td>/flags/{flagID}/segments/{segmentID}</td><td>删除分割区</td></tr><tr><td>Jsflagr.SegmentApi</td><td>findSegments</td><td>GET</td><td>/flags/{flagID}/segments</td><td>查找标志下的所有分割区</td></tr><tr><td>Jsflagr.SegmentApi</td><td>putSegment</td><td>PUT</td><td>/flags/{flagID}/segments/{segmentID}</td><td>更新某个分割区</td></tr><tr><td>Jsflagr.SegmentApi</td><td>putSegmentsReorder</td><td>PUT</td><td>/flags/{flagID}/segments/reorder</td><td>重新分配分割区</td></tr><tr><td>Jsflagr.VariantApi</td><td>createVariant</td><td>POST</td><td>/flags/{flagID}/variants</td><td>创建变体</td></tr><tr><td>Jsflagr.VariantApi</td><td>deleteVariant</td><td>DELETE</td><td>/flags/{flagID}/variants/{variantID}</td><td>删除变体</td></tr><tr><td>Jsflagr.VariantApi</td><td>findVariants</td><td>GET</td><td>/flags/{flagID}/variants</td><td>查找标志下的变体</td></tr><tr><td>Jsflagr.VariantApi</td><td>putVariant</td><td>PUT</td><td>/flags/{flagID}/variants/{variantID}</td><td>更新变体</td></tr></tbody></table><p>具体的api文档可以参考以下地址：<br><a href="https://checkr.github.io/flagr/api_docs/">https://checkr.github.io/flagr/api_docs/</a></p><h2 id="flagr实例"><a href="#flagr实例" class="headerlink" title="flagr实例"></a>flagr实例</h2><p>假设我们想向美国用户推出一个新按钮，而我们不知道哪种颜色效果最好。 绿色/蓝色/粉红色是标志的三种变体。</p><p><img src="/blog/23/1.png" alt="按钮1"></p><p><img src="/blog/23/2.png" alt="按钮2"></p><p>我们可能希望将标志公开给一小部分用户，例如加利福尼亚的用户。 因此，加利福尼亚的用户属于细分区。</p><p><img src="/blog/23/3.png" alt="细分区图1"></p><p>后来，我们了解到CA的用户喜欢绿色的按钮，NY的人们喜欢粉红色的按钮，DC的人们喜欢蓝色的按钮。因此，我们将分为三个部分，每个部分均由约束定义：州 ==？。该细分区也可以由多个约束定义。 例如，州== NY AND 年龄 &gt;= 21</p><p><img src="/blog/23/4.png" alt="细分区图2"></p><p><img src="/blog/23/5.png" alt="细分区图3"></p><p>要对此标志进行A / B测试，我们可以尝试使用50％ / 50％（分布）的绿色 / 蓝色，并仅对CA细分区域中20％（点击率）的用户进行测试。 稍后，我们可以将推广百分比设置为100％，以便CA中的每个用户都能以50％的机会获得绿色或蓝色。 当然，如果要向100％的用户推广到100％绿色，只需将分发设置为100％ / 0％的绿色 / 蓝色和100％的推广百分比。</p><p><img src="/blog/23/6.png" alt="A/B测试图1"></p><p><img src="/blog/23/7.png" alt="A/B测试图1"></p><h2 id="flagr的结构"><a href="#flagr的结构" class="headerlink" title="flagr的结构"></a>flagr的结构</h2><p>flagr中包含三个组件，标志评估器，标志管理器和flagr指标。</p><ul><li>flagr评估器：评估传入的请求。</li><li>flagr管理器：flagr管理器是 CRUD 的出入口。flagr的所有变化都在这里发生。</li><li>flagr指标. Flagr指标是收集评估结果的数据管道。 目前Flagr仅支持Kafka作为管道。</li></ul><p><img src="/blog/23/8.png" alt="flagr架构图"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要介绍一个A-B测试的中间件–flagr&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要介绍一个A-B测试的中间件–flagr&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要介绍一个A/B测试的中间件–flagr&quot;&gt;&lt;/a&gt;摘要：这篇文章主要介绍一个A/B测试的中间件–flagr&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。-它提供功能标记，实验（A-B测试）和动态配置。-它具有用于标志管理和标志评估的清晰的REST-API。&quot;&gt;&lt;a href=&quot;#前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。-它提供功能标记，实验（A-B测试）和动态配置。-它具有用于标志管理和标志评估的清晰的REST-API。&quot; class=&quot;headerlink&quot; title=&quot;前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。 它提供功能标记，实验（A / B测试）和动态配置。 它具有用于标志管理和标志评估的清晰的REST API。&quot;&gt;&lt;/a&gt;前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。 它提供功能标记，实验（A / B测试）和动态配置。 它具有用于标志管理和标志评估的清晰的REST API。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://www.blog.ajie39.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="https://www.blog.ajie39.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="A/B测试" scheme="https://www.blog.ajie39.top/tags/A-B%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ORM之他暂时可能只是个弟弟——Jooq</title>
    <link href="https://www.blog.ajie39.top/2020/03/28/ORM%E4%B9%8B%E4%BB%96%E6%9A%82%E6%97%B6%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E4%B8%AA%E5%BC%9F%E5%BC%9F%E2%80%94%E2%80%94Jooq/"/>
    <id>https://www.blog.ajie39.top/2020/03/28/ORM%E4%B9%8B%E4%BB%96%E6%9A%82%E6%97%B6%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E4%B8%AA%E5%BC%9F%E5%BC%9F%E2%80%94%E2%80%94Jooq/</id>
    <published>2020-03-28T07:32:00.031Z</published>
    <updated>2021-05-05T04:26:33.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是对之前一段时间学习Jooq的总结。"><a href="#摘要：这篇文章主要是对之前一段时间学习Jooq的总结。" class="headerlink" title="摘要：这篇文章主要是对之前一段时间学习Jooq的总结。"></a>摘要：这篇文章主要是对之前一段时间学习Jooq的总结。</h1><hr><h1 id="前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。"><a href="#前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。" class="headerlink" title="前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。"></a>前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。</h1><hr><span id="more"></span><h2 id="Jooq简介"><a href="#Jooq简介" class="headerlink" title="Jooq简介"></a>Jooq简介</h2><p>JOOQ 是基于Java访问关系型数据库的工具包，轻量，简单，并且足够灵活，可以轻松的使用Java面向对象语法来实现各种复杂的sql。不管是Hibernate或者Mybatis，都能简单的使用实体映射来访问数据库，但有时候这些“高级”的对象关系映射，没有直接使用原生sql来的灵活和简单，而且对于一些如：joins,union, nested selects等复杂的操作支持的不友好。JOOQ 既吸取了传统ORM操作数据的简单性和安全性，又保留了原生sql的灵活性，它更像是介于ORM和JDBC的中间层。</p><p>相比其它ORM，JOOQ更注重于对<a href="http://stackoverflow.com/a/4208156/851099">数据库模型的建模</a>。它拥有以下特点：</p><ul><li>面向SQL</li><li>构建类型安全的SQL</li><li>强大的代码生成工具</li><li>方便的乐观锁等高级特性</li></ul><p>详细的可以看看<a href="http://www.jooq.org/doc/3.8/manual-single-page/#preface">Jooq官网介绍</a>。</p><p>如果说它有什么缺点，那就是它对一些商用数据库，如Oracle、SQL Server是收费的。</p><h2 id="快速上手Jooq"><a href="#快速上手Jooq" class="headerlink" title="快速上手Jooq"></a>快速上手Jooq</h2><p>接下来，让我们通过官网的<a href="http://www.jooq.org/doc/3.8/manual-single-page/#jooq-in-7-steps">《JOOQ7步走》</a>中的例子快速上手JOOQ吧。</p><h3 id="第一步-下载JOOQ"><a href="#第一步-下载JOOQ" class="headerlink" title="第一步 下载JOOQ"></a>第一步 下载JOOQ</h3><p>首先需要在JOOQ的<a href="http://www.jooq.org/download">下载页面</a>下载它。如果使用的是开源版本，可以直接通过Maven等工具下载。</p><h3 id="第二步-创建数据库"><a href="#第二步-创建数据库" class="headerlink" title="第二步 创建数据库"></a>第二步 创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &#96;test&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;student&#96; (</span><br><span class="line">  &#96;id&#96; int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;stu_id&#96; int(20) NOT NULL,</span><br><span class="line">  &#96;stu_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;age&#96; int(8) DEFAULT NULL,</span><br><span class="line">  &#96;class_id&#96; int(10) NOT NULL,</span><br><span class="line">  &#96;class_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;result&#96; int(8) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="第三步-生成代码"><a href="#第三步-生成代码" class="headerlink" title="第三步 生成代码"></a>第三步 生成代码</h3><p>JOOQ生成代码方式有多种，可以按照<a href="http://www.jooq.org/doc/3.8/manual-single-page/#jooq-in-7-steps-step3">官网的方法</a>生成代码。然后就可以在自己的代码中使用这些生成的代码了。</p><p>或者参考下面配置，修改你的pom.xml，然后在Terminal运行：mvn jooq-codegen:generate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;!-- 数据库信息 --&gt;</span><br><span class="line">    &lt;db.url&gt;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&lt;&#x2F;db.url&gt;</span><br><span class="line">    &lt;!-- 你的数据库用户名 --&gt;</span><br><span class="line">    &lt;db.username&gt;root&lt;&#x2F;db.username&gt;</span><br><span class="line">    &lt;!-- 你的数据库密码 --&gt;</span><br><span class="line">    &lt;db.password&gt;&#123;*********&#125;&lt;&#x2F;db.password&gt;</span><br><span class="line">    &lt;jooq.version&gt;3.13.1&lt;&#x2F;jooq.version&gt;</span><br><span class="line">    &lt;!-- 你的packageName --&gt;</span><br><span class="line">    &lt;jooq.packageName&gt;&#123;*********&#125;&lt;&#x2F;jooq.packageName&gt;</span><br><span class="line">    &lt;!-- 你的directory --&gt;</span><br><span class="line">    &lt;jooq.directory&gt;&#123;*********&#125;&lt;&#x2F;jooq.directory&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">&lt;!-- jOOQ代码生成插件 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.jooq&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jooq-codegen-maven&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.11.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;jooq-codegen&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;generate&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;&#x2F;phase&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;skip&gt;false&lt;&#x2F;skip&gt;</span><br><span class="line">                    &lt;jdbc&gt;</span><br><span class="line">                        &lt;driver&gt;com.mysql.jdbc.Driver&lt;&#x2F;driver&gt;</span><br><span class="line">                        &lt;url&gt;$&#123;db.url&#125;&lt;&#x2F;url&gt;</span><br><span class="line">                        &lt;user&gt;$&#123;db.username&#125;&lt;&#x2F;user&gt;</span><br><span class="line">                        &lt;password&gt;$&#123;db.password&#125;&lt;&#x2F;password&gt;</span><br><span class="line">                    &lt;&#x2F;jdbc&gt;</span><br><span class="line">                    &lt;generator&gt;</span><br><span class="line">                        &lt;name&gt;org.jooq.codegen.JavaGenerator&lt;&#x2F;name&gt;</span><br><span class="line">                        &lt;database&gt;</span><br><span class="line">                            &lt;name&gt;org.jooq.meta.mysql.MySQLDatabase&lt;&#x2F;name&gt;</span><br><span class="line">                            &lt;includes&gt;.*&lt;&#x2F;includes&gt;</span><br><span class="line">                            &lt;excludes&gt;&lt;&#x2F;excludes&gt;</span><br><span class="line">                            &lt;inputSchema&gt;test&lt;&#x2F;inputSchema&gt;</span><br><span class="line">                        &lt;&#x2F;database&gt;</span><br><span class="line">                        &lt;generate&gt;</span><br><span class="line">                            &lt;javaTimeTypes&gt;true&lt;&#x2F;javaTimeTypes&gt;</span><br><span class="line">                        &lt;&#x2F;generate&gt;</span><br><span class="line">                        &lt;target&gt;</span><br><span class="line">                            &lt;!-- The destination package of your generated classes (within the</span><br><span class="line">                                destination directory) --&gt;</span><br><span class="line">                            &lt;packageName&gt;$&#123;jooq.packageName&#125;&lt;&#x2F;packageName&gt;</span><br><span class="line">                            &lt;!-- The destination directory of your generated classes --&gt;</span><br><span class="line">                            &lt;directory&gt;$&#123;jooq.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;&#x2F;target&gt;</span><br><span class="line">                        &lt;generate&gt;</span><br><span class="line">                            &lt;!-- 生成pojo --&gt;</span><br><span class="line">                            &lt;pojos&gt;true&lt;&#x2F;pojos&gt;</span><br><span class="line">                            &lt;!-- 生成dao --&gt;</span><br><span class="line">                            &lt;daos&gt;true&lt;&#x2F;daos&gt;</span><br><span class="line">                        &lt;&#x2F;generate&gt;</span><br><span class="line">                    &lt;&#x2F;generator&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">      &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><h3 id="第四、五、六步-完成增删改操作"><a href="#第四、五、六步-完成增删改操作" class="headerlink" title="第四、五、六步 完成增删改操作"></a>第四、五、六步 完成增删改操作</h3><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import org.jooq.DSLContext;</span><br><span class="line">import org.jooq.Record;</span><br><span class="line">import org.jooq.Result;</span><br><span class="line">import org.jooq.SQLDialect;</span><br><span class="line">import org.jooq.impl.DSL;</span><br><span class="line">import top.ajie.jooqDemo.entity.tables.Student;</span><br><span class="line">import top.ajie.jooqDemo.entity.tables.records.StudentRecord;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line">import static top.ajie.jooqDemo.entity.Tables.STUDENT;</span><br><span class="line"></span><br><span class="line">public class JooqCRUD &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String userName &#x3D; &quot;root&quot;;</span><br><span class="line">        String password &#x3D; &quot;&quot;;</span><br><span class="line">        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;;</span><br><span class="line">        &#x2F;&#x2F; Connection is the only JDBC resource that we need</span><br><span class="line">        &#x2F;&#x2F; PreparedStatement and ResultSet are handled by jOOQ, internally</span><br><span class="line">        try (Connection conn &#x3D; DriverManager.getConnection(url, userName, password)) &#123;</span><br><span class="line">            DSLContext dslContext &#x3D; DSL.using(conn, SQLDialect.MYSQL);</span><br><span class="line">            &#x2F;&#x2F; 查询数据</span><br><span class="line">            query(dslContext);</span><br><span class="line">            &#x2F;&#x2F; 添加数据</span><br><span class="line">            StudentRecord stu &#x3D; dslContext.newRecord(STUDENT);</span><br><span class="line">            stu.setStuId(123456);</span><br><span class="line">            stu.setStuName(&quot;张三&quot;);</span><br><span class="line">            stu.setClassId(20200306);</span><br><span class="line">            stu.setClassName(&quot;三年六班&quot;);</span><br><span class="line">            stu.setAge(9);</span><br><span class="line">            stu.setResult(100);</span><br><span class="line">            stu.store();</span><br><span class="line">            &#x2F;&#x2F; 查询数据</span><br><span class="line">            query(dslContext);</span><br><span class="line">            &#x2F;&#x2F; 修改数据</span><br><span class="line">            int sumUp &#x3D; dslContext</span><br><span class="line">                    .update(Student.STUDENT)</span><br><span class="line">                    .set(Student.STUDENT.STU_NAME, &quot;李四&quot;)</span><br><span class="line">                    .where(Student.STUDENT.STU_NAME.eq(&quot;张三&quot;)</span><br><span class="line">                            .and(Student.STUDENT.RESULT.eq(100))</span><br><span class="line">                    )</span><br><span class="line">                    .execute();</span><br><span class="line">            System.out.println(sumUp);</span><br><span class="line">            &#x2F;&#x2F; 查询数据</span><br><span class="line">            query(dslContext);</span><br><span class="line">            &#x2F;&#x2F; 删除数据</span><br><span class="line">            int sumDelete &#x3D; dslContext</span><br><span class="line">                    .delete(Student.STUDENT)</span><br><span class="line">                    .where(Student.STUDENT.STU_NAME.eq(&quot;李四&quot;)</span><br><span class="line">                            .and(Student.STUDENT.RESULT.eq(100))</span><br><span class="line">                    )</span><br><span class="line">                    .execute();</span><br><span class="line">            System.out.println(sumDelete);</span><br><span class="line">            &#x2F;&#x2F; 查询数据</span><br><span class="line">            query(dslContext);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; For the sake of this tutorial, let&#39;s keep exception handling simple</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void query(DSLContext dslContext) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询数据</span><br><span class="line">        Result&lt;Record&gt; stuResult &#x3D; dslContext.select().from(STUDENT).fetch();</span><br><span class="line">        for (Record r : stuResult) &#123;</span><br><span class="line">            String stuName &#x3D; r.getValue(STUDENT.STU_NAME);</span><br><span class="line">            String className &#x3D; r.getValue(STUDENT.CLASS_NAME);</span><br><span class="line">            Integer result &#x3D; r.getValue(STUDENT.RESULT);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;stuName: &quot; + stuName + &quot; className: &quot; + className + &quot; result: &quot; + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="探索-：略"><a href="#探索-：略" class="headerlink" title="探索 ：略"></a>探索 ：略</h3><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="1、生成POJO"><a href="#1、生成POJO" class="headerlink" title="1、生成POJO"></a>1、生成POJO</h3><p>首先在生成配置中添加生成POJO的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generate&gt;</span><br><span class="line">  &lt;pojos&gt;true&lt;&#x2F;pojos&gt;</span><br><span class="line">&lt;&#x2F;generate&gt;</span><br></pre></td></tr></table></figure><p>重新运行生成工具，一个 student 类就生成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Generated;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&#123; &quot;all&quot;, &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public class Student implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; -1386674258;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private Integer stuId;</span><br><span class="line">    private String  stuName;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Integer classId;</span><br><span class="line">    private String  className;</span><br><span class="line">    private Integer result;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Student(Student value) &#123;</span><br><span class="line">        this.id &#x3D; value.id;</span><br><span class="line">        this.stuId &#x3D; value.stuId;</span><br><span class="line">        this.stuName &#x3D; value.stuName;</span><br><span class="line">        this.age &#x3D; value.age;</span><br><span class="line">        this.classId &#x3D; value.classId;</span><br><span class="line">        this.className &#x3D; value.className;</span><br><span class="line">        this.result &#x3D; value.result;</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用JOOQ的API方便的将查询结果和POJO相互转化了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Record to POJO</span><br><span class="line">List&lt;Student&gt; list &#x3D; dslContext.selectFrom(STUDENT).fetch().into(Student.class);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; POJO to Record</span><br><span class="line">Student a &#x3D; dslContext.selectFrom(STUDENT).fetch().get(0).into(Student.class);</span><br><span class="line">StudentRecord author &#x3D; dslContext.newRecord(STUDENT);</span><br><span class="line">author.from(a);</span><br><span class="line">System.out.println(author);</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li><code>from</code>方法提供了多个重载，可以从<code>Map</code>或<code>Array</code>获取数据</li><li><code>from</code>方法从<code>Object</code>获取数据使用了反射的方式，因此效率会比较低。【后面会有解决办法】</li></ul><h3 id="2、生成接口"><a href="#2、生成接口" class="headerlink" title="2、生成接口"></a>2、生成接口</h3><p>Java提倡面向接口编程，JOOQ也提供了生成接口的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generate&gt;</span><br><span class="line">  &lt;interfaces&gt;true&lt;&#x2F;interfaces&gt;</span><br><span class="line">&lt;&#x2F;generate&gt;</span><br></pre></td></tr></table></figure><p>生成的接口是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Generated;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This class is generated by jOOQ.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Generated(</span><br><span class="line">    value &#x3D; &#123;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.jooq.org&quot;,</span><br><span class="line">        &quot;jOOQ version:3.11.11&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    comments &#x3D; &quot;This class is generated by jOOQ&quot;</span><br><span class="line">)</span><br><span class="line">@SuppressWarnings(&#123; &quot;all&quot;, &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public interface IStudent extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Setter for &lt;code&gt;test.student.id&lt;&#x2F;code&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setId(Integer value);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Getter for &lt;code&gt;test.student.id&lt;&#x2F;code&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Integer getId();</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Copy data into another generated Record&#x2F;POJO implementing the common interface IStudent</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;E extends top.ajie.jooqDemo.entity.tables.interfaces.IStudent&gt; E into(E into);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果选择生成“接口”，则生成的Record和POJO都将继承该接口。<br>而之前提到的from方法也将会增加一个IStudent的重载，并使用其中的Getters, Setters，从而具有更好的性能。</p><p>如果只生成接口，而不生成Record或POJO，则JOOQ会使用proxy动态代理对象的方法来达到相同的效果。</p><h3 id="3、生成Annotation"><a href="#3、生成Annotation" class="headerlink" title="3、生成Annotation"></a>3、生成Annotation</h3><p>JOOQ可以选择生成JPA和JSR-303的注解，从而能够更好的和JPA框架配合，并提供更加强大的校验能力：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jpaAnnotations&gt;true&lt;&#x2F;jpaAnnotations&gt;</span><br><span class="line">&lt;validationAnnotations&gt;true&lt;&#x2F;validationAnnotations&gt;</span><br></pre></td></tr></table></figure><p>选择之后，以<code>IStudent</code>为例，生成的代码将变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Generated;</span><br><span class="line">import javax.persistence.Column;</span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.GenerationType;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line">import javax.persistence.Index;</span><br><span class="line">import javax.persistence.Table;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraints.Size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This class is generated by jOOQ.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Generated(</span><br><span class="line">    value &#x3D; &#123;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.jooq.org&quot;,</span><br><span class="line">        &quot;jOOQ version:3.11.11&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    comments &#x3D; &quot;This class is generated by jOOQ&quot;</span><br><span class="line">)</span><br><span class="line">@SuppressWarnings(&#123; &quot;all&quot;, &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">@Entity</span><br><span class="line">@Table(name &#x3D; &quot;student&quot;, schema &#x3D; &quot;test&quot;, indexes &#x3D; &#123;</span><br><span class="line">    @Index(name &#x3D; &quot;PRIMARY&quot;, unique &#x3D; true, columnList &#x3D; &quot;id ASC&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">public interface IStudent extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Setter for &lt;code&gt;test.student.id&lt;&#x2F;code&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setId(Integer value);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Getter for &lt;code&gt;test.student.id&lt;&#x2F;code&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)</span><br><span class="line">    @Column(name &#x3D; &quot;id&quot;, unique &#x3D; true, nullable &#x3D; false, precision &#x3D; 10)</span><br><span class="line">    public Integer getId();</span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Copy data into another generated Record&#x2F;POJO implementing the common interface IStudent</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;E extends top.ajie.jooqDemo.entity.tables.interfaces.IStudent&gt; E into(E into);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、Builder模式"><a href="#4、Builder模式" class="headerlink" title="4、Builder模式"></a>4、Builder模式</h3><p>到了这一步，也许你已经在问自己，为什么没有早点认识JOOQ了，能省不少事呢。不过你知道吗，JOOQ还可以做得更多——它能生成具有Builder模式的Bean：</p><p>添加以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generate&gt;</span><br><span class="line">  &lt;fluentSetters&gt;true&lt;&#x2F;fluentSetters&gt;</span><br><span class="line">&lt;&#x2F;generate&gt;</span><br></pre></td></tr></table></figure><p>配置fluentSetters为true时，Setter将返回自身：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Student setId(Integer id) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的代码将可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IStudent student &#x3D; dslContext.newRecord(STUDENT);</span><br><span class="line">student.setId(1).setStuId(123456).setStuName(&quot;老六&quot;);</span><br></pre></td></tr></table></figure><p>这样代码字段设置和之前相比简洁了很多。</p><h3 id="5、DAO和spring"><a href="#5、DAO和spring" class="headerlink" title="5、DAO和spring"></a>5、DAO和spring</h3><p>如果你是DAO模式和Spring的忠实粉丝，还可以增加以下两个配置，无缝对接Spring的集成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;daos&gt;true&lt;&#x2F;daos&gt;</span><br><span class="line">&lt;springAnnotations&gt;true&lt;&#x2F;springAnnotations&gt;</span><br></pre></td></tr></table></figure><p>生成的代码类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Generated;</span><br><span class="line"></span><br><span class="line">import org.jooq.Configuration;</span><br><span class="line">import org.jooq.impl.DAOImpl;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">import top.ajie.jooqDemo.entity.tables.Student;</span><br><span class="line">import top.ajie.jooqDemo.entity.tables.records.StudentRecord;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This class is generated by jOOQ.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Generated(</span><br><span class="line">    value &#x3D; &#123;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.jooq.org&quot;,</span><br><span class="line">        &quot;jOOQ version:3.11.11&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    comments &#x3D; &quot;This class is generated by jOOQ&quot;</span><br><span class="line">)</span><br><span class="line">@SuppressWarnings(&#123; &quot;all&quot;, &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">@Repository</span><br><span class="line">public class StudentDao extends DAOImpl&lt;StudentRecord, top.ajie.jooqDemo.entity.tables.pojos.Student, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create a new StudentDao without any configuration</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public StudentDao() &#123;</span><br><span class="line">        super(Student.STUDENT, top.ajie.jooqDemo.entity.tables.pojos.Student.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create a new StudentDao with an attached configuration</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Autowired</span><br><span class="line">    public StudentDao(Configuration configuration) &#123;</span><br><span class="line">        super(Student.STUDENT, top.ajie.jooqDemo.entity.tables.pojos.Student.class, configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Fetch records that have &lt;code&gt;result IN (values)&lt;&#x2F;code&gt;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;top.ajie.jooqDemo.entity.tables.pojos.Student&gt; fetchByResult(Integer... values) &#123;</span><br><span class="line">        return fetch(Student.STUDENT.RESULT, values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、无符号数字类型"><a href="#6、无符号数字类型" class="headerlink" title="6、无符号数字类型"></a>6、无符号数字类型</h3><p>SQL支持无符号数字，但是java没有内建无符号数字的类型，为此JOOQ的作者提供了JOOU来处理无符号数。</p><p>例如对上面的age字段，类型可以设置成UInteger，可以使用age.intValue()获取对应的int数值。尽管UInteger更加准确，但是如果你觉得增加一个intValue()的调用会比较繁琐。可以通过下面这个配置使POJO直接使用int作为字段类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;database&gt;</span><br><span class="line">  &lt;unsignedTypes&gt;false&lt;&#x2F;unsignedTypes&gt;</span><br><span class="line">&lt;&#x2F;database&gt;</span><br></pre></td></tr></table></figure><h3 id="7、乐观锁支持"><a href="#7、乐观锁支持" class="headerlink" title="7、乐观锁支持"></a>7、乐观锁支持</h3><p>一个修改的常见场景是：用户读取了记录，作了修改之后再保存入数据库。如果这个时间里，有人修改了数据库的同一个字段，则上一个人的修改就被覆盖了。</p><p>乐观锁就是再出现这种情况时，通过抛出异常或其他方式，来提醒用户改动不安全，需要刷新并重新修改记录。</p><p>jOOQ允许您使用乐观锁定执行CRUD操作。您可以通过激活相关的<a href="https://www.jooq.org/doc/3.8/manual/sql-building/dsl-context/custom-settings/">executeWithOptimisticLocking</a>设置立即利用此功能。如果不进一步了解基础数据语义，这将对store()和delete()方法产生以下影响：</p><ul><li>INSERT语句不受此Setting标志的影响。</li><li>在UPDATE或DELETE语句之前，jOOQ将运行SELECT .. FOR UPDATE语句，悲观地锁定记录以用于后续的UPDATE(DELETE)。</li><li>使用先前的SELECT提取的数据将与存储或删除的记录中的数据进行比较。</li><li>一个org.jooq.exception.DataChangedException如果记录已经在平均时间被修改，则被抛出。</li><li>如果同时未修改记录，则记录成功UPDATE(DELETE)。</li></ul><p>JOOQ提供了一个配置能方便地实现乐观锁，而不需要修改业务代码【详见<a href="http://www.jooq.org/doc/3.8/manual/sql-execution/crud-with-updatablerecords/optimistic-locking/">文档</a>】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Properly configure the DSLContext</span><br><span class="line">DSLContext optimistic &#x3D; DSLContext.using(connection, SQLDialect.MYSQL,</span><br><span class="line">  new Settings().withExecuteWithOptimisticLocking(true));</span><br></pre></td></tr></table></figure><p>JOOQ的乐观锁模式虽然对业务逻辑代码没有侵入性，但是需要数据表提供<code>numeric VERSION</code>或<code>TIMESTAMP</code>字段，比如下表的<code>last_modified_time</code>字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;student&#96; (</span><br><span class="line">  &#96;id&#96; int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;stu_id&#96; int(20) NOT NULL,</span><br><span class="line">  &#96;stu_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;age&#96; int(8) DEFAULT NULL,</span><br><span class="line">  &#96;class_id&#96; int(10) NOT NULL,</span><br><span class="line">  &#96;class_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;result&#96; int(8) DEFAULT NULL,</span><br><span class="line">  &#96;time&#96; timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP(0),</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4;</span><br></pre></td></tr></table></figure><p>然后在代码生成中添加下面的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;database&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;!-- 支持正则，多个字段可以使用&#96;|&#96;分隔 --&gt;</span><br><span class="line">  &lt;recordTimestampFields&gt;last_modified_time&lt;&#x2F;recordTimestampFields&gt;</span><br><span class="line">&lt;&#x2F;database&gt;</span><br></pre></td></tr></table></figure><p>最后生成的<code>Table</code>类中将增加一个<code>getRecordTimestamp</code>方法供乐观锁使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TableField&lt;StudentRecord, Timestamp&gt; getRecordTimestamp() &#123;</span><br><span class="line">    return TIME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用集成"><a href="#应用集成" class="headerlink" title="应用集成"></a>应用集成</h2><h3 id="JOOQ与hikaricp集成管理数据源"><a href="#JOOQ与hikaricp集成管理数据源" class="headerlink" title="JOOQ与hikaricp集成管理数据源"></a>JOOQ与hikaricp集成管理数据源</h3><p>JOOQ唯一的外部依赖就是一个JDBC连接或JDBC资源池<code>DataSource</code>。JOOQ只会使用这个连接构建<code>PreparedStatement</code>和执行SQL，并不会管理这个连接的生命周期。这样做的好处是模块功能划分做的很彻底，数据源的事情由专门的数据源库来管理<code>DataSource</code>是一个独立的模块，我们可以灵活地配置它。</p><p>应用开发需要引入一个第三方的<code>DatatSource</code>数据源来管理数据库连接；这里介绍一下<a href="https://github.com/brettwooldridge/HikariCP">hikaricp</a>的集成方式：</p><p>Hikari提供了<a href="https://github.com/brettwooldridge/HikariCP#initialization">多种方式</a>创建数据源，例如可以程序直接创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HikariConfig config &#x3D; new HikariConfig();</span><br><span class="line">config.setJdbcUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;);</span><br><span class="line">config.setUsername(&quot;root&quot;);</span><br><span class="line">config.setPassword(&quot;123456&quot;);</span><br><span class="line">config.addDataSourceProperty(&quot;cachePrepStmts&quot;, &quot;true&quot;);</span><br><span class="line">config.addDataSourceProperty(&quot;prepStmtCacheSize&quot;, &quot;350&quot;);</span><br><span class="line">config.addDataSourceProperty(&quot;prepStmtCacheSqlLimit&quot;, &quot;2048&quot;);</span><br><span class="line"></span><br><span class="line">HikariDataSource ds &#x3D; new HikariDataSource(config);</span><br><span class="line">DSLContext create &#x3D; DSL.using(ds, SQLDialect.MYSQL);</span><br></pre></td></tr></table></figure><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>ExecuteListener 可以看作是一个JOOQ执行的观察者，它可以监控SQL执行的整个生命周期。并且可以通过执行上下文，做一些个性化的操作。下面SlowQueryListener类的作用就是收集sql执行过程的慢查询日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class SlowQueryListener extends DefaultExecuteListener &#123;</span><br><span class="line">  private Logger logger &#x3D; LoggerFactory.getLogger(SlowQueryListener.class);</span><br><span class="line">  StopWatch watch;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void executeStart(ExecuteContext ctx) &#123;</span><br><span class="line">    super.executeStart(ctx);</span><br><span class="line">    watch &#x3D; new StopWatch();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void executeEnd(ExecuteContext ctx) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      super.executeEnd(ctx);</span><br><span class="line">      if (watch.split() &gt; 1_000_000_000L) &#123;&#x2F;&#x2F;记录执行时间超过1s的操作</span><br><span class="line">        ExecuteType type &#x3D; ctx.type();</span><br><span class="line">        StringBuffer sqlBuffer &#x3D; new StringBuffer();</span><br><span class="line">        if(type &#x3D;&#x3D; ExecuteType.BATCH) &#123;</span><br><span class="line">          for(Query query:ctx.batchQueries()) &#123;</span><br><span class="line">            sqlBuffer.append(query.toString()).append(&quot;\n&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">          sqlBuffer.append(ctx.query() &#x3D;&#x3D; null ? &quot;blank query &quot;:ctx.query().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        watch.splitInfo(String.format(&quot;Slow SQL query meta executed : [ %s ]&quot;,</span><br><span class="line">                                      sqlBuffer.toString() ));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">      logger.error(&quot; SlowQueryListener has occur,fix bug  &quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在初始化 DSLContext 的时候把SlowQueryListener配置进去，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dslContext.configuration()</span><br><span class="line">                .set(DefaultExecuteListenerProvider.providers(slowQueryListener));</span><br></pre></td></tr></table></figure><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p>数据库分库是生产环境中经常使用的方式，例如我们提供了一个新的<code>class</code>的库，复用了<code>student</code>表。如果我们要查询<code>class</code>库，还需要重新生成<code>class</code>的代码，那就太麻烦了。JOOQ提供了运行时替换库名的能力，使得在生产环境中使用多个分库变得很轻松。还以<code>student</code>的查询为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DSLContext dsl &#x3D; DSL.using(conn, SQLDialect.MYSQL);</span><br><span class="line">List&lt;Student&gt; list &#x3D; dslContext.selectFrom(STUDENT).fetch();</span><br></pre></td></tr></table></figure><p>对应的默认查询语句是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;id&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;stu_id&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;stu_name&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;age&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;class_id&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;class_name&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;result&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;time&#96;</span><br><span class="line">from &#96;test&#96;.&#96;student&#96;</span><br></pre></td></tr></table></figure><p>如果我们配置了动态替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Settings settings &#x3D;</span><br><span class="line">        new Settings().withRenderMapping(new RenderMapping().withSchemata(</span><br><span class="line">                new MappedSchema().withInput(&quot;test&quot;).withOutput(&quot;class&quot;)));</span><br><span class="line">DSLContext dsl &#x3D; DSL.using(dataSource, SQLDialect.MYSQL, settings);</span><br><span class="line">List&lt;Student&gt; list &#x3D; dsl.selectFrom(STUDENT).fetch();</span><br></pre></td></tr></table></figure><p>则生成的语句就变为<code>class</code>下的SQL了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;id&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;stu_id&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;stu_name&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;age&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;class_id&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;class_name&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;result&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;time&#96;</span><br><span class="line">from &#96;class&#96;.&#96;student&#96;</span><br></pre></td></tr></table></figure><p>JOOQ还支持多个Schema的动态替换，以及表名的动态替换，详见<a href="http://www.jooq.org/doc/latest/manual/sql-building/dsl-context/runtime-schema-mapping/">Runtime schema mapping</a></p><h3 id="复用数据库实例"><a href="#复用数据库实例" class="headerlink" title="复用数据库实例"></a>复用数据库实例</h3><p>因为JOOQ的SQL是带有Schema名称的，所以对同一个IP实例中的不同数据库，JOOQ可以方便的支持查询。</p><p>这在当多个数据库共用一个数据库实例的时候，很有用，可以复用数据源配置，从而不需要为每一个库创建一个连接池，减少数据库连接资源的占用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataSource &#x3D; ImmutableMap.&lt;String, HikariDataSource&gt;builder()</span><br><span class="line">        .put(&quot;DATABASE1&quot;, datasources1)</span><br><span class="line">        .put(&quot;DATABASE2&quot;, datasources1).build();</span><br></pre></td></tr></table></figure><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul><li><p>Spring： <a href="http://www.jooq.org/doc/3.8/manual-single-page/#jooq-with-spring">http://www.jooq.org/doc/3.8/manual-single-page/#jooq-with-spring</a></p></li><li><p>JOOQ：<a href="https://github.com/jOOQ/jOOQ/tree/master/jOOQ-examples/jOOQ-spring-guice-example">https://github.com/jOOQ/jOOQ/tree/master/jOOQ-examples/jOOQ-spring-guice-example</a></p></li></ul><h3 id="其他常用操作：Batch、Curser、Transaction"><a href="#其他常用操作：Batch、Curser、Transaction" class="headerlink" title="其他常用操作：Batch、Curser、Transaction"></a>其他常用操作：Batch、Curser、Transaction</h3><ul><li>Batch： <a href="http://www.jooq.org/doc/3.8/manual/sql-execution/batch-execution/">http://www.jooq.org/doc/3.8/manual/sql-execution/batch-execution/</a></li><li>游标 Curser： <a href="http://www.jooq.org/doc/3.8/manual/sql-execution/fetching/lazy-fetching/">http://www.jooq.org/doc/3.8/manual/sql-execution/fetching/lazy-fetching/</a></li><li>事务： <a href="http://www.jooq.org/doc/3.8/manual-single-page/#transaction-management">http://www.jooq.org/doc/3.8/manual-single-page/#transaction-management</a></li></ul><h3 id="其它运行时配置"><a href="#其它运行时配置" class="headerlink" title="其它运行时配置"></a>其它运行时配置</h3><p>JOOQ将一些不常用的配置，放在Settings对象类管理，例如</p><ul><li>是否使用乐观锁</li><li>是否打印JOOQ的SQL日志</li></ul><p>具体可以参考<a href="http://www.jooq.org/doc/3.8/manual/sql-building/dsl-context/custom-settings/">JOOQ文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是对之前一段时间学习Jooq的总结。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是对之前一段时间学习Jooq的总结。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是对之前一段时间学习Jooq的总结。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是对之前一段时间学习Jooq的总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。&quot;&gt;&lt;a href=&quot;#前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。&quot; class=&quot;headerlink&quot; title=&quot;前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。&quot;&gt;&lt;/a&gt;前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="ORM" scheme="https://www.blog.ajie39.top/categories/ORM/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="ORM" scheme="https://www.blog.ajie39.top/tags/ORM/"/>
    
    <category term="Jooq" scheme="https://www.blog.ajie39.top/tags/Jooq/"/>
    
  </entry>
  
  <entry>
    <title>Google Java编程风格规范（中文）</title>
    <link href="https://www.blog.ajie39.top/2020/02/14/Google%20Java%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2020/02/14/Google%20Java%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89/</id>
    <published>2020-02-14T00:09:15.341Z</published>
    <updated>2021-05-05T04:24:53.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这份文档是Google-Java编程风格规范的完整定义。"><a href="#摘要：这份文档是Google-Java编程风格规范的完整定义。" class="headerlink" title="摘要：这份文档是Google Java编程风格规范的完整定义。"></a>摘要：这份文档是Google Java编程风格规范的完整定义。</h1><hr><h1 id="前言：这份文档是Google-Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。"><a href="#前言：这份文档是Google-Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。" class="headerlink" title="前言：这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。"></a>前言：这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</h1><p>原文《Google Java Style》：<a href="https://google.github.io/styleguide/javaguide.html">https://google.github.io/styleguide/javaguide.html</a></p><p>January 20, 2014<br>作者：Hawstein<br>出处：<a href="http://hawstein.com/2014/01/20/google-java-style/">http://hawstein.com/2014/01/20/google-java-style/</a><br>声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0，转载请注明作者及出处。</p><hr><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>在本文档中，除非另有说明：</p><ol><li>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)。</li><li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li></ol><p>其他的术语说明会偶尔在后面的文档出现。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式为UTF-8。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h4><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ol><li>所有其它字符串中的空白字符都要进行转义。</li><li>制表符不用于缩进。</li></ol><h4 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h4><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, &quot;, &#39;及\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p><p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String unitAbbrev &#x3D; &quot;μs&quot;;                                 | 赞，即使没有注释也非常清晰</span><br><span class="line">String unitAbbrev &#x3D; &quot;\u03bcs&quot;; &#x2F;&#x2F; &quot;μs&quot;                    | 允许，但没有理由要这样做</span><br><span class="line">String unitAbbrev &#x3D; &quot;\u03bcs&quot;; &#x2F;&#x2F; Greek letter mu, &quot;s&quot;    | 允许，但这样做显得笨拙还容易出错</span><br><span class="line">String unitAbbrev &#x3D; &quot;\u03bcs&quot;;                            | 很糟，读者根本看不出这是什么</span><br><span class="line">return &#39;\ufeff&#39; + content; &#x2F;&#x2F; byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释</span><br></pre></td></tr></table></figure><p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p><h2 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h2><p>一个源文件包含(按顺序地)：</p><ol><li>许可证或版权信息(如有需要)</li><li>package语句</li><li>import语句</li><li>一个顶级类(只有一个)</li></ol><p>以上每个部分之间用一个空行隔开。</p><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h4><p>即，不要出现类似这样的import语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h4><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p><ol><li>所有的静态导入独立成组</li><li>com.google imports(仅当这个源文件是在com.google包下)</li><li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li><li>java imports</li><li>javax imports</li></ol><p>组内不空行，按字典序排列。</p><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p><p>例外：package-info.java，该文件中可没有package-info类。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h4 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h4><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h4><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return new MyClass() &#123;</span><br><span class="line">  @Override public void method() &#123;</span><br><span class="line">    if (condition()) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        something();</span><br><span class="line">      &#125; catch (ProblemException e) &#123;</span><br><span class="line">        recover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在4.8.1节给出了enum类的一些例外。</p><h4 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h4><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void doNothing() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每个语句后要换行。</p><h3 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h3><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p><p>例外：</p><ol><li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li><li>package和import语句(见3.2节和3.3节)。</li><li>注释中那些可能被剪切并粘贴到shell中的命令行。</li></ol><h3 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h3><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p><p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p><h4 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h4><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p><ol><li>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（&lt;T extends Foo &amp; Bar&gt;)，catch块中的管道符号(catch (FooException | BarException e)</li><li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。</li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(,)与其前面的内容留在同一行。</li></ol><h4 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>在4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用一个空行：</p><ol><li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul><li>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li></ul></li><li>在函数体内，语句的逻辑分组间使用空行。</li><li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li><li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li></ol><p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p><ol><li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li><li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li><li>在任何左大括号前({)，两个例外：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. @SomeAnnotation(&#123;a, b&#125;)(不使用空格)。</span><br><span class="line"></span><br><span class="line">2. String[][] x &#x3D; foo;(大括号间没有空格，见下面的Note)。</span><br></pre></td></tr></table></figure><p>  4.在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 类型界限中的&amp;(&lt;T extends Foo &amp; Bar&gt;)。</span><br><span class="line"></span><br><span class="line">2. catch块中的管道符号(catch (FooException | BarException e)。</span><br><span class="line"></span><br><span class="line">3. foreach语句中的分号。</span><br></pre></td></tr></table></figure><ol start="5"><li>在, : ;及右括号())后。</li><li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li><li>类型和变量之间：List list。</li><li>数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</li></ol><p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p><p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p><p>以下示例先展示未对齐的代码，然后是对齐的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private int x; &#x2F;&#x2F; this is fine</span><br><span class="line">private Color color; &#x2F;&#x2F; this too</span><br><span class="line"></span><br><span class="line">private int   x;      &#x2F;&#x2F; permitted, but future edits</span><br><span class="line">private Color color;  &#x2F;&#x2F; may leave it unaligned</span><br></pre></td></tr></table></figure><p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p><h3 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h3><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h3><h4 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h4><p>枚举常量间用逗号隔开，换行可选。</p><p>没有方法和文档的枚举类可写成数组初始化的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h5><p>不要使用组合声明，比如int a, b;。</p><h5 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new int[] &#123;</span><br><span class="line">  0, 1, 2, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[] &#123;</span><br><span class="line">  0,</span><br><span class="line">  1,</span><br><span class="line">  2,</span><br><span class="line">  3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[] &#123;</span><br><span class="line">  0, 1,</span><br><span class="line">  2, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[]&#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：String[] args， 而非String args[]。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p><p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p><h5 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h5><p>在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch (input) &#123;</span><br><span class="line">  case 1:</span><br><span class="line">  case 2:</span><br><span class="line">    prepareOneOrTwo();</span><br><span class="line">    &#x2F;&#x2F; fall through</span><br><span class="line">  case 3:</span><br><span class="line">    handleOneTwoOrThree();</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h5><p>每个switch语句都包含一个default语句组，即使它什么代码也不包含。</p><h4 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h4><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public String getNameIfPresent() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override public int hashCode() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Partial @Mock DataLoader loader;</span><br></pre></td></tr></table></figure><p>参数和局部变量注解没有特定规则。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">块注释与其周围的代码在同一缩进级别。它们可以是&#x2F;* ... *&#x2F;风格，也可以是&#x2F;&#x2F; ...风格。对于多行的&#x2F;* ... *&#x2F;注释，后续行必须从*开始， 并且与前一行的*对齐。以下示例注释都是OK的。</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * This is</span><br><span class="line"> * okay.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Or you can</span><br><span class="line"> * even do this. *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; And so</span><br></pre></td></tr></table></figure><p>注释不要封闭在由星号或其它字符绘制的框架里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 &#x2F;* ... *&#x2F;。</span><br></pre></td></tr></table></figure><h4 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h4><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public protected private abstract static final transient volatile synchronized native strictfp</span><br></pre></td></tr></table></figure><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以UpperCamelCase风格编写。</p><p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以lowerCamelCase风格编写。</p><p>方法名通常是动词或动词短语。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p><p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Constants</span><br><span class="line">static final int NUMBER &#x3D; 5;</span><br><span class="line">static final ImmutableList&lt;String&gt; NAMES &#x3D; ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);</span><br><span class="line">static final Joiner COMMA_JOINER &#x3D; Joiner.on(&#39;,&#39;);  &#x2F;&#x2F; because Joiner is immutable</span><br><span class="line">static final SomeMutableType[] EMPTY_ARRAY &#x3D; &#123;&#125;;</span><br><span class="line">enum SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Not constants</span><br><span class="line">static String nonFinal &#x3D; &quot;non-final&quot;;</span><br><span class="line">final String nonStatic &#x3D; &quot;non-static&quot;;</span><br><span class="line">static final Set&lt;String&gt; mutableCollection &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">static final ImmutableSet&lt;SomeMutableType&gt; mutableElements &#x3D; ImmutableSet.of(mutable);</span><br><span class="line">static final Logger logger &#x3D; Logger.getLogger(MyClass.getName());</span><br><span class="line">static final String[] nonEmptyArray &#x3D; &#123;&quot;these&quot;, &quot;can&quot;, &quot;change&quot;&#125;;</span><br></pre></td></tr></table></figure><p>这些名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以lowerCamelCase风格编写。</p><p>这些名字通常是名词或名词短语。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以lowerCamelCase风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p><p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p><p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p>驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ol><li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Prose form                Correct               Incorrect</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest</span><br><span class="line">&quot;new customer ID&quot;         newCustomerId         newCustomerID</span><br><span class="line">&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch</span><br><span class="line">&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS</span><br><span class="line">&quot;YouTube importer&quot;        YouTubeImporter</span><br><span class="line">                          YoutubeImporter*</span><br></pre></td></tr></table></figure><p>加星号处表示可以，但不推荐。</p><p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。</p><h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><h3 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 /@Override：能用则用"></a>6.1 /@Override：能用则用</h3><p>只要是合法的，就把@Override注解给用上。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)</p><p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  int i &#x3D; Integer.parseInt(response);</span><br><span class="line">  return handleNumericResponse(i);</span><br><span class="line">&#125; catch (NumberFormatException ok) &#123;</span><br><span class="line">  &#x2F;&#x2F; it&#39;s not numeric; that&#39;s fine, just continue</span><br><span class="line">&#125;</span><br><span class="line">return handleTextResponse(response);</span><br></pre></td></tr></table></figure><p>例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  emptyStack.pop();</span><br><span class="line">  fail();</span><br><span class="line">&#125; catch (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h3><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo &#x3D; ...;</span><br><span class="line">Foo.aStaticMethod(); &#x2F;&#x2F; good</span><br><span class="line">aFoo.aStaticMethod(); &#x2F;&#x2F; bad</span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); &#x2F;&#x2F; very bad</span><br></pre></td></tr></table></figure><h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h3><p>极少会去重写Object.finalize。</p><p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解 Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p><h2 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p>Javadoc块的基本格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Multiple lines of Javadoc text are written here,</span><br><span class="line"> * wrapped normally...</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int method(String p1) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>或者是以下单行形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** An especially short bit of Javadoc. *&#x2F;</span><br></pre></td></tr></table></figure><p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签&lt;p&gt;，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的Javadoc标记按以下顺序出现：@param, @return, @throws,<br>@deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p><h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a…或This method returns…开头, 它也不会是一个完整的祈使句，如Save the record…。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tip：一个常见的错误是把简单的Javadoc写成&#x2F;** @return the customer ID *&#x2F;，这是不正确的。它应该写成&#x2F;** Returns the customer ID. *&#x2F;。</span><br></pre></td></tr></table></figure><h3 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h3><p>至少在每个public类及它的每个 public 和 protected 成员处使用 Javadoc，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 getCanonicalName ， 就不应该忽视文档说明，因为读者很可能不知道词语 canonical name 指的是什么。</p><h4 id="7-3-2-例外：重写"><a href="#7-3-2-例外：重写" class="headerlink" title="7.3.2 例外：重写"></a>7.3.2 例外：重写</h4><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这份文档是Google-Java编程风格规范的完整定义。&quot;&gt;&lt;a href=&quot;#摘要：这份文档是Google-Java编程风格规范的完整定义。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这份文档是Google Java编程风格规范的完整定义。&quot;&gt;&lt;/a&gt;摘要：这份文档是Google Java编程风格规范的完整定义。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：这份文档是Google-Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。&quot;&gt;&lt;a href=&quot;#前言：这份文档是Google-Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。&quot; class=&quot;headerlink&quot; title=&quot;前言：这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。&quot;&gt;&lt;/a&gt;前言：这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。&lt;/h1&gt;&lt;p&gt;原文《Google Java Style》：&lt;a href=&quot;https://google.github.io/styleguide/javaguide.html&quot;&gt;https://google.github.io/styleguide/javaguide.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;January 20, 2014&lt;br&gt;作者：Hawstein&lt;br&gt;出处：&lt;a href=&quot;http://hawstein.com/2014/01/20/google-java-style/&quot;&gt;http://hawstein.com/2014/01/20/google-java-style/&lt;/a&gt;&lt;br&gt;声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0，转载请注明作者及出处。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="编程规范" scheme="https://www.blog.ajie39.top/categories/Java/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习lambda表达式</title>
    <link href="https://www.blog.ajie39.top/2019/12/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.blog.ajie39.top/2019/12/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-12-03T11:18:52.686Z</published>
    <updated>2021-05-05T04:23:53.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。"><a href="#摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。" class="headerlink" title="摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。"></a>摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。</h1><hr><h1 id="前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。"><a href="#前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。" class="headerlink" title="前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。"></a>前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。</h1><hr><span id="more"></span><h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h2><p>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口。lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。Lambda表达式还增强了集合库。</p><p>Java Lambda表达式的一个重要用法是简化某些匿名内部类（Anonymous Classes）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的。</p><h2 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h2><p>Lambda 表达式在 Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;”，该操作符被称 为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分：</p><ul><li>左侧： 指定了 Lambda 表达式需要的所有参数</li><li>右侧： 指定了 Lambda 体，即 Lambda 表达式要执行的功能。</li></ul><ol><li><p>语法格式一：无参，无返回值，Lambda 体只需一条语句。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      示例：</span><br><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello Lambda!&quot;);</span><br></pre></td></tr></table></figure></li><li><p>语法格式二：Lambda 需要一个参数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">  Consumer&lt;String&gt; con &#x3D; （x） -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure></li><li><p>语法格式三：Lambda 只需要一个参数时，参数的小括号可以省略。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      示例：</span><br><span class="line">Consumer&lt;String&gt; con &#x3D; x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure></li><li><p>语法格式四：Lambda 需要两个参数，并且有返回值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">   Comparator&lt;Integer&gt; com &#x3D; (x, y) -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;函数式接口&quot;);</span><br><span class="line">      return Integer.compare(x, y);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li><li><p>语法格式五：当 Lambda 体只有一条语句时，return 与大括号可以省略。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">  Comparator&lt;Integer&gt; com &#x3D; (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure></li><li><p>Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">  Comparator&lt;Integer&gt; com &#x3D; (Integer x,Integer y) -&gt; &#123;  &#x2F;&#x2F;Integer 类型可以省略</span><br><span class="line">     System.out.println(&quot;函数式接口&quot;);</span><br><span class="line">     return Integer.compare(x, y);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  BinaryOperator&lt;Long&gt; add &#x3D; (Long x, Long y) -&gt; x + y;&#x2F;&#x2F; 4</span><br><span class="line"></span><br><span class="line">  BinaryOperator&lt;Long&gt; addImplicit &#x3D; (x, y) -&gt; x + y;&#x2F;&#x2F; 5 类型推断</span><br></pre></td></tr></table></figure></li></ol><p>类型推断：Lambda 表达式中的参数类型都是由编译器推断 得出的。 Lambda 表达式中无需指定类型，程序依然可 以编译，这是因为 javac 根据程序的上下文，在后台 推断出了参数的类型。 Lambda 表达式的类型依赖于上 下文环境，是由编译器推断出来的。这就是所谓的 “类型推断”</p><h2 id="使用Lambda表达式的要求"><a href="#使用Lambda表达式的要求" class="headerlink" title="使用Lambda表达式的要求"></a>使用Lambda表达式的要求</h2><p>也许你已经想到了，能够使用Lambda的依据是必须有相应的 <strong>函数接口</strong>。</p><p>函数接口，是指内部只有一个抽象方法的接口。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上Lambda的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。</p><h2 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h2><p>自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义函数接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface ConsumerInterface&lt;T&gt;&#123;</span><br><span class="line">void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override标注会检查是否重载了函数一样。有了上述接口定义，就可以写出类似如下的代码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConsumerInterface&lt;String&gt; consumer &#x3D; str -&gt; System.out.println(str);</span><br><span class="line">consumer.accept(&quot;我是自定义函数式接口&quot;);</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">详细例子参考：</span><br><span class="line">  import java.util.Arrays;</span><br><span class="line">  import java.util.List;</span><br><span class="line"></span><br><span class="line">  public class Test &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          TestStream&lt;String&gt; stream &#x3D; new TestStream&lt;String&gt;();</span><br><span class="line">          List list &#x3D; Arrays.asList(&quot;11&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">          stream.setList(list);</span><br><span class="line">          stream.myForEach(str -&gt; System.out.println(str));&#x2F;&#x2F; 使用自定义函数接口书写Lambda表达式</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @FunctionalInterface</span><br><span class="line">  interface ConsumerInterface&lt;T&gt;&#123;</span><br><span class="line">      void accept(T t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class TestStream&lt;T&gt;&#123;</span><br><span class="line">      private List&lt;T&gt; list;</span><br><span class="line">      public void myForEach(ConsumerInterface&lt;T&gt; consumer)&#123;&#x2F;&#x2F; 1</span><br><span class="line">          for(T t : list)&#123;</span><br><span class="line">              consumer.accept(t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setList(List&lt;T&gt; list) &#123;</span><br><span class="line">          this.list &#x3D; list;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Java-内置四大核心函数式接口"><a href="#Java-内置四大核心函数式接口" class="headerlink" title="Java 内置四大核心函数式接口"></a>Java 内置四大核心函数式接口</h2><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>Consumer&lt;T&gt;  消费型接口</td><td>T</td><td>void</td><td>对类型为T的对象应用操作，包含方法：void accept(T t);</td></tr><tr><td>Supplier&lt;T&gt;  供给型接口</td><td>无</td><td>T</td><td>返回类型为T的对象，包含方法：T get();</td></tr><tr><td>Function&lt;T, R&gt;  函数型接口</td><td>T</td><td>R</td><td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t);</td></tr><tr><td>Predicate&lt;T&gt;  断定型接口</td><td>T</td><td>boolean</td><td>确定类型为T的对象是否满足某约束，并返回boolean值。包含方法boolean test(T t);</td></tr></tbody></table><h3 id="Consumer-lt-T-gt-消费型接口"><a href="#Consumer-lt-T-gt-消费型接口" class="headerlink" title="Consumer&lt;T&gt;  消费型接口"></a>Consumer&lt;T&gt;  消费型接口</h3><p>  void accept(T t);</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    hello(&quot;张三&quot;, (m) -&gt; System.out.println(&quot;你好：&quot; + m));</span><br><span class="line">&#125;</span><br><span class="line">public void hello(String st, Consumer&lt;String&gt; con)&#123;</span><br><span class="line">    con.accept(st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Supplier-lt-T-gt-供给型接口"><a href="#Supplier-lt-T-gt-供给型接口" class="headerlink" title="Supplier&lt;T&gt; 供给型接口"></a>Supplier&lt;T&gt; 供给型接口</h3><p>  T get();</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Supplier&lt;T&gt; 供给型接口 :</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    List list &#x3D; Arrays.asList(121, 1231, 455, 56, 67,78);</span><br><span class="line">    List&lt;Integer&gt; numList &#x3D; getNumList(1, () -&gt; (int)(Math.random() * 100));</span><br><span class="line">    for (Integer num : numList) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;需求：产生指定个数的整数，并放入集合中</span><br><span class="line">public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123;</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">        Integer n &#x3D; sup.get();</span><br><span class="line">        list.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function-lt-T-R-gt-函数型接口"><a href="#Function-lt-T-R-gt-函数型接口" class="headerlink" title="Function&lt;T, R&gt; 函数型接口"></a>Function&lt;T, R&gt; 函数型接口</h3><p>  R apply(T t);</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Function&lt;T, R&gt; 函数型接口：</span><br><span class="line">@Test</span><br><span class="line">public void test3()&#123;</span><br><span class="line">    String newStr &#x3D; strHandler(&quot;\t\t\t 这是一个函数型接口 &quot;, (str) -&gt; str.trim());</span><br><span class="line">    System.out.println(newStr);</span><br><span class="line">    String subStr &#x3D; strHandler(&quot;这是一个函数型接口&quot;, (str) -&gt; str.substring(4, 7));</span><br><span class="line">    System.out.println(subStr);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;需求：用于处理字符串</span><br><span class="line">public String strHandler(String str, Function&lt;String, String&gt; fun)&#123;</span><br><span class="line">    return fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate-lt-T-gt-断定型接口"><a href="#Predicate-lt-T-gt-断定型接口" class="headerlink" title="Predicate&lt;T&gt; 断定型接口"></a>Predicate&lt;T&gt; 断定型接口</h3><p>  boolean test(T t);</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Predicate&lt;T&gt; 断言型接口：</span><br><span class="line">@Test</span><br><span class="line">public void test4()&#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;Hello&quot;, &quot;Java8&quot;, &quot;Lambda&quot;, &quot;www&quot;, &quot;ok&quot;);</span><br><span class="line">    List&lt;String&gt; strList &#x3D; filterStr(list, (s) -&gt; s.length() &gt; 3);</span><br><span class="line">    for (String str : strList) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;需求：将满足条件的字符串，放入集合中</span><br><span class="line">public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        if(pre.test(str))&#123;</span><br><span class="line">            strList.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return strList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h3><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>BiFunction&lt;T, U, R&gt;</td><td>T,U</td><td>R</td><td>对类型为 T，U 参数应用操作，返回 R 类型的结果。包含方法为R apply(T t, U u);</td></tr><tr><td>UnaryOperator&lt;T&gt; (Function子接口)</td><td>T</td><td>T</td><td>对类型为 T 的对象进行一元运算，并返回 T 类型的结果。包含方法为 T apply(T t);</td></tr><tr><td>BinaryOperator&lt;T&gt;  (BiFunction子接口)</td><td>T,T</td><td>T</td><td>对类型为T的对象进行二元运算，并返回 T 类型的结果。包含方法为 T apply(T t1, T t2);</td></tr><tr><td>BiConsumer&lt;T, U&gt;</td><td>T,U</td><td>void</td><td>对类型为T，U参数应用操作。包含方法为 void accept(T t, U u)</td></tr><tr><td>ToIntFunction&lt;T&gt; <br> ToLongFunction&lt;T&gt; <br> ToDoubleFunction&lt;T&gt; <br></td><td>T</td><td>int <br> long <br> double</td><td>分别计算int、long、double值的函数</td></tr><tr><td>IntFunction&lt;R&gt; <br> LongFunction&lt;R&gt; <br> DoubleFunction&lt;R&gt; <br></td><td>int <br> long <br> double</td><td>R</td><td>参数分别为int、long、double类型的函数</td></tr></tbody></table><h2 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给Lambda体内的操作，已经有实现的方法了，就可以使用方法引用了！</p><p>方法引用使用的前提条件是什么呢？</p><ul><li>方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表相同（完全一致）。</li><li>方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值相同（完全一致）。</li></ul><p>方法引用一般有三种格式：</p><ul><li>实例对象名::实例方法名</li><li>类名::静态方法名</li><li>类名::实例方法名</li></ul><p>注意：</p><ul><li>2和3的区别：若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： 类名::实例方法名。</li></ul><p>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。</p><h4 id="1、对象-实例方法"><a href="#1、对象-实例方法" class="headerlink" title="1、对象::实例方法"></a>1、对象::实例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    PrintStream ps &#x3D; System.out;</span><br><span class="line">    Consumer&lt;String&gt; con &#x3D; (str) -&gt; ps.println(str);</span><br><span class="line">    con.accept(&quot;Hello World！&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;--------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">    Consumer&lt;String&gt; con2 &#x3D; ps::println;</span><br><span class="line">    con2.accept(&quot;Hello Java8！&quot;);</span><br><span class="line"></span><br><span class="line">    Consumer&lt;String&gt; con3 &#x3D; System.out::println;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    Employee emp &#x3D; new Employee(1, &quot;张三&quot;, 18, 5112.99);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;String&gt; sup &#x3D; () -&gt; emp.getName();</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">    Employee emp1 &#x3D; new Employee(2, &quot;李四&quot;, 18, 5112.99);</span><br><span class="line">    Supplier&lt;String&gt; sup2 &#x3D; emp1::getName;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、类-静态方法"><a href="#2、类-静态方法" class="headerlink" title="2、类::静态方法"></a>2、类::静态方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3()&#123;</span><br><span class="line">    BiFunction&lt;Double, Double, Double&gt; fun &#x3D; (x, y) -&gt; Math.max(x, y);</span><br><span class="line">    System.out.println(fun.apply(1.5, 22.2));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;--------------------------------------------------&quot;);</span><br><span class="line">    BiFunction&lt;Double, Double, Double&gt; fun2 &#x3D; Math::max;</span><br><span class="line">    System.out.println(fun2.apply(1.2, 1.5));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test4()&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com &#x3D; (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">    System.out.println(com.compare(3,9));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-------------------------------------&quot;);</span><br><span class="line">    Comparator&lt;Integer&gt; com2 &#x3D; Integer::compare;</span><br><span class="line">    System.out.println(com2.compare(3,9));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、类-实例方法"><a href="#3、类-实例方法" class="headerlink" title="3、类::实例方法"></a>3、类::实例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test5()&#123;</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp &#x3D; (x, y) -&gt; x.equals(y);</span><br><span class="line">    System.out.println(bp.test(&quot;abcde&quot;, &quot;abcde&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp2 &#x3D; String::equals;</span><br><span class="line">    System.out.println(bp2.test(&quot;abc&quot;, &quot;abc&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    Function&lt;Employee, String&gt; fun &#x3D; (e) -&gt; e.show();</span><br><span class="line">    System.out.println(fun.apply(new Employee()));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    Function&lt;Employee, String&gt; fun2 &#x3D; Employee::show;</span><br><span class="line">    System.out.println(fun2.apply(new Employee()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器使用的前提是什么？</p><ul><li>构造器参数列表要与接口中抽象方法的参数列表一致！</li></ul><p>语法格式：</p><ul><li>类名 :: new</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Employee类中必须有一个 Employee(String name, int age) 的构造器</span><br><span class="line">BiConsumer&lt;String, Integer&gt; biConsumer &#x3D; Employee :: new;</span><br><span class="line">biConsumer.accept(&quot;王五&quot;, 19);</span><br></pre></td></tr></table></figure><h4 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h4><p>数组引用和构造引用基本相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test10()&#123;</span><br><span class="line">    &#x2F;&#x2F;传统Lambda实现</span><br><span class="line">    Function&lt;Integer,int[]&gt; function &#x3D; (i) -&gt; new int[i];</span><br><span class="line">    int[] apply &#x3D; function.apply(10);</span><br><span class="line">    System.out.println(apply.length); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数组类型引用实现</span><br><span class="line">    function &#x3D; int[] ::new;</span><br><span class="line">    apply &#x3D; function.apply(100);</span><br><span class="line">    System.out.println(apply.length); &#x2F;&#x2F; 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collections中的常用函数接口"><a href="#Collections中的常用函数接口" class="headerlink" title="Collections中的常用函数接口"></a>Collections中的常用函数接口</h2><p>Java8新增了java.util.funcion包，里面包含常用的函数接口，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。</p><p>Java集合框架的接口继承结构:</p><p><img src="/blog/21/1.png" alt="Java集合框架的接口继承结构"></p><p>上图中绿色标注的接口类，表示在Java8中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。</p><table><thead><tr><th>接口名</th><th>Java8新加入的方法</th></tr></thead><tbody><tr><td>Collection</td><td>removeIf() spliterator() stream() parallelStream() forEach()</td></tr><tr><td>List</td><td>replaceAll() sort()</td></tr><tr><td>Map</td><td>getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td></tr></tbody></table><p>这些新加入的方法大部分要用到java.util.function包下的接口，这意味着这些方法大部分都跟Lambda表达式相关。</p><h3 id="Collection中的新方法"><a href="#Collection中的新方法" class="headerlink" title="Collection中的新方法"></a>Collection中的新方法</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法的签名为void forEach(Consumer&lt;? super E&gt; action)，作用是对容器中的每个元素执行action指定的动作，其中Consumer是个函数接口，里面只有一个待实现方法void accept(T t)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.forEach(new Consumer&lt;Integer&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer)&#123;</span><br><span class="line">        if(integer % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.forEach((s) -&gt; &#123;</span><br><span class="line">    if (s % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h4><p>该方法签名为boolean removeIf(Predicate&lt;? super E&gt; filter)，作用是删除容器中所有满足filter指定条件的元素，其中Predicate是一个函数接口，里面只有一个待实现方法boolean test(T t)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.removeIf(new Predicate&lt;Integer&gt;()&#123; &#x2F;&#x2F; 删除长度大于3的元素</span><br><span class="line">    @Override</span><br><span class="line">    public boolean test(Integer sum)&#123;</span><br><span class="line">        return sum % 3 &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.removeIf(s -&gt; s % 3 &#x3D;&#x3D; 0);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为void replaceAll(UnaryOperator&lt;E&gt; operator)，作用是对每个元素执行operator指定的操作，并用操作结果来替换原来的元素。其中UnaryOperator是一个函数接口，里面只有一个待实现函数T apply(T t)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.replaceAll(new UnaryOperator&lt;Integer&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer apply(Integer sum)&#123;</span><br><span class="line">        if(sum % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return ++sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return --sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.replaceAll(sum -&gt; &#123;</span><br><span class="line">    if (sum % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return ++sum;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return --sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>该方法定义在List接口中，方法签名为void sort(Comparator&lt;? super E&gt; c)，该方法根据c指定的比较规则对容器元素进行排序。Comparator接口我们并不陌生，其中有一个方法int compare(T o1, T o2)需要实现，显然该接口是个函数接口。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(6, 10, 9, 3));</span><br><span class="line">Collections.sort(list, new Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Integer sum1, Integer sum2)&#123;</span><br><span class="line">        return sum1 - sum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(6, 10, 9, 3));</span><br><span class="line">System.out.println(list);</span><br><span class="line">list.sort((sum1, sum2) -&gt; sum1 - sum2);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h4><p>方法签名为Spliterator&lt;E&gt; spliterator()，该方法返回容器的可拆分迭代器。从名字来看该方法跟iterator()方法有点像，我们知道Iterator是用来迭代容器的，Spliterator也有类似作用，但二者有如下不同：</p><p>Spliterator既可以像Iterator那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。<br>Spliterator是可拆分的，一个Spliterator可以通过调用Spliterator<T> trySplit()方法来尝试分成两个。一个是this，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。<br>可通过（多次）调用Spliterator.trySplit()方法来分解负载，以便多线程处理。</p><h4 id="stream-和parallelStream"><a href="#stream-和parallelStream" class="headerlink" title="stream()和parallelStream()"></a>stream()和parallelStream()</h4><p>stream()和parallelStream()分别返回该容器的Stream视图表示，不同之处在于parallelStream()返回并行的Stream。Stream是Java函数式编程的核心类，具体内容后面单独介绍。</p><h3 id="Map中的新方法"><a href="#Map中的新方法" class="headerlink" title="Map中的新方法"></a>Map中的新方法</h3><h4 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法签名为void forEach(BiConsumer&lt;? super K,? super V&gt; action)，作用是对Map中的每个映射执行action指定的操作，其中BiConsumer是一个函数接口，里面有一个待实现方法void accept(T t, U u)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">map.forEach(new BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer key, String value)&#123;</span><br><span class="line">        System.out.println(key + &quot;&#x3D;&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><h4 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为V getOrDefault(Object key, V defaultValue)，作用是按照给定的key查询Map中对应的value，如果没有找到则返回defaultValue。使用该方法可以省去查询指定键值是否存在的麻烦。</p><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">&#x2F;&#x2F; Java7以及之前做法</span><br><span class="line">if(map.containsKey(4))&#123;</span><br><span class="line">    System.out.println(map.get(4));</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    System.out.println(&quot;NoValue&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Java8使用Map.getOrDefault()</span><br><span class="line">System.out.println(map.getOrDefault(4, &quot;NoValue&quot;));</span><br></pre></td></tr></table></figure><h4 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为V putIfAbsent(K key, V value)，作用是只有在不存在key值的映射或映射值为null时，才将value指定的值放入到Map中，否则不对Map做更改．该方法将条件判断和赋值合二为一，使用起来更加方便。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>我们都知道Map中有一个remove(Object key)方法，来根据指定key值删除Map中的映射关系；Java8新增了remove(Object key, Object value)方法，只有在当前Map中key正好映射到value时才删除该映射，否则什么也不做。</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>在Java7及以前，要想替换Map中的映射关系可通过put(K key, V value)方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在Map中加入了两个replace()方法，分别如下：</p><ul><li>replace(K key, V value)，只有在当前Map中key的映射存在时才用value去替换原来的值，否则什么也不做。</li><li>replace(K key, V oldValue, V newValue)，只有在当前Map中key的映射存在且等于oldValue时才用newValue去替换原来的值，否则什么也不做。</li></ul><h4 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)，作用是对Map中的每个映射执行function指定的操作，并用function的执行结果替换原来的value，其中BiFunction是一个函数接口，里面有一个待实现方法R apply(T t, U u)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">map.replaceAll(new BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer k, String v)&#123;</span><br><span class="line">        if (v.equals(&quot;我&quot;))&#123;</span><br><span class="line">            v &#x3D; &quot;你&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">map.replaceAll((k, v) -&gt; &#123;</span><br><span class="line">    if (v.equals(&quot;我&quot;))&#123;</span><br><span class="line">        v &#x3D; &quot;你&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return v.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>该方法签名为merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)。</p><p>作用是：</p><ul><li>如果Map中key对应的映射不存在或者为null，则将value（不能是null）关联到key上；</li><li>否则执行remappingFunction，如果执行结果非null则用该结果跟key关联，否则在Map中删除key的映射。</li></ul><p>  参数中BiFunction函数接口前面已经介绍过，里面有一个待实现方法R apply(T t, U u)。</p><p>merge()方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line"></span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br><span class="line">map.merge(1, &quot;和你&quot;, (v1, v2) -&gt; v1+v2);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><h4 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h4><p>该方法签名为compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)，作用是把remappingFunction的计算结果关联到key上，如果计算结果为null，则在Map中删除key的映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line"></span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br><span class="line">map.compute(1, (k,v) -&gt; v &#x3D;&#x3D; null ? &quot;值为空&quot; : v.concat(&quot;和你&quot;));</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h4><p>该方法签名为V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)，作用是：只有在当前Map中不存在key值的映射或映射值为null时，才调用mappingFunction，并在mappingFunction执行结果非null时，将结果跟key关联。</p><p>Function是一个函数接口，里面有一个待实现方法R apply(T t)。</p><p>computeIfAbsent()常用来对Map的某个key值建立初始化映射．比如我们要实现一个多值映射，Map的定义可能是Map&lt;K,Set&lt;V&gt;&gt;，要向Map中放入新值，可通过如下代码实现：</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Java7及以前的实现方式</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.get(<span class="number">1</span>).add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, valueSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8的实现方式</span></span><br><span class="line">map.computeIfAbsent(<span class="number">1</span>, v -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(<span class="string">&quot;345&quot;</span>);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;=&quot;</span> + value));</span><br></pre></td></tr></table></figure><p>使用computeIfAbsent()将条件判断和添加操作合二为一，使代码更加简洁。</p><h4 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h4><p>该方法签名为V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)，作用跟computeIfAbsent()相反。即只有在当前Map中存在key值的映射且非null时，才调用remappingFunction，如果remappingFunction执行结果为null，则删除key的映射，否则使用该结果替换key原来的映射。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>对于Java 7来说stream完全是个陌生东西，stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。</p><p>常见的stream接口继承关系如图：</p><p><img src="/blog/21/2.png" alt="Java集合框架的接口继承结构"></p><p>图中4种stream接口继承自BaseStream，其中IntStream, LongStream, DoubleStream对应三种基本类型（int, long, double，注意不是包装类型），Stream对应所有剩余类型的stream视图。</p><p>为不同数据类型设置不同stream接口，可以:</p><ol><li>提高性能</li><li>增加特定接口函数。</li></ol><p>为什么不把IntStream等设计成Stream的子接口？</p><p>答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为Java不允许只有返回类型不同的方法重载。</p><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p><ul><li>无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li><li>为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li><li>惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li>可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><p>对stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations)，二者特点是：</p><ul><li>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li><li>结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li></ul><p>下表汇总了Stream接口的部分常见方法：</p><table><thead><tr><th>操作类型</th><th>接口方法</th></tr></thead><tbody><tr><td>中间操作</td><td>concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td></tr><tr><td>结束操作</td><td>allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td></tr></tbody></table><p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。</p><h3 id="stream方法使用"><a href="#stream方法使用" class="headerlink" title="stream方法使用"></a>stream方法使用</h3><p>stream跟函数接口关系非常紧密，没有函数接口stream就无法工作。</p><p>函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。</p><h4 id="forEach-2"><a href="#forEach-2" class="headerlink" title="forEach()"></a>forEach()</h4><p>方法签名为void forEach(Consumer&lt;? super E&gt; action)，作用是对容器中的每个元素执行action指定的动作，也就是对元素进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>由于forEach()是结束方法，上述代码会立即执行，输出所有字符串。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>函数原型为Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)，作用是返回一个只包含满足predicate条件元素的Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保留长度大于等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stream.filter(str -&gt; str.length() &gt;= <span class="number">3</span>).forEach(str -&gt; System.out.println(str));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码将输出为长度大于等于3的字符串love和Java。注意，由于filter()是个中间操作，如果只调用filter()不会有实际计算，因此也不会输出任何信息。</p><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h4><p>函数原型为Stream&lt;T&gt; distinct()，作用是返回一个去除重复元素之后的Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素去重</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;you&quot;</span>);</span><br><span class="line">stream.distinct().forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>上述代码会输出去掉一个you之后的其余字符串。</p><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h4><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为Stream&lt;T&gt;　sorted()和Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length() - str2.length()).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>函数原型为&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)，作用是返回一个对当前所有元素执行执行mapper之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换成大写</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase()).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h4><p>函数原型为&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)，作用是对每个元素执行mapper指定的操作，并用所有mapper返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲flatMap()的作用就相当于把原stream中的所有元素都”摊平”之后组成的Stream，转换前后元素的个数和类型都可能会改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将两个集合中大于等于2的数重新组成Stream，然后输出</span><br><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream &#x3D; Stream.of(Arrays.asList(1,2), Arrays.asList(3, 4, 5));</span><br><span class="line">stream.flatMap(list -&gt; list.stream().filter(integer -&gt; integer &gt;&#x3D; 2)).forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h3 id="流的规约操作"><a href="#流的规约操作" class="headerlink" title="流的规约操作"></a>流的规约操作</h3><p>规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作reduce()和collect()，也有一些为简化书写而设计的专用规约操作，比如sum()、max()、min()、count()等。</p><p>最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍reduce()和collect()，这是比较有魔法的地方。</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>reduce操作可以实现从一组元素中生成一个值，sum()、max()、min()、count()等都是reduce操作，将他们单独设为函数只是因为常用。reduce()的方法定义有三种重写形式：</p><ul><li>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</li><li>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</li><li>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</li></ul><p>虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。</p><p>具体实践：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 找出最长的单词</span><br><span class="line">Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">Optional&lt;String&gt; longest &#x3D; stream1.reduce((s1, s2) -&gt; s1.length() &gt;&#x3D; s2.length() ? s1 : s2);</span><br><span class="line">&#x2F;&#x2F; Optional&lt;String&gt; longest &#x3D; stream.max((s1, s2) -&gt; s1.length() - s2.length());</span><br><span class="line">System.out.println(longest.get());</span><br><span class="line"></span><br><span class="line">上述代码会选出最长的单词love，其中Optional是（一个）值的容器，使用它可以避免null值的麻烦。当然可以使用Stream.max(Comparator&lt;? super T&gt; comparator)方法来达到同等效果，但reduce()自有其存在的理由。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 求单词长度之和</span><br><span class="line">&#x2F;&#x2F; (参数1)初始值</span><br><span class="line">&#x2F;&#x2F; (参数2)累加器</span><br><span class="line">&#x2F;&#x2F; (参数3)部分和拼接器，并行执行时才会用到</span><br><span class="line">Stream&lt;String&gt; stream2 &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">Integer lengthSum &#x3D; stream2.reduce(0, (sum, str) -&gt; sum + str.length(), (a, b) -&gt; a + b);</span><br><span class="line">&#x2F;&#x2F; int lengthSum &#x3D; stream.mapToInt(str -&gt; str.length()).sum();</span><br><span class="line">System.out.println(lengthSum);</span><br><span class="line"></span><br><span class="line">参数2处：</span><br><span class="line">  1. 字符串映射成长度。</span><br><span class="line">  2. 并和当前累加和相加。</span><br><span class="line"></span><br><span class="line">  这显然是两步操作，使用reduce()函数将这两步合二为一，更有助于提升性能。如果想要使用map()和sum()组合来达到上述目的，也是可以的。</span><br><span class="line"></span><br><span class="line">  reduce()擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h4><p>如果你发现某个功能在Stream接口中没找到，十有八九可以通过collect()方法实现。collect()是Stream接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">&#x2F;&#x2F; 转换成list集合</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());</span><br><span class="line">&#x2F;&#x2F; 转换成set集合</span><br><span class="line">&#x2F;&#x2F; Set&lt;String&gt; set &#x3D; stream.collect(Collectors.toSet());</span><br><span class="line">&#x2F;&#x2F; 转换成map集合</span><br><span class="line">&#x2F;&#x2F; Map&lt;String, Integer&gt; map &#x3D; stream.collect(Collectors.toMap(Function.identity(), String::length));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码分别列举了如何将Stream转换成List、Set和Map。虽然代码语义很明确，可是我们仍然会有几个疑问：</p><ul><li>Function.identity()是干什么的？</li><li>String::length是什么意思？</li><li>Collectors是个什么东西？</li></ul><h4 id="接口的静态方法和默认方法"><a href="#接口的静态方法和默认方法" class="headerlink" title="接口的静态方法和默认方法"></a>接口的静态方法和默认方法</h4><p>Function是一个接口，那么Function.identity()是什么意思呢？这要从两方面解释：</p><ul><li>Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。</li><li>Function.identity()返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</li></ul><p>上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得t -&gt; t比identity()方法更直观。我会告诉你接口中的default方法是一个无奈之举，在Java 7及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在Collection接口中加入一个stream()抽象方法会怎样？default方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了default方法，为何不再加入static方法来避免专门的工具类呢！</p><h4 id="方法引用-1"><a href="#方法引用-1" class="headerlink" title="方法引用"></a>方法引用</h4><p>诸如String::length的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类：</p><table><thead><tr><th>方法引用类别</th><th>举例</th></tr></thead><tbody><tr><td>引用静态方法</td><td>Integer::sum</td></tr><tr><td>引用某个对象的方法</td><td>list::add</td></tr><tr><td>引用某个类的方法</td><td>String::length</td></tr><tr><td>引用构造方法</td><td>HashMap::new</td></tr></tbody></table><h4 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h4><p>收集器（Collector）是为Stream.collect()方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：</p><ul><li>目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。</li><li>新元素如何添加到容器中？是List.add()还是Map.put()。</li><li>如果并行的进行规约，还需要告诉collect()，多个部分结果如何合并成一个。</li></ul><p>结合以上分析，collect()方法定义为 &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)，三个参数依次对应上述三条分析。</p><p>不过每次调用collect()都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装,所以collect()的另一定义为 &lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)。</p><p>Collectors工具类可通过静态方法生成各种常用的Collector。举例来说，如果要将Stream规约成List可以通过如下两种方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　将Stream规约成List</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;Collector&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式1</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>通常情况下我们不需要手动指定collect()的三个参数，而是调用collect(Collector&lt;? super T,A,R&gt; collector)方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了collect()的行为。</p><h4 id="使用collect-生成Collection"><a href="#使用collect-生成Collection" class="headerlink" title="使用collect()生成Collection"></a>使用collect()生成Collection</h4><p>有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)方法完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用toCollection()指定规约容器的类型</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;);</span><br><span class="line">ArrayList&lt;String&gt; arrayList &#x3D; stream.collect(Collectors.toCollection(ArrayList::new));</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line">&#x2F;&#x2F; HashSet&lt;String&gt; hashSet &#x3D; stream.collect(Collectors.toCollection(HashSet::new));</span><br><span class="line">&#x2F;&#x2F; System.out.println(hashSet);</span><br></pre></td></tr></table></figure><h4 id="使用collect-生成Map"><a href="#使用collect-生成Map" class="headerlink" title="使用collect()生成Map"></a>使用collect()生成Map</h4><p>通常在三种情况下collect()的结果会是Map：</p><ul><li>使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。</li><li>使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。</li><li>使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。</li></ul><p>情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码将字符列表转换成由&lt;String，字符串长度&gt;组成的Map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用toMap()统计字符长度</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());&#x2F;&#x2F; 方式2</span><br><span class="line">Map&lt;String, Integer&gt; strLength &#x3D; list.stream().collect(Collectors.toMap(Function.identity(), str -&gt; str.length()));</span><br><span class="line">System.out.println(strLength);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将字符列表分成长度大于2或不大于2的两部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对字符串列表进行分组</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());&#x2F;&#x2F; 方式2</span><br><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; listMap &#x3D; list.stream().collect(Collectors.partitioningBy(str -&gt; str.length() &gt; 2));</span><br><span class="line">System.out.println(listMap);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将字符列表按照字符长度进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照长度对字符串列表进行分组</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;, &quot;you&quot;, &quot;Java&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());&#x2F;&#x2F; 方式2</span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; listMap &#x3D; list.stream().collect(Collectors.groupingBy(String::length));</span><br><span class="line">System.out.println(listMap);</span><br></pre></td></tr></table></figure><p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如：</p><ol><li>先将员工按照部门分组。</li><li>然后统计每个部门员工的人数。</li></ol><p>Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。<br>这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对字符串列表进行分组，并统计每组元素的个数</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;, &quot;you&quot;, &quot;Java&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(toList());&#x2F;&#x2F; 方式2</span><br><span class="line">Map&lt;Integer, Long&gt; listMap &#x3D; list.stream().collect(groupingBy(String::length, Collectors.counting()));</span><br><span class="line">System.out.println(listMap);</span><br></pre></td></tr></table></figure><p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照部门对员工分布组，并只保留员工的名字</span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept &#x3D; employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,&#x2F;&#x2F; 下游收集器</span><br><span class="line">                                Collectors.toList())));&#x2F;&#x2F; 更下游的收集器</span><br></pre></td></tr></table></figure><h4 id="使用collect-做字符串join"><a href="#使用collect-做字符串join" class="headerlink" title="使用collect()做字符串join"></a>使用collect()做字符串join</h4><p>字符串拼接时使用Collectors.joining()生成的收集器，从此告别for循环。Collectors.joining()方法有三种重写形式，分别对应三种不同的拼接方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用Collectors.joining()拼接字符串</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;);</span><br><span class="line">&#x2F;&#x2F; String joined &#x3D; stream.collect(Collectors.joining());&#x2F;&#x2F; &quot;IloveCollector&quot;</span><br><span class="line">&#x2F;&#x2F; String joined &#x3D; stream.collect(Collectors.joining(&quot;,&quot;));&#x2F;&#x2F; &quot;I,love,Collector&quot;</span><br><span class="line">String joined &#x3D; stream.collect(Collectors.joining(&quot;,&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;));&#x2F;&#x2F; &quot;&#123;I,love,Collector&#125;</span><br><span class="line">System.out.println(joined);</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Stream操作分类</th><th></th><th></th></tr></thead><tbody><tr><td>操作</td><td>状态</td><td></td></tr><tr><td>中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td></td><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip()</td></tr><tr><td>结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td></td><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td></tr></tbody></table><p>参考文章：</p><ul><li><a href="https://objcoding.com/2019/03/04/lambda/#lambda-and-anonymous-classesi">https://objcoding.com/2019/03/04/lambda/#lambda-and-anonymous-classesi</a>  关于Java Lambda表达式看这一篇就够了</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。&quot;&gt;&lt;a href=&quot;#摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。&quot; class=&quot;headerlink&quot; title=&quot;摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。&quot;&gt;&lt;/a&gt;摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。&quot;&gt;&lt;a href=&quot;#前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。&quot; class=&quot;headerlink&quot; title=&quot;前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。&quot;&gt;&lt;/a&gt;前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="基础" scheme="https://www.blog.ajie39.top/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HBase学习笔记</title>
    <link href="https://www.blog.ajie39.top/2019/12/02/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.blog.ajie39.top/2019/12/02/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-02T09:30:36.490Z</published>
    <updated>2021-05-05T04:25:35.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：HBase基础。"><a href="#摘要：HBase基础。" class="headerlink" title="摘要：HBase基础。"></a>摘要：HBase基础。</h1><hr><h1 id="前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。"><a href="#前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。" class="headerlink" title="前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。"></a>前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。</h1><hr><span id="more"></span><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><h3 id="HBase是什么？"><a href="#HBase是什么？" class="headerlink" title="HBase是什么？"></a>HBase是什么？</h3><p>HBase是Apache Hadoop中的一个子项目，Hbase依托于Hadoop的HDFS作为最基本存储基础单元，通过使用hadoop的DFS工具就可以看到这些这些数据 存储文件夹的结构,还可以通过Map/Reduce的框架(算法)对HBase进行操作，如下图所示：</p><p><img src="/blog/19/3.png" alt="HBase"></p><p>HBASE是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBASE技术可在廉价PC Server上搭建起大规模结构化存储集群。</p><p>HBASE的目标是存储并处理大型的数据，更具体来说是仅需使用普通的硬件配置，就能够处理由成千上万的行和列所组成的大型数据。</p><p>HBASE是Google Bigtable的开源实现，但是也有很多不同之处。比如：Google Bigtable使用GFS作为其文件存储系统，HBASE利用Hadoop HDFS作为其文件存储系统；Google运行MAPREDUCE来处理Bigtable中的海量数据，HBASE同样利用Hadoop MapReduce来处理HBASE中的海量数据；Google Bigtable利用Chubby作为协同服务，HBASE利用Zookeeper作为协同服务。</p><h3 id="Hbase与传统数据库的对比"><a href="#Hbase与传统数据库的对比" class="headerlink" title="Hbase与传统数据库的对比"></a>Hbase与传统数据库的对比</h3><ul><li><p>传统数据库遇到的问题：</p><ol><li>数据量很大的时候无法存储。</li><li>没有很好的备份机制。</li><li>数据达到一定数量开始缓慢，很大的话基本无法支撑。</li></ol></li><li><p>HBASE优势：</p><ol><li>线性扩展，随着数据量增多可以通过节点扩展进行支撑。</li><li>数据存储在hdfs上，备份机制健全。</li><li>通过zookeeper协调查找数据，访问速度快。</li></ol></li></ul><h3 id="HBase集群中的角色"><a href="#HBase集群中的角色" class="headerlink" title="HBase集群中的角色"></a>HBase集群中的角色</h3><ul><li>一个或者多个主节点，Hmaster。</li><li>多个从节点，HregionServer。</li><li>HBase依赖项，zookeeper。</li></ul><p> HBase数据模型<br><img src="/blog/19/4.png" alt="HBase数据模型1"></p><p><img src="/blog/19/5.png" alt="HBase数据模型2"></p><h3 id="HBase的存储机制"><a href="#HBase的存储机制" class="headerlink" title="HBase的存储机制"></a>HBase的存储机制</h3><p>HBase是一个面向列的数据库，在表中它由行排序。表模式定义只能列族，也就是键值对。一个表有多个列族以及每一个列族可以有任意数量的列。后续列的值连续存储在磁盘上。表中的每个单元格值都具有时间戳。总之，在一个HBase：</p><ul><li>表是行的集合。</li><li>行是列族的集合。</li><li>列族是列的集合。</li><li>列是键值对的集合。</li></ul><p>这里的列式存储或者说面向列，其实说的是列族存储，HBase是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。</p><h4 id="Row-Key-行键"><a href="#Row-Key-行键" class="headerlink" title="Row Key 行键"></a>Row Key 行键</h4><p>与nosql数据库一样，row key是用来表示唯一一行记录的主键，HBase的数据时按照RowKey的字典顺序进行全局排序的，所有的查询都只能依赖于这一个排序维度。访问HBASE table中的行，只有三种方式：</p><ol><li>通过单个row key访问。</li><li>通过row key的range（正则）。</li><li>全表扫描。</li></ol><p>Row key行键（Row key）可以是任意字符串(最大长度是64KB，实际应用中长度一般为10-1000bytes)，在HBASE内部，row key保存为字节数组。存储时，数据按照Row key的字典序(byte order)排序存储。设计key时，要充分排序存储这个特性，将经常一起读取的行存储放到一起(位置相关性)。</p><h4 id="Columns-Family-列族"><a href="#Columns-Family-列族" class="headerlink" title="Columns Family 列族"></a>Columns Family 列族</h4><p>列族：HBASE表中的每个列，都归属于某个列族。列族是表的schema的一部分(而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如courses：history，courses：math 都属于courses这个列族。</p><h4 id="Cell-列"><a href="#Cell-列" class="headerlink" title="Cell 列"></a>Cell 列</h4><p>由{row key，columnFamily，version} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存储。</p><p>关键字：无类型、字节码</p><h4 id="Time-Stamp-时间戳"><a href="#Time-Stamp-时间戳" class="headerlink" title="Time Stamp 时间戳"></a>Time Stamp 时间戳</h4><p>HBASE中通过rowkey和columns确定的为一个存储单元称为cell。每个cell都保存着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是64位整型。时间戳可以由HBASE(在数据写入时自动)赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显示赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个cell中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。</p><p>为了避免数据存在过多版本造成的管理(包括存储和索引)负担，HBASE提供了两种数据版本回收方式。一是保存数据的最后n个版本，而是保存最近一段时间内的版本(比如最近7天)。用户可以针对每个列族进行设置。</p><h3 id="HBase原理"><a href="#HBase原理" class="headerlink" title="HBase原理"></a>HBase原理</h3><h4 id="HBase系统架构体系图"><a href="#HBase系统架构体系图" class="headerlink" title="HBase系统架构体系图"></a>HBase系统架构体系图</h4><p><img src="/blog/19/6.png" alt="HBase系统架构体系图"></p><h4 id="组成部件说明"><a href="#组成部件说明" class="headerlink" title="组成部件说明"></a>组成部件说明</h4><p>Client：</p><p>使用HBase RPC机制与HMaster和HRegionServer进行通信<br>Client与HMaster进行管理类操作<br>Client与HRegionServer进行数据读写类操作</p><p>Zookeeper：</p><p>Zookeeper Quorum存储-ROOT-表地址、HMaster地址<br>HRegionServer把自己以Ephedral方式注册到Zookeeper中，HMaster随时感知各个HRegionServer的健康状况<br>Zookeeper避免HMaster单点问题</p><p>Zookeeper的主要作用：客户端首先联系ZooKeeper子集群（quorum）（一个由ZooKeeper节点组成的单独集群）查找行健。上述过程是通过ZooKeeper获取含有-ROOT-的region服务器名（主机名）来完成的。通过含有-ROOT-的region服务器可以查询到含有.META.表中对应的region服务器名，其中包含请求的行健信息。这两处的主要内容都被缓存下来了，并且都只查询一次。最终，通过查询.META服务器来获取客户端查询的行健数据所在region的服务器名。一旦知道了数据的实际位置，即region的位置，HBase会缓存这次查询的信息，同时直接联系管理实际数据的HRegionServer。所以，之后客户端可以通过缓存信息很好地定位所需的数据位置，而不用再次查找.META.表。</p><p>HMaster：</p><p>HMaster没有单点问题，HBase可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master在运行<br>主要负责Table和Region的管理工作：</p><ol><li>管理用户对表的增删改查操作</li><li>管理HRegionServer的负载均衡，调整Region分布</li><li>Region Split后，负责新Region的分布</li><li>在HRegionServer停机后，负责失效HRegionServer上Region迁移</li></ol><p>HRegionServer：</p><p>HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统中读写</p><p><img src="/blog/19/7.png" alt="HBase系统架构体系图"></p><p>HRegionServer管理一系列HRegion对象；<br>每个HRegion对应Table中一个Region，HRegion由多个HStore组成；<br>每个HStore对应Table中一个Column Family的存储；<br>Column Family就是一个集中的存储单元，故将具有相同IO特性的Column放在一个Column Family会更高效。</p><p>可以看到，client访问hbase上的数据并不需要master参与（寻址访问zookeeper和region server，数据读写访问region server），master仅仅维护table和region的元数据信息（table的元数据信息保存在zookeeper上），负载很低。HRegionServer存取一个子表时，会创建一个HRegion对象，然后对表的每个列族创建一个Store实例，每个Store都会有一个MemStore和0个或多个StoreFile与之对应，每个StoreFile都会对应一个HFile，HFile就是实际的存储文件。因此，一个HRegion（表）有多少个列族就有多少个Store。一个HRegionServer会有多个HRegion和一个HLog。</p><p>HRegion：</p><p>table在行的方向上分隔为多个Region。Region是HBase中分布式存储和负载均衡的最小单元，即不同的region可以分别在不同的Region Server上，但同一个Region是不会拆分到多个server上。</p><p>Region按大小分隔，每个表一般是只有一个region。随着数据不断插入表，region不断增大，当region的某个列族达到一个阀值（默认256M）时就会分成两个新的region。</p><p>每个region由以下信息标识：</p><p>&lt;表名，startRowKey，创建时间&gt;<br>由目录表(-ROOT-和.META.)记录该region的endRowKey<br>HRegion定位：Region被分配给哪个RegionServer是完全动态的，所以需要机制来定位Region具体在哪个region server。</p><p>HBase使用三层结构来定位region：</p><p>通过zookeeper里的文件/hbase/rs得到-ROOT-表的位置。-ROOT-表只有一个region。<br>通过-ROOT-表查找.META.表的第一个表中相应的region的位置。其实-ROOT-表是.META.表的第一个region；.META.表中的每一个region在-ROOT-表中都是一行记录。<br>通过.META.表找到所要的用户表region的位置。用户表中的每个region在.META表中都是一行记录。<br>注意：</p><p> -ROOT-表永远不会被分隔为多个region，保证了最多需要三次跳转，就能定位到任意的region。client会将查询的位置信息缓存起来，缓存不会主动失效，因此如果client上的缓存全部失效，则需要进行6次网络来回，才能定位到正确的region，其中三次用来发现缓存失效，另外三次用来获取位置信息。</p><p>table和region的关系</p><p>table默认最初只有一个region，随着记录数的不断增加而变大，起初的region会逐渐分裂成多个region，一个region有【startKey, endKey】表示，不同的region会被master分配给相应的regionserver管理。</p><p>region是hbase分布式存储和负载均衡的最小单元，不同的region分不到不同的regionServer。</p><p>注意：region虽然是分布式存储的最小单元，但并不是存储的最小单元。region是由一个或者多个store组成的，每个store就是一个column family。每个store又由memStore和1至多个store file 组成(memstore到一个阀值会刷新，写入到storefile，有hlog来保证数据的安全性，一个regionServer有且只有一个hlog)　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><p>HStore：</p><p>HBase存储的核心。由MemStore和StoreFile组成。MemStore是Stored Memory Buffer。<br>HLog：</p><p>引入HLog原因：在分布式系统环境中，无法避免系统出错或者宕机，一旦HRegionServer意外退出，MemStore中的内存数据就会丢失，引入HLog就是防止这种情况。</p><p>工作机制：<br>每个HRegionServer中都会有一个HLog对象，HLog是一个实现Write Ahead Log的类，每次用户操作写入MemStore的同时，也会写一份数据到HLog文件，HLog文件定期会滚动出新，并删除旧的文件(已持久化到StoreFile中的数据)。当HRegionServer意外终止后，HMaster会通过Zookeeper感知，HMaster首先处理遗留的HLog文件，将不同region的log数据拆分，分别放到相应region目录下，然后再将失效的region重新分配，领取到这些region的HRegionServer在Load Region的过程中，会发现有历史HLog需要处理，因此会Replay HLog中的数据到MemStore中，然后flush到StoreFiles，完成数据恢复。</p><h2 id="搭建hbase"><a href="#搭建hbase" class="headerlink" title="搭建hbase"></a>搭建hbase</h2><p>1、配置java环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">set java environment</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_151</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_151&#x2F;jre</span><br><span class="line">CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">使修改生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">java -version</span><br><span class="line">如果出现版本信息，则安装成功</span><br></pre></td></tr></table></figure><p>2、下载Hbase，<a href="http://archive.apache.org/dist/hbase/">http://archive.apache.org/dist/hbase/</a></p><p>3、配置Hbase环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">HBASE_HOME&#x3D;&#x2F;opt&#x2F;hbase</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$HBASE_HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line">使修改生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">hbase version</span><br><span class="line">如果出现版本信息，则安装成功</span><br></pre></td></tr></table></figure><p>4、单价模式配置hbase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;opt&#x2F;hbase&#x2F;conf&#x2F;hbase-env.sh</span><br><span class="line"></span><br><span class="line">末尾加上</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_151</span><br><span class="line">export HBASE_MANAGES_ZK&#x3D;true</span><br><span class="line"></span><br><span class="line">配置HBASE_MANAGES_ZK为true，表示由hbase自己管理zookeeper，不需要单独的zookeeper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;conf&#x2F;hbase-site.xml</span><br><span class="line"></span><br><span class="line">在启动HBase前需要设置属性hbase.rootdir，用于指定HBase数据的存储位置，因为如果不设置的话，hbase.rootdir默认为&#x2F;tmp&#x2F;hbase-$&#123;user.name&#125;,这意味着每次重启系统都会丢失数据。此处设置为HBase安装目录下的hbase-tmp文件夹即（&#x2F;usr&#x2F;local&#x2F;hbase&#x2F;hbase-tmp）,添加配置如下：</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;file:&#x2F;&#x2F;&#x2F;opt&#x2F;hbase&#x2F;hbase-tmp&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">cd &#x2F;opt&#x2F;hbase</span><br><span class="line">bin&#x2F;start-hbase.sh</span><br><span class="line">bin&#x2F;hbase shell</span><br></pre></td></tr></table></figure><p>5、配置外置的zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www-us.apache.org&#x2F;dist&#x2F;zookeeper&#x2F;</span><br></pre></td></tr></table></figure><h3 id="JAVA实际操作"><a href="#JAVA实际操作" class="headerlink" title="JAVA实际操作"></a>JAVA实际操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> com.ypsx.miniTask.server.bean.StoresData;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.filter.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleForHbase</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Admin admin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLENAME = <span class="string">&quot;shopOrderStatisticsTest0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        configuration  = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>,<span class="string">&quot;yp-ubuntu-server-1,yp-ubuntu-server-2,yp-ubuntu-server-3&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.port&quot;</span>,<span class="string">&quot;2181&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">            admin = connection.getAdmin();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(admin != <span class="keyword">null</span>)&#123;</span><br><span class="line">                admin.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建表。HBase的表中会有一个系统默认的属性作为主键，主键无需自行创建，默认为put命令操作中表名后第一个数据，因此此处无需创建id列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> myTableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colFamily 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">(String myTableName,String[] colFamily)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        TableName tableName = TableName.valueOf(myTableName);</span><br><span class="line">        <span class="keyword">if</span>(admin.tableExists(tableName))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;talbe is exists!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            HTableDescriptor hTableDescriptor = <span class="keyword">new</span> HTableDescriptor(tableName);</span><br><span class="line">            <span class="keyword">for</span>(String str:colFamily)&#123;</span><br><span class="line">                HColumnDescriptor hColumnDescriptor = <span class="keyword">new</span> HColumnDescriptor(str);</span><br><span class="line">                hTableDescriptor.addFamily(hColumnDescriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            admin.createTable(hTableDescriptor);</span><br><span class="line">            System.out.println(<span class="string">&quot;create table success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteTable</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        TableName tn = TableName.valueOf(tableName);</span><br><span class="line">        <span class="keyword">if</span> (admin.tableExists(tn)) &#123;</span><br><span class="line">            admin.disableTable(tn);</span><br><span class="line">            admin.deleteTable(tn);</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看已有表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listTables</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        HTableDescriptor hTableDescriptors[] = admin.listTables();</span><br><span class="line">        <span class="keyword">for</span>(HTableDescriptor hTableDescriptor : hTableDescriptors)&#123;</span><br><span class="line">            System.out.println(hTableDescriptor.getNameAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向某一行的某一列插入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey 行键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colFamily 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 列名（如果其列族下没有子列，此参数可为空）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertRow</span><span class="params">(String tableName,String rowKey,String colFamily,String col,String val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Put put = <span class="keyword">new</span> Put(rowKey.getBytes());</span><br><span class="line">        put.addColumn(colFamily.getBytes(), col.getBytes(), val.getBytes());</span><br><span class="line">        table.put(put);</span><br><span class="line">        table.close();</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey 行键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colFamily 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 列名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRow</span><span class="params">(String tableName,String rowKey,String colFamily,String col)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Delete delete = <span class="keyword">new</span> Delete(rowKey.getBytes());</span><br><span class="line">        <span class="comment">//删除指定列族的所有数据</span></span><br><span class="line">        <span class="comment">//delete.addFamily(colFamily.getBytes());</span></span><br><span class="line">        <span class="comment">//删除指定列的数据</span></span><br><span class="line">        <span class="comment">//delete.addColumn(colFamily.getBytes(), col.getBytes());</span></span><br><span class="line">        table.delete(delete);</span><br><span class="line">        table.close();</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据行键rowkey查找数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey 行键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colFamily 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 列名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(String tableName,String rowKey,String colFamily,String col)</span><span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Get get = <span class="keyword">new</span> Get(rowKey.getBytes());</span><br><span class="line">        get.addColumn(colFamily.getBytes(),col.getBytes());</span><br><span class="line">        Result result = table.get(get);</span><br><span class="line">        showCell(result);</span><br><span class="line">        table.close();</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从指定行scan表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shopId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;StoresData&gt; <span class="title">scanTableByRow</span><span class="params">(String cityCode, String dayTime, String shopId, String[] stArr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        HTableDescriptor hTableDescriptors[] = admin.listTables();</span><br><span class="line">        List&lt;String&gt; tableList = Lists.newArrayList();</span><br><span class="line">        <span class="comment">//获取所有表名称</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hTableDescriptors.length; i++) &#123;</span><br><span class="line">            tableList.add(hTableDescriptors[i].getNameAsString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;StoresData&gt; storesDataList = Lists.newArrayList();</span><br><span class="line">        <span class="comment">//判断需要查询的表是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (tableList.contains(TABLENAME)) &#123;</span><br><span class="line">            Table table = connection.getTable(TableName.valueOf(TABLENAME));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义scan条件</span></span><br><span class="line">            Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//过滤rowkey，$&#123;cityCode&#125;_$&#123;dayTime&#125;_$&#123;shopId&#125;,如C320100_20190910_100002445</span></span><br><span class="line">            <span class="keyword">if</span> (shopId.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                scan.setRowPrefixFilter(Bytes.toBytes(cityCode + <span class="string">&quot;_&quot;</span> + dayTime));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                scan.setRowPrefixFilter(Bytes.toBytes(cityCode + <span class="string">&quot;_&quot;</span> + dayTime + <span class="string">&quot;_&quot;</span> + shopId));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//数据要满足全部过滤器才可以</span></span><br><span class="line">            FilterList filterList = <span class="keyword">new</span> FilterList(FilterList.Operator.MUST_PASS_ALL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//过滤器1，用于过滤dayTime</span></span><br><span class="line">            SingleColumnValueFilter filter1= <span class="keyword">new</span> SingleColumnValueFilter(Bytes.toBytes(<span class="string">&quot;statistics&quot;</span>), Bytes.toBytes(<span class="string">&quot;dayTime&quot;</span>), CompareFilter.CompareOp.EQUAL, dayTime.getBytes());</span><br><span class="line">            filter1.setFilterIfMissing(<span class="keyword">true</span>); <span class="comment">//默认为false， 没有此列的数据也会返回 ，为true则只返回name=lisi的数据</span></span><br><span class="line">            filterList.addFilter(filter1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!shopId.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//过滤器2，用于过滤shopId</span></span><br><span class="line">                SingleColumnValueFilter filter2 = <span class="keyword">new</span> SingleColumnValueFilter(Bytes.toBytes(<span class="string">&quot;statistics&quot;</span>), Bytes.toBytes(<span class="string">&quot;shopId&quot;</span>), CompareFilter.CompareOp.EQUAL, shopId.getBytes());</span><br><span class="line">                filter2.setFilterIfMissing(<span class="keyword">true</span>); <span class="comment">//默认为false， 没有此列的数据也会返回 ，为true则只返回name=lisi的数据</span></span><br><span class="line">                filterList.addFilter(filter2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line"></span><br><span class="line">            ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">            <span class="comment">// 遍历scanner</span></span><br><span class="line">            Iterator&lt;Result&gt; iterator = scanner.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Result result = iterator.next();</span><br><span class="line">                <span class="comment">// 遍历result</span></span><br><span class="line">                CellScanner cellScanner = result.cellScanner();</span><br><span class="line">                StoresData storesData = <span class="keyword">new</span> StoresData();</span><br><span class="line">                storesData.setShopId(Integer.valueOf(shopId));</span><br><span class="line">                storesData.setMerchantName(stArr[<span class="number">0</span>]);</span><br><span class="line">                storesData.setShopOrganizationCode(stArr[<span class="number">1</span>]);</span><br><span class="line">                storesData.setCityCode(cityCode);</span><br><span class="line">                storesData.setDayTime(dayTime);</span><br><span class="line">                <span class="keyword">while</span> (cellScanner.advance()) &#123;</span><br><span class="line">                    Cell cell = cellScanner.current();</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;行键:&quot; + Bytes.toString(CellUtil.copyRow(cell)));</span></span><br><span class="line">                    <span class="comment">// System.out.println(&quot;列族:&quot; + Bytes.toString(CellUtil.cloneFamily(cell)));</span></span><br><span class="line">                    <span class="comment">// System.out.println(&quot;列名:&quot; + Bytes.toString(CellUtil.cloneQualifier(cell)));</span></span><br><span class="line">                    <span class="comment">// System.out.println(&quot;值:&quot; + Bytes.toString(CellUtil.cloneValue(cell)));</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// totalPayUserNumber  totalPayOrderNumber  totalPayPrice</span></span><br><span class="line">                    String tempName = Bytes.toString(CellUtil.cloneQualifier(cell));</span><br><span class="line">                    String tempValue = Bytes.toString(CellUtil.cloneValue(cell));</span><br><span class="line">                    <span class="keyword">if</span> (tempName.equals(<span class="string">&quot;totalPayUserNumber&quot;</span>))&#123;</span><br><span class="line">                        storesData.setTotalPayUserNumber(Long.valueOf(tempValue));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tempName.equals(<span class="string">&quot;totalPayOrderNumber&quot;</span>))&#123;</span><br><span class="line">                        storesData.setTotalPayOrderNumber(Long.valueOf(tempValue));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tempName.equals(<span class="string">&quot;totalPayPrice&quot;</span>))&#123;</span><br><span class="line">                        storesData.setTotalPayPrice(Long.valueOf(tempValue));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//为客单价赋值</span></span><br><span class="line">                <span class="keyword">if</span> (storesData.getTotalPayPrice() != <span class="number">0</span> || storesData.getTotalPayOrderNumber() != <span class="number">0</span> )&#123;</span><br><span class="line">                    BigDecimal bi1 = <span class="keyword">new</span> BigDecimal(storesData.getTotalPayPrice());</span><br><span class="line">                    BigDecimal bi2 = <span class="keyword">new</span> BigDecimal(storesData.getTotalPayOrderNumber());</span><br><span class="line">                    BigDecimal divide = bi1.divide(bi2, <span class="number">2</span>, RoundingMode.HALF_UP);</span><br><span class="line">                    storesData.setUnitPrice(divide.doubleValue());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                storesDataList.add(storesData);</span><br><span class="line">            &#125;</span><br><span class="line">            table.close();</span><br><span class="line">            <span class="keyword">return</span> storesDataList;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">return</span> storesDataList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 格式化输出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCell</span><span class="params">(Result result)</span></span>&#123;</span><br><span class="line">        Cell[] cells = result.rawCells();</span><br><span class="line">        <span class="keyword">for</span>(Cell cell:cells)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;RowName:&quot;</span>+<span class="keyword">new</span> String(CellUtil.cloneRow(cell))+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Timetamp:&quot;</span>+cell.getTimestamp()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;column Family:&quot;</span>+<span class="keyword">new</span> String(CellUtil.cloneFamily(cell))+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;row Name:&quot;</span>+<span class="keyword">new</span> String(CellUtil.cloneQualifier(cell))+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;value:&quot;</span>+<span class="keyword">new</span> String(CellUtil.cloneValue(cell))+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考文章：</p><ul><li><p>Hbase批量查询-scan介绍 <a href="https://blog.csdn.net/kangkangwanwan/article/details/89332536">https://blog.csdn.net/kangkangwanwan/article/details/89332536</a></p></li><li><p>Ubuntu下HBase安装与使用(shell+Java API) <a href="https://blog.csdn.net/flyfish111222/article/details/51893096">https://blog.csdn.net/flyfish111222/article/details/51893096</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：HBase基础。&quot;&gt;&lt;a href=&quot;#摘要：HBase基础。&quot; class=&quot;headerlink&quot; title=&quot;摘要：HBase基础。&quot;&gt;&lt;/a&gt;摘要：HBase基础。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。&quot;&gt;&lt;a href=&quot;#前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。&quot; class=&quot;headerlink&quot; title=&quot;前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。&quot;&gt;&lt;/a&gt;前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="基础" scheme="https://www.blog.ajie39.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="HBase" scheme="https://www.blog.ajie39.top/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>GRPC学习笔记</title>
    <link href="https://www.blog.ajie39.top/2019/09/24/GRPC%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.blog.ajie39.top/2019/09/24/GRPC%E7%AC%94%E8%AE%B0/</id>
    <published>2019-09-24T08:11:41.829Z</published>
    <updated>2021-05-05T04:24:59.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是总结了一下这段时间学习gRPC的过程中遇到的一些问题和知识点"><a href="#摘要：这篇文章主要是总结了一下这段时间学习gRPC的过程中遇到的一些问题和知识点" class="headerlink" title="摘要：这篇文章主要是总结了一下这段时间学习gRPC的过程中遇到的一些问题和知识点"></a>摘要：这篇文章主要是总结了一下这段时间学习gRPC的过程中遇到的一些问题和知识点</h1><hr><h1 id="前言：本篇文章主要是总结了一下学习gRPC的过程中遇到的一些问题和知识点。"><a href="#前言：本篇文章主要是总结了一下学习gRPC的过程中遇到的一些问题和知识点。" class="headerlink" title="前言：本篇文章主要是总结了一下学习gRPC的过程中遇到的一些问题和知识点。"></a>前言：本篇文章主要是总结了一下学习gRPC的过程中遇到的一些问题和知识点。</h1><hr><span id="more"></span><h2 id="gRPC是啥？？？？？"><a href="#gRPC是啥？？？？？" class="headerlink" title="gRPC是啥？？？？？"></a>gRPC是啥？？？？？</h2><p>所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。如下图所示就是一个典型的RPC结构图。</p><p><img src="/blog/19/1.png" alt="RPC"></p><p>gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="基于HTTP-2"><a href="#基于HTTP-2" class="headerlink" title="基于HTTP/2"></a>基于HTTP/2</h3><p>HTTP/2 提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。gRPC 的协议设计上使用了HTTP2 现有的语义，请求和响应的数据使用HTTP Body 发送，其他的控制信息则用Header 表示。</p><h3 id="IDL使用ProtoBuf"><a href="#IDL使用ProtoBuf" class="headerlink" title="IDL使用ProtoBuf"></a>IDL使用ProtoBuf</h3><p>gRPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。</p><h3 id="多语言支持（C-C-Python-PHP-Nodejs-C-Objective-C、Golang、Java）"><a href="#多语言支持（C-C-Python-PHP-Nodejs-C-Objective-C、Golang、Java）" class="headerlink" title="多语言支持（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java）"></a>多语言支持（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java）</h3><p>gRPC支持多种语言，并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>gRPC已经应用在Google的云服务和对外提供的API中，其主要应用场景如下：</p><ul><li>低延迟、高扩展性、分布式的系统。</li><li>同云服务器进行通信的移动应用客户端。</li><li>设计语言独立、高效、精确的新协议。</li><li>便于各方面扩展的分层设计，如认证、负载均衡、日志记录、监控等。</li></ul><h2 id="gRPC通信方式"><a href="#gRPC通信方式" class="headerlink" title="gRPC通信方式"></a>gRPC通信方式</h2><p>gRPC有四种通信方式:</p><h3 id="1、-Simple-RPC"><a href="#1、-Simple-RPC" class="headerlink" title="1、 Simple RPC"></a>1、 Simple RPC</h3><p>简单rpc：这就是一般的rpc调用，一个请求对象对应一个返回对象。proto语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc simpleHello(Person) returns (Result) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="2、Server-side-streaming-RPC"><a href="#2、Server-side-streaming-RPC" class="headerlink" title="2、Server-side streaming RPC"></a>2、Server-side streaming RPC</h3><p>服务端流式rpc：一个请求对象，服务端可以传回多个结果对象。proto语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc serverStreamHello(Person) returns (stream Result) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3、Client-side-streaming-RPC"><a href="#3、Client-side-streaming-RPC" class="headerlink" title="3、Client-side streaming RPC"></a>3、Client-side streaming RPC</h3><p>客户端流式rpc：客户端传入多个请求对象，服务端返回一个响应结果。proto语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc clientStreamHello(stream Person) returns (Result) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Bidirectional-streaming-RPC"><a href="#4、Bidirectional-streaming-RPC" class="headerlink" title="4、Bidirectional streaming RPC"></a>4、Bidirectional streaming RPC</h3><p>双向流式rpc：结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象。proto语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc biStreamHello(stream Person) returns (stream Result) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Protobuf3语法"><a href="#Protobuf3语法" class="headerlink" title="Protobuf3语法"></a>Protobuf3语法</h2><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;&#x2F;&#x2F; 文件首个非空、非注释的行必须表明protobuf的版本，默认是proto2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;import</span><br><span class="line">import &quot;google&#x2F;protobuf&#x2F;wrappers.proto&quot;;</span><br><span class="line">import &quot;src&#x2F;main&#x2F;proto&#x2F;other.proto&quot;;</span><br><span class="line">&#x2F;&#x2F;import 导入的定义仅在当前文件有效，也就是当前文件只能引用other.proto直接定义的</span><br><span class="line">&#x2F;&#x2F;import public 导入的定义是可以被传递引用的，也就是other.proto中如果</span><br><span class="line">&#x2F;&#x2F;通过import public引用的new.proto,当前文件是可以引用new.proto定义的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;package</span><br><span class="line">package cn.sdut.majiatao;</span><br><span class="line">&#x2F;&#x2F;指定包名后，会对生成的代码产生影响，以Java为例，生成的类会以你指定的package作为包名</span><br><span class="line">&#x2F;&#x2F; 同时引入的.proto文件的路径也需要改动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;option</span><br><span class="line">option java_package &#x3D; &quot;cn.sdut.majiatao&quot;;</span><br><span class="line"> &#x2F;&#x2F; 编译器为以此作为生成的Java类的包名，如果没有该选项，则会以pb的package作为包名</span><br><span class="line">option java_multiple_files &#x3D; true;</span><br><span class="line">&#x2F;&#x2F; 该选项为true时，生成的Java类将是包级别的，</span><br><span class="line">&#x2F;&#x2F;如果是false，则所有的message和service都将会是java_outer_classname的内部类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; java_outer_classname (文件选项):</span><br><span class="line">    &#x2F;&#x2F; 该选项表明想要生成Java类的名称。</span><br><span class="line">    &#x2F;&#x2F; 如果在.proto文件中没有明确的java_outer_classname定义，生成的class名称将会根据.proto文件的名称采用驼峰式的命名方式进行生成。</span><br><span class="line">    &#x2F;&#x2F; 如（foo_bar.proto生成的java类名为FooBar.java）,如果不生成java代码，则该选项不起任何作用。如：</span><br><span class="line">      option java_outer_classname &#x3D; &quot;Ponycopter&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;option optimize_for &#x3D; SPEDD;</span><br><span class="line">&#x2F;&#x2F; 对生成的代码的一种优化，有三个值:SPEED,  CODE_SIZE, LITE_RUNTIME;</span><br><span class="line">    &#x2F;&#x2F; SPEED (default): protocol buffer编译器将通过在消息类型上执行序列化、语法分析及其他通用的操作。这种代码是最优的。</span><br><span class="line">    &#x2F;&#x2F; CODE_SIZE: protocol buffer编译器将会产生最少量的类，通过共享或基于反射的代码来实现序列化、语法分析及各种其它操作。采用该方式产生的代码将比SPEED要少得多，但是操作要相对慢些。当然实现的类及其对外的API与SPEED模式都是一样的。这种方式经常用在一些包含大量的.proto文件而且并不盲目追求速度的应用中。</span><br><span class="line">    &#x2F;&#x2F; LITE_RUNTIME: protocol buffer编译器依赖于运行时核心类库来生成代码（即采用libprotobuf-lite 替代libprotobuf）。这种核心类库由于忽略了一些描述符及反射，要比全类库小得多。这种模式经常在移动手机平台应用多一些。编译器采用该模式产生的方法实现与SPEED模式不相上下，产生的类通过实现 MessageLite接口，但它仅仅是Messager接口的一个子集。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;message</span><br><span class="line">&#x2F;&#x2F; message 逻辑上类似于一个Java class,由多个字段(属性)构成,</span><br><span class="line">&#x2F;&#x2F; 每一个字段：由类型、名称组成，等号右边的数值不是默认值，而是数字签名码，不可重复</span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query &#x3D; 1;</span><br><span class="line">    int32 page_number &#x3D; 2;</span><br><span class="line">    int32 result_per_page &#x3D; 3;</span><br><span class="line">    repeated string args &#x3D; 4;&#x2F;&#x2F; 等同于Java中的List&lt;String&gt; args</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每个枚举类有对应的数值，数值不一定是连续的。</span><br><span class="line">    &#x2F;&#x2F; 第一个枚举值必须是0并且至少有一个枚举值</span><br><span class="line">    enum Corpus&#123;</span><br><span class="line">        option allow_alias &#x3D; true;</span><br><span class="line">        UNIVERSAL &#x3D; 0;&#x2F;&#x2F; 默认</span><br><span class="line">        WEB &#x3D; 1;</span><br><span class="line">        IMAGES &#x3D; 2;</span><br><span class="line">        LOCAL &#x3D; 3;</span><br><span class="line">        &#x2F;&#x2F; 如果一个数值需要对应多个枚举值,必须标明 option allow_alias &#x3D; true</span><br><span class="line">        FRAMEWORK &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    Result result &#x3D; 5;&#x2F;&#x2F; 字段类型也可以引用其他的message类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">    string url &#x3D; 1;</span><br><span class="line">    repeated string snippets &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;scalar value type</span><br><span class="line">&#x2F;&#x2F;类型</span><br><span class="line">&#x2F;&#x2F; 1. for strings, the default value is the empty string</span><br><span class="line">&#x2F;&#x2F; 2. for bytes, the default value is the empty bytes</span><br><span class="line">&#x2F;&#x2F; 3. for bools, the default value is false</span><br><span class="line">&#x2F;&#x2F; 4. for numeric types, the default value is zero</span><br><span class="line">&#x2F;&#x2F; 5. for enums, the default value s the first defined enum value, which must be 0</span><br><span class="line">&#x2F;&#x2F; 6. for message fields, the field is not set, Iys exact value is language-dependent</span><br><span class="line">&#x2F;&#x2F; 7. for repeated fields, the default value is empty list</span><br><span class="line">&#x2F;&#x2F;PS:if a scalar message field is set to its default, the value will not be serialized on the wire.</span><br><span class="line">&#x2F;&#x2F; 如果一个字段的值等于默认值(如bool类型字段为false)，那么它将不会被序列化</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Any</span><br><span class="line">&#x2F;&#x2F; Any类型 需要import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;</span><br><span class="line">&#x2F;&#x2F; Any类型可以允许包装任意的message类型</span><br><span class="line">&#x2F;&#x2F; Any类型消息允许你在没有指定他们的.proto定义的情况下使用消息作为一个嵌套类型。</span><br><span class="line">&#x2F;&#x2F; 一个Any类型包括一个可以被序列化bytes类型的任意消息，以及一个URL作为一个全局标识符和解析消息类型。</span><br><span class="line">import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;</span><br><span class="line">message Response &#123;</span><br><span class="line">    google.protobuf.Any data &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Oneof</span><br><span class="line">&#x2F;&#x2F;Oneof 有一些字段最多只能有一个被设置，任何一个字段被设置，其他字段会自动成为默认值</span><br><span class="line">&#x2F;&#x2F; 该类型不支持repeated</span><br><span class="line">message SampleMessage &#123;</span><br><span class="line">    oneof test_oneof &#123;</span><br><span class="line">        string last_name &#x3D; 1;</span><br><span class="line">        string family_name &#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Maps</span><br><span class="line">message MapsMessage &#123;</span><br><span class="line">    &#x2F;&#x2F; 除了float、bytes、枚举类型作为key，其他scalar value types都可以作为key</span><br><span class="line">    &#x2F;&#x2F; 除了map之外的任意类型可以作为value</span><br><span class="line">    &#x2F;&#x2F; map类型字段不支持repeated,value顺序是无序的</span><br><span class="line">    &#x2F;&#x2F; 当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。</span><br><span class="line">    &#x2F;&#x2F; 从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。</span><br><span class="line">    map&lt;string, SearchRequest&gt; searchRequest &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义服务(Service)</span><br><span class="line">&#x2F;&#x2F;想要定义一个RPC服务并具有一个方法，该方法能够接收 SearchRequest并返回一个SearchResponse，此时可以在.proto文件中进行如下定义：</span><br><span class="line">service SearchService &#123;</span><br><span class="line">  rpc Search (SearchRequest) returns (SearchResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JSON映射"><a href="#JSON映射" class="headerlink" title="JSON映射"></a>JSON映射</h3><p>Proto3支持标准的JSON编码，使得在不同的系统直接共享数据变得简单。下表列出的是基础的类型对照。</p><p>在JSON编码中，如果某个值被设置为null或丢失，在映射为ProtoBuf的时候会转换为相应的默认值。在ProtoBuf中如果一个字段是默认值，在映射为JSON编码的时候，这个默认值会被忽略以节省空间。可以通过选项设置，使得JSON编码输出中字段带有默认值。</p><table><thead><tr><th>proto3</th><th>JSON</th><th>JSON example</th><th>Notes</th></tr></thead><tbody><tr><td>message</td><td>object</td><td>{“fooBar”: v,”g”: null,…}</td><td>生成JSON对象。 消息字段名称映射到lowerCamelCase并成为JSON对象键。 如果指定了json_name字段选项，则将指定的值用作键。解析器接受 lowerCamelCase名称（或json_name选项指定的名称）和原始proto字段名称。 null是所有字段类型的可接受值，并被视为相应字段类型的默认值。</td></tr><tr><td>enum</td><td>string</td><td>“FOO_BAR”</td><td>使用proto中指定的枚举值的名称。 解析器接受枚举名称和整数值。</td></tr><tr><td>map&lt;K,V&gt;</td><td>object</td><td>{“k”: v, …}</td><td>所有键都转换为字符串。</td></tr><tr><td>repeated V</td><td>array</td><td>[v, …]</td><td>null被转换为空列表[]</td></tr><tr><td>bool</td><td>true, false</td><td>true, false</td><td></td></tr><tr><td>string</td><td>string</td><td>“Hello World!”</td><td></td></tr><tr><td>bytes</td><td>base64 string</td><td>“YWJjMTIzIT8kKiYoKSctPUB+”</td><td>JSON值将是使用带填充的标准base64编码编码为字符串的数据。 接受带有/不带填充的标准或URL安全base64编码。</td></tr><tr><td>int32, fixed32, uint32</td><td>number</td><td>1, -10, 0</td><td>JSON值将是十进制数。 接受数字或字符串。</td></tr><tr><td>int64, fixed64, uint64</td><td>string</td><td>“1”, “-10”</td><td>JSON值将是十进制字符串。 接受数字或字符串。</td></tr><tr><td>float, double</td><td>number</td><td>1.1, -10.0, 0, “NaN”, “Infinity”</td><td>JSON值将是一个或多个特殊字符串值“NaN”，“Infinity”和“-Infinity”。 接受数字或字符串。 指数表示法也被接受。</td></tr><tr><td>Any</td><td>object</td><td>{“@type”: “url”, “f”: v, … }</td><td>如果Any包含具有特殊JSON映射的值，则它将按如下方式转换： {“@ type”：xxx，“value”：yyy} 。 否则，该值将转换为JSON对象，并将插入 “@ type” 字段以指示实际数据类型。</td></tr><tr><td>Timestamp</td><td>string</td><td>“1972-01-01T10:00:20.021Z”</td><td>使用RFC 3339，其中生成的输出将始终被Z标准化并使用0,3,6或9个小数位。 也接受“Z”以外的偏移。</td></tr><tr><td>Duration</td><td>string</td><td>“1.000340012s”, “1s”</td><td>生成的输出始终包含0,3,6或9个小数位，具体取决于所需的精度，后跟后缀“s”。 接受的是任何小数位（也没有），只要它们符合纳秒精度并且需要后缀“s”。</td></tr><tr><td>Struct</td><td>object</td><td>{ … }</td><td>任意JSON对象</td></tr><tr><td>Wrapper types</td><td>various types</td><td>2, “2”, “foo”, true, “true”, null, 0, …</td><td>Wrappers在JSON中使用与包装基元类型相同的表示形式，除了在数据转换和传输期间允许并保留 null .</td></tr><tr><td>FieldMask</td><td>string</td><td>“f.fooBar,h”</td><td>见field_mask.proto.</td></tr><tr><td>ListValue</td><td>array</td><td>[foo, bar, …]</td><td></td></tr><tr><td>Value</td><td>value</td><td></td><td>任意JSON 值</td></tr><tr><td>NullValue</td><td>null</td><td></td><td>JSON null</td></tr></tbody></table><p><img src="/blog/19/2.png" alt="JSON映射"></p><h2 id="grpcurl的使用"><a href="#grpcurl的使用" class="headerlink" title="grpcurl的使用"></a>grpcurl的使用</h2><p>下载grpcurl工具：</p><p>github地址：<a href="https://github.com/fullstorydev/grpcurl/releases/tag/v1.3.1">https://github.com/fullstorydev/grpcurl/releases/tag/v1.3.1</a> 点击release下载对应的版本</p><p>Linux内核的系统下：./grpcurl -plaintext -d ‘{JSON_FROMAT_DATA}’ {ADDRESS}:{PORT} {SERVICE_NAME}.{METHOD_NAME}</p><p>Windows操作系统下：grpcurl -d {JSON_FROMAT_DATA} -plaintext {ADDRESS}:{PORT} {SERVICE_NAME}/{METHOD_NAME}<br>    需要注意Windows操作系统下{JSON_FROMAT_DATA}需要转义，例如入参为{“aa”:1,”bb”:”zhangsan”} 需要写成 {&quot;aa&quot;:1,&quot;bb&quot;:&quot;zhangsan&quot;}</p><p>调用gRPC服务：</p><p>Linux系统下：./grpcurl -plaintext -d ‘{“name”:”zhangsan”}’ {ADDRESS}:{PORT} com.ypsx.项目名.client.service.HelloService.sayHello</p><p>Windows操作系统cmd命令行下：grpcurl.exe -d {&quot;name&quot;:&quot;zhangsan&quot;} -plaintext {ADDRESS}:{PORT} com.ypsx.项目名.client.service.HelloService/sayHello</p><p>Windows操作系统PowerShell命令行下：grpcurl.exe -d ‘{&quot;name&quot;:&quot;zhangsan&quot;}’ -plaintext ‘{ADDRESS}:{PORT}’ ‘com.ypsx.项目名.client.service.HelloService/sayHello’</p><p>成功返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;message&quot;: &quot;Hello zhangsan&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://colobu.com/2017/03/16/Protobuf3-language-guide/">https://colobu.com/2017/03/16/Protobuf3-language-guide/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是总结了一下这段时间学习gRPC的过程中遇到的一些问题和知识点&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是总结了一下这段时间学习gRPC的过程中遇到的一些问题和知识点&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是总结了一下这段时间学习gRPC的过程中遇到的一些问题和知识点&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是总结了一下这段时间学习gRPC的过程中遇到的一些问题和知识点&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：本篇文章主要是总结了一下学习gRPC的过程中遇到的一些问题和知识点。&quot;&gt;&lt;a href=&quot;#前言：本篇文章主要是总结了一下学习gRPC的过程中遇到的一些问题和知识点。&quot; class=&quot;headerlink&quot; title=&quot;前言：本篇文章主要是总结了一下学习gRPC的过程中遇到的一些问题和知识点。&quot;&gt;&lt;/a&gt;前言：本篇文章主要是总结了一下学习gRPC的过程中遇到的一些问题和知识点。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="RPC" scheme="https://www.blog.ajie39.top/categories/RPC/"/>
    
    
    <category term="微服务" scheme="https://www.blog.ajie39.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="RPC" scheme="https://www.blog.ajie39.top/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>linux深入浅出</title>
    <link href="https://www.blog.ajie39.top/2019/09/19/linux%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"/>
    <id>https://www.blog.ajie39.top/2019/09/19/linux%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</id>
    <published>2019-09-19T12:00:14.753Z</published>
    <updated>2021-05-05T04:26:19.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：本文主要是对linux的一些知识点进行总结。"><a href="#摘要：本文主要是对linux的一些知识点进行总结。" class="headerlink" title="摘要：本文主要是对linux的一些知识点进行总结。"></a>摘要：本文主要是对linux的一些知识点进行总结。</h1><hr><h1 id="前言：主要是对linux的一些知识点进行总结。"><a href="#前言：主要是对linux的一些知识点进行总结。" class="headerlink" title="前言：主要是对linux的一些知识点进行总结。"></a>前言：主要是对linux的一些知识点进行总结。</h1><hr><span id="more"></span><h2 id="linux基础篇"><a href="#linux基础篇" class="headerlink" title="linux基础篇"></a>linux基础篇</h2><h3 id="虚拟机的网络连接三种形式的说明"><a href="#虚拟机的网络连接三种形式的说明" class="headerlink" title="虚拟机的网络连接三种形式的说明"></a>虚拟机的网络连接三种形式的说明</h3><ul><li><p>Bridged（桥接模式）<br>桥接模式是通过虚拟网桥将主机的网卡与虚拟机的Vmnet0连接在一起，虚拟机即可通过VMnet0连接到主机的网卡进而进行网络的访问，所以桥接模式的虚拟机的IP地址需要和主机的IP地址在同一个网段，并且子网掩码，网关，与DNS也需要和主机的一致才可以。也就是说桥接的方式是虚拟机通过vmnet0这块虚拟网卡来和主机上面的网卡进行连接，进而进行通信的。</p><p><img src="/blog/18/1.png" alt="桥接模式"></p></li><li><p>NAT地址转换模式<br>在Nat模式上面主机网卡直接和虚拟NAT相连，NAT与DHCP一同连接到Vmnet8上面，这样就实现了虚拟联网。也就是说我们在用NAT进行联网的时候，采用的是Vmnet8这块网卡。NAT模式可以手动编辑虚拟机的静态IP，不要求和主机的IP地址在同一个网段。</p><p><img src="/blog/18/2.png" alt="NAT地址转换模式"></p></li><li><p>仅主机模式<br>HostOnly模式通过主机的VMware NetWork  Adapter Vmnet1来连接虚拟机的VMnet1，这样做使得虚拟机只能够和主机进行通信，而不能够上网。</p><p><img src="/blog/18/3.png" alt="仅主机模式"></p></li><li><p>总结：桥接方式可以进行连接互联网，使用的是VMnet0，IP地址需要和主机的IP地址在同一个网段当中。NAT模式也可以进行连接互联网，IP地址可以自己定义，不过要在许可的范围内。仅主机模式使用的是VMnet1，只能够和主机进行通信，不能够连接网络。</p></li></ul><h3 id="源修改"><a href="#源修改" class="headerlink" title="源修改"></a>源修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看现在有哪些源</span><br><span class="line">yum repolist</span><br><span class="line"></span><br><span class="line">下载阿里yum源到&#x2F;etc&#x2F;yum.repos.d</span><br><span class="line">cd &#x2F;etc&#x2F;yum.repos.d</span><br><span class="line">sudo wget -nc http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br><span class="line"></span><br><span class="line">清除yum机制的本地缓存</span><br><span class="line">sudo yum clean all</span><br><span class="line">sudo yum makecache</span><br><span class="line">sudo yum  list</span><br><span class="line">sudo yum -y update</span><br></pre></td></tr></table></figure><h3 id="linux的目录结构"><a href="#linux的目录结构" class="headerlink" title="linux的目录结构"></a>linux的目录结构</h3><ul><li>linux的目录中有且只有一个根目录。</li><li>linux系统中，一切皆为文件。</li></ul><p>  <img src="/blog/18/4.jpg" alt="linux的目录结构"></p><p>以下是对这些目录的解释：</p><ul><li><p>系统启动必须：</p><ul><li>/boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录，更改目录下的文件可能会导致系统不能启动。</li><li>/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li>/sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。<ul><li>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。</li><li>该文件系统是内核设备树的一个直观反映。</li><li>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li></ul></li></ul></li><li><p>指令集合：</p><ul><li>/bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li>/sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li></ul></li><li><p>外部文件管理：</p><ul><li>/dev ：dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li>/media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li>/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li></ul></li><li><p>临时文件：</p><ul><li>/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</li><li>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>/tmp：这个目录是用来存放一些临时文件的。</li></ul></li><li><p>账户：</p><ul><li>/root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>/home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li>/usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li>/usr/bin：系统用户使用的应用程序与指令。</li><li>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</li><li>/usr/src：内核源代码默认的放置目录。</li></ul></li><li><p>运行过程中要用：</p><ul><li><p>/var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件（/var/log 目录下）。</p></li><li><p>/proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</span><br></pre></td></tr></table></figure></li><li><p>/selinux：这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li></ul></li><li><p>扩展用的：</p><ul><li>/opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li>/srv：该目录存放一些服务启动之后需要提取的数据。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：本文主要是对linux的一些知识点进行总结。&quot;&gt;&lt;a href=&quot;#摘要：本文主要是对linux的一些知识点进行总结。&quot; class=&quot;headerlink&quot; title=&quot;摘要：本文主要是对linux的一些知识点进行总结。&quot;&gt;&lt;/a&gt;摘要：本文主要是对linux的一些知识点进行总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：主要是对linux的一些知识点进行总结。&quot;&gt;&lt;a href=&quot;#前言：主要是对linux的一些知识点进行总结。&quot; class=&quot;headerlink&quot; title=&quot;前言：主要是对linux的一些知识点进行总结。&quot;&gt;&lt;/a&gt;前言：主要是对linux的一些知识点进行总结。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="linux" scheme="https://www.blog.ajie39.top/categories/linux/"/>
    
    
    <category term="linux" scheme="https://www.blog.ajie39.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>彩笔的一天之面试总结</title>
    <link href="https://www.blog.ajie39.top/2019/09/16/%E5%BD%A9%E7%AC%94%E7%9A%84%E4%B8%80%E5%A4%A9%E4%B9%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2019/09/16/%E5%BD%A9%E7%AC%94%E7%9A%84%E4%B8%80%E5%A4%A9%E4%B9%8B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-09-16T07:36:57.677Z</published>
    <updated>2021-05-05T04:23:49.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：2019-09-16这是一个悲惨的日子，菜鸡啊杰在线丢人，笔试没做完，电面也不会，我太难了。"><a href="#摘要：2019-09-16这是一个悲惨的日子，菜鸡啊杰在线丢人，笔试没做完，电面也不会，我太难了。" class="headerlink" title="摘要：2019.09.16这是一个悲惨的日子，菜鸡啊杰在线丢人，笔试没做完，电面也不会，我太难了。"></a>摘要：2019.09.16这是一个悲惨的日子，菜鸡啊杰在线丢人，笔试没做完，电面也不会，我太难了。</h1><hr><h1 id="前言：本篇文章主要是记录一下，今天面试过程中遇到的一些面试题，还有一些遗忘的知识点。"><a href="#前言：本篇文章主要是记录一下，今天面试过程中遇到的一些面试题，还有一些遗忘的知识点。" class="headerlink" title="前言：本篇文章主要是记录一下，今天面试过程中遇到的一些面试题，还有一些遗忘的知识点。"></a>前言：本篇文章主要是记录一下，今天面试过程中遇到的一些面试题，还有一些遗忘的知识点。</h1><hr><span id="more"></span><h2 id="丢人之知识点遗忘"><a href="#丢人之知识点遗忘" class="headerlink" title="丢人之知识点遗忘"></a>丢人之知识点遗忘</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li><p>1、什么是事务？事务的特性（ACID）</p><ul><li>什么是事务：事务是程序中一系列严密的操作，所有操作执行必须成功完成，否则在每个操作所做的更改将会被撤销，这也是事务的原子性（要么成功，要么失败）。</li><li>事务特性分为四个：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）简称ACID。<ul><li>1、原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</li><li>2、一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</li><li>3、隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>4、持久性：也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li></ul></li></ul></li><li><p>2、事务的隔离级别有几种，最常用的隔离级别是哪两种？</p><ul><li>并发过程中会出现的问题：<ul><li>丢失更新：是不可重复读的特殊情况。如果两个事物都读取同一行，然后两个都进行写操作，并提交，第一个事物所做的改变就会丢失。</li><li>脏读：一个事务读取到另一个事务未提交的更新数据。</li><li>幻读也叫虚读：一个事务执行两次查询，第二次结果集包含第一次中没有或某些行已经被删除的数据，造成两次结果不一致，只是另一个事务在这两次查询中间插入或删除了数据造成的。</li><li>不可重复读：一个事务两次读取同一行的数据，结果得到不同状态的结果，中间正好另一个事务更新了该数据，两次结果相异，不可被信任。</li></ul></li><li>事务的隔离级别有4种：<ul><li>1、未提交读（Read uncommitted）<ul><li>定义：就是一个事务读取到其他事务未提交的数据，是级别最低的隔离机制。</li><li>缺点：会产生脏读、不可重复读、幻读。</li></ul></li><li>2、提交读（Read committed)<ul><li>定义：就是一个事务读取到其他事务提交后的数据。Oracle默认隔离级别。</li><li>缺点：会产生不可重复读、幻读。</li></ul></li><li>3、可重复读（Repeatable read）<ul><li>定义：就是一个事务对同一份数据读取到的相同，不在乎其他事务对数据的修改。MySQL默认的隔离级别。</li><li>缺点：会产生幻读。</li></ul></li><li>4、串行化（Serializable）<ul><li>定义：事务串行化执行，隔离级别最高，牺牲了系统的并发性。</li><li>缺点：可以解决并发事务的所有问题。但是效率地下，消耗数据库性能，一般不使用。</li></ul></li></ul></li></ul></li></ul><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th></th></tr></thead><tbody><tr><td>未提交读（read uncommited）</td><td>是</td><td>是</td><td>是</td><td></td></tr><tr><td>不可重复读（read commited）</td><td>否</td><td>是</td><td>是</td><td></td></tr><tr><td>可重复读（repeatable read）</td><td>否</td><td>否</td><td>是</td><td></td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td><td></td></tr></tbody></table><ul><li>最常用的隔离级别是提交读和可重复读。<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3></li><li>3、分布式缓存的典型应用场景？<ul><li>页面缓存，用来缓存Web页面的内容片段，包括HTML、CSS 和图片等，多应用于社交网站等。</li><li>应用对象缓存，缓存系统作为ORM框架的二级缓存对外提供服务，目的是减轻数据库的负载压力，加速应用访问。</li><li>状态缓存，缓存包括Session会话状态及应用横向扩展时的状态数据等，这类数据一般是难以恢复的，对可用性要求较高，多应用于高可用集群。</li><li>并行处理，通常涉及大量中间计算结果需要共享。</li><li>事件处理，分布式缓存提供了针对事件流的连续查询(continuous query)处理技术，满足实时性需求。</li><li>极限事务处理，分布式缓存为事务型应用提供高吞吐率、低延时的解决方案，支持高并发事务请求处理，多应用于铁路、金融服务和电信等领域。</li></ul></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><p>4、MongoDB与Mysql的区别？</p><ul><li>两种数据库的区别：<ul><li>1、传统的关系型数据库，数据是以表单为媒介进行存储的。</li><li>2、相比较Mysql，Mongodb以一种直观文档的方式来完成数据的存储。</li></ul></li><li>Mongodb的鲜明特征：<ul><li>1、自带GirdFS的分布式文件系统，这也为Mongodb的部署提供了很大便利。</li><li>2、Mongodb内自建了对map-reduce运算框架的支持，虽然这种支持从功能上看还算是比较简单的，相当于MySQL里GroupBy功能的扩展版，不过也为数据的统计带来了方便。</li><li>3、Mongodb在启动后将数据库中得数据以文件映射的方式加载到内存中，如果内存资源相当丰富的话，这将极大的提高数据库的查询速度。</li></ul></li><li>Mongodb的优势：<ul><li>1）Mongodb适合那些对数据库具体格式不明确或者数据库数据格式经常变化的需求模型，而且对开发者十分友好。</li><li>2）Mongodb官方就自带一个分布式文件系统，Mongodb官方就自带一个分布式文件系统，可以很方便的部署到服务器机群上。</li></ul></li><li>Mongodb的缺陷：<ul><li>1）事务关系支持薄弱。这也是所有NoSQL数据库共同的缺陷，不过NoSQL并不是为了事务关系而设计的，具体应用还是很需求。</li><li>2）稳定性有些欠缺</li><li>3）方便开发者的同时，对运维人员提出了更高的要求。</li></ul></li><li>Mongodb的应用场景：<ul><li>1）表结构不明确且数据不断变大：MongoDB是非结构化文档数据库，扩展字段很容易且不会影响原有数据。内容管理或者博客平台等，例如圈子系统，存储用户评论之类的。</li><li>2）更高的写入负载：MongoDB侧重高数据写入的性能，而非事务安全，适合业务系统中有大量“低价值”数据的场景。本身存的就是json格式数据。例如做日志系统。</li><li>3）数据量很大或者将来会变得很大：Mysql单表数据量达到5-10G时会出现明细的性能降级，需要做数据的水平和垂直拆分、库的拆分完成扩展，MongoDB内建了sharding、很多数据分片的特性，容易水平扩展，比较好的适应大数据量增长的需求。</li><li>4）高可用性：自带高可用，自动主从切换（副本集）：</li></ul></li><li>不适用的场景<ul><li>1）MongoDB不支持事务操作，需要用到事务的应用建议不用MongoDB。</li><li>2）MongoDB目前不支持join操作，需要复杂查询的应用也不建议使用MongoDB。</li><li>3）在带“_id”插入数据的时候，MongoDB的插入效率其实并不高。如果想充分利用MongoDB性能的话，推荐采取不带“_id”的插入方式，然后对相关字段作索引来查询。</li></ul></li><li>关系型数据库和非关系型数据库的应用场景对比：<ul><li>关系型数据库适合存储结构化数据，如用户的帐号、地址：<ul><li>1）这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹。</li><li>2）这些数据的规模、增长的速度通常是可以预期的。</li><li>3）事务性、一致性。</li></ul></li></ul></li><li>NoSQL适合存储非结构化数据，如文章、评论：<ul><li>1）这些数据通常用于模糊处理，如全文搜索、机器学习。</li><li>2）这些数据是海量的，而且增长的速度是难以预期的。</li><li>3）根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性。</li><li>4）按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差。</li></ul></li></ul></li><li><p>5、Mysql索引相关问题。</p><ul><li><p>1）什么是索引？</p><ul><li>索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据。</li></ul></li><li><p>2）索引具体采用的哪种数据结构呢？</p><ul><li>常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，通常使用的是InnoDB引擎，默认的是B+树。</li></ul></li><li><p>3）InnoDb内存使用机制？</p><ul><li><p>Innodb体系结构如图所示：<br><img src="/blog/17/1.jpg" alt="Innodb体系结构"></p></li><li><p>Innodb关于查询效率有影响的两个比较重要的参数分别是innodb_buffer_pool_size，innodb_read_ahead_threshold:</p><ul><li>innodb_buffer_pool_size指的是Innodb缓冲池的大小，该参数的大小可通过命令指定innodb_buffer_pool_size 20G。缓冲池使用改进的LRU算法进行管理，维护一个LRU列表、一个FREE列表，FREE列表存放空闲页，数据库启动时LRU列表是空的，当需要从缓冲池分页时，首先从FREE列表查找空闲页，有则放入LRU列表，否则LRU执行淘汰，淘汰尾部的页分配给新页。</li><li>innodb_read_ahead_threshold相对应的是数据预加载机制，innodb_read_ahead_threshold 30表示的是如果一个extent中的被顺序读取的page超过或者等于该参数变量的，Innodb将会异步的将下一个extent读取到buffer pool中，比如该参数的值为30，那么当该extent中有30个pages被sequentially的读取，则会触发innodb linear预读，将下一个extent读到内存中；在没有该变量之前，当访问到extent的最后一个page的时候，Innodb会决定是否将下一个extent放入到buffer pool中；可以在Mysql服务端通过show innodb status中的Pages read ahead和evicted without access两个值来观察预读的情况：Innodb_buffer_pool_read_ahead：表示通过预读请求到buffer pool的pages；Innodb_buffer_pool_read_ahead_evicted：表示由于请求到buffer pool中没有被访问，而驱逐出内存的页数。</li><li>可以看出来，Mysql的缓冲池机制是能充分利用内存且有预加载机制，在某些条件下目标数据完全在内存中，也能够具备非常好的查询性能。</li></ul></li></ul></li><li><p>4）B+ Tree索引和Hash索引区别？</p><ul><li>哈希索引适合等值查询，但是无法进行范围查询。</li><li>哈希索引没办法利用索引完成排序。</li><li>哈希索引不支持多列联合索引的最左匹配规则。</li><li>如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</li></ul></li><li><p>5）B+ Tree的叶子节点都可以存哪些东西吗？</p><ul><li>InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值。</li></ul></li><li><p>6）这两者有什么区别吗？</p><ul><li>在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。</li></ul></li><li><p>7）聚簇索引和非聚簇索引，在查询数据的时候有区别吗？</p><ul><li>聚簇索引查询会更快，因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询。</li></ul></li><li><p>8）主键索引查询只会查一次，而非主键索引需要回表查询多次（这个过程叫做回表）。是所有情况都是这样的吗？非主键索引一定会查询多次吗？</p><ul><li>覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。</li></ul></li><li><p>9）在创建索引的时候都会考虑哪些因素呢？</p><ul><li>一般对于查询概率比较高，经常作为where条件的字段设置索引。</li></ul></li><li><p>10）在创建联合索引的时候，需要做联合索引多个字段之间顺序，这是如何选择的呢？</p><ul><li>在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边，因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。</li></ul></li><li><p>11）你知道在MySQL 5.6中，对索引做了哪些优化吗？</p><ul><li>索引条件下推：“索引条件下推”，称为 Index Condition Pushdown (ICP)，这是MySQL提供的用某一个索引对一个特定的表从表中获取元组”，注意我们这里特意强调了“一个”，这是因为这样的索引优化不是用于多表连接而是用于单表扫描，确切地说，是单表利用索引进行扫描以获取数据的一种方式。 </li><li>例如有索引（key1，key2）,SQL语句中where key1 = ‘XXX’ and key2 like ‘%XXX%’：<ul><li>如果没有使用索引下推技术，MySQL会通过key1 = ‘XXX’从存储引擎返回对应的数据至MySQL服务端，服务端再基于key2 like 判断是否符合条件。</li><li>如果使用了索引下推技术，MySQL首先返回key1=’XXX’的索引，再根据key2 like 判断索引是否符合条件，如果符合则通过索引定位数据，如果不符合则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。</li></ul></li></ul></li><li><p>12）如何知道索引是否生效？</p><ul><li>explain显示了MySQL如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。使用方法，在select语句前加上explain就可以了。</li></ul></li><li><p>13）那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？</p><ul><li>在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。优化过程大致如下：<ul><li>1、根据搜索条件，找出所有可能使用的索引。</li><li>2、计算全表扫描的代价。</li><li>3、计算使用不同索引执行查询的代价。</li><li>4、对比各种执行方案的代价，找出成本最低的那一个。</li></ul></li></ul></li><li><p>14）为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？</p><ul><li>B+tree是一种多路平衡查询树，节点是天然有序的，非叶子节点包含多个元素，不保存数据，只用来索引，叶子节点包含完整数据和带有指向下一个节点的指针，形成一个有序链表，有助于范围和顺序查找。因为非叶子节点不保存数据，所以同样大小的磁盘页可以容纳更多的元素，同样能数据量的情况下，B+tree相比B-tree高度更低，因此查询时IO会更少。</li><li>B-tree不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；</li><li>Hash索引底层是基于哈希表，就是以key-value存储数据的结构，多个数据在存储关系上是没有任何顺序关系的。只适合等值查询，不适合范围查询，而且也无法利用索引完成排序，不支持联合索引的最左匹配原则，如果有大量重复键值的情况下，哈希索引效率会很低，因为存在哈希碰撞。</li><li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</li><li>红黑树：树的高度随着数据量增加而增加，IO代价高。</li></ul></li></ul></li><li><p>6、如何优化MySQL？</p><ul><li>MySQL优化大致可以分为三部分：索引的优化、SQL语句优化和表的优化</li><li>索引优化可以遵循以下几个原则：<ul><li>联合索引最左前缀匹配原则</li><li>尽量把字段长度小的列放在联合索引的最左侧（因为字段越小，一页存储的数据量越大，IO性能也就越好）</li><li>order by 有多个列排序的，应该建立联合索引</li><li>对于频繁的查询优先考虑使用覆盖索引</li><li>前导模糊查询不会使用索引，比如说Like ‘%aaa%’这种</li><li>负向条件不会使用索引，如!=，&lt;&gt;，not like，not in，not exists</li><li>索引应该建立在区分度比较高的字段上  一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*)</li><li>对于where子句中经常使用的列，最好设置索引</li></ul></li><li>SQL语句优化，可以通过explain查看SQL的执行计划，优化语句原则可以有：<ul><li>在where和order by涉及的列上建立合适的索引，避免全表扫描</li><li>任何查询都不要使用select * ，而是用具体的字段列表代替</li><li>多表连接时，尽量小表驱动大表，即小表join大表</li><li>用exists代替in</li><li>尽量避免在where字句中对字段进行函数操作</li></ul></li><li>数据库表优化<ul><li>表字段尽可能用not null</li><li>字段长度固定表查询会更快</li><li>将数据库大表按照时间或者一些标志拆分成小表</li><li>水平拆分：将记录散列到不同的表中，每次从分表查询</li><li>垂直拆分：将表中的大字段单独拆分到另一张表，形成一对一的关系</li></ul></li></ul></li><li><p>7、为什么任何查询都不要使用SELECT *？</p><ul><li>多出一些不用的列，这些列可能正好不在索引的范围之内（索引的好处不多说）select * 杜绝了索引覆盖的可能性，而索引覆盖又是速度极快，效率极高，业界极为推荐的查询方式。（索引覆盖）</li><li>数据库需要知道 * 等于什么 = 查数据字典会增大开销（记录数据库和应用程序元数据的目录）。</li><li>不需要的字段会增加数据传输的时间，即使 mysql 服务器和客户端是在同一台机器上，使用的协议还是 tcp，通信也是需要额外的时间。</li><li>大字段，例如很长的 varchar，blob，text。准确来说，长度超过 728 字节的时候，会把超出的数据放到另外一个地方，因此读取这条记录会增加一次 io 操作。（mysql innodb）</li><li>影响数据库自动重写优化SQL（类似 Java 中编译 class 时的编译器自动优化） 。（Oracle）</li><li>select * 数据库需要解析更多的 对象，字段，权限，属性相关，在 SQL 语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担。</li><li>额外的 io，内存和 cpu 的消耗，因为多取了不必要的列。</li><li>用 SELECT * 需谨慎，因为一旦列的个数或顺序更改，就有可能程序执行失败。</li></ul></li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><p>Java实现多线程有几种方式？</p><ul><li>有三种方式：<ul><li>继承Thread类,并重写run方法。</li><li>实现Runnable接口，并重写run方法。</li><li>实现Callable接口，并重写run方法，并使用FutureTask包装器。</li></ul></li></ul></li><li><p>线程的生命周期</p><p><img src="/blog/17/2.png" alt="线程的生命周期"></p><ul><li>1、新建状态（New）：新创建了一个线程对象。</li><li>2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。</li><li>3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。</li><li>4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ul><li>（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)</li><li>（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。</li><li>（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）</li></ul></li><li>5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li><li><p>start()方法和run()方法的区别？</p><ul><li>start()方法会使得该线程开始执行，java虚拟机会去调用该线程的run()方法。</li><li>通过调用Thread类的 start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。</li><li>run()方法只是类的一个普通方法而已，如果直接调用run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。</li></ul></li><li><p>Runnable接口和Callable接口的区别？</p><ul><li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已。</li><li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li><li>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable + Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</li></ul></li><li><p>volatile关键字</p><ul><li>volatile基本介绍：volatile可以看成是synchronized的一种轻量级的实现，但volatile并不能完全代替synchronized，volatile有synchronized可见性的特性，但没有synchronized原子性的特性。可见性即用volatile关键字修饰的成员变量表明该变量不存在工作线程的副本，线程每次直接都从主内存中读取，每次读取的都是最新的值，这也就保证了变量对其他线程的可见性。另外，使用volatile还能确保变量不能被重排序，保证了有序性。</li><li>当一个变量定义为volatile之后，它将具备两种特性：<ul><li>①保证此变量对所有线程的可见性：当一条线程修改了这个变量的值，新值对于其他线程可以说是可以立即得知的。Java内存模型规定了所有的变量都存储在主内存，每条线程还有自己的工作内存，线程的工作内存保存了该线程使用到的变量在主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读取主内存中的变量。</li><li>②禁止指令重排序优化：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean isOK &#x3D; false;</span><br><span class="line">&#x2F;&#x2F;假设以下代码在线程A执行</span><br><span class="line">A.init();</span><br><span class="line">isOK&#x3D;true;</span><br><span class="line">&#x2F;&#x2F;假设以下代码在线程B执行</span><br><span class="line">while(!isOK)&#123;</span><br><span class="line">sleep();</span><br><span class="line"> &#125;</span><br><span class="line"> B.init();</span><br></pre></td></tr></table></figure>A线程在初始化的时候，B线程处于睡眠状态，等待A线程完成初始化的时候才能够进行自己的初始化。这里的先后关系依赖于isOK这个变量。如果没有volatile修饰isOK这个变量，那么isOK的赋值就可能出现在A.init()之前（指令重排序,Java虚拟机的一种优化措施），此时A没有初始化，而B的初始化就破坏了它们之前形成的那种依赖关系，可能就会出错。</li></ul></li><li>volatile使用场景：<ul><li>如果正确使用volatile的话，必须依赖下以下种条件：<ul><li>1、对变量的写操作不依赖当前变量的值。</li><li>2、该变量没有包含在其他变量的不变式中。</li></ul></li><li>在以下两种情况下都必须使用volatile：<ul><li>1、状态的改变。</li><li>2、读多写少的情况。</li></ul></li></ul></li></ul></li><li><p>什么是线程安全？</p><ul><li>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</li><li>线程安全的级别：<ul><li>1）不可变：像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用。</li><li>2）绝对线程安全：不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet。</li><li>3）相对线程安全：相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</li><li>4）线程非安全：ArrayList、LinkedList、HashMap等都是线程非安全的类。</li></ul></li></ul></li><li><p>sleep方法和wait方法有什么区别？</p><ul><li>原理不同：sleep()方法是Thread类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，而把执行机会让给其他线程，等到计时时间一到，此线程会自动苏醒。而wait()方法是Object类的方法，用于线程间的通信，这个方法会使当前拥有该对象锁的进程等待，直到其他线程用调用notify()或notifyAll()时才苏醒过来，开发人员也可以给它指定一个时间使其自动醒来。</li><li>对锁的处理机制不同：由于sleep()方法的主要作用是让线程暂停一段时间，时间一到则自动恢复，不涉及线程间的通信，因此调用sleep()方法并不会释放锁。而wait()方法则不同，当调用wait()方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他synchronized数据可被别的线程使用。</li><li>使用区域不同：wait()方法必须放在同步控制方法或者同步语句块中使用，而sleep方法则可以放在任何地方使用。</li><li>sleep()方法必须捕获异常，而wait()、notify()、notifyAll()不需要捕获异常。在sleep的过程中，有可能被其他对象调用它的interrupt()，产生InterruptedException异常。</li><li>由于sleep不会释放锁标志，容易导致死锁问题的发生，一般情况下，不推荐使用sleep()方法，而推荐使用wait()方法。</li></ul></li><li><p>写一个会导致死锁的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread&#123;</span><br><span class="line">private static Object lock1 &#x3D; new Object();</span><br><span class="line">private static Object lock2 &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        synchronized (lock1)&#123;</span><br><span class="line">            System.out.println(&quot;thread1 get lock1&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock2)&#123;</span><br><span class="line">                System.out.println(&quot;thread1 get lock2&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;thread1 end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">        synchronized (lock2)&#123;</span><br><span class="line">            System.out.println(&quot;thread2 get lock2&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            synchronized (lock1)&#123;</span><br><span class="line">                System.out.println(&quot;thread2 get lock1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;thread2 end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul><li>1、类加载过程：加载-&gt;链接（验证+准备+解析）-&gt;初始化（使用前的准备）-&gt;使用-&gt;卸载<br><img src="/blog/17/3.jpg" alt="类加载过程"></li></ul><p>具体过程如下：</p><ul><li><p>1）加载：首先通过一个类的全限定名来获取此类的二进制字节流；其次将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；最后在java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口。总的来说就是查找并加载类的二进制数据。</p></li><li><p>2）链接：</p><ul><li>验证：确保被加载类的正确性。</li><li>准备：为类的静态变量分配内存，并将其初始化为默认值。</li><li>解析：把类中的符号引用转换为直接引用。<ul><li>符号引用即用字符串符号的形式来表示引用，其实被引用的类、方法或者变量还没有被加载到内存中。</li><li>直接引用则是有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中。<br><img src="/blog/17/4.png" alt="符号引用和直接引用"></li><li>直接引用可以是：<ul><li>1、直接指向目标的指针。（个人理解为：指向对象，类变量和类方法的指针）</li><li>2、相对偏移量。（指向实例的变量，方法的指针）</li><li>3、一个间接定位到对象的句柄。</li></ul></li><li>为什么要使用符号引用？<ul><li>符号引用要转换成直接引用才有效，这也说明直接引用的效率要比符号引用高。那为什么要用符号引用呢？这是因为类加载之前，javac会将源代码编译成.class文件，这个时候javac是不知道被编译的类中所引用的类、方法或者变量他们的引用地址在哪里，所以只能用符号引用来表示，当然，符号引用是要遵循java虚拟机规范的。还有一种情况需要用符号引用，就例如前文举得变量的符号引用的例子，是为了逻辑清晰和代码的可读性。</li></ul></li></ul></li></ul></li><li><p>3）为类的静态变量赋予正确的初始值。</p></li><li><p>2、类的初始化</p><ul><li>1）类什么时候才被初始化：<ul><li>1、创建类的实例，也就是new一个对象。</li><li>2、访问某个类或接口的静态变量，或者对该静态变量赋值。</li><li>3、调用类的静态方法。</li><li>4、反射（Class.forName(“com.lyj.load”)）。</li><li>5、初始化一个类的子类（会首先初始化子类的父类）。</li><li>6、JVM启动时标明的启动类，即文件名和类名相同的那个类。</li></ul></li><li>2）类的初始化顺序<ul><li>1、如果这个类还没有被加载和链接，那先进行加载和链接</li><li>2、假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）</li><li>3、加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。</li><li>4、总的来说，初始化顺序依次是：<ul><li>（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；</li><li>如果有父类，则顺序是：父类的静态变量 –&gt; 父类的静态代码块 –&gt; 子类的静态变量 –&gt; 子类的静态代码块 –&gt; 父类的非静态变量 –&gt; 父类的非静态代码块 –&gt; 父类的构造方法 –&gt; 子类的非静态变量 –&gt; 子类的非静态代码块 –&gt; 子类的构造方法。</li></ul></li></ul></li></ul></li><li><p>3、类的加载</p><ul><li><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。如：<br><img src="/blog/17/5.jpg" alt="类的加载过程"></p></li><li><p>类的加载的最终产品是位于堆区中的Class对象。Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。加载类的方式有以下几种：</p></li><li><p>1）从本地系统直接加载。</p></li><li><p>2）通过网络下载.class文件。</p></li><li><p>3）从zip，jar等归档文件中加载.class文件。</p></li><li><p>4）从专有数据库中提取.class文件。</p></li><li><p>5）将Java源文件动态编译为.class文件（服务器）。<br><img src="/blog/17/6.png" alt="类的加载过程"></p></li></ul></li><li><p>4、加载器</p><ul><li><p>JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：<br><img src="/blog/17/7.png" alt="加载器"></p></li><li><p>加载器介绍：</p><ul><li>1）BootstrapClassLoader（启动类加载器）：<ul><li>负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，加载System.getProperty(“sun.boot.class.path”)所指定的路径或jar。</li></ul></li><li>2）ExtensionClassLoader（标准扩展类加载器）：<ul><li>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。载System.getProperty(“java.ext.dirs”)所指定的路径或jar。</li></ul></li><li>3）AppClassLoader（系统类加载器）：<ul><li>负责加载classpath中指定的jar包及目录中class。</li></ul></li><li>4）CustomClassLoader（自定义加载器）：<ul><li>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。</li></ul></li></ul></li><li><p>类加载器的顺序</p><ul><li>1）加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</li><li>2）在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载。</li><li>3）Bootstrap Loader（启动类加载器）是最顶级的类加载器了，其父加载器为null。</li></ul></li></ul></li><li><p>5、类加载器之双亲委派模型</p><ul><li>所谓的双亲委派模型指除了启动类加载器以外，其余的加载器都有自己的父类加载器，而在工作的时候，如果一个类加载器收到加载请求，他不会马上加载类，而是将这个请求向上传递给他的父加载器，看父加载器能不能加载这个类，加载的原则就是优先父加载器加载，如果父加载器加载不了，自己才能加载。</li><li>因为有了双亲委派模型的存在，类似Object类重复多次的问题就不会存在了，因为经过层层传递，加载请求最终都会被Bootstrap ClassLoader所响应。加载的Object对象也会只有一个。并且面对同一JVM进程多版本共存的问题，只要自定义一个不向上传递加载请求的加载器就好啦。<br><img src="/blog/17/8.png" alt="双亲委派模型"></li></ul></li></ul><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><ul><li><p>Java内存区域划分</p><ul><li>我们先来看看Java的内存区域划分情况，如下图所示：</li></ul><p><img src="/blog/17/9.png" alt="Java内存区域划分"></p><ul><li>私有内存区的区域名和相应的特性如下表所示：</li></ul></li></ul><table><thead><tr><th>区域名称</th><th>特性</th></tr></thead><tbody><tr><td>程序计数器</td><td>指示当前程序执行到了哪一行，执行Java方法时记录正在执行的虚拟机字节地址；执行本地方法时，计数器值为undefined。</td></tr><tr><td>虚拟机栈</td><td>用于执行Java方法。栈帧存储局部变量表、操作数栈、动态链接、方法返回一些额外的附加信息。程序执行时栈帧入栈；执行完成后栈帧出栈。</td></tr><tr><td>本地方法栈</td><td>用于执行本地方法，其他和虚拟机栈类似。</td></tr></tbody></table><ul><li><p>虚拟机栈中的局部变量表里面存放了三个信息：</p><ul><li>各种基本数据类型(boolean、byte、char、short、int、float、long、double)。</li><li>对象引用(reference)。</li><li>returnAddress地址。</li><li>这个returnAddress和程序计数器有什么区别？前者是指示JVM的指令执行到了哪一行，后者是指你的代码执行到哪一行。</li></ul></li><li><p>共享内存区（接下来主要讲jdk1.7）的区域名和相应的特性如下表所示：</p></li></ul><table><thead><tr><th>区域名称</th><th>特性</th></tr></thead><tbody><tr><td>Java堆</td><td>Java虚拟机管理的内存中最大的一块，所有线程共享，几乎所有的对象实例和数组都在这类分配内存。GC主要就是在Java堆中进行的。</td></tr><tr><td>方法区</td><td>用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据。但是已被最新的JVM取消了。现在，被加载的类作为元数据加载到底层操作系统的本地内存区。</td></tr></tbody></table><ul><li><p>哪些内存需要回收？</p><ul><li>私有内存区伴随着线程的产生而产生，一旦线程中止，私有内存区也会自动消除，因此我们在本文中讨论的内存回收主要是针对共享内存区。</li></ul></li><li><p>Java堆</p><p><img src="/blog/17/10-1.png" alt="Java堆"></p><ul><li><p>新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为Java对象大都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p></li><li><p>老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC （但非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p></li></ul></li><li><p>新生代：刚刚新建的对象在Eden中，经历一次Minor GC, Eden中的存活对象就被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC, Eden和S0中的存活对象会被复制送入第二块survivor space S1。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就被送到老年代中。</p><ul><li>为什么新生代内存需要有两个Sruvivor区：<ul><li>先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？<ul><li>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。你也许会问，执行时间长有什么坏处？频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度，更不要说某些连接会因为超时发生连接错误了。那我们来想想在没有Survivor的情况下，有没有什么解决办法，可以避免上述情况：</li></ul></li></ul></li></ul></li></ul><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>增加老年代空间</td><td>更多存活对象才能填满老年代。降低Full GC频率</td><td>随着老年代空间加大，一旦发生Full GC，执行所需要的时间更长</td></tr><tr><td>减少老年代空间</td><td>Full GC所需时间减少</td><td>老年代很快被存活对象填满，Full GC频率增加</td></tr></tbody></table><p>显而易见，没有Survivor的话，上述两种解决方案都不能从根本上解决问题。我们可以得到第一条结论：Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p><ul><li><p>设置两个Survivor区最大的好处就是解决了碎片化，下面我们来分析一下。为什么一个Survivor区不行？</p><ul><li>第一部分中，我们知道了必须设置Survivor区。假设现在只有一个survivor区，我们来模拟一下流程：<ul><li>刚刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，下一次Eden满了的时候，问题来了，此时进行Minor GC，Eden和Survivor各有一些存活对象，如果此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化。</li><li>那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。</li></ul></li><li>参考文章：<a href="https://blog.csdn.net/antony9118/article/details/51425581">为什么新生代内存需要有两个Survivor区</a></li></ul></li><li><p>老年代：如果某个对象经历了几次垃圾回收之后还存活，就会被存放到老年代中。老年代的空间一般比新生代大。</p></li><li><p>这个流程如下图所示：<br><img src="/blog/17/11.jpg" alt="GC流程"></p></li><li><p>什么时候回收？<br>Java并没有给我们提供明确的代码来标注一块内存并将其回收。或许你会说，我们可以将相关对象设为null或者用System.gc()。然而，后者将会严重影响代码的性能，因为每一次显示调用system.gc()都会停止所有响应，去检查内存中是否有可回收的对象，这会对程序的正常运行造成极大威胁。另外，调用该方法并不能保障JVM立即进行垃圾回收，仅仅是通知JVM要进行垃圾回收了，具体回收与否完全由JVM决定。</p></li><li><p>生存还是死亡</p><ul><li><p>可达性算法：这个算法的基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br><img src="/blog/17/12.png" alt="可达性算法"></p></li><li><p>二次标记：在可达性分析算法中被判断是对象不可达时不一定会被垃圾回收机制回收，因为要真正宣告一个对象的死亡，必须经历两次标记的过程。如果发现对象不可达时，将会进行第一次标记，此时如果该对象调用了finalize()方法，那么这个对象会被放置在一个叫F-Queue的队列之中，如果在此队列中该对象没有成功拯救自己（拯救自己的方法是该对象有没有被重新引用），那么GC就会对F-Queue队列中的对象进行小规模的第二次标记，一旦被第二次标记的对象，将会被移除队列并等待被GC回收，所以finalize()方法是对象逃脱死亡命运的最后一次机会。</p></li><li><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul></li></ul></li><li><p>GC的算法</p><ul><li><p>引用计数法（Reference Counting）：</p><ul><li>给对象添加一个引用计数器，每过一个引用计数器值就+1，少一个引用就-1。当它的引用变为0时，该对象就不能再被使用。它的实现简单，但是不能解决互相循环引用的问题。</li><li>优点：<ul><li>及时回收无效内存，实时性高。</li><li>垃圾回收过程中无需挂起。</li><li>没有全局扫描，性能高。</li></ul></li><li>缺点：<ul><li>对象创建时需要更新引用计数器，耗费一部分时间。</li><li>浪费CPU资源,计数器统计需要实时进行。</li><li>无法解决循环引用问题，即使对象无效仍不会被回收。</li></ul></li></ul></li><li><p>标记-清除(Mark-Sweep)算法：</p><ul><li>分为两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象（后续的垃圾回收算法都是基于此算法进行改进的）。</li><li>缺点：效率问题，标记和清除两个过程的效率都不高；空间问题，会产生很多碎片。<br><img src="/blog/17/13.jpg" alt="标记清除算法"></li></ul></li><li><p>复制算法：</p><ul><li>将可用内存按容量划分为大小相等的两块，每次只用其中一块。当这一块用完了，就将还存活的对象复制到另外一块上面，然后把原始空间全部回收。高效、简单。</li><li>缺点：将内存缩小为原来的一半。<br><img src="/blog/17/14.jpg" alt="复制算法"></li></ul></li><li><p>标记-整理(Mark-Compat)算法</p><ul><li>标记过程与标记-清除算法过程一样，但后面不是简单的清除，而是让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<br><img src="/blog/17/15.png" alt="标记整理算法"></li></ul></li><li><p>分代收集(Generational Collection)算法</p><ul><li>新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</li><li>老年代中，其存活率较高、没有额外空间对它进行分配担保，就应该使用“标记-整理”或“标记-清除”算法进行回收。</li></ul></li><li><p>增量回收GC和并行回收GC</p></li></ul></li><li><p>垃圾收集器</p><ul><li><p>Serial收集器：单线程收集器，表示在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。”Stop The World”。</p></li><li><p>ParNew收集器：实际就是Serial收集器的多线程版本。</p><ul><li>并发(Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并行(Concurrent):指用户线程与垃圾收集线程同时执行，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li></ul></li><li><p>Parallel Scavenge收集器：该收集器比较关注吞吐量(Throughout)(CPU用于用户代码的时间与CPU总消耗时间的比值)，保证吞吐量在一个可控的范围内。</p></li><li><p>CMS(Concurrent Mark Sweep)收集器：CMS收集器是一种以获取最短回收停顿时间为目标的垃圾收集器，是基于“标记——清除”算法实现的。</p><ul><li>其回收过程主要分为四个步骤：<ul><li>1）初始标记：标记一下GC Roots能直接关联到的对象，速度很快。</li><li>2）并发标记：进行GC Roots Tracing的过程，也就是标记不可达的对象，相对耗时。</li><li>3）重新标记：修正并发标记期间因用户程序继续运作导致的标记变动，速度比较快。</li><li>4）并发清除：对标记的对象进行统一回收处理，比较耗时。</li></ul></li><li>由于初始标记和重新标记速度比较快，其它工作线程停顿的时间几乎可以忽略不计，所以CMS的内存回收过程是与用户线程一起并发执行的。初始标记和重新标记两个步骤需要Stop the world；并发标记和并发清除两个步骤可与用户线程并发执行。“Stop the world”意思是垃圾收集器在进行垃圾回收时，会暂停其它所有工作线程，直到垃圾收集结束为止。</li><li>CMS的缺点：<ul><li>1）对CPU资源非常敏感；也就是说当CMS开启垃圾收集线程进行垃圾回收时，会占用部分用户线程，如果在CPU资源紧张的情况下，会导致用户程序的工作效率下降。</li><li>2）无法处理浮动垃圾导致又一次FULL GC的产生；由于CMS并发回收垃圾时用户线程同时也在运行，伴随用户线程的运行自然会有新的垃圾产生，这部分垃圾出现在标记过程之后，CMS无法在当次收集过程中进行回收，只能在下一次GC时在进行清除。所以在CMS运行期间要确保内存中有足够的预留空间用来存放用户线程的产生的浮动垃圾，不允许像其它收集器一样等到老年代区完全填满了之后再进行收集；那么当内存预留的空间不足时就会产生又一次的FULL GC来释放内存空间，由于是通过Serial Old收集器进行老年代的垃圾收集，所以导致停顿的时间变长了（系统有一个阈值来触发CMS收集器的启动，这个阈值不允许太高，太高反而导致性能降低）。</li><li>3）标记——清除算法会产生内存碎片；如果产生过多的内存碎片时，当系统虚拟机想要再分配大对象时，会找不到一块足够大的连续内存空间进行存储，不得不又一次触发FULL GC。</li></ul></li></ul></li><li><p>G1(Garbage First)收集器：G1收集器是一款成熟的商用的垃圾收集器，是基于“标记——整理”算法实现的。</p><ul><li>其回收过程主要分为四个步骤：<ul><li>1）初始标记：标记一下GC Roots能直接关联到的对象，速度很快。</li><li>2）并发标记：进行GC Roots Tracing的过程，也就是标记不可达的对象，相对耗时。</li><li>3）最终标记：修正并发标记期间因用户程序继续运作导致的标记变动，速度比较快。</li><li>4）筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</li></ul></li><li>G1收集器的特点：<ul><li>1）并发与并行：机型垃圾收集时可以与用户线程并发运行。</li><li>2）分代收集：能根据对象的存活时间采取不同的收集算法进行垃圾回收。</li><li>3）不会产生内存碎片：基于标记——整理算法和复制算法保证不会产生内存空间碎片。</li><li>4）可预测的停顿：G1除了追求低停顿时间外，还能建立可预测的停顿时间模型，便于用户的实时监控。</li></ul></li></ul></li><li><p>CMS收集器与G1收集器的区别：</p><ul><li>1）CMS采用标记——清除算法会产生空间碎片，G1采用标记——整理算法不会产生空间碎片。</li><li>2）G1可以建立可预测的停顿时间模型，而CMS则不能。</li></ul></li></ul></li><li><p>JDK 1.8 JVM的变化</p><ul><li>1、为什么取消方法区<ul><li>1）它在启动时固定大小，很难进行调优，并且FullGC时会移动类元信息。</li><li>2）类及方法的信息等比较难确定大小，因此对永久代的大小指定比较困难。</li><li>3）在某些场景下，如果动态加载类过多，容易造成Perm区的OOM。</li><li>4）字符串存在方法区中，容易出现性能问题和内存溢出。</li><li>5）永久代GC垃圾回收效率偏低。</li></ul></li><li>2、JDK 1.8里Perm区中的所有内容中字符串常量移至堆内存，其他内容如类元信息、字段、静态属性、方法、常量等都移动到元空间内。</li><li>2、元空间<ul><li>元空间（MetaSpace）不在堆内存上，而是直接占用的本地内存。因此元空间的大小仅受本地内存限制</li><li>也可通过参数来设定元空间的大小：<ul><li>-XX:MetaSpaceSize　　初始元空间大小</li><li>-XX:MaxMetaSpaceSize　　最大元空间大小</li></ul></li><li>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<ul><li>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。</li><li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。</li></ul></li><li>元空间的特点：<ul><li>1）每个加载器有专门的存储空间。</li><li>2）不会单独回收某个类。</li><li>3）元空间里的对象的位置是固定的。</li><li>4）如果发现某个加载器不再存货了，会把相关的空间整个回收。</li></ul></li></ul></li></ul></li><li><p>性能优化：</p><ul><li>减少new对象。每次new对象之后，都要开辟新的内存空间。这些对象不被引用之后，还要回收掉。因此，如果最大限度地合理重用对象，或者使用基本数据类型替代对象，都有助于节省内存。</li><li>多使用局部变量，减少使用静态变量。局部变量被创建在栈中，存取速度快。静态变量则是存储在堆内存中。</li><li>避免使用finalize，该方法会给GC增添很大的负担。</li><li>如果是单线程，尽量使用非多线程安全的，因为线程安全来自于同步机制，同步机制会降低性能。例如，单线程程序，能使用HashMap，就不要使用HashTabl。同理，尽量减少使用synchronized。</li><li>用移位符号替代乘除号。比如：a*8应该写作a&lt;&lt;3。</li><li>对于经常反复使用的对象使用缓存。</li><li>尽量使用基本类型而不是包装类型，尽量使用一维数组而不是二维数组。</li><li>尽量使用final修饰符，final表示不可修改，访问效率高。</li><li>单线程下(或者是针对于局部变量)，字符串尽量使用StringBuilder,比StringBuffer要快。</li><li>尽量使用StringBuffer来连接字符串。这里需要注意的是，StringBuffer的默认缓存容量是16个字符，如果超过16，append方法调用私有的expandCapacity()方法，来保证足够的缓存容量。因此，如果可以预设StringBuffer的容量，避免append再去扩展容量。</li></ul></li></ul><h3 id="AOP和IOC"><a href="#AOP和IOC" class="headerlink" title="AOP和IOC"></a>AOP和IOC</h3><ul><li><p>1、AOP</p><ul><li><p>涉及到一个重要的思想：代理，代理分为：</p><ul><li>静态代理</li><li>JDK动态代理</li><li>CGLib动态代理</li></ul></li><li><p>增强类型：前置增强、后置增强、环绕增强、抛出增强、引用增强<br><img src="/blog/17/16.png" alt="AOP"></p></li></ul></li></ul><table><thead><tr><th>增强类型</th><th>基于AOP接口</th><th>基于 @Aspect</th><th>基于 &lt;aop:config&gt;</th></tr></thead><tbody><tr><td>Before Advice（前置增强）</td><td>MethodBeforeAdvice</td><td>@Before</td><td>&lt;aop:before&gt;</td></tr><tr><td>AfterAdvice（后置增强）</td><td>AfterReturningAdvice</td><td>@After</td><td>&lt;aop:after&gt;</td></tr><tr><td>AroundAdvice（环绕增强）</td><td>MethodInterceptor</td><td>@Around</td><td>&lt;aop:around&gt;</td></tr><tr><td>ThrowsAdvice（抛出增强）</td><td>ThrowsAdvice</td><td>@AfterThrowing</td><td>&lt;aop:after-throwing&gt;</td></tr><tr><td>IntroductionAdvice（引入增强）</td><td>DelegatingIntroductionInterceptor</td><td>@DeclareParents</td><td>&lt;aop:declare-parents&gt;</td></tr></tbody></table><ul><li>2、IOC（利用了工厂模式）<ul><li>IOC(Inversion of Control)：其思想是反转资源获取的方向。传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源。而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式。</li></ul></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul><li>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</li><li>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</li><li>Java 反射主要提供以下功能：<ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li><li>在运行时调用任意一个对象的方法</li></ul></li><li>重点：是运行时而不是编译时</li></ul><h3 id="java自动装箱拆箱总结"><a href="#java自动装箱拆箱总结" class="headerlink" title="java自动装箱拆箱总结"></a>java自动装箱拆箱总结</h3><p>当基本类型包装类与基本类型值进行==运算时，包装类会自动拆箱。即比较的是基本类型值。</p><p>具体实现上，是调用了Integer.intValue()方法实现拆箱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">1</span>;</span><br><span class="line">Integer c = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">System.out.println(a == c); <span class="comment">//true</span></span><br><span class="line">System.out.println(c == b); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">会调用这个 Integer a = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">Integer已经默认创建了数值【-<span class="number">128</span>到<span class="number">127</span>】的Integer常量池</span><br><span class="line"></span><br><span class="line">Integer a = -<span class="number">128</span>;</span><br><span class="line">Integer b = -<span class="number">128</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer a = <span class="number">128</span>;</span><br><span class="line">Integer b = <span class="number">128</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java的数学计算是在内存栈里操作的</span><br><span class="line">c1 + c2 会进行拆箱，比较还是基本类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">Integer b1 = <span class="number">1000</span>;</span><br><span class="line">Integer c1 = <span class="keyword">new</span> Integer(<span class="number">1000</span>);</span><br><span class="line">Integer b2 = <span class="number">0</span>;</span><br><span class="line">Integer c2 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">System.out.println(b1 == b1 + b2); <span class="comment">//true</span></span><br><span class="line">System.out.println(c1 == c1 + c2); <span class="comment">//true</span></span><br><span class="line">System.out.println(b1 == b1 + a); <span class="comment">//true</span></span><br><span class="line">System.out.println(c1 == c1 + a); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：2019-09-16这是一个悲惨的日子，菜鸡啊杰在线丢人，笔试没做完，电面也不会，我太难了。&quot;&gt;&lt;a href=&quot;#摘要：2019-09-16这是一个悲惨的日子，菜鸡啊杰在线丢人，笔试没做完，电面也不会，我太难了。&quot; class=&quot;headerlink&quot; title=&quot;摘要：2019.09.16这是一个悲惨的日子，菜鸡啊杰在线丢人，笔试没做完，电面也不会，我太难了。&quot;&gt;&lt;/a&gt;摘要：2019.09.16这是一个悲惨的日子，菜鸡啊杰在线丢人，笔试没做完，电面也不会，我太难了。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：本篇文章主要是记录一下，今天面试过程中遇到的一些面试题，还有一些遗忘的知识点。&quot;&gt;&lt;a href=&quot;#前言：本篇文章主要是记录一下，今天面试过程中遇到的一些面试题，还有一些遗忘的知识点。&quot; class=&quot;headerlink&quot; title=&quot;前言：本篇文章主要是记录一下，今天面试过程中遇到的一些面试题，还有一些遗忘的知识点。&quot;&gt;&lt;/a&gt;前言：本篇文章主要是记录一下，今天面试过程中遇到的一些面试题，还有一些遗忘的知识点。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>python之操作Excel模块</title>
    <link href="https://www.blog.ajie39.top/2019/09/01/python%E4%B9%8B%E6%93%8D%E4%BD%9CExcel%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.blog.ajie39.top/2019/09/01/python%E4%B9%8B%E6%93%8D%E4%BD%9CExcel%E6%A8%A1%E5%9D%97/</id>
    <published>2019-09-01T07:02:14.249Z</published>
    <updated>2021-05-05T04:26:46.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：python操作Excel文件，第三方模块汇总。"><a href="#摘要：python操作Excel文件，第三方模块汇总。" class="headerlink" title="摘要：python操作Excel文件，第三方模块汇总。"></a>摘要：python操作Excel文件，第三方模块汇总。</h1><hr><h1 id="前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。"><a href="#前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。" class="headerlink" title="前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。"></a>前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。</h1><hr><span id="more"></span><h2 id="常见库简介"><a href="#常见库简介" class="headerlink" title="常见库简介"></a>常见库简介</h2><h3 id="1-xlrd"><a href="#1-xlrd" class="headerlink" title="1.xlrd"></a>1.xlrd</h3><p>xlrd是一个从Excel文件读取数据和格式化信息的库，支持.xls以及.xlsx文件。<br><a href="http://xlrd.readthedocs.io/en/latest/">http://xlrd.readthedocs.io/en/latest/</a><br>    1、xlrd支持.xls，.xlsx文件的读<br>    2、通过设置on_demand变量使open_workbook()函数只加载那些需要的sheet，从而节省时间和内存（该方法对.xlsx文件无效）。<br>    3、xlrd.Book对象有一个unload_sheet方法，它将从内存中卸载工作表，由工作表索引或工作表名称指定（该方法对.xlsx文件无效）</p><h3 id="2-xlwt"><a href="#2-xlwt" class="headerlink" title="2.xlwt"></a>2.xlwt</h3><p>xlwt是一个用于将数据和格式化信息写入旧Excel文件的库（如.xls）。<br><a href="https://xlwt.readthedocs.io/en/latest/">https://xlwt.readthedocs.io/en/latest/</a><br>    1、xlwt支持.xls文件写。</p><h3 id="3-xlutils"><a href="#3-xlutils" class="headerlink" title="3.xlutils"></a>3.xlutils</h3><p>xlutils是一个处理Excel文件的库，依赖于xlrd和xlwt。<br><a href="http://xlutils.readthedocs.io/en/latest/">http://xlutils.readthedocs.io/en/latest/</a><br>    1、xlutils支持.xls文件。<br>    2、支持Excel操作。</p><h3 id="4-xlwings"><a href="#4-xlwings" class="headerlink" title="4.xlwings"></a>4.xlwings</h3><p>xlwings是一个可以实现从Excel调用Python，也可在python中调用Excel的库。<br><a href="http://docs.xlwings.org/en/stable/index.html">http://docs.xlwings.org/en/stable/index.html</a><br>    1、xlwings支持.xls读，支持.xlsx文件读写。<br>    2、支持Excel操作。<br>    3、支持VBA。<br>    4、强大的转换器可以处理大部分数据类型，包括在两个方向上的numpy array和pandas DataFrame。</p><h3 id="5-openpyxl"><a href="#5-openpyxl" class="headerlink" title="5.openpyxl"></a>5.openpyxl</h3><p>openpyxl是一个用于读取和编写Excel 2010 xlsx/xlsm/xltx/xltm文件的库。<br><a href="https://openpyxl.readthedocs.io/en/stable/">https://openpyxl.readthedocs.io/en/stable/</a><br>    1、openpyxl支持.xlsx文件的读写。<br>    2、支持Excel操作。<br>    3、加载大.xlsx文件可以使用read_only模式。<br>    4、写入大.xlsx文件可以使用write_only模式。</p><h3 id="6-xlsxwriter"><a href="#6-xlsxwriter" class="headerlink" title="6.xlsxwriter"></a>6.xlsxwriter</h3><p>xlsxwriter是一个用于创建Excel .xlsx文件的库。<br><a href="https://xlsxwriter.readthedocs.io/">https://xlsxwriter.readthedocs.io/</a><br>    1、xlswriter支持.xlsx文件的写。<br>    2、支持VBA。<br>    3、写入大.xlsx文件时使用内存优化模式。</p><h3 id="7-win32com"><a href="#7-win32com" class="headerlink" title="7.win32com"></a>7.win32com</h3><p>win32com库存在于pywin32中，是一个读写和处理Excel文件的库。<br><a href="http://pythonexcels.com/python-excel-mini-cookbook/">http://pythonexcels.com/python-excel-mini-cookbook/</a><br>    1、win32com支持.xls，.xlsx文件的读写，支持.xlsx文件的写。<br>    2、支持Excel操作。</p><h3 id="8-DataNitro"><a href="#8-DataNitro" class="headerlink" title="8.DataNitro"></a>8.DataNitro</h3><p>DataNitro是一个内嵌在Excel中的插件。<br><a href="https://datanitro.com/docs/">https://datanitro.com/docs/</a> <br>    1、DataNitro支持.xls，.xlsx文件的读写。<br>    2、支持Excel操作。<br>    3、支持VBA。<br>    4、收费</p><h3 id="9-pandas"><a href="#9-pandas" class="headerlink" title="9.pandas"></a>9.pandas</h3><p>pandas通过对Excel文件的读写实现数据输入输出<br><a href="http://pandas.pydata.org/">http://pandas.pydata.org/</a><br>    1、pandas支持.xls，.xlsx文件的读写。<br>    2、支持只加载每个表的单一工作页。</p><table><thead><tr><th></th><th>win</th><th>MAC</th><th>Py2</th><th>Py3</th><th>.xls</th><th>.xlsx</th><th>读</th><th>写</th><th>修改</th></tr></thead><tbody><tr><td>xlrd</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td></tr><tr><td>xlwt</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>xlutils</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td><td>&chi;</td><td>&radic;</td></tr><tr><td>xlwings</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>openpyxl</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>xlswriter</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&chi;</td></tr><tr><td>win32com</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>DataNitro</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr><tr><td>pandas</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td></tr></tbody></table><h3 id="提醒及注意："><a href="#提醒及注意：" class="headerlink" title="提醒及注意："></a>提醒及注意：</h3><p>xlutils 仅支持 xls 文件，即2003以下版本；<br>win32com 与 DataNitro 仅支持 windows 系统；<br>xlwings 安装成功后，如果运行提示报错“ImportError: no module named win32api”，请再安装 pypiwin32 或者 pywin32 包；<br>win32com 不是独立的扩展库，而是集成在其他库中，安装 pypiwin32 或者 pywin32 包即可使用；<br>DataNitro 是 Excel 的插件，安装需到官网下载。</p><h2 id="基本功能："><a href="#基本功能：" class="headerlink" title="基本功能："></a>基本功能：</h2><p>由于设计目的不同，每个模块通常着重于某一方面功能，各有所长。</p><h3 id="1-xlwings"><a href="#1-xlwings" class="headerlink" title="1.xlwings"></a>1.xlwings</h3><p>可结合 VBA 实现对 Excel 编程，强大的数据输入分析能力，同时拥有丰富的接口，结合 pandas/numpy/matplotlib 轻松应对 Excel 数据处理工作。</p><h3 id="2-openpyxl"><a href="#2-openpyxl" class="headerlink" title="2.openpyxl"></a>2.openpyxl</h3><p>简单易用，功能广泛，单元格格式/图片/表格/公式/筛选/批注/文件保护等等功能应有尽有，图表功能是其一大亮点，缺点是对 VBA 支持的不够好。</p><h3 id="3-pandas"><a href="#3-pandas" class="headerlink" title="3.pandas"></a>3.pandas</h3><p>数据处理是 pandas 的立身之本，Excel 作为 pandas 输入/输出数据的容器。</p><h3 id="4-win32com"><a href="#4-win32com" class="headerlink" title="4.win32com"></a>4.win32com</h3><p>从命名上就可以看出，这是一个处理 windows 应用的扩展，Excel 只是该库能实现的一小部分功能。该库还支持 office 的众多操作。需要注意的是，该库不单独存在，可通过安装 pypiwin32 或者 pywin32 获取。</p><h3 id="5-xlsxwriter"><a href="#5-xlsxwriter" class="headerlink" title="5.xlsxwriter"></a>5.xlsxwriter</h3><p>拥有丰富的特性，支持图片/表格/图表/筛选/格式/公式等，功能与openpyxl相似，优点是相比 openpyxl 还支持 VBA 文件导入，迷你图等功能，缺点是不能打开/修改已有文件，意味着使用 xlsxwriter 需要从零开始。</p><h3 id="6-DataNitro"><a href="#6-DataNitro" class="headerlink" title="6.DataNitro"></a>6.DataNitro</h3><p>作为插件内嵌到 Excel 中，可完全替代 VBA，在 Excel 中使用 python 脚本。既然被称为 Excel 中的 python，协同其他 python 库亦是小事一桩。然而，这是付费插件…</p><h3 id="7-xlutils"><a href="#7-xlutils" class="headerlink" title="7.xlutils"></a>7.xlutils</h3><p>基于 xlrd/xlwt，老牌 python 包，算是该领域的先驱，功能特点中规中矩，比较大的缺点是仅支持 xls 文件。</p><h2 id="读写测试"><a href="#读写测试" class="headerlink" title="读写测试"></a>读写测试</h2><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>用例1. 读.xls文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例2. 读.xlsx文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例3. 读.xls文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例4. 读.xlsx文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例5. 写.xls文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例6. 写.xlsx文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例7. 写.xls文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例8. 写.xlsx文件的整个表（表有1个分页，页有2000行1200列的整数）。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th>测试模块</th><th>用例1</th><th>用例2</th><th>用例3</th><th>用例4</th><th>用例5</th><th>用例6</th><th>用例7</th><th>用例8</th></tr></thead><tbody><tr><td>xlrd</td><td>5.77</td><td>98.06</td><td>1.28</td><td>19.72</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td></td></tr><tr><td>xlwt</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>20.33</td><td>&mdash;</td><td>4.06</td><td>&mdash;</td></tr><tr><td>xlwings</td><td>1.57</td><td>11.91</td><td>2.01</td><td>3.09</td><td>&mdash;</td><td>44.00</td><td>&mdash;</td><td>9.30</td></tr><tr><td>openpyxl</td><td>&mdash;</td><td>321.70/0.01</td><td>&mdash;</td><td>42.42/0.01</td><td>&mdash;</td><td>2109.93/135.5</td><td>&mdash;</td><td>31.84/25.0</td></tr><tr><td>xlsxwriter</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>152.28</td><td>&mdash;</td><td>24.09</td></tr><tr><td>win32com</td><td>0.37</td><td>10.16</td><td>0.36</td><td>2.26</td><td>&mdash;</td><td>32.48</td><td>&mdash;</td><td>26.78</td></tr><tr><td>pandas</td><td>32.34</td><td>553.15</td><td>1.82</td><td>22.42</td><td>34.66</td><td>40.43</td><td>6.92</td><td>8.02</td></tr></tbody></table><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>1.xlwt和pandas每个工作页最多写入256列，因此测试用例修改为每页有2000行256列的整数.<br>2.xlutils读写依赖于xlrd和xlwt，不单独测试。<br>3.openpyxl测试两种模式，一是普通加载写入，二是read_only/write_only模式下的加载写入。<br>4.DataNitro要收费，且需依托Excel使用，本次不测试。</p><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>  单从读写的性能上考虑，win32com的性能是最好的，xlwings其次。</p><p>  openpyxl虽然操作Excel的功能强大，但读写性能过于糟糕，尤其是写大表时，会占用大量内存（把我的4G内存用完了），开启read_only和write_only模式后对其性能有大幅提升，尤其是对读的性能提升很大，使其几乎不耗时（0.01秒有点夸张，不过确实是加载上了）。pandas把Excel当作数据读写的容器，为其强大的数据分析服务，因此读写性能表现中规中矩，但其对Excel文件兼容性是最好的，支持读写.xls，.xlsx文件，且支持只读表中单一工作页。同样支持此功能的库还有xlrd，但xlrd只支持读，并不支持写，且性能不突出，需要配合xlutils进行Excel操作，并使用xlwt保存数据，而xlwt只能写入.xls文件（另一个可以写入.xls文件的库是pandas，且这两个写入的Excel文件最多只能有256列，其余库就我目前的了解均只能写入.xlsx文件），性能一般。xlsxwriter功能单一，一般用来创建.xlsx文件，写入性能中庸。win32com拥有最棒的读写性能，但该库存在于pywin32的库中，自身没有完善的文档，使用略吃力。xlwings拥有和win32com不相伯仲的读写性能，强大的转换器可以处理大部分数据类型，包括二维的numpy array和pandas DataFrame，可以轻松搞定数据分析的工作。</p><p>  综合考虑，xlwings的表现最佳，正如其名，xlwings——Make Excel Fly！</p><h3 id="便捷性比较"><a href="#便捷性比较" class="headerlink" title="便捷性比较"></a>便捷性比较</h3><p>    本测试目前只是针对Excel文件的读写，并未涉及Excel操作，单从读写的便捷性来讲，各库的表现难分上下，但是win32com和xlwings这两个库可以在程序运行时实时在打开的Excel文件中进行操作，实现过程的可视化，其次xlwings的数据结构转换器使其可以快速的为Excel文件添加二维数据结构而不需要在Excel文件中重定位数据的行和列，因此从读写的便捷性来比较，仍是xlwings胜出。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>最后，附上一些演示代码，大家可自行体会下不同模块的使用。</p><h3 id="6-1-xlwings基本代码"><a href="#6-1-xlwings基本代码" class="headerlink" title="6.1 xlwings基本代码"></a>6.1 xlwings基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment">#连接到excel</span></span><br><span class="line">workbook = xw.Book(<span class="string">r&#x27;path/myexcel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">#连接到指定单元格</span></span><br><span class="line">data_range = workbook.sheets(<span class="string">&#x27;Sheet1&#x27;</span>).<span class="built_in">range</span>(<span class="string">&#x27;A1&#x27;</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">data_range.value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">workbook.save()</span><br></pre></td></tr></table></figure><h3 id="6-2-xlsxwriter基本代码"><a href="#6-2-xlsxwriter基本代码" class="headerlink" title="6.2 xlsxwriter基本代码"></a>6.2 xlsxwriter基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlsxwriter <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment">#新建excel</span></span><br><span class="line">workbook  = xw.Workbook(<span class="string">&#x27;myexcel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">#新建工作薄</span></span><br><span class="line">worksheet = workbook.add_worksheet()</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">worksheet.write(<span class="string">&#x27;A1&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#关闭保存</span></span><br><span class="line">workbook.close()</span><br></pre></td></tr></table></figure><h3 id="6-3-xlutils基本代码import-xlrd-读取数据"><a href="#6-3-xlutils基本代码import-xlrd-读取数据" class="headerlink" title="6.3 xlutils基本代码import xlrd #读取数据"></a>6.3 xlutils基本代码import xlrd #读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt <span class="comment">#写入数据</span></span><br><span class="line"><span class="keyword">import</span> xlutils <span class="comment">#操作excel</span></span><br><span class="line"><span class="comment">#----xlrd库</span></span><br><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#获取表单</span></span><br><span class="line">worksheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">data = worksheet.cell_value(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#----xlwt库</span></span><br><span class="line"><span class="comment">#新建excel</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"><span class="comment">#添加工作薄</span></span><br><span class="line">sh = wb.add_sheet(<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">sh.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">wb.save(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#----xlutils库</span></span><br><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">book = xlrd.open_workbook(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#复制一份</span></span><br><span class="line">new_book = xlutils.copy(book)</span><br><span class="line"><span class="comment">#拿到工作薄</span></span><br><span class="line">worksheet = new_book.getsheet(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">worksheet.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;new data&#x27;</span>)</span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">new_book.save()</span><br></pre></td></tr></table></figure><h3 id="6-4-win32com基本代码"><a href="#6-4-win32com基本代码" class="headerlink" title="6.4 win32com基本代码"></a>6.4 win32com基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32com.client <span class="keyword">as</span> wc</span><br><span class="line"><span class="comment">#启动Excel应用</span></span><br><span class="line">excel_app = wc.Dispatch(<span class="string">&#x27;Excel.Application&#x27;</span>)</span><br><span class="line"><span class="comment">#连接excel</span></span><br><span class="line">workbook = excel_app.Workbooks.Open(<span class="string">r&#x27;e:/myexcel.xlsx&#x27;</span> )</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">workbook.Worksheets(<span class="string">&#x27;Sheet1&#x27;</span>).Cells(<span class="number">1</span>,<span class="number">1</span>).Value = <span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment">#关闭并保存</span></span><br><span class="line">workbook.SaveAs(<span class="string">&#x27;newexcel.xlsx&#x27;</span>)</span><br><span class="line">excel_app.Application.Quit()</span><br></pre></td></tr></table></figure><h3 id="6-5-openpyxl基本代码"><a href="#6-5-openpyxl基本代码" class="headerlink" title="6.5 openpyxl基本代码"></a>6.5 openpyxl基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">workbook = openpyxl.Workbook()</span><br><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">sheet = workbook.activesheet[<span class="string">&#x27;A1&#x27;</span>]=<span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">workbook.save(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-6-DataNitro基本代码"><a href="#6-6-DataNitro基本代码" class="headerlink" title="6.6 DataNitro基本代码"></a>6.6 DataNitro基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单一单元格赋值</span></span><br><span class="line">Cell(<span class="string">&#x27;A1&#x27;</span>).value = <span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment">#单元区域赋值</span></span><br><span class="line">CellRange(<span class="string">&#x27;A1:B2&#x27;</span>).value = <span class="string">&#x27;data&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="openpyxl具体使用"><a href="#openpyxl具体使用" class="headerlink" title="openpyxl具体使用"></a>openpyxl具体使用</h3><h4 id="1、-创建一个excel-文件，并写入不同类的内容"><a href="#1、-创建一个excel-文件，并写入不同类的内容" class="headerlink" title="1、 创建一个excel 文件，并写入不同类的内容"></a>1、 创建一个excel 文件，并写入不同类的内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件对象</span></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 获取第一个sheet</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第1行第A列，写入数字23333</span></span><br><span class="line">ws[<span class="string">&#x27;A1&#x27;</span>] = <span class="number">23333</span></span><br><span class="line"><span class="comment"># 写入中文（unicode中文也可以）</span></span><br><span class="line">ws[<span class="string">&#x27;B1&#x27;</span>] = <span class="string">&quot;你好！&quot;</span>+<span class="string">&quot;欢迎使用openpyxl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在下一行，写入多个单元格</span></span><br><span class="line">ws.append([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入一个当前时间</span></span><br><span class="line">ws[<span class="string">&#x27;A2&#x27;</span>] = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入一个自定义的时间格式</span></span><br><span class="line">ws[<span class="string">&#x27;A3&#x27;</span>] = time.strftime(<span class="string">&#x27;%Y&#123;y&#125;%m&#123;m&#125;%d&#123;d&#125;%H&#123;h&#125;%M&#123;f&#125;%S&#123;s&#125;&#x27;</span>, time.localtime()).<span class="built_in">format</span>(y=<span class="string">&#x27;年&#x27;</span>, m=<span class="string">&#x27;月&#x27;</span>, d=<span class="string">&#x27;日&#x27;</span>, h=<span class="string">&#x27;时&#x27;</span>, f=<span class="string">&#x27;分&#x27;</span>, s=<span class="string">&#x27;秒&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件，注意文件覆盖</span></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br><span class="line"><span class="comment"># 关闭流</span></span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="2、创建sheet"><a href="#2、创建sheet" class="headerlink" title="2、创建sheet"></a>2、创建sheet</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># 设定一个sheet的名字</span></span><br><span class="line">ws1.title = <span class="string">&quot;sheet1 Title&quot;</span></span><br><span class="line"><span class="comment"># 设定sheet的插入位置 默认插在后面</span></span><br><span class="line">ws2 = wb.create_sheet(<span class="string">&quot;Mysheet&quot;</span>, <span class="number">0</span>)</span><br><span class="line">ws2.title = <span class="string">&quot;Mysheet&quot;</span></span><br><span class="line"><span class="comment"># 设定sheet的标签的背景颜色</span></span><br><span class="line">ws1.sheet_properties.tabColor = <span class="string">&quot;1072BA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个sheet对象</span></span><br><span class="line"><span class="built_in">print</span>(wb[<span class="string">&quot;sheet1 Title&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(wb[<span class="string">&quot;Mysheet&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取全部sheet的名字，遍历sheet名字</span></span><br><span class="line"><span class="built_in">print</span>(wb.sheetnames)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> wb.sheetnames:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> wb:</span><br><span class="line">    <span class="built_in">print</span>(sheet.title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将sheet1中的A1单元格赋值为zeke</span></span><br><span class="line">wb[<span class="string">&quot;sheet1 Title&quot;</span> ][<span class="string">&quot;A1&quot;</span>] = <span class="string">&quot;zeke&quot;</span></span><br><span class="line"><span class="comment"># 复制一个sheet</span></span><br><span class="line">source = wb[<span class="string">&quot;sheet1 Title&quot;</span>]</span><br><span class="line">target = wb.copy_worksheet(source)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test2.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="3、操作单元格"><a href="#3、操作单元格" class="headerlink" title="3、操作单元格"></a>3、操作单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;Sheet1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将A1单元格赋值为123.11</span></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">123.11</span></span><br><span class="line"><span class="comment"># 将B2单元格赋值为你好</span></span><br><span class="line">ws1[<span class="string">&quot;B2&quot;</span>] = <span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="comment"># 将第4行第2列的单元赋值为10</span></span><br><span class="line">temp = ws1.cell(row=<span class="number">4</span>, column=<span class="number">2</span>, value=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A1&quot;</span>].value)</span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;B2&quot;</span>].value)</span><br><span class="line"><span class="built_in">print</span>(temp.value)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test3.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="4、操作已存在的文件"><a href="#4、操作已存在的文件" class="headerlink" title="4、操作已存在的文件"></a>4、操作已存在的文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开test5.xlsx文件</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test5.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 猜测格式类型</span></span><br><span class="line">wb.guess_types = <span class="literal">True</span></span><br><span class="line">ws = wb.active</span><br><span class="line">ws[<span class="string">&quot;A1&quot;</span>] = <span class="string">&quot;12%&quot;</span></span><br><span class="line"><span class="built_in">print</span>(ws[<span class="string">&quot;A1&quot;</span>].value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意如果原文件有一些图片或者图标，则保存的时候可能会导致图片丢失</span></span><br><span class="line">wb.save(<span class="string">&quot;test5.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="5、操作批量的单元格"><a href="#5、操作批量的单元格" class="headerlink" title="5、操作批量的单元格"></a>5、操作批量的单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;Sheet&quot;</span>)</span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">1</span></span><br><span class="line">ws1[<span class="string">&quot;A2&quot;</span>] = <span class="number">2</span></span><br><span class="line">ws1[<span class="string">&quot;A3&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;B1&quot;</span>] = <span class="number">4</span></span><br><span class="line">ws1[<span class="string">&quot;B2&quot;</span>] = <span class="number">5</span></span><br><span class="line">ws1[<span class="string">&quot;B3&quot;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;C1&quot;</span>] = <span class="number">7</span></span><br><span class="line">ws1[<span class="string">&quot;C2&quot;</span>] = <span class="number">8</span></span><br><span class="line">ws1[<span class="string">&quot;C3&quot;</span>] = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作单列</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> ws1[<span class="string">&quot;A&quot;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从A列到C列,获取每一个值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A:C&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> ws1[<span class="string">&quot;A:C&quot;</span>]:</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> column:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第1行到第3行，获取每一个值</span></span><br><span class="line">row_range = ws1[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(row_range)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> row_range:</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第1行到第3行，从第1列到第3列</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws1.iter_rows(min_row=<span class="number">1</span>, min_col=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有行</span></span><br><span class="line"><span class="built_in">print</span>(ws1.rows)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws1.rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有列</span></span><br><span class="line"><span class="built_in">print</span>(ws1.columns)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ws1.columns:</span><br><span class="line">    <span class="built_in">print</span>(col)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test4.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="6、获取所有的行-列-对象："><a href="#6、获取所有的行-列-对象：" class="headerlink" title="6、获取所有的行(列)对象："></a>6、获取所有的行(列)对象：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开test5.xlsx文件</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test5.xlsx&#x27;</span>)</span><br><span class="line">ws = wb.active</span><br><span class="line">rows = []</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows():</span><br><span class="line">    rows.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有行</span></span><br><span class="line"><span class="built_in">print</span>(rows)</span><br><span class="line"><span class="comment"># 获取第一行</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一行第一列的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一行第一列的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>][<span class="number">0</span>].value)</span><br><span class="line"><span class="comment"># 获取最后行 print rows[-1]</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取第后一行和最后一列的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>][<span class="built_in">len</span>(rows[<span class="number">0</span>]) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取第后一行和最后一列的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>][<span class="built_in">len</span>(rows[<span class="number">0</span>]) - <span class="number">1</span>].value)</span><br><span class="line"></span><br><span class="line">cols = []</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ws.iter_cols():</span><br><span class="line">    cols.append(col)</span><br><span class="line"><span class="comment"># 所有列</span></span><br><span class="line"><span class="built_in">print</span>(cols)</span><br><span class="line"><span class="comment"># 获取第一列</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一列的第一行的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一列的第一行的值</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>][<span class="number">0</span>].value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 获取最后一列</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>] )</span><br><span class="line"><span class="comment"># 获取最后一列的最后一行的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>][<span class="built_in">len</span>(cols[<span class="number">0</span>]) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取最后一列的最后一行的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>][<span class="built_in">len</span>(cols[<span class="number">0</span>]) - <span class="number">1</span>].value)</span><br><span class="line"></span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="7、使用公式"><a href="#7、使用公式" class="headerlink" title="7、使用公式"></a>7、使用公式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br><span class="line">ws1 = wb.active</span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">1</span></span><br><span class="line">ws1[<span class="string">&quot;A2&quot;</span>] = <span class="number">2</span></span><br><span class="line">ws1[<span class="string">&quot;A3&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A4&quot;</span>] = <span class="string">&quot;=SUM(1, 1)&quot;</span></span><br><span class="line">ws1[<span class="string">&quot;A5&quot;</span>] = <span class="string">&quot;=SUM(A1:A3)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印的是公式内容，不是公式计算后的值,程序无法取到计算后的值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A4&quot;</span>].value)</span><br><span class="line"><span class="comment"># 打印的是公式内容，不是公式计算后的值,程序无法取到计算后的值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A5&quot;</span>].value)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="8、合并单元格"><a href="#8、合并单元格" class="headerlink" title="8、合并单元格"></a>8、合并单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line">ws.merge_cells(<span class="string">&#x27;A2:D2&#x27;</span>)</span><br><span class="line"><span class="comment"># 合并后的单元格，脚本单独执行拆分操作会报错，需要重新执行合并操作再拆分</span></span><br><span class="line">ws.unmerge_cells(<span class="string">&#x27;A2:D2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ws.merge_cells(start_row=<span class="number">2</span>, start_column=<span class="number">1</span>, end_row=<span class="number">2</span>, end_column=<span class="number">4</span>)</span><br><span class="line">ws.unmerge_cells(start_row=<span class="number">2</span>, start_column=<span class="number">1</span>, end_row=<span class="number">2</span>, end_column=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/zeke-python-road/p/8986318.html">https://www.cnblogs.com/zeke-python-road/p/8986318.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：python操作Excel文件，第三方模块汇总。&quot;&gt;&lt;a href=&quot;#摘要：python操作Excel文件，第三方模块汇总。&quot; class=&quot;headerlink&quot; title=&quot;摘要：python操作Excel文件，第三方模块汇总。&quot;&gt;&lt;/a&gt;摘要：python操作Excel文件，第三方模块汇总。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot;&gt;&lt;a href=&quot;#前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot; class=&quot;headerlink&quot; title=&quot;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot;&gt;&lt;/a&gt;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/categories/python/"/>
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis笔记</title>
    <link href="https://www.blog.ajie39.top/2019/05/20/Mybatis%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.blog.ajie39.top/2019/05/20/Mybatis%E7%AC%94%E8%AE%B0/</id>
    <published>2019-05-20T01:23:01.955Z</published>
    <updated>2021-05-05T04:26:26.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：Mybatis笔记"><a href="#摘要：Mybatis笔记" class="headerlink" title="摘要：Mybatis笔记"></a>摘要：Mybatis笔记</h1><hr><h1 id="前言：对这段时间学习mybatis的一些记录。"><a href="#前言：对这段时间学习mybatis的一些记录。" class="headerlink" title="前言：对这段时间学习mybatis的一些记录。"></a>前言：对这段时间学习mybatis的一些记录。</h1><hr><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="http://www.mybatis.org/mybatis-3/zh/index.html">官方文档</a></p><p><a href="https://github.com/mybatis/mybatis-3">Github开源地址</a></p><p><a href="https://blog.mybatis.org/">版本更新介绍</a></p><h2 id="Mybatis的编程步骤"><a href="#Mybatis的编程步骤" class="headerlink" title="Mybatis的编程步骤"></a>Mybatis的编程步骤</h2><ol><li>获取全局配置文件路径</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">&quot;conf/mybatis-config.xml&quot;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>读取配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br></pre></td></tr></table></figure><ol start="3"><li>创建SqlSessionFactoryBuilder,通过SqlsesionFactoryBuilder创建sqlSessionFactory</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory =</span><br><span class="line">        <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><ol start="4"><li>通过SqlSessionFactory创建sqlSession</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure><ol start="5"><li>通过sqlSession执行数据库操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用sqlSession对象来执行增删改查,例如：</span><br><span class="line"><span class="comment">//获取接口类</span></span><br><span class="line">EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line"><span class="comment">//mapper接口没有实现类，但是将接口和xml进行绑定后，mybatis会为这个接口生成一个代理对象。</span></span><br><span class="line"><span class="comment">//调用方法，将获取的结果赋值给引用</span></span><br><span class="line">Employee employee = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//打印员工</span></span><br><span class="line">System.out.println(employee.toString());</span><br></pre></td></tr></table></figure><ol start="6"><li>调用session.commit()提交事务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.commit();</span><br></pre></td></tr></table></figure><ol start="7"><li>调用session.close()关闭会话</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>SqlSession代表和数据库的一次会话，用完必须关闭。</li><li>SqlSession和connection一样都是非线程安全的。每次使用都应该去获取新的对象，不要放在成员变量中。</li><li>mapper接口没有实现类，但是将接口和xml进行绑定后，mybatis会为这个接口生成一个代理对象。</li><li>两个重要的配置文件：<ul><li>mybatis的全局配置文件（mybatis-config.xml）：包含数据库连接池信息，事务管理器等，系统运行环境信息。</li><li>sql映射文件（***Mapper.xml）：保存了每个sql语句的映射信息。将sql抽取出来。</li></ul></li></ol><h2 id="全局配置文件常用标签（mybatis-config-xml）"><a href="#全局配置文件常用标签（mybatis-config-xml）" class="headerlink" title="全局配置文件常用标签（mybatis-config.xml）"></a>全局配置文件常用标签（mybatis-config.xml）</h2><p>configuration（配置）</p><ul><li>properties（属性）</li><li>settings（设置）</li><li>typeAliases（类型别名）</li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂）</li><li>plugins（插件）</li><li>environments（环境配置）<ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li>databaseIdProvider（数据库厂商标识）</li><li>mappers（映射器）</li></ul><h3 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h3><p>mybatis可以使用properties来引用外部的properties配置文件的内容：</p><ul><li>resource：引入类路径下的资源。</li><li>url：引入网络路径或者磁盘路径下的资源。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;application.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="setting标签"><a href="#setting标签" class="headerlink" title="setting标签"></a>setting标签</h3><p>setting包含很多重要的设置项：</p><ul><li>setting:用来设置每一个设置项</li><li>name：设置项名</li><li>value：设置项取值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启字段名驼峰命名规则--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">其他的后续补充</span><br></pre></td></tr></table></figure><h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><p>typeAliases：别名处理器，可以为我们的java类型起别名，别名不区分大小写</p><ol><li>typeAlias:为某个java类型起别名<ul><li>type：指定要起别名的类型全类名，默认别名就是类名小写。</li><li>alias：指定新的别名。</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;top.ajie.mybatisDemo.bean.Employee&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;emp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>package：为某个包下的所有类批量起别名<ul><li>name：指定包名（为当前包以及下面所有的后代包的每一个类都起一个默认别名（类名小写））</li><li>批量起别名的情况下，使用@Alias注解为某个类型指定新的别名。</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;top.ajie.mybatisDemo.bean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="environments标签"><a href="#environments标签" class="headerlink" title="environments标签"></a>environments标签</h3><p>environments：mybatis可以配置多种环境，default指定使用某种环境，可以达到快速切换环境。</p><ul><li>environment：配置一个具体的环境<ul><li>必须有transactionManager和dataSource标签。</li><li>transactionManager：事务管理器<ul><li>type：事务管理器类型：JDBC（JdbcTransactionFactory.class）或 MANAGED（ManagedTransactionFactory.class）</li><li>自定义事务管理器：实现TransactionFactory接口，type指定为全类名</li></ul></li><li>dataSource：数据源<ul><li>type：数据源类型：<ul><li>UNPOOLED（不使用连接池 UnpooledDataSourceFactory.class）</li><li>POOLED（使用连接池PooledDataSourceFactory.class）</li><li>JNDI（JndiDataSourceFactory.class）</li></ul></li><li>自定义数据源：实现DataSourceFactory接口，type是全类名</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;oracle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;orcl.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;orcl.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;orcl.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;orcl.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="databaseIdProvider标签"><a href="#databaseIdProvider标签" class="headerlink" title="databaseIdProvider标签"></a>databaseIdProvider标签</h3><p>databaseIdProvider支持多数据库厂商的，type=”DB_VENDOR”（VendorDatabaseIdProvider），作用就是得到数据库厂商的标识（getDatabassProductName()），mybatis就能根据数据库厂商标识来执行不同的sql，例如：MsySQL、Oracle、SQL Server、***等标识。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为不同的数据库厂商起别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Oracle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h3><p>将我们写好的sql映射文件一定要注册到全局配置文件中。</p><ul><li>sql映射文件:****Mapper.xml</li><li>全局配置文件:mybatis-config.xml</li></ul><p>mappers：将sql映射注册到全局配置中。</p><ul><li>mapper：注册一个sql映射。<ul><li>resource：引用类路径下的sql映射文件。</li><li>url：引用网络路径或者磁盘路径下的sql映射文件。</li><li>注册接口：class：引用（注册）接口：<ul><li>有sql映射文件，映射文件名必须和接口同名，并且放在与接口同一目录下。</li><li>没有sql映射文件，所有的sql都是利用注解写在接口上。</li><li>推荐：<ul><li>比较重要的、复杂的Dao接口，我们来写sql映射文件。</li><li>不重要的、简单的Dao接口为了开发快速可以使用注解。</li></ul></li></ul></li><li>批量注册：package</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- url --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span>--&gt;</span><br><span class="line"><span class="comment">&lt;!-- resource --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;conf/mapper/EmployeeMapper.xml&quot;</span>/&gt;</span>--&gt;</span><br><span class="line"><span class="comment">&lt;!-- class --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;top.ajie.mybatisDemo.top.EmployeeMapeerAnnotation&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--批量注册：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;top.ajie.mybatisDemo.dao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="properties文件"><a href="#properties文件" class="headerlink" title="properties文件"></a>properties文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver &#x3D; com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?serverTimezone&#x3D;UTC</span><br><span class="line">jdbc.username &#x3D;</span><br><span class="line">jdbc.password &#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">orcl.driver &#x3D; oracle.jdbc.driver.OracleDriver</span><br><span class="line">orcl.url &#x3D; jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class="line">orcl.username &#x3D;</span><br><span class="line">orcl.password &#x3D;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="xxxMapper-xml文件"><a href="#xxxMapper-xml文件" class="headerlink" title="xxxMapper.xml文件"></a>xxxMapper.xml文件</h2><p>namespace：名称空间;指定为接口的全类名<br>id:唯一标识(接口方法名)<br>resultType：返回值类型<br>#{id}：从传递过来的参数中取出id值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;top.ajie.mybatisDemo.dao.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;top.ajie.mybatisDemo.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">        select * from tbl_employee where id = #&#123;id&#125; and last_name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="主键自增问题"><a href="#主键自增问题" class="headerlink" title="主键自增问题"></a>主键自增问题</h3><p>parameterType：参数类型，可以省略。</p><ul><li><p>获取自增主键的值：</p><p>mysql支持自增主键，自增主键值的获取，mybatis也是用statement.getGenreatedKeys()。</p><ul><li>useGeneratedKeys=”true”：使用自增主键获取主键值策略。</li><li>keyProperty：指定对应的主键属性，也就是mybatis获取到主键值以后，将这个值封装给javaBean的哪个属性。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.Employee&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">  insert into tbl_employee(last_name,email,gender)</span><br><span class="line">  values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>获取非自增主键的值：</p><p>Oracle不支持自增，Oracle使用序列来模拟自增。每次插入的数据的主键是从序列中拿到的值，如何获取到这个值？<br>keyProperty:查出的主键值封装给javaBean的哪个属性。</p><ul><li><p>order=”xxxxxx”(BEFORE | AFTER)</p><ul><li>BEFORE:当前sql在插入sql之前运行。</li><li>AFTER：当前sql在插入sql之后运行。</li></ul></li><li><p>resultType:查出的数据的返回值类型。</p></li><li><p>BEFORE运行顺序：</p><pre><code>  - 先运行selectKey查询id的sql；查出id值封装给javaBean的id属性。  - 再运行插入的sql；就可以取出id属性对应的值。</code></pre></li><li><p>AFTER运行顺序：</p><pre><code>  - 先运行插入的sql（从序列中取出新值作为id）。  - 再运行selectKey查询id的sql。</code></pre></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用BEFORE --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmp&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;oracle&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 编写查询主键的sql语句 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Integer&quot;</span>&gt;</span></span><br><span class="line">    select EMPLOYEES_SEQ.nextval from dual</span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插入时的主键是从序列中拿到的 --&gt;</span></span><br><span class="line">  insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL)</span><br><span class="line">  values(#&#123;id&#125;,#&#123;lastName&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用AFTER --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addEmp&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;oracle&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 编写查询主键的sql语句 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Integer&quot;</span>&gt;</span></span><br><span class="line">    select EMPLOYEES_SEQ.currval from dual</span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL)</span><br><span class="line">  values(employees_seq.nextval,#&#123;lastName&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mybatis参数处理问题"><a href="#mybatis参数处理问题" class="headerlink" title="mybatis参数处理问题"></a>mybatis参数处理问题</h3><ul><li><p>单个参数：mabatis不会做特殊处理</p><ul><li>#{参数名}:取出参数值</li></ul></li><li><p>多个参数：mybatis会做特殊处理：</p><ul><li><p>多个参数会被封装成一个map</p><ul><li>key：param1…..paramN，或者参数的索引也可以</li><li>value：传入的参数值</li></ul></li><li><p>#{}就是从map中获取指定的key的值</p></li><li><p>3.4.3以前的版本：</p><ul><li>操作：<ul><li>方法：public Employee getEmpByIdAndLastName(Integer id,String lastName);</li><li>取值：#{id},#{lastName}</li></ul></li><li>异常：org.apache.ibatis.binding.BindingException:Parameter ‘id’ not found.Available parameters are [1, 0, param1, param2]。</li><li>解决：命名参数：<ul><li>明确指定封装参数时map的key，@Param(“id”)，多个参数会被封装成一个map：<ul><li>key：使用@Param注解指定的值</li><li>value：参数值</li></ul></li><li>#{指定的key}取出对应的参数值</li><li>POJO：如果多个参数正好是我们业务逻辑的数据模型，我们就可以直接传入pojo：<ul><li>#{属性名}：取出传入的pojo的属性值</li></ul></li><li>Map：如果多个参数不是业务模型中的数据，没有对应的pojo，不经常使用，为了方便，我们也可以传入map：<ul><li>#{key}：取出对应的值。</li></ul></li><li>TO(Transfer Object)数据传输对象：如果多个参数不是业务模型中的数据，但是经常要使用，推荐来编写一个TO(Transfer Object)数据传输对象。</li></ul></li></ul></li><li><p>3.4.3及以后的版本：</p></li><li><p>操作：</p><ul><li>方法：public Employee getEmpByIdAndLastName(Integer id,String lastName);</li><li>取值：#{id},#{lastName}</li></ul></li><li><p>结果：可以正常运行，无任何异常，推荐使用。</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public Employee getEmp(@Param(&quot;id&quot;)Integer id,String lastName);</span><br><span class="line">取值：id&#x3D;&#x3D;&gt;#&#123;id&#x2F;param1&#125;   lastName&#x3D;&#x3D;&gt;#&#123;param2&#125;</span><br><span class="line"></span><br><span class="line">public Employee getEmp(Integer id,@Param(&quot;e&quot;)Employee emp);</span><br><span class="line">取值：id&#x3D;&#x3D;&gt;#&#123;param1&#125;    lastName&#x3D;&#x3D;&#x3D;&gt;#&#123;param2.lastName&#x2F;e.lastName&#125;</span><br><span class="line"></span><br><span class="line">特别注意：</span><br><span class="line">如果是Collection（List、Set）类型或者是数组，</span><br><span class="line">也会特殊处理。也是把传入的list或者数组封装在map中。</span><br><span class="line">key：Collection（collection）,</span><br><span class="line">如果是List还可以使用这个key(list)，数组(array)</span><br><span class="line"></span><br><span class="line">public Employee getEmpById(List&lt;Integer&gt; ids);</span><br><span class="line">取值：取出第一个id的值：   #&#123;list[0]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：Mybatis笔记&quot;&gt;&lt;a href=&quot;#摘要：Mybatis笔记&quot; class=&quot;headerlink&quot; title=&quot;摘要：Mybatis笔记&quot;&gt;&lt;/a&gt;摘要：Mybatis笔记&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对这段时间学习mybatis的一些记录。&quot;&gt;&lt;a href=&quot;#前言：对这段时间学习mybatis的一些记录。&quot; class=&quot;headerlink&quot; title=&quot;前言：对这段时间学习mybatis的一些记录。&quot;&gt;&lt;/a&gt;前言：对这段时间学习mybatis的一些记录。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="ORM" scheme="https://www.blog.ajie39.top/categories/ORM/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="Mybatis" scheme="https://www.blog.ajie39.top/tags/Mybatis/"/>
    
    <category term="ORM" scheme="https://www.blog.ajie39.top/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>python数据可视化</title>
    <link href="https://www.blog.ajie39.top/2019/05/10/python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://www.blog.ajie39.top/2019/05/10/python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2019-05-10T01:03:23.019Z</published>
    <updated>2021-05-05T04:26:42.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：python数据可视化"><a href="#摘要：python数据可视化" class="headerlink" title="摘要：python数据可视化"></a>摘要：python数据可视化</h1><hr><h1 id="前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！"><a href="#前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！" class="headerlink" title="前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！"></a>前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！</h1><hr><span id="more"></span><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>安装matplotlib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user matplotlib</span><br></pre></td></tr></table></figure><h3 id="1、绘制简单的折线图"><a href="#1、绘制简单的折线图" class="headerlink" title="1、绘制简单的折线图"></a>1、绘制简单的折线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">plt.plot(squares)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、修改标签文字和线条粗细"><a href="#2、修改标签文字和线条粗细" class="headerlink" title="2、修改标签文字和线条粗细"></a>2、修改标签文字和线条粗细</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">plt.plot(squares, linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、校正图形"><a href="#3、校正图形" class="headerlink" title="3、校正图形"></a>3、校正图形</h3><p>当你向plot()提供一系列数字时，它假设第一个数据点对应的x坐标值为0，但我们的第一个点对应的x值为1。为改变这种默认行为，我们可以给plot()同时提供输入值和输出值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">input_values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squares = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">plt.plot(input_values, squares, linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、使用scatter-绘制散点图并设置其样式"><a href="#4、使用scatter-绘制散点图并设置其样式" class="headerlink" title="4、使用scatter()绘制散点图并设置其样式"></a>4、使用scatter()绘制散点图并设置其样式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(<span class="number">2</span>, <span class="number">4</span>, s=<span class="number">200</span>)</span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5、使用scatter-绘制一系列点"><a href="#5、使用scatter-绘制一系列点" class="headerlink" title="5、使用scatter()绘制一系列点"></a>5、使用scatter()绘制一系列点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y_values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、自动计算数据"><a href="#6、自动计算数据" class="headerlink" title="6、自动计算数据"></a>6、自动计算数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每个坐标轴的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">1100</span>, <span class="number">0</span>, <span class="number">1100000</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、删除数据点的轮廓"><a href="#7、删除数据点的轮廓" class="headerlink" title="7、删除数据点的轮廓"></a>7、删除数据点的轮廓</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plt.scatter(x_values, y_values, edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8、自定义颜色"><a href="#8、自定义颜色" class="headerlink" title="8、自定义颜色"></a>8、自定义颜色</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要修改数据点的颜色，可向scatter()传递参数c，</span><br><span class="line">并将其设置为要使用的颜色的名称，如下所示：</span><br><span class="line">plt.scatter(x_values, y_values, c=<span class="string">&#x27;red&#x27;</span>, edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">你还可以使用RGB颜色模式自定义颜色。要指定自定义颜色，可传递参数c，</span><br><span class="line">并将其设置为一个元组，其中包含三个<span class="number">0</span>~<span class="number">1</span>之间的小数值，</span><br><span class="line">它们分别表示红色、绿色和蓝色分量。例如，下面的代码行创建一个由淡蓝色点组成的散点图：</span><br><span class="line">plt.scatter(x_values, y_values, c=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>), edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9、使用颜色映射"><a href="#9、使用颜色映射" class="headerlink" title="9、使用颜色映射"></a>9、使用颜色映射</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line"><span class="comment">#我们将参数c设置成了一个y值列表，并使用参数cmap告诉pyplot使用哪个颜色映射。</span></span><br><span class="line"><span class="comment">#这些代码将y值较小的点显示为浅蓝色，并将y值较大的点显示为深蓝色.</span></span><br><span class="line">plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues,</span><br><span class="line">            edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10、自动保存图表"><a href="#10、自动保存图表" class="headerlink" title="10、自动保存图表"></a>10、自动保存图表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#可将对可将对plt.show()的调用替换为对plt.savefig()的调用</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;squares_plot.png&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line"></span><br><span class="line">第一个实参指定要以什么样的文件名保存图表，</span><br><span class="line">这个文件将存储到scatter_squares.py所在的目录中；</span><br><span class="line">第二个实参指定将图表多余的空白区域裁剪掉。</span><br><span class="line">如果要保留图表周围多余的空白区域，可省略这个实参。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11、随机漫步"><a href="#11、随机漫步" class="headerlink" title="11、随机漫步"></a>11、随机漫步</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWalk</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_points=<span class="number">5000</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.num_points = num_points</span><br><span class="line">        <span class="comment"># 所有随机漫步都始于(0, 0)</span></span><br><span class="line">        self.x_values = [<span class="number">0</span>]</span><br><span class="line">        self.y_values = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算随机漫步包含的所有点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不断漫步，直到列表达到指定的长度</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.x_values) &lt; self.num_points:</span><br><span class="line">            <span class="comment"># 决定前进方向以及沿这个方向前进的距离</span></span><br><span class="line"></span><br><span class="line">            x_direction = choice([<span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">            x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            x_step = x_direction * x_distance</span><br><span class="line"></span><br><span class="line">            y_direction = choice([<span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">            y_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            y_step = y_direction * y_distance</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 拒绝原地踏步</span></span><br><span class="line">            <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算下一个点的x和y值</span></span><br><span class="line">            next_x = self.x_values[-<span class="number">1</span>] + x_step</span><br><span class="line">            next_y = self.y_values[-<span class="number">1</span>] + y_step</span><br><span class="line"></span><br><span class="line">            self.x_values.append(next_x)</span><br><span class="line">            self.y_values.append(next_y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line"><span class="comment"># rw = RandomWalk()</span></span><br><span class="line"><span class="comment"># rw.fill_walk()</span></span><br><span class="line"><span class="comment"># plt.scatter(rw.x_values, rw.y_values, s=15)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw = RandomWalk(<span class="number">50000</span>)</span><br><span class="line">    rw.fill_walk()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置绘图窗口的尺寸</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">    point_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,</span><br><span class="line">                edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">&#x27;green&#x27;</span>, edgecolors=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.scatter(rw.x_values[-<span class="number">1</span>], rw.y_values[-<span class="number">1</span>], c=<span class="string">&#x27;red&#x27;</span>, edgecolors=<span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">                s=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐藏坐标轴</span></span><br><span class="line">    plt.axes().get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    plt.axes().get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line">    keep_running = <span class="built_in">input</span>(<span class="string">&quot;Make another walk? (y/n): &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调整尺寸以适合屏幕"><a href="#调整尺寸以适合屏幕" class="headerlink" title="调整尺寸以适合屏幕"></a>调整尺寸以适合屏幕</h3><p>函数figure()用于指定图表的宽度、高度、分辨率和背景色。你需要给形参figsize指定一个元组，向matplotlib指出绘图窗口的尺寸，单位为英寸。</p><p>plt.figure(dpi=128, figsize=(10, 6))</p><h3 id="使用Pygal-模拟掷骰子"><a href="#使用Pygal-模拟掷骰子" class="headerlink" title="使用Pygal 模拟掷骰子"></a>使用Pygal 模拟掷骰子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Die</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;表示一个骰子的类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_sides=<span class="number">6</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;骰子默认为6面&quot;&quot;&quot;</span></span><br><span class="line">        self.num_sides = num_sides</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;返回一个位于1和骰子面数之间的随机值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> randint(<span class="number">1</span>, self.num_sides)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个D6</span></span><br><span class="line">die = Die()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 掷几次骰子，并将结果存储在一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    result = die.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, die.num_sides+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对结果进行可视化</span></span><br><span class="line">hist = pygal.Bar()</span><br><span class="line"></span><br><span class="line">hist.title = <span class="string">&quot;Results of rolling one D6 1000 times.&quot;</span></span><br><span class="line">hist.x_labels = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>]</span><br><span class="line">hist.x_title = <span class="string">&quot;Result&quot;</span></span><br><span class="line">hist.y_title = <span class="string">&quot;Frequency of Result&quot;</span></span><br><span class="line"></span><br><span class="line">hist.add(<span class="string">&#x27;D6&#x27;</span>, frequencies)</span><br><span class="line">hist.render_to_file(<span class="string">&#x27;die_visual.png&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><p>读取csv文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line">filename = <span class="string">&#x27;sitka_weather_2014.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line"></span><br><span class="line">    highs = []</span><br><span class="line">    dates = []</span><br><span class="line">    lows = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        high = <span class="built_in">int</span>(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">        low = <span class="built_in">int</span>(row[<span class="number">3</span>])</span><br><span class="line">        lows.append(low)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(highs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">&#x27;red&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">&#x27;blue&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=<span class="string">&#x27;blue&#x27;</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">&quot;Daily high and low temperatures - 2014&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">&quot;Temperature (F)&quot;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.show()s</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="读取json文件"><a href="#读取json文件" class="headerlink" title="读取json文件"></a>读取json文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pygal_maps_world.maps</span><br><span class="line"><span class="keyword">from</span> pygal_maps_world.maps <span class="keyword">import</span> COUNTRIES</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> RotateStyle</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据加载到一个列表中</span></span><br><span class="line">filename = <span class="string">&#x27;population_data.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_country_code</span>(<span class="params">country_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据指定的国家，返回Pygal使用的两个字母的国别码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> code, name <span class="keyword">in</span> COUNTRIES.items():</span><br><span class="line">        <span class="keyword">if</span> name == country_name:</span><br><span class="line">            <span class="keyword">return</span> code</span><br><span class="line"><span class="comment"># 如果没有找到指定的国家，就返回None</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含人口数量的字典</span></span><br><span class="line">cc_populations = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">&#x27;Year&#x27;</span>] == <span class="string">&#x27;2010&#x27;</span>:</span><br><span class="line">        country = pop_dict[<span class="string">&#x27;Country Name&#x27;</span>]</span><br><span class="line">        population = <span class="built_in">int</span>(<span class="built_in">float</span>(pop_dict[<span class="string">&#x27;Value&#x27;</span>]))</span><br><span class="line">        code = get_country_code(country)</span><br><span class="line">        <span class="keyword">if</span> code:</span><br><span class="line">            cc_populations[code] = population</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据人口数量将所有的国家分成三组</span></span><br><span class="line">cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> cc, pop <span class="keyword">in</span> cc_populations.items():</span><br><span class="line">    <span class="keyword">if</span> pop &lt; <span class="number">10000000</span>:</span><br><span class="line">        cc_pops_1[cc] = pop</span><br><span class="line">    <span class="keyword">elif</span> pop &lt; <span class="number">1000000000</span>:</span><br><span class="line">        cc_pops_2[cc] = pop</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cc_pops_3[cc] = pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看看每组分别包含多少个国家</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(cc_pops_1), <span class="built_in">len</span>(cc_pops_2), <span class="built_in">len</span>(cc_pops_3))</span><br><span class="line"></span><br><span class="line">wm_style = RotateStyle(<span class="string">&#x27;#336699&#x27;</span>)</span><br><span class="line">wm_style = LightColorizedStyle</span><br><span class="line">wm = pygal_maps_world.maps.World(style=wm_style)</span><br><span class="line">wm.title = <span class="string">&#x27;World Population in 2010, by Country&#x27;</span></span><br><span class="line">wm.add(<span class="string">&#x27;0-10m&#x27;</span>, cc_pops_1)</span><br><span class="line">wm.add(<span class="string">&#x27;10m-1bn&#x27;</span>, cc_pops_2)</span><br><span class="line">wm.add(<span class="string">&#x27;&gt;1bn&#x27;</span>, cc_pops_3)</span><br><span class="line"></span><br><span class="line">wm.render_to_file(<span class="string">&#x27;world_population.svg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：python数据可视化&quot;&gt;&lt;a href=&quot;#摘要：python数据可视化&quot; class=&quot;headerlink&quot; title=&quot;摘要：python数据可视化&quot;&gt;&lt;/a&gt;摘要：python数据可视化&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！&quot;&gt;&lt;a href=&quot;#前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！&quot; class=&quot;headerlink&quot; title=&quot;前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！&quot;&gt;&lt;/a&gt;前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/categories/python/"/>
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/tags/python/"/>
    
    <category term="数据可视化" scheme="https://www.blog.ajie39.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
</feed>
