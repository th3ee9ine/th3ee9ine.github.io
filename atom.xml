<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教练，我想学技术!</title>
  
  <subtitle>开局一双手，升级全靠苟，拼一拼，搏一搏，单车变摩托。</subtitle>
  <link href="https://www.blog.ajie39.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.ajie39.top/"/>
  <updated>2022-06-04T09:27:38.578Z</updated>
  <id>https://www.blog.ajie39.top/</id>
  
  <author>
    <name>th3ee9ine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 入门总结（二）</title>
    <link href="https://www.blog.ajie39.top/2022/05/07/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/05/07/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-05-07T07:10:19.400Z</published>
    <updated>2022-06-04T09:27:38.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十三章的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十三章的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十三章的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：六到十三章的内容。</h1><hr><span id="more"></span><h2 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h2><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><h4 id="1）特性"><a href="#1）特性" class="headerlink" title="1）特性"></a>1）特性</h4><ul><li>函数是基本的代码块。</li><li>Go 是编译型语言，所以函数编写的顺序是无关紧要的。</li><li>最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。</li><li>DRY 原则：即不要重复你自己（Don’t Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次。</li><li>当函数执行到代码块最后一行（} 之前）或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数。</li><li>函数可以将其他函数调用作为它的参数，只要这个被调用函数的返回值个数、返回值类型和返回值的顺序与调用函数所需求的实参是一致的，例如：f1(f2(a, b))。</li><li>Go不允许函数重载。</li></ul><h4 id="2）不同类型的函数"><a href="#2）不同类型的函数" class="headerlink" title="2）不同类型的函数"></a>2）不同类型的函数</h4><p>Go 里面有三种类型的函数：</p><ul><li>普通的带有名字的函数</li><li>匿名函数或者 lambda 函数</li><li>方法</li></ul><p>除了 main ()、init () 函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为<strong>函数签名</strong>。</p><h4 id="3）语法"><a href="#3）语法" class="headerlink" title="3）语法"></a>3）语法</h4><p>函数基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数被调用的基本格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pack1.Function(arg1, arg2, …, argn)</span><br></pre></td></tr></table></figure><p>Function 是 pack1 包里面的一个函数，括号里的是被调用函数的 <strong>实参</strong>（argument）：这些值被传递给被调用函数的 <strong>形参</strong>。函数被调用的时候，这些实参将被复制（简单而言）然后传递给被调用函数。</p><p>函数一般是在其他函数里面被调用的，这个其他函数被称为调用函数（calling function）。函数能多次调用其他函数，这些被调用函数按顺序（简单而言）执行，理论上，函数调用其他函数的次数是无限制的（直到函数调用栈被耗尽）。</p><h4 id="4）方法"><a href="#4）方法" class="headerlink" title="4）方法"></a>4）方法</h4><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><p>Go语言中的 ​​方法（Method）​​ 是一种作用于特定类型变量的函数。这种特定类型变量叫做 ​​接收者（Receiver）​​。接收者的概念就类似于其他语言中的 ​​this​​ 或者 ​​self​​。</p><p>方法的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">  &#x2F;&#x2F; 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在go语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接受者的函数，<strong>方法和函数的写法只有一个区别</strong>，那就是 <strong>方法在 func 和标识符之间多了一个参数——接受者定义在func关键字和函数名之间</strong>。</p><p>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</p><p>方法的接收者什么时候适合指向结构体的指针而不是结构体值？</p><p>以C语言为例，我们知道在C中如果对一个指针变量进行修改，那么它的“副本”们也都会被修改。所以在Go中，如果你的方法是需要对结构体本身修改的，请使用指针作为接收器。否则，以值为接收器，改动将无效（类似slice，map特殊结构体）。你的结构体很大，用一个指针传递，会节约资源。为统一起见，如果你的大多方法以指针为接收器，请把其他方法也优先以指针作为接收器，不然调用时可能会提示该方法不属于某结构体的乌龙错误。</p><h4 id="5）函数类型"><a href="#5）函数类型" class="headerlink" title="5）函数类型"></a>5）函数类型</h4><p>函数也可以以申明的方式被使用，作为一个函数类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明 Greeting 函数类型</span><br><span class="line">type Greeting func(name string) string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义方法</span><br><span class="line">func (g Greeting) say(n string) &#123;</span><br><span class="line">fmt.Println(g(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO 是类C语言，也就是面向过程语言。<a href="https://go.dev/doc/faq#ancestors">见此</a><br>以C语言为例，它是没有类这种概念的，只有结构体。<br>在C中，编写一个结构体的方法，我们通常采用以下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func(s *Student, id int)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把第一个参数做为该方法的 <strong>“类对象”</strong>，也称为 <strong>接受者</strong>，receiver。<br>而 <strong>Go只是把C语言中的第一个参数放到方法前面</strong> 而已，所以它并不是用来类型转换的，而是一个接收者，<strong>说明该方法属于哪个结构体</strong>。</p><h3 id="2、传递变长参数"><a href="#2、传递变长参数" class="headerlink" title="2、传递变长参数"></a>2、传递变长参数</h3><p>如果函数的最后一个参数是采用 …type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变长函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func myFunc(a, b, arg ...int) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受一个类似某个类型的 slice 的参数，该参数可以通过 for 循环结构迭代。</p><p>如果参数被存储在一个 slice 类型的变量 slice 中，则可以通过 slice… 的形式来传递参数调用变参函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    x :&#x3D; min(1, 3, 2, 0)</span><br><span class="line">    fmt.Printf(&quot;The minimum is: %d\n&quot;, x)</span><br><span class="line">    slice :&#x3D; []int&#123;7,9,3,5,1&#125;</span><br><span class="line">    x &#x3D; min(slice...)</span><br><span class="line">    fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(s ...int) int &#123;</span><br><span class="line">    if len(s)&#x3D;&#x3D;0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    min :&#x3D; s[0]</span><br><span class="line">    for _, v :&#x3D; range s &#123;</span><br><span class="line">        if v &lt; min &#123;</span><br><span class="line">            min &#x3D; v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、defer-和追踪"><a href="#3、defer-和追踪" class="headerlink" title="3、defer 和追踪"></a>3、defer 和追踪</h3><p>关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。</p><p>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    function1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func function1() &#123;</span><br><span class="line">    fmt.Printf(&quot;In function1 at the top\n&quot;)</span><br><span class="line">    defer function2()</span><br><span class="line">    fmt.Printf(&quot;In function1 at the bottom!\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func function2() &#123;</span><br><span class="line">    fmt.Printf(&quot;function2: Deferred until the end of the calling function!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">In Function1 at the top</span><br><span class="line">In Function1 at the bottom!</span><br><span class="line">Function2: Deferred until the end of the calling function!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 defer 的语句同样可以接受参数，下面这个例子就会在执行 defer 语句时打印 0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">    i :&#x3D; 0</span><br><span class="line">    defer fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func f() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">        defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">4 3 2 1 0</span><br></pre></td></tr></table></figure><h4 id="1）使用-defer-语句实现代码追踪"><a href="#1）使用-defer-语句实现代码追踪" class="headerlink" title="1）使用 defer 语句实现代码追踪"></a>1）使用 defer 语句实现代码追踪</h4><p>一个基础但十分实用的实现代码执行追踪的方案就是在进入和离开某个函数打印相关的消息，即可以提炼为下面两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func trace(s string) &#123; fmt.Println(&quot;entering:&quot;, s) &#125;</span><br><span class="line">func untrace(s string) &#123; fmt.Println(&quot;leaving:&quot;, s) &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func trace(s string)   &#123; fmt.Println(&quot;entering:&quot;, s) &#125;</span><br><span class="line">func untrace(s string) &#123; fmt.Println(&quot;leaving:&quot;, s) &#125;</span><br><span class="line"></span><br><span class="line">func a() &#123;</span><br><span class="line">    trace(&quot;a&quot;)</span><br><span class="line">    defer untrace(&quot;a&quot;)</span><br><span class="line">    fmt.Println(&quot;in a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func b() &#123;</span><br><span class="line">    trace(&quot;b&quot;)</span><br><span class="line">    defer untrace(&quot;b&quot;)</span><br><span class="line">    fmt.Println(&quot;in b&quot;)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）使用-defer-语句来记录函数的参数与返回值"><a href="#2）使用-defer-语句来记录函数的参数与返回值" class="headerlink" title="2）使用 defer 语句来记录函数的参数与返回值"></a>2）使用 defer 语句来记录函数的参数与返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func func1(s string) (n int, err error) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        log.Printf(&quot;func1(%q) &#x3D; %d, %v&quot;, s, n, err)</span><br><span class="line">    &#125;()</span><br><span class="line">    return 7, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    func1(&quot;Go&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Output: 2011&#x2F;10&#x2F;04 10:46:11 func1(&quot;Go&quot;) &#x3D; 7, EOF</span><br></pre></td></tr></table></figure><h3 id="4、内置函数"><a href="#4、内置函数" class="headerlink" title="4、内置函数"></a>4、内置函数</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td>new、make</td><td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new (type)、make (type)。new (T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make (T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作 new () 是一个函数，不要忘记它的括号</td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数，在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real、imag</td><td>用于创建和操作复数</td></tr></tbody></table><h3 id="5、将函数作为参数"><a href="#5、将函数作为参数" class="headerlink" title="5、将函数作为参数"></a>5、将函数作为参数</h3><p>函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    callback(1, Add)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) &#123;</span><br><span class="line">    fmt.Printf(&quot;The sum of %d and %d is: %d\n&quot;, a, b, a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func callback(y int, f func(int, int)) &#123;</span><br><span class="line">    f(y, 2) &#x2F;&#x2F; this becomes Add(1, 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The sum of 1 and 2 is: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、匿名函数（闭包，函数式语言的术语）"><a href="#6、匿名函数（闭包，函数式语言的术语）" class="headerlink" title="6、匿名函数（闭包，函数式语言的术语）"></a>6、匿名函数（闭包，函数式语言的术语）</h3><p>当我们不希望给函数起名字的时候，可以使用匿名函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func(x, y int) int &#123; return x + y &#125;。</span><br><span class="line"></span><br><span class="line">这样的一个函数不能够独立存在（编译器会返回错误：non-declaration statement outside function body），但可以被赋值于某个变量，即保存函数的地址到变量中：</span><br><span class="line"></span><br><span class="line">fplus :&#x3D; func(x, y int) int &#123; return x + y &#125;</span><br><span class="line"></span><br><span class="line">然后通过变量名对函数进行调用：fplus(3,4)。</span><br></pre></td></tr></table></figure><p>当然，也可以直接对匿名函数进行调用：func(x, y int) int { return x + y } (3, 4)。</p><p>具体语法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func() &#123;</span><br><span class="line">    sum :&#x3D; 0</span><br><span class="line">    for i :&#x3D; 1; i &lt;&#x3D; 1e6; i++ &#123;</span><br><span class="line">        sum +&#x3D; i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>表示参数列表的第一对括号必须紧挨着关键字 func，因为匿名函数没有名称。花括号 {} 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。</p><p>具体例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line">func f() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 4; i++ &#123;</span><br><span class="line">        g :&#x3D; func(i int) &#123; fmt.Printf(&quot;%d &quot;, i) &#125; &#x2F;&#x2F;此例子中只是为了演示匿名函数可分配不同的内存地址，在现实开发中，不应该把该部分信息放置到循环中。</span><br><span class="line">        g(i)</span><br><span class="line">        fmt.Printf(&quot; - g is of type %T and has value %v\n&quot;, g, g)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到变量 g 代表的是 func(int)，变量的值是一个内存地址。</p><p>所以我们实际上拥有的是一个函数值：匿名函数可以被赋值给变量并作为值使用。</p><h2 id="二、数组与切片"><a href="#二、数组与切片" class="headerlink" title="二、数组与切片"></a>二、数组与切片</h2><h3 id="1、数组（概念和java相同，略过）"><a href="#1、数组（概念和java相同，略过）" class="headerlink" title="1、数组（概念和java相同，略过）"></a>1、数组（概念和java相同，略过）</h3><p>Go 语言中的数组是一种 值类型（不像 C/C++ 中是指向首元素的指针），所以可以通过 new() 来创建： var arr1 = new([5]int)。</p><p>那么这种方式和 var arr2 [5]int 的区别是什么呢？arr1 的类型是 *[5]int，而 arr2 的类型是 [5]int。</p><p>这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 :&#x3D; *arr1</span><br><span class="line">arr2[2] &#x3D; 100</span><br></pre></td></tr></table></figure><p>这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效。</p><p>所以在函数中数组作为参数传入时，如 func1(arr2)，会产生一次数组拷贝，func1 方法不会修改原始的数组 arr2。</p><p>如果你想修改原数组，那么 arr2 必须通过 &amp; 操作符以引用方式传过来，例如 func1 (&amp;arr2），例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func f(a [3]int) &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">a[0] &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fp(a *[3]int) &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">a[0] &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var ar [3]int</span><br><span class="line">f(ar)   &#x2F;&#x2F; passes a copy of ar</span><br><span class="line">fp(&amp;ar) &#x2F;&#x2F; passes a pointer to ar</span><br><span class="line">fmt.Println(ar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1）数组初始化"><a href="#1）数组初始化" class="headerlink" title="1）数组初始化"></a>1）数组初始化</h4><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; var arrAge &#x3D; [5]int&#123;18, 20, 15, 22, 16&#125;</span><br><span class="line">&#x2F;&#x2F; var arrLazy &#x3D; [...]int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="line">&#x2F;&#x2F; var arrLazy &#x3D; []int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="line">var arrKeyValue &#x3D; [5]string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; var arrKeyValue &#x3D; []string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; len(arrKeyValue); i++ &#123;</span><br><span class="line">fmt.Printf(&quot;Person at %d is %s\n&quot;, i, arrKeyValue[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）将数组传递给函数"><a href="#2）将数组传递给函数" class="headerlink" title="2）将数组传递给函数"></a>2）将数组传递给函数</h4><p>把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象：</p><ul><li>传递数组的指针</li><li>使用数组的切片</li></ul><h5 id="传递数组的指针"><a href="#传递数组的指针" class="headerlink" title="传递数组的指针"></a>传递数组的指针</h5><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">array :&#x3D; [3]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; Sum(&amp;array) &#x2F;&#x2F; Note the explicit address-of operator</span><br><span class="line">&#x2F;&#x2F; to pass a pointer to the array</span><br><span class="line">fmt.Printf(&quot;The sum of the array is: %f&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Sum(a *[3]float64) (sum float64) &#123;</span><br><span class="line">for _, v :&#x3D; range *a &#123; &#x2F;&#x2F; derefencing *a to get back to the array is not necessary!</span><br><span class="line">sum +&#x3D; v</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">The sum of the array is: 24.600000</span><br></pre></td></tr></table></figure><p>但这在 Go 中并不常用，通常使用切片。</p><h5 id="使用数组的切片"><a href="#使用数组的切片" class="headerlink" title="使用数组的切片"></a>使用数组的切片</h5><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">array :&#x3D; [3]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; sum(array[:])</span><br><span class="line">fmt.Printf(&quot;The sum of the array is: %f&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sum(a []float64) float64 &#123;</span><br><span class="line">s :&#x3D; 0.0</span><br><span class="line">for i :&#x3D; 0; i &lt; len(a); i++ &#123;</span><br><span class="line">s +&#x3D; a[i]</span><br><span class="line">&#125;</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、切片"><a href="#2、切片" class="headerlink" title="2、切片"></a>2、切片</h3><h4 id="1）概念"><a href="#1）概念" class="headerlink" title="1）概念"></a>1）概念</h4><p>切片（slice）是对数组一个 <strong>连续片段的引用（该数组我们称之为相关数组，通常是匿名的）</strong>，所以 <strong>切片是一个引用类型</strong>（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。</p><p>特点如下所示：</p><ul><li>切片是一个引用类型</li><li>切片是可索引的，并且可以由 len() 函数获取长度。</li><li>给定项的切片索引可能比相关数组的相同元素的索引小。</li><li>和数组不同的是，切片的长度可以在运行时修改，最小为 0 ，最大为相关数组的长度：切片是一个长度可变的数组。</li><li>切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少：它等于切片从第一个元素开始，到相关数组末尾的元素个数。对于 切片 s 来说该不等式永远成立：0 &lt;= len(s) &lt;= cap(s)。</li><li>多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</li></ul><p>声明切片的格式，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier []type（不需要说明长度）</span><br></pre></td></tr></table></figure><p>一个切片在未初始化之前默认为 nil，长度为 0。</p><p>切片的初始化格式，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var slice1 []type &#x3D; arr1[start:end]</span><br></pre></td></tr></table></figure><p>这表示 slice1 是由数组 arr1 从 start 索引到 end-1 索引之间的元素构成的子集（切分数组，start:end 被称为 slice 表达式）。所以 slice1[0] 就等于 arr1[start]。这可以在 arr1 被填充前就定义好。</p><p>如果某个人写：var slice1 []type = arr1[:] 那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 arr1[0:len(arr1)] 的一种缩写）。另外一种表述方式是：slice1 = &amp;arr1。</p><p>arr1[2:] 和 arr1[2:len(arr1)] 相同，都包含了数组从第三个到最后的所有元素。</p><p>arr1[:3] 和 arr1[0:3] 相同，包含了从第一个到第三个元素（不包括第四个 / 不包含下标为三的元素）。</p><p>如果你想去掉 slice1 的最后一个元素，只要 slice1 = slice1[:len(slice1)-1]。</p><p>一个由数字 1、2、3 组成的切片可以这么生成：s := [3]int{1,2,3}[:] 甚至更简单的 s := []int{1,2,3}。</p><p>s2 := s[:] 是用切片组成的切片，拥有相同的元素，但是 <strong>仍然指向相同的相关数组</strong>。</p><p>一个切片 s 可以这样扩展到它的大小上限：s = s[:cap(s)]，如果再扩大的话就会导致运行时错误。</p><p>切片也可以用类似数组的方式初始化：var x = []int{2, 3, 5, 7, 11}。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。</p><h4 id="2）切片的内存结构"><a href="#2）切片的内存结构" class="headerlink" title="2）切片的内存结构"></a>2）切片的内存结构</h4><p>切片在内存中的组织方式实际上是一个有 3 个域的结构体：</p><ul><li>指向相关数组的指针</li><li>切片长度：切片的长度就是它所包含的元素个数。</li><li>切片容量：切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</li></ul><p>一个长度为 2，容量为 4 的切片 y，如下所示：</p><p><img src="/img/image/blog/20220604/%E5%88%87%E7%89%87%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="切片内存结构"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[0] &#x3D; 3 且 y[1] &#x3D; 5。</span><br></pre></td></tr></table></figure><p>切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。</p><p>注意: <strong>绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针！！</strong></p><h4 id="3）创建切片"><a href="#3）创建切片" class="headerlink" title="3）创建切片"></a>3）创建切片</h4><p>当相关数组还没有定义时，我们可以使用 make () 函数来创建一个切片 同时创建好相关数组：var slice1 []type = make([]type, len)。</p><p>也可以简写为 slice1 := make([]type, len)，这里 len 是数组的长度并且也是 slice 的初始长度。</p><p>所以定义 s2 := make([]int, 10)，那么 cap(s2) == len(s2) == 10。</p><p>make 接受 2 个参数：元素的类型以及切片的元素个数。</p><p>如果你想创建一个 slice1，它不占用整个数组，而只是占用以 len 为个数个项，那么只要：slice1 := make([]type, len, cap)。</p><p>make 的使用方式是：func make([]T, len, cap)，其中 cap 是可选参数。</p><p>所以下面两种方法可以生成相同的切片:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make([]int, 50, 100)</span><br><span class="line">new([100]int)[0:50]</span><br></pre></td></tr></table></figure><p>使用 make 方法生成的切片的内存结构，如下图所示：</p><p><img src="/img/image/blog/20220604/make%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90%E7%9A%84%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="make方法生成的切片的内存结构"></p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var slice1 []int &#x3D; make([]int, 10)</span><br><span class="line">    &#x2F;&#x2F; load the array&#x2F;slice:</span><br><span class="line">    for i :&#x3D; 0; i &lt; len(slice1); i++ &#123;</span><br><span class="line">        slice1[i] &#x3D; 5 * i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; print the slice:</span><br><span class="line">    for i :&#x3D; 0; i &lt; len(slice1); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;Slice at %d is %d\n&quot;, i, slice1[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;\nThe length of slice1 is %d\n&quot;, len(slice1))</span><br><span class="line">    fmt.Printf(&quot;The capacity of slice1 is %d\n&quot;, cap(slice1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）new-和-make-的区别"><a href="#4）new-和-make-的区别" class="headerlink" title="4）new () 和 make () 的区别"></a>4）new () 和 make () 的区别</h4><p>看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</p><ul><li>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T{}。</li><li>make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel。</li></ul><p>换言之，new 函数分配内存，make 函数初始化；下图给出了区别：</p><p><img src="/img/image/blog/20220604/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="new和make的区别"></p><h4 id="5）多维切片"><a href="#5）多维切片" class="headerlink" title="5）多维切片"></a>5）多维切片</h4><p>Go语言中同样允许使用多维切片，声明一个多维数组的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sliceName [][]...[]sliceType</span><br></pre></td></tr></table></figure><p>下面以二维切片为例，声明一个二维切片并赋值，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明一个二维切片</span><br><span class="line">var slice [][]int</span><br><span class="line">&#x2F;&#x2F;为二维切片赋值</span><br><span class="line">slice &#x3D; [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125;</span><br><span class="line">上面的代码也可以简写为下面的样子。</span><br><span class="line">&#x2F;&#x2F; 声明一个二维整型切片并赋值</span><br><span class="line">slice :&#x3D; [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; 为第一个切片追加值为 20 的元素</span><br><span class="line">slice[0] &#x3D; append(slice[0], 20)</span><br></pre></td></tr></table></figure><h2 id="三、Map"><a href="#三、Map" class="headerlink" title="三、Map"></a>三、Map</h2><h2 id="四、包（package）"><a href="#四、包（package）" class="headerlink" title="四、包（package）"></a>四、包（package）</h2><h2 id="五、结构与方法"><a href="#五、结构与方法" class="headerlink" title="五、结构与方法"></a>五、结构与方法</h2><h2 id="六、接口与反射"><a href="#六、接口与反射" class="headerlink" title="六、接口与反射"></a>六、接口与反射</h2><h2 id="七、读写数据"><a href="#七、读写数据" class="headerlink" title="七、读写数据"></a>七、读写数据</h2><h2 id="八、错误处理与测试"><a href="#八、错误处理与测试" class="headerlink" title="八、错误处理与测试"></a>八、错误处理与测试</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://learnku.com/docs/the-way-to-go">Go 入门指南</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十三章的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十三章的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十三章的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：六到十三章的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go 入门总结（一）</title>
    <link href="https://www.blog.ajie39.top/2022/03/06/Go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/03/06/Go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-03-06T06:50:08.425Z</published>
    <updated>2022-05-07T07:24:49.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：一到五章的内容。</h1><hr><span id="more"></span><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1、包相关"><a href="#1、包相关" class="headerlink" title="1、包相关"></a>1、包相关</h3><p>①第一种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;; import &quot;os&quot;</span><br></pre></td></tr></table></figure><p>②第二种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (&quot;fmt&quot;; &quot;os&quot;)</span><br></pre></td></tr></table></figure><h3 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h3><ul><li>布尔类型：bool</li><li>整数：int、int8、int16、int32、int64</li><li>无符号整数：uint、uint8、uint16、uint32、uint64</li><li>字节：byte(和 uint8 等价)</li><li>Unicode：rune(和 int32 等价)</li><li>整数指针：uintptr(存储 uint32、uint64 的指针)</li><li>浮点数：float32、float64</li><li>复数：complex64、complex128</li><li>字符串类型：string</li><li>值类型：array(数组)、struct(结构化变量)</li><li>引用类型：slice(动态数组)、map、channel(管道)</li><li>接口：interface</li><li>函数：function</li></ul><h3 id="3、函数相关"><a href="#3、函数相关" class="headerlink" title="3、函数相关"></a>3、函数相关</h3><p>函数执行顺序：init —》main</p><p>测试代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;demo&#x2F;com.th3ee9ine&#x2F;servic&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">&#x2F;&#x2F; 先执行</span><br><span class="line">fmt.Println(&quot;初始化.....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">  主函数</span><br><span class="line">*&#x2F;</span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 后执行</span><br><span class="line">fmt.Println(&quot;主函数......&quot;)</span><br><span class="line">fmt.Println(&quot;加法&quot;)</span><br><span class="line">fmt.Println(servic.Add(1, 2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、类型转换"><a href="#4、类型转换" class="headerlink" title="4、类型转换"></a>4、类型转换</h3><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOfTypeB &#x3D; typeB(valueOfTypeA)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 5.0</span><br><span class="line">var b &#x3D; int(a)</span><br></pre></td></tr></table></figure><h3 id="5、Go-程序的一般结构"><a href="#5、Go-程序的一般结构" class="headerlink" title="5、Go 程序的一般结构"></a>5、Go 程序的一般结构</h3><p>一般结构如下：</p><ul><li>在完成包的 import 之后，开始对常量、变量和类型的定义或声明。</li><li>如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li><li>如果当前包是 main 包，则定义 main 函数。</li><li>然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const c &#x3D; &quot;C&quot;</span><br><span class="line"></span><br><span class="line">var v int &#x3D; 5</span><br><span class="line"></span><br><span class="line">type T struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123; &#x2F;&#x2F; initialization of package</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var a int</span><br><span class="line">   Func1()</span><br><span class="line">   &#x2F;&#x2F; ...</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t T) Method1() &#123;</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Func1() &#123; &#x2F;&#x2F; exported function Func1</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、常量、变量"><a href="#6、常量、变量" class="headerlink" title="6、常量、变量"></a>6、常量、变量</h3><h4 id="①常量"><a href="#①常量" class="headerlink" title="①常量"></a>①常量</h4><p>常量使用关键字 const 定义，用于存储不会改变的数据。</p><p>存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const identifier [type] &#x3D; value</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">const PI &#x3D; 3.14159</span><br><span class="line">const NAME string &#x3D; &quot;张三&quot;</span><br><span class="line">const beef, two, c &#x3D; &quot;eat&quot;, 2, &quot;veg&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>②常量枚举</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Unknown &#x3D; 0</span><br><span class="line">    Female &#x3D; 1</span><br><span class="line">    Male &#x3D; 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota 可以被用作枚举值，第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1，例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b &#x3D; iota</span><br><span class="line">    c &#x3D; iota</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="②变量"><a href="#②变量" class="headerlink" title="②变量"></a>②变量</h4><p>声明变量的一般形式是使用 var 关键字，例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var identifier type</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">var a int &#x3D; 15</span><br><span class="line">var i &#x3D; 5</span><br><span class="line">var b bool &#x3D; false</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    a &#x3D; 15</span><br><span class="line">    b &#x3D; false</span><br><span class="line">    city string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">简短形式，使用 :&#x3D; 赋值操作符，例如：</span><br><span class="line"></span><br><span class="line">a, b, c :&#x3D; 5, 7, &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。</span><br><span class="line"></span><br><span class="line">同个变量不可以多次使用 :&#x3D; 赋值操作符。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、运算符"><a href="#7、运算符" class="headerlink" title="7、运算符"></a>7、运算符</h3><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优先级     运算符</span><br><span class="line"> 7      ^ !</span><br><span class="line"> 6      * &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^</span><br><span class="line"> 5      + - | ^</span><br><span class="line"> 4      &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt;&#x3D; &gt;</span><br><span class="line"> 3      &lt;-</span><br><span class="line"> 2      &amp;&amp;</span><br><span class="line"> 1      ||</span><br></pre></td></tr></table></figure><h3 id="8、字符串"><a href="#8、字符串" class="headerlink" title="8、字符串"></a>8、字符串</h3><p>字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。</p><p>Go 支持以下 2 种形式的字面值：</p><p>解释字符串：</p><p>该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\n：换行符</span><br><span class="line">\r：回车符</span><br><span class="line">\t：tab 键</span><br><span class="line">\u 或 \U：Unicode 字符</span><br><span class="line">\\：反斜杠自身</span><br></pre></td></tr></table></figure><p>非解释字符串：</p><p>该类字符串使用反引号括起来，支持换行，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;This is a raw string \n&#96; 中的 &#96;\n\&#96; 会被原样输出。</span><br></pre></td></tr></table></figure><h3 id="9、时间和日期"><a href="#9、时间和日期" class="headerlink" title="9、时间和日期"></a>9、时间和日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var week time.Duration</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">t :&#x3D; time.Now()</span><br><span class="line">fmt.Println(t) &#x2F;&#x2F; e.g. Wed Dec 21 09:52:14 +0100 RST 2011</span><br><span class="line">fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</span><br><span class="line">&#x2F;&#x2F; 21.12.2011</span><br><span class="line">t &#x3D; time.Now().UTC()</span><br><span class="line">fmt.Println(t)          &#x2F;&#x2F; Wed Dec 21 08:52:14 +0000 UTC 2011</span><br><span class="line">fmt.Println(time.Now()) &#x2F;&#x2F; Wed Dec 21 09:52:14 +0100 RST 2011</span><br><span class="line">&#x2F;&#x2F; calculating times:</span><br><span class="line">week &#x3D; 60 * 60 * 24 * 7 * 1e9 &#x2F;&#x2F; must be in nanosec</span><br><span class="line">weekFromNow :&#x3D; t.Add(week)</span><br><span class="line">fmt.Println(weekFromNow) &#x2F;&#x2F; Wed Dec 28 08:52:14 +0000 UTC 2011</span><br><span class="line">&#x2F;&#x2F; formatting times:</span><br><span class="line">fmt.Println(t.Format(time.RFC822))         &#x2F;&#x2F; 21 Dec 11 0852 UTC</span><br><span class="line">fmt.Println(t.Format(time.ANSIC))          &#x2F;&#x2F; Wed Dec 21 08:56:34 2011</span><br><span class="line">fmt.Println(t.Format(&quot;21 Dec 2011 08:52&quot;)) &#x2F;&#x2F; 21 Dec 2011 08:52</span><br><span class="line">s :&#x3D; t.Format(&quot;20060102&quot;)</span><br><span class="line">fmt.Println(t, &quot;&#x3D;&gt;&quot;, s)</span><br><span class="line">&#x2F;&#x2F; Wed Dec 21 08:52:14 +0000 UTC 2011 &#x3D;&gt; 20111221</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、指针"><a href="#10、指针" class="headerlink" title="10、指针"></a>10、指针</h3><p>Go 语言为程序员提供了控制数据结构的指针的能力；但是，你不能进行指针运算。</p><p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i1 &#x3D; 5</span><br><span class="line">fmt.Printf(&quot;An integer: %d, it&#39;s location in memory: %p\n&quot;, i1, &amp;i1)</span><br></pre></td></tr></table></figure><p>Go 语言的存地址符是 *，放到一个变量前使用就会返回相应变量的内存地址。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var intP *int &#x3D; &amp;i1</span><br><span class="line"></span><br><span class="line">使用 intP &#x3D; &amp;i1 是合法的，此时 intP 指向 i1。</span><br><span class="line">intP 存储了 i1 的内存地址；它指向了 i1 的位置，它引用了变量 i1。</span><br><span class="line">指针的格式化标识符为 %p。</span><br></pre></td></tr></table></figure><p>一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。</p><p>当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；你可以在指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。</p><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><p>一个指针变量通常缩写为 ptr。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、在书写表达式类似 var p *type 时，切记在 * 号和指针名称间留有一个空格.</span><br><span class="line">因为 var p*type 是语法正确的，但是在更复杂的表达式中，它容易被误认为是一个乘法表达式！</span><br><span class="line"></span><br><span class="line">2、符号 * 可以放在一个指针前，如 *intP，那么它将得到这个指针指向地址上所存储的值；</span><br><span class="line">这被称为反引用（或者内容或者间接引用）操作符；另一种说法是指针转移。</span><br><span class="line"></span><br><span class="line">对于任何一个变量 var， 如下表达式都是正确的：var &#x3D;&#x3D; *(&amp;var)</span><br><span class="line"></span><br><span class="line">3、不能得到一个文字或常量的地址，例如：</span><br><span class="line">const i &#x3D; 5</span><br><span class="line">ptr :&#x3D; &amp;i &#x2F;&#x2F;error: cannot take the address of i</span><br><span class="line">ptr2 :&#x3D; &amp;10 &#x2F;&#x2F;error: cannot take the address of 10</span><br></pre></td></tr></table></figure><p>例子一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var i1 &#x3D; 5</span><br><span class="line">    fmt.Printf(&quot;An integer: %d, its location in memory: %p\n&quot;, i1, &amp;i1)</span><br><span class="line">    var intP *int</span><br><span class="line">    intP &#x3D; &amp;i1</span><br><span class="line">    fmt.Printf(&quot;The value at memory location %p is %d\n&quot;, intP, *intP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    s :&#x3D; &quot;good bye&quot;</span><br><span class="line">    var p *string &#x3D; &amp;s</span><br><span class="line">    *p &#x3D; &quot;ciao&quot;</span><br><span class="line">    fmt.Printf(&quot;Here is the pointer p: %p\n&quot;, p) &#x2F;&#x2F; prints address</span><br><span class="line">    fmt.Printf(&quot;Here is the string *p: %s\n&quot;, *p) &#x2F;&#x2F; prints string</span><br><span class="line">    fmt.Printf(&quot;Here is the string s: %s\n&quot;, s) &#x2F;&#x2F; prints same string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子三：</p><p>对一个空指针的反向引用是不合法的，并且会使程序崩溃：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var p *int &#x3D; nil</span><br><span class="line">*p &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; in Windows: stops only with: &lt;exit code&#x3D;&quot;-1073741819&quot; msg&#x3D;&quot;process crashed&quot;&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; runtime error: invalid memory address or nil pointer dereference</span><br></pre></td></tr></table></figure><h2 id="二、控制结构"><a href="#二、控制结构" class="headerlink" title="二、控制结构"></a>二、控制结构</h2><ul><li>if-else 结构</li><li>多返回值函数</li><li>switch 结构</li><li>for (range) 结构</li><li>标签与 goto</li><li>select 结构，用于 channel 的选择</li></ul><h3 id="1、if-else-结构"><a href="#1、if-else-结构" class="headerlink" title="1、if-else 结构"></a>1、if-else 结构</h3><p>关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 } 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition1 &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125; else if condition2 &#123;</span><br><span class="line">    &#x2F;&#x2F; do something else</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; catch-all or default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 可以包含一个初始化语句（如：给一个变量赋值）。这种写法具有固定的格式（在初始化语句后方必须加上分号）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if initialization; condition &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line">if val :&#x3D; 10; val &gt; max &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但要注意的是，使用简短方式 := 声明的变量的作用域只存在于 if 结构中（在 if 结构的大括号之间，如果使用 if-else 结构则在 else 代码块中变量也会存在）。</p><p>如果变量在 if 结构之前就已经存在，那么在 if 结构中，该变量原来的值会被隐藏。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var first int &#x3D; 10</span><br><span class="line">    var cond int</span><br><span class="line"></span><br><span class="line">    if first &lt;&#x3D; 0 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is less than or equal to 0\n&quot;)</span><br><span class="line">    &#125; else if first &gt; 0 &amp;&amp; first &lt; 5 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is between 0 and 5\n&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is 5 or greater\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if cond &#x3D; 5; cond &gt; 10 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;cond is greater than 10\n&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;cond is not greater than 10\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、多返回值函数"><a href="#2、多返回值函数" class="headerlink" title="2、多返回值函数"></a>2、多返回值函数</h3><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var orig string &#x3D; &quot;ABC&quot;</span><br><span class="line">    &#x2F;&#x2F; var an int</span><br><span class="line">    var newS string</span><br><span class="line">    &#x2F;&#x2F; var err error</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;The size of ints is: %d\n&quot;, strconv.IntSize)</span><br><span class="line">    &#x2F;&#x2F; anInt, err &#x3D; strconv.Atoi(origStr)</span><br><span class="line">    an, err :&#x3D; strconv.Atoi(orig)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;orig %s is not an integer - exiting with error\n&quot;, orig)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;The integer is %d\n&quot;, an)</span><br><span class="line">    an &#x3D; an + 5</span><br><span class="line">    newS &#x3D; strconv.Itoa(an)</span><br><span class="line">    fmt.Printf(&quot;The new string is: %s\n&quot;, newS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>习惯用法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, err :&#x3D; pack1.Function1(param1)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Printf(&quot;An error occured in pack1.Function1 with parameter %v&quot;, param1)</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 未发生错误，继续执行：</span><br></pre></td></tr></table></figure><p>由于本例的函数调用者属于 main 函数，所以程序会直接停止运行。</p><p>如果我们想要在错误发生的同时终止程序的运行，我们可以使用 os 包的 Exit 函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Program stopping with error %v&quot;, err)</span><br><span class="line">    os.Exit(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者将 ok-pattern 的获取放置在 if 语句的初始化部分，然后进行判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if value, ok :&#x3D; readData(); ok &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、switch-结构"><a href="#3、switch-结构" class="headerlink" title="3、switch 结构"></a>3、switch 结构</h3><p>Go 语言中的 switch 结构使用上更加灵活。它接受任意形式的表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    case val1:</span><br><span class="line">        ...</span><br><span class="line">    case val2:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 switch 关键字在同一行。</p><p>一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，也就是说您不需要特别使用 break 语句来表示结束。</p><p>因此，程序也不会自动地去执行下一个分支的代码。如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch i &#123;</span><br><span class="line">    case 0: &#x2F;&#x2F; 空分支，只有当 i &#x3D;&#x3D; 0 时才会进入分支</span><br><span class="line">    case 1:</span><br><span class="line">        f() &#x2F;&#x2F; 当 i &#x3D;&#x3D; 0 时函数不会被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch i &#123;</span><br><span class="line">    case 0: fallthrough</span><br><span class="line">    case 1:</span><br><span class="line">        f() &#x2F;&#x2F; 当 i &#x3D;&#x3D; 0 时函数也会被调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">例一：</span><br><span class="line">var num1 int &#x3D; 100</span><br><span class="line"></span><br><span class="line">switch num1 &#123;</span><br><span class="line">case 98, 99:</span><br><span class="line">fmt.Println(&quot;It&#39;s equal to 98&quot;)</span><br><span class="line">case 100:</span><br><span class="line">fmt.Println(&quot;It&#39;s equal to 100&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;It&#39;s not equal to 98 or 100&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例二：</span><br><span class="line">var num1 int &#x3D; 7</span><br><span class="line"></span><br><span class="line">switch &#123;</span><br><span class="line">case num1 &lt; 0:</span><br><span class="line">fmt.Println(&quot;Number is negative&quot;)</span><br><span class="line">case num1 &gt; 0 &amp;&amp; num1 &lt; 10:</span><br><span class="line">fmt.Println(&quot;Number is between 0 and 10&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;Number is 10 or greater&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例三:</span><br><span class="line">switch a, b :&#x3D; x[i], y[j]; &#123;</span><br><span class="line">    case a &lt; b: t &#x3D; -1</span><br><span class="line">    case a &#x3D;&#x3D; b: t &#x3D; 0</span><br><span class="line">    case a &gt; b: t &#x3D; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、for-range-结构"><a href="#4、for-range-结构" class="headerlink" title="4、for (range) 结构"></a>4、for (range) 结构</h3><h4 id="第一种形式"><a href="#第一种形式" class="headerlink" title="第一种形式"></a>第一种形式</h4><p>基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for 初始化语句; 条件语句; 修饰语句 &#123;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;This is the %d iteration\n&quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种形式"><a href="#第二种形式" class="headerlink" title="第二种形式"></a>第二种形式</h4><p>基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for 条件语句 &#123;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i int &#x3D; 5</span><br><span class="line"></span><br><span class="line">    for i &gt;&#x3D; 0 &#123;</span><br><span class="line">        i &#x3D; i - 1</span><br><span class="line">        fmt.Printf(&quot;The variable i is now: %d\n&quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三种形式"><a href="#第三种形式" class="headerlink" title="第三种形式"></a>第三种形式</h4><p>无限循环，基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="第四种形式"><a href="#第四种形式" class="headerlink" title="第四种形式"></a>第四种形式</h4><p>for-range 结构，一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ix, val :&#x3D; range coll &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（译者注：如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）。</p><p>一个字符串是 Unicode 编码的字符（或称之为 rune）集合，因此您也可以用它迭代字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    str :&#x3D; &quot;Go is a beautiful language!&quot;</span><br><span class="line">    fmt.Printf(&quot;The length of str is: %d\n&quot;, len(str))</span><br><span class="line">    for pos, char :&#x3D; range str &#123;</span><br><span class="line">        fmt.Printf(&quot;Character on position %d is: %c \n&quot;, pos, char)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    str2 :&#x3D; &quot;Chinese: 日本語&quot;</span><br><span class="line">    fmt.Printf(&quot;The length of str2 is: %d\n&quot;, len(str2))</span><br><span class="line">    for pos, char :&#x3D; range str2 &#123;</span><br><span class="line">        fmt.Printf(&quot;character %c starts at byte position %d\n&quot;, char, pos)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(&quot;index int(rune) rune    char bytes&quot;)</span><br><span class="line">    for index, rune :&#x3D; range str2 &#123;</span><br><span class="line">        fmt.Printf(&quot;%-2d      %d      %U &#39;%c&#39; % X\n&quot;, index, rune, rune, rune, []byte(string(rune)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、标签与-goto"><a href="#5、标签与-goto" class="headerlink" title="5、标签与 goto"></a>5、标签与 goto</h3><p>for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词（gofmt 会将后续代码自动移至下一行）。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">LABEL1:</span><br><span class="line">    for i :&#x3D; 0; i &lt;&#x3D; 5; i++ &#123;</span><br><span class="line">        for j :&#x3D; 0; j &lt;&#x3D; 5; j++ &#123;</span><br><span class="line">            if j &#x3D;&#x3D; 4 &#123;</span><br><span class="line">                continue LABEL1</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;i is: %d, and j is: %d\n&quot;, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continue 语句指向 LABEL1，当执行到该语句的时候，就会跳转到 LABEL1 标签的位置。</p><p>您可以看到当 j==4 和 j==5 的时候，没有任何输出：标签的作用对象为外部循环，因此 i 会直接变成下一个循环的值，而此时 j 的值就被重设为 0，即它的初始值。</p><p>如果将 continue 改为 break，则不会只退出内层循环，而是直接退出外层循环了。</p><p>注意：</p><ul><li>标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母</li></ul><p>例子二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">i :&#x3D; 0</span><br><span class="line">HERE:</span><br><span class="line">print(i)</span><br><span class="line">i++</span><br><span class="line">if i &#x3D;&#x3D; 5 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">goto HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：一到五章的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>git--Fork代码更新与同步</title>
    <link href="https://www.blog.ajie39.top/2022/02/02/git----Fork%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>https://www.blog.ajie39.top/2022/02/02/git----Fork%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%90%8C%E6%AD%A5/</id>
    <published>2022-02-02T13:20:12.729Z</published>
    <updated>2022-02-02T13:39:28.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：记录使用git–Fork代码更新与同步"><a href="#摘要：记录使用git–Fork代码更新与同步" class="headerlink" title="摘要：记录使用git–Fork代码更新与同步"></a>摘要：记录使用git–Fork代码更新与同步</h1><hr><span id="more"></span><h2 id="一、clone-fork的代码"><a href="#一、clone-fork的代码" class="headerlink" title="一、clone fork的代码"></a>一、clone fork的代码</h2><p>git clone xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git clone <a href="mailto:&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#x2e;&#112;&#x70;&#100;&#97;&#x69;&#99;&#x6f;&#114;&#112;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#64;&#103;&#x69;&#116;&#x2e;&#112;&#x70;&#100;&#97;&#x69;&#99;&#x6f;&#114;&#112;&#x2e;&#x63;&#x6f;&#109;</a>:cs-global/phl/cschannel.git</p><h2 id="二、把主仓库加入-remote"><a href="#二、把主仓库加入-remote" class="headerlink" title="二、把主仓库加入 remote"></a>二、把主仓库加入 remote</h2><p>未加入前：</p><p>执行 git remote 则只会有一个仓库</p><p><img src="/img/image/blog/20220202/remote1.png" alt="remote1"></p><p>执行命令，加入主仓库</p><p>git remote add xxxxxname（自定义名字） xxxxxxxxxxxx（主仓库地址）</p><p>例如：</p><p>git remote add main <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#105;&#116;&#46;&#112;&#x70;&#100;&#97;&#105;&#99;&#111;&#114;&#x70;&#46;&#x63;&#111;&#109;">&#103;&#x69;&#x74;&#64;&#103;&#105;&#116;&#46;&#112;&#x70;&#100;&#97;&#105;&#99;&#111;&#114;&#x70;&#46;&#x63;&#111;&#109;</a>:cs-global/cschannel.git</p><p>再次执行 git remote 命令，则会出现两个选项</p><p><img src="/img/image/blog/20220202/remote2.png" alt="remote2"></p><h2 id="三、同步主仓库分支至本地"><a href="#三、同步主仓库分支至本地" class="headerlink" title="三、同步主仓库分支至本地"></a>三、同步主仓库分支至本地</h2><p>命令：</p><p>git fetch xxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git fetch main</p><h2 id="四、同步主分支代码"><a href="#四、同步主分支代码" class="headerlink" title="四、同步主分支代码"></a>四、同步主分支代码</h2><p>基于 origin/master 分支创建一个临时分支</p><p>例如：</p><p>git branch origin/temp</p><p>然后将 main 分支的代码合并到 origin/temp</p><p>例如：</p><p>git merge main/master<br>解决冲突后，提交代码即可</p><p>注意：</p><p>如果出现如下报错，则需要强制合并</p><p>refusing to merge unrelated histories</p><p>强制合并命令：</p><p>git merge xxxxxxxxxxxxxxxxxxxxxx –allow-unrelated-histories</p><p>例如：</p><p>git merge main/master –allow-unrelated-histories</p><h2 id="五、移除远程分支"><a href="#五、移除远程分支" class="headerlink" title="五、移除远程分支"></a>五、移除远程分支</h2><p>git remote remove xxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git remote remove main</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：记录使用git–Fork代码更新与同步&quot;&gt;&lt;a href=&quot;#摘要：记录使用git–Fork代码更新与同步&quot; class=&quot;headerlink&quot; title=&quot;摘要：记录使用git–Fork代码更新与同步&quot;&gt;&lt;/a&gt;摘要：记录使用git–Fork代码更新与同步&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/categories/git/"/>
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>重写TreeMap的比较器(Comparator)引发的问题（源码分析）</title>
    <link href="https://www.blog.ajie39.top/2022/01/16/%E9%87%8D%E5%86%99TreeMap%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8(Comparator)%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98(%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/"/>
    <id>https://www.blog.ajie39.top/2022/01/16/%E9%87%8D%E5%86%99TreeMap%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8(Comparator)%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98(%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/</id>
    <published>2022-01-16T06:58:04.646Z</published>
    <updated>2022-01-17T12:49:26.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。"><a href="#摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。" class="headerlink" title="摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。"></a>摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。</h1><hr><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>1、给一个无序的map，按照value的值进行排序，value值越小，排在越前面。<br>2、key和value都不为null<br>3、value可能相同<br>4、返回结果为一个相同的有序map</p><p>代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，key=商品id，value=商品剩余库存</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1L</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2L</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="number">3L</span>, <span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，大家可以先想想，如果是你会怎么解决？</p><span id="more"></span><h2 id="我的解决思路"><a href="#我的解决思路" class="headerlink" title="我的解决思路"></a>我的解决思路</h2><p>1、使用TreeMap，因为TreeMap可以对元素进行排序<br>2、重写TreeMap的比较器</p><p>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 承接上面的代码</span></span><br><span class="line"><span class="comment">// 按照 value 排序</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap1 = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long o1, Long o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、如果v1等于v2，则值为0</span></span><br><span class="line">        <span class="comment">// 2、如果v1小于v2，则值为-1</span></span><br><span class="line">        <span class="comment">// 3、如果v1等于v2，则值为1</span></span><br><span class="line">        Integer value1 = map.get(o1);</span><br><span class="line">        Integer value2 = map.get(o2);</span><br><span class="line">        <span class="keyword">return</span> value1.compareTo(value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap1.putAll(map);</span><br><span class="line">System.out.println(treeMap1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>what？为什么我们添加了3个元素，结果少了一个呢？</p><p><img src="/img/image/blog/20220116/%E7%96%91%E9%97%AE.jpg" alt="疑问"></p><h2 id="TreeMap-putAll源码分析"><a href="#TreeMap-putAll源码分析" class="headerlink" title="TreeMap putAll源码分析"></a>TreeMap putAll源码分析</h2><p>让我们来看看 putAll 的具体过程</p><h3 id="1、分析-TreeMap-putAll"><a href="#1、分析-TreeMap-putAll" class="headerlink" title="1、分析 TreeMap.putAll"></a>1、分析 TreeMap.putAll</h3><p>源码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、获取待添加的map的大小</span></span><br><span class="line">    <span class="keyword">int</span> mapSize = map.size();</span><br><span class="line">    <span class="comment">// 二、当前的size大小等于0 且 待添加的map的大小不等于0 且 待添加的map是SortedMap的实现类，则执行以下逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span> &amp;&amp; mapSize!=<span class="number">0</span> &amp;&amp; map <span class="keyword">instanceof</span> SortedMap) &#123;</span><br><span class="line">        <span class="comment">// 1、获取待添加的map的比较器</span></span><br><span class="line">        Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator();</span><br><span class="line">        <span class="comment">// 2、如果两个比较器相同，则执行以下逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (c == comparator || (c != <span class="keyword">null</span> &amp;&amp; c.equals(comparator))) &#123;</span><br><span class="line">            <span class="comment">// 3、修改次数+1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4、基于排序数据的线性时间树构建算法，进行build</span></span><br><span class="line">                buildFromSorted(mapSize, map.entrySet().iterator(),</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三、如果不符合上面的条件，则执行父类的 putAll 方法</span></span><br><span class="line">    <span class="keyword">super</span>.putAll(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面源码，不难看出，我们的数据符合 流程二，但是不符合 流程二-2，所以我们会执行父类的 putAll 方法，即流程三。</p><h3 id="2、分析-AbstractMap-putAll"><a href="#2、分析-AbstractMap-putAll" class="headerlink" title="2、分析 AbstractMap.putAll"></a>2、分析 AbstractMap.putAll</h3><p>TreeMap 继承 AbstractMap，所以 super.putAll(map)，执行的 putAll 为 AbstractMap 的 putAll 方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 m map，将它所有的值，使用put方法，全部添加到当前的map中</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码简单，就是一个遍历添加元素的。</p><p>但是有一个问题，这里的 put 方法执行的是谁的 put 方法呢？</p><ul><li>1、AbstractMap.put</li><li>2、TreeMap.put</li></ul><p>这里大家可以先思考1分钟，然后再继续往下看。</p><p>答案是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行的是 TreeMap.put</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回答错误 or 不知道真实原因的小伙伴，可以去网上搜搜答案，这里是一个很重要的基础知识点哦。</p><h3 id="3、分析-TreeMap-put"><a href="#3、分析-TreeMap-put" class="headerlink" title="3、分析 TreeMap.put"></a>3、分析 TreeMap.put</h3><p>源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、获取根节点</span></span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">// 二、判断跟节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 类型检查 and null 检查</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> TreeMap.Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 三、如果比较器不为空，则执行一下逻辑，即自定义比较器执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 1、将t节点赋值给parent</span></span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 2、比较t节点的key是否与待添加的key相等</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="comment">// 3、如果返回值小于0，则将左子树赋值给t节点，即后续遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="comment">// 4、如果返回值大于0，则将右子树赋值给t节点，即后续遍历右子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 5、如果返回值为0，则覆盖原来的值</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四、如果比较器为空，则执行以下逻辑，即默认执行逻辑</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这部分逻辑，先忽略</span></span><br><span class="line">    &#125;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; e = <span class="keyword">new</span> TreeMap.Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们结合上面的源码和我们自定义的排序器，就可以发现以下问题：</p><p>1、我们比较的是两个 value 的大小，而 value 可能是一样的。</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A81.jpg" alt="比较器1"></p><p>这种情况下，就会覆盖原来的值，这个就是我们执行 putAll 后，元素缺失的原因了。</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A82.jpg" alt="比较器2"></p><p>好了既然问题找到了，那如何解决这个问题呢？</p><p>如果是你，你会怎么解决呢？可以花一分钟时间思考一下，再看后面的内容。</p><h3 id="4、解决-TreeMap-putAll，元素缺失的问题"><a href="#4、解决-TreeMap-putAll，元素缺失的问题" class="headerlink" title="4、解决 TreeMap.putAll，元素缺失的问题"></a>4、解决 TreeMap.putAll，元素缺失的问题</h3><p>我当时想到最直接的方案就是，在 value 相等的情况下，不返回 0，返回1 or -1，这样就可以最简单、最快捷的解决这个问题了。</p><p>修改后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里换了一种写法，是java8的特性，简化了代码（为了偷懒）</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap2 = <span class="keyword">new</span> TreeMap&lt;&gt;((key1, key2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 1、如果v1等于v2，则值为0</span></span><br><span class="line">    <span class="comment">// 2、如果v1小于v2，则值为-1</span></span><br><span class="line">    <span class="comment">// 3、如果v1等于v2，则值为1</span></span><br><span class="line">    Integer value1 = map.get(key1);</span><br><span class="line">    Integer value2 = map.get(key2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value1.compareTo(value2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">treeMap2.putAll(map);</span><br><span class="line">System.out.println(treeMap2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>=<span class="number">10</span>, <span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以发现，3个值都有了，并且是有序的，完美符合需求！好了，关机下班！</p><p><img src="/img/image/blog/20220116/%E5%85%B3%E6%9C%BA%E4%B8%8B%E7%8F%AD.webp" alt="关机下班"></p><p>然而事情并没有结束<strong>（大家可以想一下，这样写会有什么问题呢？）</strong>！</p><h2 id="新的问题出现"><a href="#新的问题出现" class="headerlink" title="新的问题出现"></a>新的问题出现</h2><p>第二天，高高兴兴的写着业务代码、调试逻辑，突然一个<strong>空指针</strong>的报错，出现了。这也太常见了吧，3分钟内解决！</p><p><img src="/img/image/blog/20220116/2000%E5%B9%B4%E4%B9%8B%E5%90%8E.jpeg" alt="2000年之后"></p><p>排查了半天，发现又回到了昨天的修改的那段逻辑了。</p><h3 id="1、TreeMap-get-获取不到值"><a href="#1、TreeMap-get-获取不到值" class="headerlink" title="1、TreeMap.get 获取不到值"></a>1、TreeMap.get 获取不到值</h3><p>简化版代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，key=商品id，value=商品剩余库存</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1L</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2L</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="number">3L</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap2 = <span class="keyword">new</span> TreeMap&lt;&gt;((key1, key2) -&gt; &#123;</span><br><span class="line">    Integer value1 = map.get(key1);</span><br><span class="line">    Integer value2 = map.get(key2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value1.compareTo(value2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap2.putAll(map);</span><br><span class="line">System.out.println(treeMap2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取商品1的剩余数量</span></span><br><span class="line">Integer quantity = treeMap2.get(<span class="number">1L</span>);</span><br><span class="line">System.out.println(quantity);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>=<span class="number">10</span>, <span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个结果令我百思不得其解，只能看看源码咯。</p><h3 id="2、分析-TreeMap-get"><a href="#2、分析-TreeMap-get" class="headerlink" title="2、分析 TreeMap.get"></a>2、分析 TreeMap.get</h3><p>源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据key获取节点</span></span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="comment">// 节点为空则返回null，否则返回节点的 value 值</span></span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、如果比较器不为空，则执行一下逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 1、使用自定义比较器取出key对应的节点</span></span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// 二、如果比较器为空，且key为null，则抛空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">// 三、取出key对应的节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码，我们可以发现，问题肯定就是出现在 getEntryUsingComparator 方法里了。</p><h3 id="2、分析-TreeMap-getEntryUsingComparator"><a href="#2、分析-TreeMap-getEntryUsingComparator" class="headerlink" title="2、分析 TreeMap.getEntryUsingComparator"></a>2、分析 TreeMap.getEntryUsingComparator</h3><p>源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、将key转换成对应的类型</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    K k = (K) key;</span><br><span class="line">    <span class="comment">// 二、获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 三、判断比较器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、遍历map，取出key对应的节点对象</span></span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="comment">// 2、如果小于0，则将左节点的值赋值给p</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="comment">// 3、如果大于0，则将右节点的值赋值给p</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 4、如果等于0，则返回p节点</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合上面的源码，和我们之前自定义的比较器，我们不难发现问题出现在哪里：</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A83.jpg" alt="比较器3"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自定义比较器，没有返回0的情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题找到了，解决吧！<br>加班中，今天到此结束！<br>啊杰，在这里谢谢大家的观看，下次再见。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot;&gt;&lt;a href=&quot;#摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot; class=&quot;headerlink&quot; title=&quot;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot;&gt;&lt;/a&gt;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;1、给一个无序的map，按照value的值进行排序，value值越小，排在越前面。&lt;br&gt;2、key和value都不为null&lt;br&gt;3、value可能相同&lt;br&gt;4、返回结果为一个相同的有序map&lt;/p&gt;
&lt;p&gt;代码如下所示:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 假设，key=商品id，value=商品剩余库存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Map&amp;lt;Long, Integer&amp;gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;2L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;3L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;到这里，大家可以先想想，如果是你会怎么解决？&lt;/p&gt;</summary>
    
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    <category term="Map" scheme="https://www.blog.ajie39.top/tags/Map/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="源码分析" scheme="https://www.blog.ajie39.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Jackson序列化时间类型的数据导致的相关问题</title>
    <link href="https://www.blog.ajie39.top/2021/12/03/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://www.blog.ajie39.top/2021/12/03/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-02T17:17:52.573Z</published>
    <updated>2022-02-04T15:03:56.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。"><a href="#前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。" class="headerlink" title="前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。"></a>前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。</h1><hr><span id="more"></span><h2 id="1、现象"><a href="#1、现象" class="headerlink" title="1、现象"></a>1、现象</h2><p>在开发国际化项目中发现，数据库取出的时间和对象拿到的时间都是一致的，但是通过 postman 调用接口展示的时候，时间和数据库的时间相差8小时。</p><h2 id="2、原因"><a href="#2、原因" class="headerlink" title="2、原因"></a>2、原因</h2><p>SpringBoot 默认使用 Jackson 为序列化工具，Jackson 在没有指定序列化和反序列化形式的情况下，会采用默认的序列化方式。</p><p>其中 date 类型的数据，默认的序列化格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ</span><br><span class="line">例如：</span><br><span class="line"> 2021-06-08T05:43:28.000+0000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中时间的默认时区为UTC+0，在传输的过程中，会以字符串的形式按照上面的格式进行序列化。而国内的时区是 UTC+8，所以最终时间会相差 8小时。</p><p>各个符号解释：</p><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>YYYY</td><td>is the decimal digits of the year 0000 to 9999 in the Gregorian calendar.</td></tr><tr><td>-</td><td>“-“ (hyphen) appears literally twice in the string.</td></tr><tr><td>MM</td><td>is the month of the year from 01 (January) to 12 (December).</td></tr><tr><td>DD</td><td>is the day of the month from 01 to 31.</td></tr><tr><td>T</td><td>“T” appears literally in the string, to indicate the beginning of the time element.</td></tr><tr><td>HH</td><td>is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.</td></tr><tr><td>:</td><td>“:” (colon) appears literally twice in the string.</td></tr><tr><td>mm</td><td>is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.</td></tr><tr><td>ss</td><td>is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.</td></tr><tr><td>.</td><td>“.” (dot) appears literally in the string.</td></tr><tr><td>sss</td><td>is the number of complete milliseconds since the start of the second as three decimal digits.</td></tr><tr><td>Z</td><td>is the time zone offset specified as “Z” (for UTC) or either “+” or “-“ followed by a time expression HH:mm</td></tr></tbody></table><h2 id="3、解决"><a href="#3、解决" class="headerlink" title="3、解决"></a>3、解决</h2><h3 id="①前端拿到这样的数据的时候，需要做如下处理："><a href="#①前端拿到这样的数据的时候，需要做如下处理：" class="headerlink" title="①前端拿到这样的数据的时候，需要做如下处理："></a>①前端拿到这样的数据的时候，需要做如下处理：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Date(&#39;2021-06-08T05:43:28.000+0000&#39;)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">moment(date).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化前后的区别：</p><p><img src="/img/image/blog/20220204/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt="格式化后的效果"></p><h3 id="②如果使用-Fegin-Client"><a href="#②如果使用-Fegin-Client" class="headerlink" title="②如果使用 Fegin Client"></a>②如果使用 Fegin Client</h3><p>需要确认服务端的时间格式，如果没有指定格式，则使用默认格式。</p><p>具体使用：在对应字段加上 @JsonFormat 注解即可，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING, pattern &#x3D; &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;)</span><br><span class="line">private Date inserttime;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="③SpringBoot-全局配置-JsonFormat-date的序列化方式"><a href="#③SpringBoot-全局配置-JsonFormat-date的序列化方式" class="headerlink" title="③SpringBoot 全局配置 JsonFormat date的序列化方式"></a>③SpringBoot 全局配置 JsonFormat date的序列化方式</h3><p>在 application.yml 文件加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ssZ</span><br><span class="line">  mvc:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ssZ</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、其他问题"><a href="#4、其他问题" class="headerlink" title="4、其他问题"></a>4、其他问题</h2><p>①支持 Java 8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-datatype-jsr310&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在添加 JSR-310 模块后, 让 jackson 能够识别出 Java 8 的日期 &amp; 时间类型(pom.xml)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/aerchi/article/details/78717232">https://blog.csdn.net/aerchi/article/details/78717232</a></p><p><a href="https://xiaoym.gitee.io/2021/03/26/spring-boot-code-action-jackson/">https://xiaoym.gitee.io/2021/03/26/spring-boot-code-action-jackson/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。&quot;&gt;&lt;a href=&quot;#前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。&quot; class=&quot;headerlink&quot; title=&quot;前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。&quot;&gt;&lt;/a&gt;前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Jackson" scheme="https://www.blog.ajie39.top/tags/Jackson/"/>
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>算法--排序奇升偶降链表</title>
    <link href="https://www.blog.ajie39.top/2021/11/21/%E6%8E%92%E5%BA%8F%E5%A5%87%E5%8D%87%E5%81%B6%E9%99%8D%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.blog.ajie39.top/2021/11/21/%E6%8E%92%E5%BA%8F%E5%A5%87%E5%8D%87%E5%81%B6%E9%99%8D%E9%93%BE%E8%A1%A8/</id>
    <published>2021-11-21T07:36:47.986Z</published>
    <updated>2021-11-21T07:47:42.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分"><a href="#摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分" class="headerlink" title="摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分"></a>摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分</h1><hr><h1 id="前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。"><a href="#前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。" class="headerlink" title="前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。"></a>前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。</h1><p>输入: 1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;NULL</p><p>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL</p><hr><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：根据奇偶顺序，将链表拆分成两个链表</p><p>第二步：将偶链表，翻转，变成升序链表(这部分可以优化，在第一步拆分链表时，就将链表翻转)</p><p>第三步：排序两个链表</p><p>leetcode 类似题目：</p><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">奇偶链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></p><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ListNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;val=&quot;</span> + val +</span><br><span class="line">                <span class="string">&quot;, next=&quot;</span> + next +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;NULL</span></span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">8</span>,</span><br><span class="line">                <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">6</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>,</span><br><span class="line">                        <span class="keyword">new</span> ListNode(<span class="number">7</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>))))))));</span><br><span class="line">        sortList(listNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">sortList</span><span class="params">(ListNode root)</span> </span>&#123;</span><br><span class="line">        ListNode rootNode = <span class="keyword">new</span> ListNode(root.val, root.next);</span><br><span class="line">        ListNode leftRoot = <span class="keyword">null</span>;</span><br><span class="line">        ListNode leftTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode rightRoot = <span class="keyword">null</span>;</span><br><span class="line">        ListNode rightTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分成两个链表</span></span><br><span class="line">        <span class="keyword">while</span> (rootNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 找出奇数链表</span></span><br><span class="line">                <span class="keyword">if</span> (leftRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    leftTemp.val = rootNode.val;</span><br><span class="line">                    leftRoot = leftTemp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    leftTemp.next = <span class="keyword">new</span> ListNode(rootNode.val);</span><br><span class="line">                    leftTemp = leftTemp.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rightRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rightTemp.val = rootNode.val;</span><br><span class="line">                    rightRoot = rightTemp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 找出偶数链表并翻转链表</span></span><br><span class="line">                    rightRoot = <span class="keyword">new</span> ListNode(rootNode.val, rightTemp);</span><br><span class="line">                    rightTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">                    rightTemp.val = rightRoot.val;</span><br><span class="line">                    rightTemp.next = rightRoot.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rootNode = rootNode.next;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表排序</span></span><br><span class="line">        rootNode = <span class="keyword">null</span>;</span><br><span class="line">        ListNode rootTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> leftNum = leftRoot.val;</span><br><span class="line">               <span class="keyword">if</span> (rightRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">int</span> rightNum = rightRoot.val;</span><br><span class="line">                   <span class="keyword">if</span> (leftNum &gt; rightNum) &#123;</span><br><span class="line">                       ListNode[] listArr = getNode(rootNode, rootTemp, rightRoot);</span><br><span class="line">                       rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">                       rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">                       rightRoot = rightRoot.next;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               ListNode[] listArr = getNode(rootNode, rootTemp, leftRoot);</span><br><span class="line">               rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">               rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">               leftRoot = leftRoot.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode[] listArr = getNode(rootNode, rootTemp, rightRoot);</span><br><span class="line">                rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">                rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">                rightRoot = rightRoot.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rootNode);</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode[] getNode(ListNode rootNode, ListNode rootTemp, ListNode transferNode) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = transferNode.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rootTemp.val = num;</span><br><span class="line">            rootNode = rootTemp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rootTemp.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            rootTemp = rootTemp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;rootNode, rootTemp&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot;&gt;&lt;a href=&quot;#摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot; class=&quot;headerlink&quot; title=&quot;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot;&gt;&lt;/a&gt;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot;&gt;&lt;a href=&quot;#前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot; class=&quot;headerlink&quot; title=&quot;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot;&gt;&lt;/a&gt;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&lt;/h1&gt;&lt;p&gt;输入: 1-&amp;gt;8-&amp;gt;3-&amp;gt;6-&amp;gt;5-&amp;gt;4-&amp;gt;7-&amp;gt;2-&amp;gt;NULL&lt;/p&gt;
&lt;p&gt;输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;NULL&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://www.blog.ajie39.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试题目总结（非完整版，待补充）</title>
    <link href="https://www.blog.ajie39.top/2021/11/14/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2021/11/14/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-14T07:21:41.423Z</published>
    <updated>2022-04-27T14:30:29.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言：主要总结这段时间遇到过的常见面试题目。"><a href="#前言：主要总结这段时间遇到过的常见面试题目。" class="headerlink" title="前言：主要总结这段时间遇到过的常见面试题目。"></a>前言：主要总结这段时间遇到过的常见面试题目。</h1><hr><h2 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h2><ul><li>Java 基础</li><li>算法</li><li>多线程</li><li>计算机网络</li><li>JVM</li><li>Mysql</li><li>Redis</li><li>消息中间件：Kafka、RabbitMQ</li><li>SpringBoot、SpringCloud</li><li>分布式系统</li><li>高可用系统</li><li>开放性题目</li></ul><span id="more"></span><h2 id="二、Java-基础"><a href="#二、Java-基础" class="headerlink" title="二、Java 基础"></a>二、Java 基础</h2><ul><li>1、Objects.equals(3L, 3) 返回结果是什么，为什么?</li><li>2、Java 的基本类型有哪些，分别占多少个字符。</li><li>3、重载、重写的区别？</li><li>4、什么时候继承父类？什么时候实现接口？</li><li>5、对象的创建过程。</li><li>6、常见的集合有哪些？它们都有哪些特性？</li><li>7、HashMap 和 HashTable 的区别？</li><li>8、HashTable 为什么是安全的？</li><li>9、Hashtable、ConcurrentHashMap、TreeMap</li><li>10、ArrayList</li><li>11、什么是双亲委派机制（类加载）？</li><li>12、什么是反射机制？反射机制的使用场景有哪些？</li><li>13、Java 8的新特性有哪些？</li></ul><h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><ul><li>冒泡排序、快速排序</li><li>链表翻转</li><li>给一个链表，奇数位为升序，偶数位是降序，从小到大排序。</li><li>如何判断一个链表中是否有环？</li><li>找出两个链表的交点。</li><li>有100杯咖啡，小A一次拿2杯，小B一次拿3杯，使用Java多线程模拟该场景，打印出每次拿完咖啡后，剩余的咖啡数量。</li></ul><p>必刷 LeetCode 题目：</p><ul><li>LeetCode 001. Two Sum</li><li>LeetCode 015. 3Sum (可能会问 LeetCode 18. 4Sum 思路)</li><li>LeetCode 020. Valid Parentheses</li><li>LeetCode 021. Merge Two Sorted Lists</li><li>LeetCode 025. Reverse Nodes in k-Group</li><li>LeetCode 053. Maximum Subarray</li><li>LeetCode 066. Plus One（等价于：高精度加法）</li><li>LeetCode 098. Validate Binary Search Tree</li><li>LeetCode 110. Balanced Binary Tree</li><li>LeetCode 134. Gas Station</li><li>LeetCode 136. Single Number</li><li>LeetCode 137. Single Number II</li><li>LeetCode 146. LRU Cache（变形题：带有过期时间的 LRU 缓存）</li><li>LeetCode 206. Reverse Linked List</li><li>LeetCode 215. Kth Largest Element in an Array（等价于：快速排序）</li><li>LeetCode 232. Implement Queue using Stacks</li><li>LeetCode 328. Odd Even Linked List</li><li>LeetCode 415. Add Strings（等价于：大数加法）</li><li>LeetCode 470：rand7() rand10()</li><li>LeetCode 496. Next Greater Element I（时间复杂度O(n)）</li><li>LeetCode 716. Max Stack（两个栈实现最大栈，要求 pop，push，get_max 都为O(1)）</li><li>LeetCode 860. Lemonade Change</li><li>LeetCode 862. Shortest Subarray with Sum at Least K</li><li>LeetCode 876. Middle of the Linked List</li><li>LeetCode 946. Validate Stack Sequences</li></ul><p>字节算法汇总：<a href="https://leetcode-cn.com/circle/discuss/nBoYGv/">https://leetcode-cn.com/circle/discuss/nBoYGv/</a></p><h2 id="四、多线程"><a href="#四、多线程" class="headerlink" title="四、多线程"></a>四、多线程</h2><ul><li>1、什么是线程？什么事进程？</li><li>2、CAS是什么，用来解决什么问题？</li><li>3、什么是 BIO？什么是 NIO？两者的区别是什么</li><li>4、AQS</li></ul><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><ul><li>1、三次握手、四次挥手</li><li>2、IO模型：NIO、BIO 多路复用</li><li>3、多路复用</li></ul><h2 id="六、JVM"><a href="#六、JVM" class="headerlink" title="六、JVM"></a>六、JVM</h2><ul><li>1、JVM 内存模型</li><li>2、垃圾回收算法有哪些？</li><li>3、jvm 复制算法、标记算法</li><li>4、垃圾回收器</li></ul><h2 id="七、Mysql"><a href="#七、Mysql" class="headerlink" title="七、Mysql"></a>七、Mysql</h2><p>在线练习sql，地址：<a href="https://sqlzoo.net/wiki/SELECT_basics/zh">https://sqlzoo.net/wiki/SELECT_basics/zh</a></p><ul><li>1、有哪些数据库引擎</li><li>2、事务的隔离级别</li><li>3、mysql是如何实现对应的事务隔离级别的</li><li>4、索引优化</li><li>5、哪些情况不走索引</li><li>6、执行一条sql查询的整个过程</li><li>7、如何实现可重复读</li></ul><h2 id="八、Redis"><a href="#八、Redis" class="headerlink" title="八、Redis"></a>八、Redis</h2><ul><li>1、redis 基础数据结构</li><li>2、redis 数据结构的底层实现</li><li>3、redis 持久化方式</li><li>4、AOF追加写操作，文件超过阈值，会如何处理</li><li>5、AOF重写机制</li><li>6、动态字符串的底层实现</li><li>7、redis 使用场景</li></ul><h2 id="九、消息中间件"><a href="#九、消息中间件" class="headerlink" title="九、消息中间件"></a>九、消息中间件</h2><p>Kafka、RabbitMQ</p><ul><li>1、生产一条消息的整个过程</li><li>2、kafka 的存储</li><li>3、kafka 中的一些基本概念</li><li>4、kafka 消费一条消息的过程</li><li>5、kafka 如何保证消息不丢的</li><li>6、生产一条消息的整个过程</li></ul><h2 id="十、SpringBoot、SpringCloud"><a href="#十、SpringBoot、SpringCloud" class="headerlink" title="十、SpringBoot、SpringCloud"></a>十、SpringBoot、SpringCloud</h2><ul><li>1、SpringBoot的启动过程</li><li>2、Spring 中的 SPI 机制是什么？</li><li>3、JDK、Dubbo、Spring 三种 SPI 机制，谁更好？</li><li>4、Spring 自定义注解的实现原理</li></ul><h2 id="十一、分布式系统"><a href="#十一、分布式系统" class="headerlink" title="十一、分布式系统"></a>十一、分布式系统</h2><ul><li>1、分布式事务</li><li>2、微服务相关内容</li><li>3、服务注册发现</li><li>4、GRPC</li></ul><h2 id="十二、高可用系统"><a href="#十二、高可用系统" class="headerlink" title="十二、高可用系统"></a>十二、高可用系统</h2><h2 id="十三、开放性题目"><a href="#十三、开放性题目" class="headerlink" title="十三、开放性题目"></a>十三、开放性题目</h2><ul><li>1、介绍一下自己</li><li>2、项目经历<ul><li>项目中难点、有意思的点</li><li>项目中用到的中间件</li><li>设计思路</li></ul></li><li>3、离职原因</li><li>4、内存占用 100% 排查问题</li><li>5、并发高，会造成什么问题</li><li>6、堆栈溢出</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul><li><a href="https://www.cnblogs.com/rocker-pg/p/11635414.html">MySQL索引_组合索引和单列索引</a></li><li>单列索引和组合索引效率问题</li><li>聚簇索引和非聚簇索引</li><li><a href="https://www.php.cn/mysql-tutorials-483811.html">深入了解MySQL中的组合索引，看看与单列索引的区别</a></li><li><a href="https://juejin.cn/post/6844904180440629262">MySQL是如何实现可重复读的</a></li><li><a href="https://zhuanlan.zhihu.com/p/166152616">MySQL 的可重复读到底是怎么实现的？图解 ReadView 机制</a></li><li><a href="https://www.cnblogs.com/mengxinJ/p/14045520.html">一条 sql 的执行过程详解</a></li><li><a href="https://cloud.tencent.com/developer/article/1635488">一条查询SQL的执行过程</a></li><li>mysql 事务隔离级别，及其实现原理</li></ul><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><ul><li><a href="https://segmentfault.com/a/1190000040633029">7张图了解kafka基本概念</a></li><li><a href="https://zhuanlan.zhihu.com/p/366375032">Kafka概念和基本架构</a></li><li><a href="https://segmentfault.com/a/1190000039125247">怎么理解 Kafka 消费者与消费组之间的关系?</a></li><li><a href="https://segmentfault.com/a/1190000037689992">(三)Kafka的生产者原理及使用详解</a></li><li><a href="https://www.zhenchao.org/categories/kafka/">blog-Kafka</a></li><li><a href="https://cloud.tencent.com/developer/article/1618180">Kafka精进 | 一文读懂Producer消息发送机制</a></li><li><a href="https://www.cnblogs.com/frankdeng/p/9310704.html">Kafka（三）Kafka的高可用与生产消费过程解析</a></li><li><a href="https://dunwu.github.io/bigdata-tutorial/kafka/Kafka%E6%B6%88%E8%B4%B9%E8%80%85.html#_1-%E6%B6%88%E8%B4%B9%E8%80%85%E7%AE%80%E4%BB%8B">Kafka 消费者</a></li></ul><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul><li><a href="https://segmentfault.com/a/1190000039208726">Redis专题：万字长文详解持久化原理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言：主要总结这段时间遇到过的常见面试题目。&quot;&gt;&lt;a href=&quot;#前言：主要总结这段时间遇到过的常见面试题目。&quot; class=&quot;headerlink&quot; title=&quot;前言：主要总结这段时间遇到过的常见面试题目。&quot;&gt;&lt;/a&gt;前言：主要总结这段时间遇到过的常见面试题目。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、目录&quot;&gt;&lt;a href=&quot;#一、目录&quot; class=&quot;headerlink&quot; title=&quot;一、目录&quot;&gt;&lt;/a&gt;一、目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java 基础&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;计算机网络&lt;/li&gt;
&lt;li&gt;JVM&lt;/li&gt;
&lt;li&gt;Mysql&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;消息中间件：Kafka、RabbitMQ&lt;/li&gt;
&lt;li&gt;SpringBoot、SpringCloud&lt;/li&gt;
&lt;li&gt;分布式系统&lt;/li&gt;
&lt;li&gt;高可用系统&lt;/li&gt;
&lt;li&gt;开放性题目&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何写容易测试的代码（结尾附带单元测试神器推荐）</title>
    <link href="https://www.blog.ajie39.top/2021/10/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E5%8F%A6%E6%9C%89%E7%A5%9E%E5%99%A8%E5%88%86%E4%BA%AB%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/10/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E5%8F%A6%E6%9C%89%E7%A5%9E%E5%99%A8%E5%88%86%E4%BA%AB%EF%BC%89/</id>
    <published>2021-10-24T16:13:02.000Z</published>
    <updated>2021-12-13T16:24:00.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。"><a href="#摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。" class="headerlink" title="摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。"></a>摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。</h1><hr><h1 id="前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。"><a href="#前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。" class="headerlink" title="前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。"></a>前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。</h1><hr><span id="more"></span><h2 id="关于单元测试"><a href="#关于单元测试" class="headerlink" title="关于单元测试"></a>关于单元测试</h2><h3 id="一、什么是单元测试？"><a href="#一、什么是单元测试？" class="headerlink" title="一、什么是单元测试？"></a>一、什么是单元测试？</h3><p>单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p><p>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是必须的，但也不坏，这牵涉到项目管理的政策决定。</p><p><strong>总结：对于程序单元（软件设计的最小单位）进行正确性检验。</strong></p><h3 id="二、关于编写单元测试的一些声音"><a href="#二、关于编写单元测试的一些声音" class="headerlink" title="二、关于编写单元测试的一些声音"></a>二、关于编写单元测试的一些声音</h3><p>不愿写单元测试的人，千篇一律——这里收集了一些网友们不愿意写单元测试的原因：</p><ul><li>开发时间太紧张了，还要写单元测试？没时间呀！！！有时间我也愿意写。</li><li>我直接进行接口测试、功能测试、集成测试、系统测试。。。不就行了，速度快，而且效率高，要写啥单元测试。</li><li>有测试工程师了，我要写啥单元测试，让测试工程师测试不就好了，分工明确。</li><li>单元测试仅仅是证明这些代码做了什么，写了没有意义呀，这些代码都是我写的，我知道它们是做什么的。</li><li>测试代码的正确性，是测试工程师的工作，如果我找出了所有问题，我的工资可以翻倍吗？</li><li>我在开发环境发布后，通过测试业务，来验证我代码的正确性就好了，不需要通过单元测试。</li></ul><p>总结：</p><ul><li>开发时间太紧张，写单元测试太耗费时间。</li><li>有其他测试流程做了单元测试做的事情，没必要重复劳动。</li><li>开发工程师负责开发，测试工程师负责测试。</li><li>写单元测试对于我没有收益。</li><li>我可以直接执行代码，来验证正确性，没必要通过单元测试。</li><li>代码都是我写的，我知道是做什么的，写单元测试没有意义。</li></ul><h3 id="二、单元测试的好处"><a href="#二、单元测试的好处" class="headerlink" title="二、单元测试的好处"></a>二、单元测试的好处</h3><h4 id="1、适应变更"><a href="#1、适应变更" class="headerlink" title="1、适应变更"></a>1、适应变更</h4><p>单元测试允许程序员在未来重构代码，并且确保模块依然工作正确（复合测试）。这个过程就是为所有函数和方法编写单元测试，一旦变更导致错误发生，借助于单元测试可以快速定位并修复错误。</p><p>可读性强的单元测试可以使程序员方便地检查代码片断是否依然正常工作。良好设计的单元测试案例覆盖程序单元分支和循环条件的所有路径。</p><p>在连续的单元测试环境，通过其固有的持续维护工作，单元测试可以延续用于准确反映当任何变更发生时可执行程序和代码的表现。借助于上述开发实践和单元测试的覆盖，可以分分秒秒维持准确性。</p><p>总结：</p><ul><li>代码变更后，快速的验证业务逻辑是否正确，快速定位问题。一定程度上，缓解不敢更改老旧逻辑的情况。</li></ul><h4 id="2、简化集成"><a href="#2、简化集成" class="headerlink" title="2、简化集成"></a>2、简化集成</h4><p>单元测试消除程序单元的不可靠，采用自底向上的测试路径。通过先测试程序部件再测试部件组装，使集成测试变得更加简单。</p><p>业界对于人工集成测试的必要性存在较大争议。尽管精心设计的单元测试体系看上去实现了集成测试，因为集成测试需要人为评估一些人为因素才能证实的方面，单元测试替代集成测试不可信。一些人认为在足够的自动化测试系统的条件下，人力集成测试组不再是必需的。事实上，真实的需求最终取决于开发产品的特点和使用目标。另外，人工或手动测试很大程度上依赖于组织的可用资源。</p><p>总结：</p><ul><li>在开发过程中，可以屏蔽部分外部依赖，验证程序的正确性。</li></ul><h4 id="3、文档记录"><a href="#3、文档记录" class="headerlink" title="3、文档记录"></a>3、文档记录</h4><p>单元测试提供了系统的一种文档记录。借助于查看单元测试提供的功能和单元测试中如何使用程序单元，开发人员可以直观的理解程序单元的基础API。</p><p>单元测试具体表现了程序单元成功的关键特点。这些特点可以指出正确使用和非正确使用程序单元，也能指出需要捕获的程序单元的负面表现（译注：异常和错误）。尽管很多软件开发环境不仅依赖于代码做为产品文档，在单元测试中和单元测试本身确实文档化了程序单元的上述关键特点。</p><p>另一方面，传统文档易受程序本身实现的影响，并且时效性难以保证（如设计变更、功能扩展等在不太严格时经常不能保持文档同步更新）。</p><ul><li>有助于他人或者自己（在自己遗忘的情况下）快速了解业务逻辑。</li></ul><h4 id="4、表达设计（测试驱动开发）"><a href="#4、表达设计（测试驱动开发）" class="headerlink" title="4、表达设计（测试驱动开发）"></a>4、表达设计（测试驱动开发）</h4><p>在测试驱动开发的软件实践中，单元测试可以取代正式的设计。每一个单元测试案例均可以视为一项类、方法和待观察行为等设计元素。</p><p>不同于其他基于图的设计方法，用单元测试表达设计有一项显著优点：设计文档（单元测试本身）可以用于验证程序实现符合设计。UML可能会遇到这样的问题：尽管图上一个类被命名为Customer，但开发人员可以称其为Wibble，而且系统中没有任何地方会显示出这个差异。基于单元测试设计方法，开发人员不遵循设计要求的解决方案永远不会通过测试。</p><p>当然，单元测试缺乏图的可读性，但UML图可以在自由工具（通常可从IDE扩展获取）中为大多数现代程序语言生成UML图，很难要求采购昂贵的UML设计套装软件。自由工具，类似于基于xUnit框架的工具，测试结果输出到一些可生成供人工识读的图形化工具系统中去。</p><p>总结：</p><ul><li>测试驱动开发，利用单元测试表达接口设计</li></ul><h2 id="如何写好单元测试？"><a href="#如何写好单元测试？" class="headerlink" title="如何写好单元测试？"></a>如何写好单元测试？</h2><p>虚假的标题：如何写好单元测试</p><p>真实的标题：如何写容易测试的代码</p><p>编写单元测试没有任何技巧，只有编写可测试代码的技巧。</p><p><img src="/img/image/blog/20211024/%E9%97%AE%E5%8F%B7.jpeg" alt="问号"></p><p>为什么说编写单元测试没有任何技巧呢？因为单元测试的本质就是验证你代码的正确性，代码如果写的不好、不可被单独测试，那么单元测试也无能为力。单元测试本来就是枯燥的事情，并没有任何捷径。</p><h3 id="一、为什么写容易测试的代码很重要？"><a href="#一、为什么写容易测试的代码很重要？" class="headerlink" title="一、为什么写容易测试的代码很重要？"></a>一、为什么写容易测试的代码很重要？</h3><p>渣男：我在忙，晚点聊</p><p>暖男：我正在开会，大概6.30左右结束，到时候回复你。</p><p>容易测试的代码通常意味：</p><ul><li>更容易理解：更容易理解意图，写出有效的测试case</li><li>更好维护：容易单元测试的代码一般解耦做的更好，便于后期维护</li></ul><p>于是乎，容易测试——》容易理解——》容易维护，三者形成了闭环。</p><p><img src="/img/image/blog/20211024/%E5%AE%B9%E6%98%93%E6%B5%8B%E8%AF%95.png" alt="容易测试"></p><h3 id="二、导致测试不好写的几类问题"><a href="#二、导致测试不好写的几类问题" class="headerlink" title="二、导致测试不好写的几类问题"></a>二、导致测试不好写的几类问题</h3><h4 id="1、复杂的构造函数-or-无参的构造函数"><a href="#1、复杂的构造函数-or-无参的构造函数" class="headerlink" title="1、复杂的构造函数 or 无参的构造函数"></a>1、复杂的构造函数 or 无参的构造函数</h4><p><img src="/img/image/blog/20211024/%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png" alt="复杂的构造函数"></p><h4 id="2、混合业务逻辑和构建依赖对象的逻辑"><a href="#2、混合业务逻辑和构建依赖对象的逻辑" class="headerlink" title="2、混合业务逻辑和构建依赖对象的逻辑"></a>2、混合业务逻辑和构建依赖对象的逻辑</h4><p><img src="/img/image/blog/20211024/%E6%B7%B7%E5%90%88%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%92%8C%E6%9E%84%E5%BB%BA%E4%BE%9D%E8%B5%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%BB%E8%BE%91.png" alt="混合业务逻辑和构建依赖对象的逻辑"></p><h4 id="3、太多、嵌套太深的条件判断语句"><a href="#3、太多、嵌套太深的条件判断语句" class="headerlink" title="3、太多、嵌套太深的条件判断语句"></a>3、太多、嵌套太深的条件判断语句</h4><p><img src="/img/image/blog/20211024/%E5%A4%AA%E5%A4%9A%E3%80%81%E5%B5%8C%E5%A5%97%E5%A4%AA%E6%B7%B1%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5.png" alt="太多、嵌套太深的条件判断语句"></p><h4 id="4、不必要的、太深的继承"><a href="#4、不必要的、太深的继承" class="headerlink" title="4、不必要的、太深的继承"></a>4、不必要的、太深的继承</h4><p><img src="/img/image/blog/20211024/%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E3%80%81%E5%A4%AA%E6%B7%B1%E7%9A%84%E7%BB%A7%E6%89%BF.png" alt="不必要的、太深的继承"></p><h4 id="5、在一个方法内混合纯计算与IO"><a href="#5、在一个方法内混合纯计算与IO" class="headerlink" title="5、在一个方法内混合纯计算与IO"></a>5、在一个方法内混合纯计算与IO</h4><p><img src="/img/image/blog/20211024/%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%86%85%E6%B7%B7%E5%90%88%E7%BA%AF%E8%AE%A1%E7%AE%97%E4%B8%8EIO.png" alt="在一个方法内混合纯计算与IO"></p><h4 id="6、不写毫无价值的单元测试"><a href="#6、不写毫无价值的单元测试" class="headerlink" title="6、不写毫无价值的单元测试"></a>6、不写毫无价值的单元测试</h4><p><img src="/img/image/blog/20211024/%E4%B8%8D%E5%86%99%E6%AF%AB%E6%97%A0%E4%BB%B7%E5%80%BC%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.jpeg" alt="不写毫无价值的单元测试"></p><h3 id="三、让测试更简单的一些建议"><a href="#三、让测试更简单的一些建议" class="headerlink" title="三、让测试更简单的一些建议"></a>三、让测试更简单的一些建议</h3><ul><li>使用依赖注入器(dependency injector), 而不是尝试手动创建 object graph</li><li>坚持单一原则：努力做到能用一句话描述一个 method 的功能</li><li>坚持最少知识原则：只使用直接依赖对象的API，不使用间接依赖对象的API(不要有 .getX().doY())</li><li>警惕使用 static 和 new 关键字</li><li>优先使用组合而不是继承</li><li>使用多态替代复杂的条件语句</li><li>尽量写无副作用的函数</li><li>用 give-when-then（准备、执行、校验） 为每个 test case 做三段式注释</li></ul><h2 id="一些-mock-技巧"><a href="#一些-mock-技巧" class="headerlink" title="一些 mock 技巧"></a>一些 mock 技巧</h2><h3 id="一、推荐使用构造器注入"><a href="#一、推荐使用构造器注入" class="headerlink" title="一、推荐使用构造器注入"></a>一、推荐使用构造器注入</h3><p>推荐阅读文章：</p><p>spring 官方文章：<a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">Setter injection versus constructor injection and the use of @Required</a></p><p>腾讯云专栏：<a href="https://cloud.tencent.com/developer/article/1126880">【Spring】浅谈spring为什么推荐使用构造器注入</a></p><p>使用构造器注入的好处，总结：</p><ul><li>保证依赖不可变（final关键字）</li><li>保证依赖不为空（省去了我们对其检查）</li><li>保证返回客户端（调用）的代码的时候是完全初始化的状态</li><li>避免了循环依赖</li><li>提升了代码的可复用性</li></ul><p>对于单元测试的好处：更容易的 mock 依赖对象</p><h3 id="二、如何mock-Value注解修饰的变量"><a href="#二、如何mock-Value注解修饰的变量" class="headerlink" title="二、如何mock @Value注解修饰的变量"></a>二、如何mock @Value注解修饰的变量</h3><p>参考文章：</p><ul><li><a href="https://my.oschina.net/u/4286379/blog/4455366">编写单测时，使用mock如何解决使用用@Value注解注入的属性</a></li><li><a href="https://stackoverflow.com/questions/23162777/how-do-i-mock-an-autowired-value-field-in-spring-with-mockito">How do I mock an autowired @Value field in Spring with Mockito?</a></li></ul><h3 id="三、如何mock静态方法"><a href="#三、如何mock静态方法" class="headerlink" title="三、如何mock静态方法"></a>三、如何mock静态方法</h3><p>参考文章：</p><ul><li><a href="https://frontbackend.com/java/how-to-mock-static-methods-with-mockito">How to mock static methods with Mockito</a></li><li><a href="https://yanbin.blog/mockito-3-4-0-mock-static-method/">Mockito 3.4.0 开始可 Mock 静态方法</a></li></ul><h3 id="四、如何校验没有返回值的方法"><a href="#四、如何校验没有返回值的方法" class="headerlink" title="四、如何校验没有返回值的方法"></a>四、如何校验没有返回值的方法</h3><p>校验关键逻辑是否都被调用。</p><p><img src="/img/image/blog/20211024/%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="如何校验没有返回值的方法"></p><h2 id="附：单元测试神器"><a href="#附：单元测试神器" class="headerlink" title="附：单元测试神器"></a>附：单元测试神器</h2><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>说起来，这是一个悲伤的故事，公司要求今年第四季度结束前，所有项目的单元测试覆盖率要达到50%。</p><p>于是乎，我开始炸毛了，新项目进度紧张吧，编写单元测试非常耗时，而且还有一堆老旧项目单元测试覆盖率基本为0%，这要慢慢写，不得补到天荒地老？？？？？</p><p>而且在编写单元测试的过程中，其实是有很大一部份内容是重复劳动，作为一名开发者，对于这种重复且量大的工作，肯定第一个想法就是可不可以通过技术手段，减少这部分工作的耗时，以及操作步骤。</p><h3 id="二、神器介绍"><a href="#二、神器介绍" class="headerlink" title="二、神器介绍"></a>二、神器介绍</h3><p><a href="https://weirddev.com/testme/">https://weirddev.com/testme/</a><br><a href="https://squaretest.com/">https://squaretest.com/</a>  付费<br><a href="http://www.evosuite.org/">http://www.evosuite.org/</a><br><a href="https://randoop.github.io/randoop/">https://randoop.github.io/randoop/</a></p><h3 id="三、神器之TestMe"><a href="#三、神器之TestMe" class="headerlink" title="三、神器之TestMe"></a>三、神器之TestMe</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>TestMe 是一款 IntelliJ 插件，用于生成单元测试样板代码。</p><p>TestMe 支持的单元测试模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Unit4 + Mockito</span><br><span class="line">Unit5 + Mockito</span><br><span class="line">TestNG + Mockito</span><br><span class="line">Groovy +Unit4 + Mockito</span><br><span class="line">Spock + Mockito</span><br><span class="line">Spock Parameterized tests+ Mockito</span><br><span class="line">Specs2(Scala) + Mockito</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h5><ul><li>在 Java、Groovy 或 Scala 中自动生成单元测试代码</li><li>为测试类的非原始字段生成模拟</li><li>支持 Mockito 作为 Mock 框架</li><li>支持 JUnit4、JUnit5、TestNG 和 Spock 框架</li><li>为每个可访问的非私有方法生成测试方法，不包括 setter/getter</li><li>为测试方法生成默认输入参数</li><li>生成测试结果断言表达式</li><li>支持的目标测试类语言： Java、Groovy、Scala。</li></ul><p>示例：<br><img src="/img/image/blog/20211024/simple-use-case.gif" alt="&quot;示例&quot;"></p><h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><h5 id="1、-从-IntelliJ-IDEA-中安装最新版本，并重启IDEA"><a href="#1、-从-IntelliJ-IDEA-中安装最新版本，并重启IDEA" class="headerlink" title="1、 从 IntelliJ IDEA 中安装最新版本，并重启IDEA"></a>1、 从 IntelliJ IDEA 中安装最新版本，并重启IDEA</h5><p>在IDEA菜单：Preferences（Ctrl+ Shift+ S） - &gt; Plugins- &gt; Browse repositories…- &gt;搜索：TestMe- &gt;Install Plugin</p><p><img src="/img/image/blog/20211024/TestMe%E6%88%AA%E5%9B%BE01.png" alt="&quot;TestMe截图01&quot;"></p><h5 id="2、生成测试代码模板"><a href="#2、生成测试代码模板" class="headerlink" title="2、生成测试代码模板"></a>2、生成测试代码模板</h5><h6 id="1）选择测试类："><a href="#1）选择测试类：" class="headerlink" title="1）选择测试类："></a>1）选择测试类：</h6><p>选择一个需要测试的类 -》 alt + Insert 跳出如下选择框</p><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%811.png" alt="&quot;生成代码1&quot;"></p><h6 id="2）选择测试工具："><a href="#2）选择测试工具：" class="headerlink" title="2）选择测试工具："></a>2）选择测试工具：</h6><p>并选择 TestMe 后跳出如下选项框</p><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%812.png" alt="&quot;生成代码2&quot;"></p><p>选择你最常用的测试工具即可，我比较常用的是 Unit4 + Mockito，所以我选择的是第一个。</p><h6 id="3）根据生成的测试模板代码修改测试用例"><a href="#3）根据生成的测试模板代码修改测试用例" class="headerlink" title="3）根据生成的测试模板代码修改测试用例"></a>3）根据生成的测试模板代码修改测试用例</h6><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%813.png" alt="&quot;生成代码3&quot;"></p><h5 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h5><p>默认值是为测试的方法参数自动生成的。目前，此行为不可配置。</p><p>作者解释：从某种意义上说，Groovy 测试生成器更健壮，可以使用映射构造函数（在适用时）通过内联 setter 初始化对象。Java 测试生成器尚不支持此类匹配功能，因为为测试参数初始化分配给局部变量会使测试生成模板复杂化。就我个人而言，在进行单元测试时，我总是建议使用 Groovy 而不是 Java。如果您还没有过渡到 Groovy作为您选择的测试代码语言 - 现在是开始的好时机:)</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">维基百科–单元测试</a></p><p><a href="https://testing.googleblog.com/2008/08/by-miko-hevery-so-you-decided-to.html">Writing Testable Code</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot;&gt;&lt;a href=&quot;#摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot; class=&quot;headerlink&quot; title=&quot;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot;&gt;&lt;/a&gt;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot;&gt;&lt;a href=&quot;#前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot; class=&quot;headerlink&quot; title=&quot;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot;&gt;&lt;/a&gt;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="测试" scheme="https://www.blog.ajie39.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="https://www.blog.ajie39.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="开发基础" scheme="https://www.blog.ajie39.top/tags/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（基础篇）</title>
    <link href="https://www.blog.ajie39.top/2021/06/29/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/06/29/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</id>
    <published>2021-06-29T15:25:40.000Z</published>
    <updated>2021-12-13T16:21:40.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（拓展篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（进阶篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、Redis 是什么?<br>2、Redis 的数据类型？<br>3、Redis 是单进程单线程的？<br>4、Redis 的持久化机制有哪些？各自的优缺点？<br>5、Redis 常见性能问题和解决方案：<br>6、Redis 过期键的删除策略？<br>7、Redis 的回收策略（淘汰策略）?<br>8、为什么 Redis 需要把所有数据放到内存中？<br>9、Redis 支持的 Java 客户端都有哪些？<br>10、Jedis 与 Redisson 对比有什么优缺点？<br>12、Pipeline 有什么好处，为什么要用 pipeline？<br>13、怎么理解 Redis 事务？<br>16、Redis 事务相关的命令有哪几个？<br>17、Redis key 的过期时间和永久有效分别怎么设置？<br>18、Redis 如何做内存优化？<br>20、Redis 回收进程如何工作的？<br>21、都有哪些办法可以降低 Redis 的内存使用情况呢？<br>22、Redis 的内存用完了会发生什么？<br>24、查看 Redis 使用情况及状态信息用什么命令？<br>25、怎么测试 Redis 的连通性？<br>28、修改配置不重启 Redis 会实时生效吗？<br>29、使用过 Redis 分布式锁么，它是什么回事？<br>30、使用过 Redis 做异步队列么，你是怎么用的？<br>31、Redis 最适合的场景？</p><h2 id="1、Redis-是什么？"><a href="#1、Redis-是什么？" class="headerlink" title="1、Redis 是什么？"></a>1、Redis 是什么？</h2><p>Redis 是一个 <code>远程内存数据库</code>，它不仅性能强劲，而且还具有 <code>复制特性</code> 以及 <code>为解决问题而生</code> 的独一无二的数据模型。Redis提供了 <code>5种不同类型的数据结构</code>，它可以存储键 (key) 与 5种不同类型的值 (value) 之间的映射(mapping)；可以将存储在内存的键值对数据待久化到硬盘，可以 <code>使用复制特性来扩展读性能</code>，还可以使用 <code>客户端分片来扩展写性能</code>，各式各样的问题都可以很自然地映射到这些数据结构上：Redis的数据结构致力千帮助用户解决问题，而不会像其他数据库那样，要求用户扭曲问题来适应数据库。除此之外，通过 <code>复制</code>、 <code>持久化(persistence)</code> 和 <code>客户端分片(client-side sharding)</code> 等特性，用户可以很方便地将 Redis 扩展成一个能够包含数百GB数据、 每秒处理上百万次请求的系统。</p><h2 id="2、Redis-的数据类型？"><a href="#2、Redis-的数据类型？" class="headerlink" title="2、Redis 的数据类型？"></a>2、Redis 的数据类型？</h2><p>Redis 数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：</p><ul><li>数据库 <code>键</code> 总是一个 <code>字符串对象（string object）</code>；</li><li>Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为 <code>String</code> (字符串)、 <code>List</code> （列表）、<code>Set</code>（集合）、<code>Hash</code>（散列）、<code>Zset</code>（有序集合）。</li></ul><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>String（字符串）</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作。</td></tr><tr><td>List（列表）</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素。</td></tr><tr><td>Set（集合）</td><td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td><td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素。</td></tr><tr><td>Hash（散列）</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对。</td></tr><tr><td>Zset（有序集合）</td><td>字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围或者成员来获取元素。</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1) 简单动态字符串"></a>1) 简单动态字符串</h4><p>​        Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称C<br>字符串），而是自己构建了一种名为 <code>简单动态字符串（simple dynamic string，SDS）</code>的抽象<br>类型，并将 SDS 用作 Redis 的<code>默认字符串</code>表示。</p><p>​        当 Redis 需要的不仅仅是一个字符串字面量，而是一个可以<code>被修改的字符串值</code>时，Redis<br>就会使用 SDS 来表示字符串值，比如在 Redis 的数据库里面，包含字符串值的键值对在底<br>层都是由 SDS 实现的。除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区（buffer）：AOF 模块中的 AOF 缓冲区，以及客户端状态中的输入缓冲区，都是由 SDS 实现的。</p><h4 id="2-SDS-的定义"><a href="#2-SDS-的定义" class="headerlink" title="2) SDS 的定义"></a>2) SDS 的定义</h4><p>SDS 的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">// 记录buf 数组中已使用字节的数量</span></span><br><span class="line"><span class="comment">// 等于SDS 所保存字符串的长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 记录buf 数组中未使用字节的数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图展示了一个 SDS 示例：</p><p><img src="/img/image/blog/20210505/SDS%E7%A4%BA%E4%BE%8B.png" alt="SDS示例"></p><ul><li>free 属性的值为0，表示这个 SDS 没有分配任何未使用空间。</li><li>len 属性的值为5，表示这个 SDS 保存了一个五字节长的字符串。</li><li>buf 属性是一个 <code>char 类型的数组</code>，数组的前五个字节分别保存了 ‘R’、’e’、’d’、’i’、’s’ 五个字符，而最后一个字节则保存了空字符 ‘\0’。</li></ul><p>SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的1 字节空间不计算在SDS 的 len 属性里面，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由SDS 函数自动完成的，所以这个空字符对于 SDS 的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分C 字符串函数库里面的函数。</p><h4 id="3-C-字符串和-SDS-之间的区别"><a href="#3-C-字符串和-SDS-之间的区别" class="headerlink" title="3) C 字符串和 SDS 之间的区别"></a>3) C 字符串和 SDS 之间的区别</h4><table><thead><tr><th align="center">C 字符串</th><th align="center">SDS</th></tr></thead><tbody><tr><td align="center">获取字符串长度的复杂度为O(N)</td><td align="center">获取字符串长度的复杂度为O(1)</td></tr><tr><td align="center">API 是不安全的，可能会造成缓冲区溢出</td><td align="center">API 是安全的，不会造成缓冲区溢出</td></tr><tr><td align="center">修改字符串长度N 次<code>必然</code>需要执行N 次内存重分配</td><td align="center">修改字符串长度N 次<code>最多</code>需要执行N 次内存重分配</td></tr><tr><td align="center">只能保存文本数据</td><td align="center">可以保存文本或者二进制数据</td></tr><tr><td align="center">可以使用所有&lt;string.h&gt; 库中的函数</td><td align="center">可以使用一部分&lt;string.h&gt; 库中的函数</td></tr></tbody></table><h4 id="4-C-字符串和-SDS-之间的区别"><a href="#4-C-字符串和-SDS-之间的区别" class="headerlink" title="4) C 字符串和 SDS 之间的区别"></a>4) C 字符串和 SDS 之间的区别</h4><p>比起C 字符串，SDS 具有以下优点：</p><ul><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出（空间预分配）。</li><li>减少修改字符串长度时所需的内存重分配次数（惰性空间释放）。</li><li>二进制安全。</li><li>兼容部分C 字符串函数。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>在 Redis 5.0 版本引入了一个新的数据类型–Streams(流信息)。它支持消费者组，借鉴 Kafka 设计的支持多播的可持久化消息队列(支持 group，不支持 partition)。</li><li>其他的数据类型的具体内容，这里就不在进行过多的展开了，后面会补上相关文章。</li><li>各个数据类型的存储最大存储大小：<ul><li>String：最大可以存储512M。</li><li>List：元素个数最多为 2^32-1 个，即 4294967295 个。</li><li>Set：元素个数最多为 2^32-1 个，即 4294967295 个。</li><li>Hash：键值对个数最多为 2^32-1 个，即 4294967295 个。</li><li>Zset：同 Sets。</li></ul></li></ul><h2 id="3、Redis-是单进程单线程的？"><a href="#3、Redis-是单进程单线程的？" class="headerlink" title="3、Redis 是单进程单线程的？"></a>3、Redis 是单进程单线程的？</h2><p>​        <code>Redis 服务器</code>使用<code>单线程单进程</code>的方式来处理命令请求， 并与多个客户端进行网络通信。Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><p>​        Redis 服务器是典型的一对多服务器程序： 一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求， 而服务器则接收并处理客户端发送的命令请求， 并向客户端返回命令回复。</p><p>​        对于每个与服务器进行连接的客户端， 服务器都为这些客户端建立了相应的 redis.h/ redisClient 结构（客户端状态），这个结构保存了客户端当前的状态信息． 以及执行相关功能时需要用到的数据结构， 其中包括：</p><ul><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值 (flag)。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制(soft limit) 的时间。</li></ul><p>​    Redis 服务器状态结构的 clients 属性是一个链表。这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历 clients 链表来完成。</p><p>关于 Redis 单线程的相关问题，因为内容较多，全部写到该篇文章中不太合适，所以这里重新写了一篇文章来进行总结 ：</p><p><a href="https://www.blog.ajie39.top/2021/05/08/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84">Redis 是单线程的？？？？你别唬我，我可不是厦（吓）大的</a></p><h2 id="4、Redis-的持久化机制有哪些？各自的优缺点？"><a href="#4、Redis-的持久化机制有哪些？各自的优缺点？" class="headerlink" title="4、Redis 的持久化机制有哪些？各自的优缺点？"></a>4、Redis 的持久化机制有哪些？各自的优缺点？</h2><p>​        Redis 是一个内存数据库，数据都存储在内存中，这也是 Redis 非常快的原因之一。虽然速度提上来了，但是如果数据一直放在内存中，是非常容易丢失的。比如服务器关闭或宕机了，内存中的数据就丢失了。为了解决这一问题，Redis 提供了持久化机制。一种是 RDB 持久化（<strong>原理是将Redis 在内存中的数据库记录定时dump到磁盘上</strong>），另一种是 AOF (append only file) 持久化，（<strong>原理是将 Redis 的操作日志以追加的方式写入文件</strong>）。两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。</p><h4 id="1）RDB（默认）"><a href="#1）RDB（默认）" class="headerlink" title="1）RDB（默认）"></a>1）RDB（默认）</h4><p>RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照 (point-in-time snapshot)。</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><img src="/img/image/blog/20210505/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="RDB持久化过程"></p><p><strong>RDB存在哪些优势？</strong></p><ol><li>一旦采用该方式，那么你的整个 Redis 数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松地将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样可以极大地避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ol><p><strong>RDB的劣势？</strong></p><ol><li>如果你想保证数据的高可用性，即最大限度地避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据将丢失。</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至1秒钟。</li></ol><h4 id="2）AOF"><a href="#2）AOF" class="headerlink" title="2）AOF"></a>2）AOF</h4><p>AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。</p><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF进行重写<strong>，</strong>重写后的新 AOF 文件包含了恢复当前数据集所需的<strong>最小命令集合</strong>。</p><p>AOF 持久化以日志的形式记录服务器所处理的每一个写、删操作（注意查询操作不会被记录）。以文本的方式记录，可以打开文件看到详细的操作记录。</p><p><img src="/img/image/blog/20210505/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="AOF持久化过程"></p><p><strong>AOF的优势？</strong></p><ol><li>该机制可以带来更高的数据安全性，即数据持久性。Redis 中提供了3种同步策略，及每秒同步，每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率非常高。所差的是一旦系统出现宕机现象，那么这一秒种之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，大家都能正确的理解它。</li><li>由于该机制对日志文件的写入操作采用的是 append（在被选元素的结尾插入指定内容） 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。</li><li>如果日志文件过大，Redis可以自动启动 rewrite 机制。即 Reids 以 append 模式不断地修改数据并写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行切换时可以更高的保证数据安全性。</li><li>AOF 包含一个格式清晰，易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ol><p><strong>AOF的劣势？</strong></p><ol><li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件，RDB 在恢复大数据集时速度比AOF 的恢复速度快。</li><li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。总之，每秒同步策略的效率是比较高的。同步禁用策略的效率和 RDB 一样高效。</li></ol><p><strong>二者选择的标准</strong>：就是看系统是愿意牺牲一些性能，换取更高的缓存一致性(AOF)，还是愿意写操作频繁的时候，不启动备份来换取更高的性能。待手动运行save的时候，再做备份(RDB)。RDB 这个就更有些最终一致性的意思了。</p><h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><h5 id="RDB持久化配置"><a href="#RDB持久化配置" class="headerlink" title="RDB持久化配置"></a><strong>RDB持久化配置</strong></h5><p>Redis 会将数据集的快照 dump 到 dump.rdb 文件中。此外，我们也可以通过配置文件来修改Redis 服务器 dump 快照的频率，在打开 redis.conf 文件之后，我们搜索 save 可以看到下面的配置信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save　　900　　1 #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照</span><br><span class="line"></span><br><span class="line">save　　300　　10 #在300秒(5分钟)之后，如果至少有10个key发生变化，则dunp内存快照</span><br><span class="line"></span><br><span class="line">save　　60　　 10000　　#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照</span><br></pre></td></tr></table></figure><h5 id="AOF持久化配置"><a href="#AOF持久化配置" class="headerlink" title="AOF持久化配置"></a><strong>AOF持久化配置</strong></h5><p>在 Redis 的配置文件中存在三种同步方式，它们分别是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendsync always #每次有数据修改发生时都会写入AOF文件</span><br><span class="line"></span><br><span class="line">appendsync everysec #每秒同步一次，该策略为AOF的缺省策略</span><br><span class="line"></span><br><span class="line">appendsync no #从不同步。高效但是数据不会被持久化</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（拓展篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（进阶篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>开发工具汇总</title>
    <link href="https://www.blog.ajie39.top/2021/06/20/%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
    <id>https://www.blog.ajie39.top/2021/06/20/%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</id>
    <published>2021-06-19T18:15:56.000Z</published>
    <updated>2021-06-19T18:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：本文主要总结了自己开发所用的各种工具。"><a href="#摘要：本文主要总结了自己开发所用的各种工具。" class="headerlink" title="摘要：本文主要总结了自己开发所用的各种工具。"></a>摘要：本文主要总结了自己开发所用的各种工具。</h1><hr><h1 id="前言：主要是汇总了一下，自己在开发过程中的各种工具。"><a href="#前言：主要是汇总了一下，自己在开发过程中的各种工具。" class="headerlink" title="前言：主要是汇总了一下，自己在开发过程中的各种工具。"></a>前言：主要是汇总了一下，自己在开发过程中的各种工具。</h1><hr><span id="more"></span><h2 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h2><ul><li>clear 刷新屏幕</li><li>tab 自动补全</li></ul><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><ul><li>打包、跳过测试<br>mvn clean package -Dmaven.test.skip</li><li>执行<br>java -jar *.jar</li><li>退出<br>ctrl + c</li></ul><h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><ul><li><p>Lombok插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lombok官方api：https:&#x2F;&#x2F;projectlombok.org&#x2F;features&#x2F;index.html</span><br><span class="line"></span><br><span class="line">使用lombok之后，省去了许多没必要的get，set，toString，</span><br><span class="line">equals，hashCode代码，简化了代码编写，减少了代码量。</span><br><span class="line"></span><br><span class="line">另外@Data注解的作用相当于 @Getter @Setter</span><br><span class="line">@RequiredArgsConstructor @ToString @EqualsAndHashCode的合集</span><br></pre></td></tr></table></figure></li><li><p>Background Image 背景图片设置插件</p></li><li><p>Maven Helper：展示的pom文件依赖关系<br>使用参考地址：<a href="https://blog.csdn.net/u013870094/article/details/79712500">https://blog.csdn.net/u013870094/article/details/79712500</a></p></li><li><p>Alibaba Java Coding Guidelines 阿里巴巴Java编码准则插件</p></li><li><p>Translation 翻译插件</p></li><li><p>MyBatis Log Plugin 打印mybatis的sql语句</p></li><li><p>Free Mybatis plugin 生成mapper xml文件，快速从代码跳转到mapper及从mapper返回代码<br>使用参考地址：<a href="https://github.com/wuzhizhan/free-idea-mybatis">https://github.com/wuzhizhan/free-idea-mybatis</a></p></li><li><p>protobuf support proto文件插件</p></li><li><p>VisualVM Launcher 查看jvm的情况</p></li><li><p>FindBugs 检测代码中可能的bug及不规范的位置</p></li><li><p>MybatisX MybatisX 辅助 idea 快速开发插件</p></li><li><p>CodeGlance 代码编辑区缩略图插件</p></li><li><p>Kubernetes</p></li><li><p>Zoolytic  zookeeper可视化</p></li></ul><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><ul><li>中文简体语言包：Chinese (Simplified) Language Pack for Visual Studio Code</li><li>PlantUML</li><li>VS Code JavaScript(ES6) snippets：这个插件为 JavaScript、TypeScript、HTML、React 和 Vue 提供了 ES6 的语法支持。</li><li>React-Redux ES6 Snippets</li><li>jQuery Code Snippets</li><li>Path Intellisense：自动路径补全</li><li>Vetur：Vue 的语法高亮、智能感知、Emmet 等。</li><li>Debugger for Chrome</li><li>Markdown All in One</li></ul><h2 id="一些工具类网站"><a href="#一些工具类网站" class="headerlink" title="一些工具类网站"></a>一些工具类网站</h2><ul><li>PlantUML：<a href="https://plantuml.com/zh/">https://plantuml.com/zh/</a></li><li>时间戳：<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></li><li>cron表达式生成器：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li><li>json：<a href="https://www.bejson.com/jsoneditoronline/">https://www.bejson.com/jsoneditoronline/</a></li><li>思维导图、流程图：<a href="https://www.processon.com/">https://www.processon.com/</a></li><li>jwt解密：<a href="https://jwt.io/">https://jwt.io/</a></li><li>代码分享：<a href="https://paste.ubuntu.com/">https://paste.ubuntu.com/</a></li></ul><h2 id="ATOM"><a href="#ATOM" class="headerlink" title="ATOM"></a>ATOM</h2><ul><li>DocBlocker                          自动代码补全，注释</li><li>atom-material-ui                    美化</li><li>language-markdown                   markdown语法高亮插件</li><li>markdown-preview-plus 或者<br>markdown-preview-enhanced           语法高亮，双向实时预览</li><li>markdown-table-editor               markdown表格插件</li><li>regex-railroad-diagram              正则表达式插件</li><li>simplified-chinese-menu             菜单汉化语言包</li></ul><h2 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h2><ul><li>JSON Viewer插件<br>  地址：<a href="https://github.com/tulios/json-viewer">https://github.com/tulios/json-viewer</a></li></ul><h2 id="渗透工具"><a href="#渗透工具" class="headerlink" title="渗透工具"></a>渗透工具</h2><ul><li>Nmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装命令：</span><br><span class="line">sudo apt-get install nmap</span><br></pre></td></tr></table></figure><ul><li>Zenmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装命令：</span><br><span class="line">sudo apt-get install -y zenmap</span><br></pre></td></tr></table></figure><ul><li>Sqlmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安装git:</span><br><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line">然后使用git安装sqlmap:</span><br><span class="line">sudo git clone git:&#x2F;&#x2F;github.com&#x2F;sqlmapproject&#x2F;sqlmap.git</span><br><span class="line"></span><br><span class="line">修改环境变量：</span><br><span class="line">sudo vi &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">export sqlmap&#x3D;&#39;python **&#x2F;sqlmap&#x2F;sqlmap.py&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：本文主要总结了自己开发所用的各种工具。&quot;&gt;&lt;a href=&quot;#摘要：本文主要总结了自己开发所用的各种工具。&quot; class=&quot;headerlink&quot; title=&quot;摘要：本文主要总结了自己开发所用的各种工具。&quot;&gt;&lt;/a&gt;摘要：本文主要总结了自己开发所用的各种工具。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot;&gt;&lt;a href=&quot;#前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot; class=&quot;headerlink&quot; title=&quot;前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot;&gt;&lt;/a&gt;前言：主要是汇总了一下，自己在开发过程中的各种工具。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    <category term="Tool" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/Tool/"/>
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 数据库相关知识点总结</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-16T14:51:14.000Z</published>
    <updated>2021-12-13T16:13:46.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：对于-Mysql-常见的知识点总结。"><a href="#摘要：对于-Mysql-常见的知识点总结。" class="headerlink" title="摘要：对于 Mysql 常见的知识点总结。"></a>摘要：对于 Mysql 常见的知识点总结。</h1><hr><h1 id="前言：对于-Mysql-常见的知识点的总结。"><a href="#前言：对于-Mysql-常见的知识点的总结。" class="headerlink" title="前言：对于 Mysql 常见的知识点的总结。"></a>前言：对于 Mysql 常见的知识点的总结。</h1><hr><h2 id="Mysql-知识点脑图"><a href="#Mysql-知识点脑图" class="headerlink" title="Mysql 知识点脑图"></a>Mysql 知识点脑图</h2><p><img src="/img/image/blog/20210516/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE.png" alt="Mysql 知识点脑图"></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：对于-Mysql-常见的知识点总结。&quot;&gt;&lt;a href=&quot;#摘要：对于-Mysql-常见的知识点总结。&quot; class=&quot;headerlink&quot; title=&quot;摘要：对于 Mysql 常见的知识点总结。&quot;&gt;&lt;/a&gt;摘要：对于 Mysql 常见的知识点总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于-Mysql-常见的知识点的总结。&quot;&gt;&lt;a href=&quot;#前言：对于-Mysql-常见的知识点的总结。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于 Mysql 常见的知识点的总结。&quot;&gt;&lt;/a&gt;前言：对于 Mysql 常见的知识点的总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Mysql-知识点脑图&quot;&gt;&lt;a href=&quot;#Mysql-知识点脑图&quot; class=&quot;headerlink&quot; title=&quot;Mysql 知识点脑图&quot;&gt;&lt;/a&gt;Mysql 知识点脑图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/image/blog/20210516/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE.png&quot; alt=&quot;Mysql 知识点脑图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Mysql/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://www.blog.ajie39.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之Hashmap</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/Java%E9%9D%A2%E8%AF%95%E4%B9%8BHashmap/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/Java%E9%9D%A2%E8%AF%95%E4%B9%8BHashmap/</id>
    <published>2021-05-16T10:46:10.000Z</published>
    <updated>2021-12-13T16:26:35.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：Hashmap面试内容总结"><a href="#摘要：Hashmap面试内容总结" class="headerlink" title="摘要：Hashmap面试内容总结"></a>摘要：Hashmap面试内容总结</h1><hr><h1 id="前言：Hashmap面试内容总结，为面试做准备。"><a href="#前言：Hashmap面试内容总结，为面试做准备。" class="headerlink" title="前言：Hashmap面试内容总结，为面试做准备。"></a>前言：Hashmap面试内容总结，为面试做准备。</h1><hr><span id="more"></span><h2 id="1、为什么用HashMap？"><a href="#1、为什么用HashMap？" class="headerlink" title="1、为什么用HashMap？"></a>1、为什么用HashMap？</h2><ul><li>HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射</li><li>HashMap 采用了数组和链表的数据结构，查询和修改方便，继承了数组的线性查找和链表的寻址修改</li><li>HashMap 是非 synchronized，所以 HashMap 很快</li><li>HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）</li><li>HashMap 存储着Entry(hash, key, value, next)对象</li></ul><h2 id="2、HashMap-的工作原理是什么？"><a href="#2、HashMap-的工作原理是什么？" class="headerlink" title="2、HashMap 的工作原理是什么？"></a>2、HashMap 的工作原理是什么？</h2><p>HashMap 通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p><p><img src="/img/image/blog/12/1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以下是 HashMap 初始化</span><br><span class="line">简化的模拟数据结构：</span><br><span class="line"></span><br><span class="line">Node[] table = <span class="keyword">new</span> Node[<span class="number">16</span>]; <span class="comment">// 散列桶初始化，table</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    hash; <span class="comment">//hash值</span></span><br><span class="line">    key; <span class="comment">//键</span></span><br><span class="line">    value; <span class="comment">//值</span></span><br><span class="line">    node next; <span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是具体的 put 过程（JDK1.8）</p><ol><li>对 Key 求 Hash 值，然后再计算下标</li><li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）</li><li>如果碰撞了，以链表的方式链接到后面</li><li>如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li><li>如果节点已经存在就替换旧值</li><li>如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）</li></ol><p>以下是具体 get 过程</p><p>考虑特殊情况：如果两个键的 hashcode 相同，你如何获取值对象？</p><p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p><p><img src="/img/image/blog/12/2.png"></p><h2 id="3、有什么方法可以减少碰撞？"><a href="#3、有什么方法可以减少碰撞？" class="headerlink" title="3、有什么方法可以减少碰撞？"></a>3、有什么方法可以减少碰撞？</h2><p><strong>碰撞：所谓“碰撞”就上面所述是多个元素计算得出相同的hashCode，在put时出现冲突。</strong></p><p>处理方法:<br>　　Java中HashMap是利用“拉链法”处理HashCode的碰撞问题。在调用HashMap的put方法或get方法时，都会首先调用hashcode方法，去查找相关的key，当有冲突时，再调用equals方法。</p><p>hashMap 通过put和get方法存取对象。当我们将键值对传递给put方法时，他调用键对象的hashCode()方法来计算hashCode，然后找到bucket（哈希桶）位置来存储对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当碰撞发生了，对象将会存储在链表的下一个节点中。hashMap在每个链表节点存储键值对对象。当两个不同的键却有相同的hashCode时，他们会存储在同一个bucket位置的链表中。键对象的equals()来找到键值对。</p><p><strong>HashMap基本结构概念图：</strong></p><p><img src="/img/image/blog/12/3.png"></p><p>到目前为止，我们了解了两件事：</p><ul><li>1、HashMap通过键的hashCode来快速的存取元素。</li><li>2、当不同的对象发生碰撞时，HashMap通过单链表来解决，将新元素加入链表表头，通过next指向原有的元素。单链表在Java中的实现就是对象的引用(复合)。</li></ul><h2 id="4、为什么-String、Integer-这样的-wrapper-类适合作为键？"><a href="#4、为什么-String、Integer-这样的-wrapper-类适合作为键？" class="headerlink" title="4、为什么 String、Integer 这样的 wrapper 类适合作为键？"></a>4、为什么 String、Integer 这样的 wrapper 类适合作为键？</h2><p>因为 String 是 final，而且已经重写了 equals() 和 hashCode() 方法了。不可变性是必要的，因为为了要计算 hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的 hashcode 的话，那么就不能从 HashMap 中找到你想要的对象。</p><h2 id="5、HashMap-中-hash-函数怎么是实现的"><a href="#5、HashMap-中-hash-函数怎么是实现的" class="headerlink" title="5、HashMap 中 hash 函数怎么是实现的?"></a>5、HashMap 中 hash 函数怎么是实现的?</h2><p>我们可以看到，在 hashmap 中要找到某个元素，需要根据 key 的 hash 值来求得对应数组中的位置。如何计算这个位置就是 hash 算法。</p><p>前面说过，hashmap 的数据结构是数组和链表的结合，所以我们当然希望这个 hashmap 里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个。那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以，我们首先想到的就是把 hashcode 对数组长度取模运算。这样一来，元素的分布相对来说是比较均匀的。</p><p>但是“模”运算的消耗还是比较大的，能不能找一种更快速、消耗更小的方式？我们来看看 JDK1.8 源码是怎么做的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    h = key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">    <span class="keyword">return</span> (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/image/blog/12/4.png"></p><p>简单来说就是：</p><ul><li>1、高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和6 bit做了一个异或）</li><li>2、(n·1) &amp; hash = -&gt; 得到下标</li></ul><h2 id="6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？"><a href="#6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？"></a>6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷：</p><p>二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成层次很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋、右旋、变色这些操作来保持平衡。引入红黑树就是为了查找数据快，解决链表查询深度的问题。我们知道红黑树属于平衡二叉树，为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少。所以当长度大于8的时候，会使用红黑树；如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h2 id="7、说说你对红黑树的见解？"><a href="#7、说说你对红黑树的见解？" class="headerlink" title="7、说说你对红黑树的见解？"></a>7、说说你对红黑树的见解？</h2><p><img src="/img/image/blog/12/5.png"></p><ol><li>每个节点非红即黑</li><li>根节点总是黑色的</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li><li>每个叶子节点都是黑色的空节点（NIL节点）</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ol><h2 id="8、解决-hash-碰撞还有那些办法？"><a href="#8、解决-hash-碰撞还有那些办法？" class="headerlink" title="8、解决 hash 碰撞还有那些办法？"></a>8、解决 hash 碰撞还有那些办法？</h2><p><strong>1.开放地址法</strong></p><p>开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。</p><p>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。</p><p>如果di取值可能为伪随机数列。称伪随机探测再散列。</p><p><strong>2.再哈希法</strong></p><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止。</p><p><strong>3.链地址法（拉链法）</strong></p><p>将所有关键字为同义词的记录存储在同一线性链表中。如下：</p><p><img src="/img/image/blog/12/6.png"></p><p>因此这种方法，可以近似的认为是筒子里面套筒子。</p><p><strong>优点：</strong></p><ol><li>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li><li>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</li><li>开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</li><li>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li></ol><p><strong>缺点：</strong></p><ul><li>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</li></ul><h2 id="9、如果-HashMap-的大小超过了负载因子（load-factor）定义的容量怎么办？"><a href="#9、如果-HashMap-的大小超过了负载因子（load-factor）定义的容量怎么办？" class="headerlink" title="9、如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？"></a>9、如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？</h2><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</span><br><span class="line"></span><br><span class="line">大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</span><br></pre></td></tr></table></figure><p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="/img/image/blog/12/7.png"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/img/image/blog/12/8.png"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p><img src="/img/image/blog/12/9.png"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><h2 id="10、重新调整-HashMap-大小存在什么问题吗？"><a href="#10、重新调整-HashMap-大小存在什么问题吗？" class="headerlink" title="10、重新调整 HashMap 大小存在什么问题吗？"></a>10、重新调整 HashMap 大小存在什么问题吗？</h2><p>重新调整 HashMap 大小的时候，确实存在条件竞争。</p><p>因为如果两个线程都发现 HashMap 需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来。因为移动到新的 bucket 位置的时候，HashMap 并不会将元素放在链表的尾部，而是放在头部。这是为了避免尾部遍历（tail traversing）。如果条件竞争发生了，那么就死循环了。<strong>多线程的环境下不使用 HashMap。</strong></p><p>为什么多线程会导致死循环，它是怎么发生的？<br>HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。这时候， HashMap 需要扩展它的长度，也就是进行Resize。</p><ol><li>扩容：创建一个新的 Entry 空数组，长度是原数组的2倍</li><li>rehash：遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组</li></ol><p>详细文章参考: <a href="https://www.cnblogs.com/zhuoqingsen/p/8577646.html">HashMap扩容全过程</a></p><h2 id="11、HashTable"><a href="#11、HashTable" class="headerlink" title="11、HashTable"></a>11、HashTable</h2><ol><li>数组 + 链表方式存储</li><li>默认容量：11（质数为宜）</li><li>put操作：首先进行索引计算 （key.hashCode() &amp; 0x7FFFFFFF）% table.length；若在链表中找到了，则替换旧值，若未找到则继续；当总元素个数超过 容量 * 加载因子 时，扩容为原来 2 倍并重新散列；将新元素加到链表头部</li><li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全</li></ol><h2 id="12、HashMap-与-HashTable-区别"><a href="#12、HashMap-与-HashTable-区别" class="headerlink" title="12、HashMap 与 HashTable 区别"></a>12、HashMap 与 HashTable 区别</h2><ol><li>默认容量不同，扩容不同</li><li>线程安全性：HashTable 安全</li><li>效率不同：HashTable 要慢，因为加锁</li></ol><h2 id="13、可以使用-CocurrentHashMap-来代替-Hashtable-吗？"><a href="#13、可以使用-CocurrentHashMap-来代替-Hashtable-吗？" class="headerlink" title="13、可以使用 CocurrentHashMap 来代替 Hashtable 吗？"></a>13、可以使用 CocurrentHashMap 来代替 Hashtable 吗？</h2><ol><li>我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁</li><li>ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性</li><li>它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map</li></ol><h2 id="14、CocurrentHashMap（JDK-1-7）"><a href="#14、CocurrentHashMap（JDK-1-7）" class="headerlink" title="14、CocurrentHashMap（JDK 1.7）"></a>14、CocurrentHashMap（JDK 1.7）</h2><ol><li>CocurrentHashMap 是由 Segment 数组和 HashEntry 数组和链表组成</li><li>Segment 是基于重入锁（ReentrantLock）：一个数据段竞争锁。每个 HashEntry 一个链表结构的元素，利用 Hash 算法得到索引确定归属的数据段，也就是对应到在修改时需要竞争获取的锁。ConcurrentHashMap 支持 CurrencyLevel（Segment 数组数量）的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment</li><li>核心数据如 value，以及链表都是 volatile 修饰的，保证了获取时的可见性</li><li>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put 操作如下：<ul><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li><li>遍历该 HashEntry，如果不为空则判断传入的  key 和当前遍历的 key 是否相等，相等则覆盖旧的 value</li><li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li><li>最后会解除在 1 中所获取当前 Segment 的锁。</li></ul></li><li>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理<ul><li>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。</li><li>尝试自旋获取锁，如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。最后解除当前 Segment 的锁</li></ul></li></ol><h2 id="15、CocurrentHashMap（JDK-1-8）"><a href="#15、CocurrentHashMap（JDK-1-8）" class="headerlink" title="15、CocurrentHashMap（JDK 1.8）"></a>15、CocurrentHashMap（JDK 1.8）</h2><p>CocurrentHashMap 抛弃了原有的 Segment 分段锁，采用了 CAS + synchronized 来保证并发安全性。其中的 val next 都用了 volatile 修饰，保证了可见性。</p><p><strong>最大特点是引入了 CAS</strong></p><p>  借助 Unsafe 来实现 native code。CAS有3个操作数，内存值 V、旧的预期值 A、要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值V修改为 B，否则什么都不做。Unsafe 借助 CPU 指令 cmpxchg 来实现。</p><p><strong>CAS 使用实例</strong></p><p>对 sizeCtl 的控制都是用 CAS 来实现的：</p><ul><li>-1 代表 table 正在初始化</li><li>N 表示有 -N-1 个线程正在进行扩容操作</li><li>如果 table 未初始化，表示table需要初始化的大小</li><li>如果 table 初始化完成，表示table的容量，默认是table大小的0.75倍，用这个公式算 0.75（n – (n &gt;&gt;&gt; 2)）</li></ul><p><strong>CAS 会出现的问题：ABA</strong></p><p>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。</p><p><strong>put 过程</strong></p><ul><li>根据 key 计算出 hashcode</li><li>判断是否需要进行初始化</li><li>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容</li><li>如果都不满足，则利用 synchronized 锁写入数据</li><li>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树</li></ul><p><strong>get 过程</strong></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值</li><li>如果是红黑树那就按照树的方式获取值</li><li>就不满足那就按照链表的方式遍历获取值</li></ul><h2 id="16、ConcurrentHashMap-在-Java-8-中存在一个-bug-会进入死循环"><a href="#16、ConcurrentHashMap-在-Java-8-中存在一个-bug-会进入死循环" class="headerlink" title="16、ConcurrentHashMap 在 Java 8 中存在一个 bug 会进入死循环"></a>16、ConcurrentHashMap 在 Java 8 中存在一个 bug 会进入死循环</h2><p>原因是递归创建 ConcurrentHashMap 对象，但是在 JDK 1.9 已经修复了。场景重现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; cache =<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        ConcurrentHashMapDemo ch =    <span class="keyword">new</span> ConcurrentHashMapDemo();</span><br><span class="line">        System.out.println(ch.fibonaacci(<span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonaacci</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>||i ==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cache.computeIfAbsent(i,(key) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fibonaacci : &quot;</span>+key);</span><br><span class="line">            <span class="keyword">return</span> fibonaacci(key -<span class="number">1</span>)+fibonaacci(key - <span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：Hashmap面试内容总结&quot;&gt;&lt;a href=&quot;#摘要：Hashmap面试内容总结&quot; class=&quot;headerlink&quot; title=&quot;摘要：Hashmap面试内容总结&quot;&gt;&lt;/a&gt;摘要：Hashmap面试内容总结&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：Hashmap面试内容总结，为面试做准备。&quot;&gt;&lt;a href=&quot;#前言：Hashmap面试内容总结，为面试做准备。&quot; class=&quot;headerlink&quot; title=&quot;前言：Hashmap面试内容总结，为面试做准备。&quot;&gt;&lt;/a&gt;前言：Hashmap面试内容总结，为面试做准备。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法与数据结构" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数据结构" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础复习</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-16T07:34:26.000Z</published>
    <updated>2021-12-13T16:24:36.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章是对数据库基础的总结和归纳。"><a href="#摘要：这篇文章是对数据库基础的总结和归纳。" class="headerlink" title="摘要：这篇文章是对数据库基础的总结和归纳。"></a>摘要：这篇文章是对数据库基础的总结和归纳。</h1><hr><h1 id="前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。"><a href="#前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。" class="headerlink" title="前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。"></a>前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。</h1><hr><span id="more"></span><p><strong>1.常用的数据库有哪些？redis用过吗?</strong></p><ul><li>常用的数据库<ul><li>MySQL</li><li>SQLServer</li><li>Redis</li><li>oracle</li></ul></li><li>Redis是一个速度非常快的非关系型数据库，他可以存储键(key)与5种不同类型的值（value）之间的映射，可以将存储在内存中的键值对数据持久化到硬盘中。</li><li>与Memcached相比<ul><li>两者都可用于存储键值映射，彼此性能也相差无几</li><li>Redis能够自动以两种不同的方式将数据写入硬盘</li><li>Redis除了能存储普通的字符串键之外，还可以存储其他4种数据结构，memcached只能存储字符串键</li><li>Redis既能用作主数据库，由可以作为其他存储系统的辅助数据库</li></ul></li></ul><p><strong>2数据库索引的优缺点以及什么时候数据库索引失效</strong></p><ul><li><p>索引的特点</p><ul><li>可以加快数据库的检索速度</li><li>降低数据库插入、修改、删除等维护的速度</li><li>只能创建在表上，不能创建到视图上</li><li>既可以直接创建又可以间接创建</li><li>可以在优化隐藏中使用索引</li><li>使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引</li></ul></li><li><p>索引的优点</p><ul><li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li><li>大大加快数据的检索速度，这是创建索引的最主要的原因</li><li>加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能</li></ul></li><li><p>索引的缺点</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度</li></ul></li><li><p>索引分类</p><ul><li>直接创建索引和间接创建索引</li><li>普通索引和唯一性索引</li><li>单个索引和复合索引</li><li>聚簇索引和非聚簇索引</li></ul></li><li><p>索引失效</p><ul><li>如果条件中有or，即使其中有条件带索引也不会使用(这就是问什么尽量少使用or的原因)</li><li>对于多列索引，不是使用的第一部分，则不会使用索引</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中使用引号引起来，否则不会使用索引</li></ul></li><li><p>如果mysql估计使用全表扫秒比使用索引快，则不适用索引。</p></li><li><p>各引擎支持索引<br><img src="/img/image/blog/6/sql.png" alt="sql"></p></li></ul><p><strong>3.事务隔离级别</strong></p><ul><li>串行化(Serializable)：所有事务一个接着一个的执行，这样可以避免幻读(phantom read),对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需回滚该事务。</li><li>可重复读(Repeated Read)：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取不一致的情况。但是没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为强恶意事务没有范围锁</li><li>读已提交(Read Committed)：被读取的数据可以被其他事务修改，这样可能导致不可重复读。也就是说，事务读取的时候获取读锁，但是在读完之后立即释放(不需要等事务结束)，而写锁则是事务提交之后才释放，释放读锁之后，就可能被其他事务修改数据。改等级也是SQL Server默认的隔离等级</li><li>读未提交(Read Uncommitted)：最低的隔离等级，允许其他事务看到没有提交的数据，会导致脏读</li><li>总结<ul><li>四个级别逐渐增强，每个级别解决一个问题，每个级别解决一个问题，事务级别遇到，性能越差，大多数环境(Read committed 就可以用了)<br><img src="/img/image/blog/6/sql1.png" alt="sql1"></li></ul></li></ul><p><strong>4.数据库中的范式有哪些？</strong></p><ul><li>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。</li><li>范式的包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式…</li><li>范式</li><li>1NF ：符合1NF的关系中的每个属性都不可再分</li><li>2NF：属性完全依赖于主键 [消除部分子函数依赖]</li><li>3NF：属性不依赖于其它非主属性[消除传递依赖]</li><li>BCNF：在1NF基础上，任何非主属性不能对主键子集依赖[在3NF基础上消除对主码子集的依赖]</li><li>4NF：要求把同一表内的多对多关系删除。</li><li>5NF：从最终结构重新建立原始结构。</li></ul><p><strong>5数据库中的索引的结构？什么情况下适合建索引?</strong></p><ul><li><p>数据库中的索引结构<br>因为在使用二叉树的时候，由于二叉树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下。因此采用多叉树结构。B树的各种操作能使B树能保持较低的高度。</p></li><li><p>B 树又叫平衡多路查找树，一棵 m 阶的 B 树的特性如下</p></li><li><p>树中每个结点最多含有 m 个孩子（m&gt;=2）；</p></li><li><p>除根结点和叶子结点外，其他每个结点至少有[ceil(m / 2)]个孩子（其中 ceil(x)是一个取上限的函数）；</p></li><li><p>根结点至少有 2 个孩子（除非 B 树只包含一个结点：根结点）；</p></li><li><p>所有叶子结点都出现在同一层， 叶子结点不包含任何关键字信息 (可以看做是外部结点或查询失败的结点，指向这些结点的指针都为 null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存<br>在，也有元素。类似红黑树中，每一个 NULL 指针即当做叶子结点，只是没画出来而已）。</p></li><li><p>每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>a) Ki (i=1…n)为关键字，且关键字按顺序升序排序 K(i-1)&lt; Ki。<br>b) Pi 为指向子树根的结点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。<br>c) 关键字的个数 n 必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。比如有 j 个孩子的非叶结点恰好有 j-1 个关<br>键码。<br><img src="/img/image/blog/6/sql2.png" alt="sql2"></p></li><li><p>B+树<br><img src="/img/image/blog/6/sql3.png" alt="sql3"></p></li><li><p>在什么情况下适合建立索引</p><ul><li>为经常出现在关键字order by、group by、distinct后面的字段，建立索引。</li><li>在union等集合操作的结果集字段上，建立索引。其建立索引的目的同上。</li><li>为经常用作查询选择的字段，建立索引。</li><li>在经常用作表连接的属性上，建立索引。</li><li>考虑使用索引覆盖。对数据很少被更新的表，如果用户经常只查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描。</li></ul></li></ul><p><strong>6.Redis的存储结构，或者说如何工作的，与mysql的区别？有哪些数据类型？</strong></p><ul><li>Redis的数据结构<ul><li>STRING：可以是字符串、整数或者浮点数</li><li>LIST：一个链表，链表上的每个节点都包含了一个字符串</li><li>SET：包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二、各不相同的</li><li>HAST：包含键值对的无序散列表</li><li>ZSET：字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</li></ul></li></ul><p><strong>7.数据库中的分页查询语句怎么写？<a href="http://qimo601.iteye.com/blog/1634748">http://qimo601.iteye.com/blog/1634748</a></strong></p><ul><li>Mysql的limit用法<ul><li>SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</li><li>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</li></ul></li><li>最基本的分页方式：SELECT … FROM … WHERE … ORDER BY … LIMIT …</li><li>子查询的分页方式：</li></ul><p><strong>8.数据库ACID</strong></p><ul><li>原子性(Atomicity)：保证事务中的所有操作全部执行或全部不执行</li><li>一致性(Consistency)：保证数据库始终保持数据的一致性——事务操作之前和之后都是一致的</li><li>隔离性(Isolation)：多个事务并发执行的话，结果应该与多个事务串行执行效果是一样的</li><li>持久性(Durability)：事务操作完成之后，对数据库的影响是持久的，即使数据库因故障而受到破坏，数据库也能够恢复(日志)</li></ul><p><strong>9.脏读、不可重复读和幻读</strong></p><ul><li>脏读：事务T1更新了一行记录的内容，但是并没有提交所做的修改。事务T2读取更新后的行，然后T1执行了回滚操作，取消了刚才所做的修改。现在T2读取的行就无效了（一个事务读取了另一个事务未提交的数据）</li><li>不可重复读：事务T1读取了一行记录，紧接着T2修改了T1刚才读取的那一行记录，然后T1又再次读取这行记录，发现与刚才读取的结果不同。</li><li>幻读：事务T1读取一条指定的Where子句所返回的结果集，然后T2事务新插入一行记录，这行记录恰好可以满足T1所使用的查询条件。然后T1再次对表进行检索，但又看到了T2插入的数据。</li></ul><p><strong>10.MyISAM和InnoDB引擎的区别</strong></p><ul><li><p>主要区别：</p><ul><li>MyISAM是非事务安全型的，而InnoDB是事务安全型的。</li><li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</li><li>MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li><li>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</li><li>MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li><li>InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li></ul></li><li><p>应用场景：</p><ul><li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</li><li>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章是对数据库基础的总结和归纳。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章是对数据库基础的总结和归纳。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章是对数据库基础的总结和归纳。&quot;&gt;&lt;/a&gt;摘要：这篇文章是对数据库基础的总结和归纳。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot;&gt;&lt;a href=&quot;#前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot; class=&quot;headerlink&quot; title=&quot;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot;&gt;&lt;/a&gt;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="数据库" scheme="https://www.blog.ajie39.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="数据库" scheme="https://www.blog.ajie39.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis 是单线程的？？？？你别唬我，我可不是厦（吓）大的</title>
    <link href="https://www.blog.ajie39.top/2021/05/09/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84/"/>
    <id>https://www.blog.ajie39.top/2021/05/09/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84/</id>
    <published>2021-05-09T12:53:14.000Z</published>
    <updated>2021-05-09T12:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。"><a href="#摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。" class="headerlink" title="摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。"></a>摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。</h1><hr><h1 id="前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。"><a href="#前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。" class="headerlink" title="前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。"></a>前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。</h1><hr><span id="more"></span><h2 id="一、Redis-是否真的是单线程？"><a href="#一、Redis-是否真的是单线程？" class="headerlink" title="一、Redis 是否真的是单线程？"></a>一、Redis 是否真的是单线程？</h2><p>​        <code>Redis 服务器</code>使用<code>单线程单进程</code>的方式来处理命令请求， 并与多个客户端进行网络通信。Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。所以说 Redis 不是所有模块都是单线程的。</p><p>​         Redis 服务器是典型的一对多服务器程序： 一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求， 并向客户端返回命令回复。</p><p>​    Redis 服务器状态结构的 clients 属性是一个链表。这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历 clients 链表来完成。</p><ul><li>Redis v4.0（引入多线程处理异步任务）</li><li>Redis v6.0（正式在网络模型中实现 I/O 多线程）</li></ul><h2 id="二、Redis-单线程模型"><a href="#二、Redis-单线程模型" class="headerlink" title="二、Redis 单线程模型"></a>二、Redis 单线程模型</h2><p>Redis作为一个成熟的分布式缓存框架，它由很多个模块组成，如网络请求模块、索引模块、存储模块、高可用集群支撑模块、数据操作模块等。</p><p>我们所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。</p><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所以每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题。</p><h2 id="三、Redis-客户端到服务端请求过程"><a href="#三、Redis-客户端到服务端请求过程" class="headerlink" title="三、Redis 客户端到服务端请求过程"></a>三、Redis 客户端到服务端请求过程</h2><ol><li>客户端到服务端建立网络连接</li><li>客户端发生读写事件并向服务器端发送请求数据</li><li>服务端进行数据处理</li><li>服务端数据返回</li></ol><h3 id="1、客户端到服务端建立网络连接"><a href="#1、客户端到服务端建立网络连接" class="headerlink" title="1、客户端到服务端建立网络连接"></a>1、客户端到服务端建立网络连接</h3><p>首先，客户端和服务端是 socket 通信方式，socket 服务端监听可同时接受多个客户端请求，这点很重要，如果不理解可先记住。注意这里可以理解为本质上与 redis 无关，这里仅仅做网络连接，或者可以理解为，为 redis 服务端提供网络交互api。</p><p>假设建立网络连接需要15秒（实际上比这个时间小非常多）。</p><h3 id="2、客户端发生读写事件并向服务端发送请求数据"><a href="#2、客户端发生读写事件并向服务端发送请求数据" class="headerlink" title="2、客户端发生读写事件并向服务端发送请求数据"></a>2、客户端发生读写事件并向服务端发送请求数据</h3><p>首先确定一点，redis的客户端与服务端通信是基于TCP连接，第一阶段仅仅是建立了客户端到服务端的网络连接，然后才是发生第二阶段的读写事件。</p><p>完成了上一个阶段的网络连接，redis客户端开始真正向服务端发起读写事件，假设是set（写）事件，此时redis客户端开始向建立的网络流中送数据，服务端可以理解为给每一个网络连接创建一个线程同时接收客户端的请求数据。<br>假设从客户端发数据，到服务端接收完数据需要5秒。</p><h3 id="3、Redis-服务器进行数据处理"><a href="#3、Redis-服务器进行数据处理" class="headerlink" title="3、Redis 服务器进行数据处理"></a>3、Redis 服务器进行数据处理</h3><p>服务端完成了第二阶段的数据接收，接下来开始依据接收到的数据做逻辑处理，然后得到处理后的数据。数据处理可以理解为一次方法调用，带参调用方法，最终得到方法返回值。不要想复杂，重在理解流程。假设redis服务端处理数据需要0.1秒</p><h3 id="4、服务器数据返回"><a href="#4、服务器数据返回" class="headerlink" title="4、服务器数据返回"></a>4、服务器数据返回</h3><p>这一阶段很简单，当reids服务端数据处理完后 就会立即返回处理后的数据，没什么特别需要强调的。假设服务端把处理后的数据回送给客户端需要5秒。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>第一阶段说过，redis 是以 socket 方式通信，socket服务端可同时接受多个客户端请求连接，也就是说，redis服务同时面对多个redis客户端连接请求，而redis服务本身是单线程运行。</p><p>假设，现在有A,B,C,D,E五个客户端同时发起redis请求，A优先稍微一点点第一个到达，然后是B，C，D，E依次到达，此时redis服务端开始处理A请求，建立连接需要15秒，获取请求数据需要5秒，然后处理数据需要0.1秒，回送数据给客户端需要5秒，总共大概需要25.1秒。也就是说，下一个B请求需要等待25.1秒，这里注意，也许这五个几乎同时请求，由于socket可以同时处理多个请求，所以建立网络连接阶段时间差可忽略<code>(也就是说少了15秒)</code>，但是在第二阶段，服务端需要什么事都不干，坐等5秒中，对于CPU和客户端来说是无法忍受的。所以说单线程效率非常，非常低，但是正是因为这些类似问题，Redis单线程本质上并不是如此运行。接下来讨论redis真正的单线程运行方式。</p><h2 id="Redis-单线程运行方式简单理解"><a href="#Redis-单线程运行方式简单理解" class="headerlink" title="Redis 单线程运行方式简单理解"></a>Redis 单线程运行方式简单理解</h2><p>客户端与服务端建立连接交由 socket，可以同时建立多个连接（这里应该是多线程/多进程），建立的连接redis是知道的（不了解的，这里可以去看一下socket编程），然后 redis 会基于这些建立的连接去探测哪个连接已经接收完了客户端的请求数据（注意：不是探测哪个连接建立好了，<code>而是探测哪个接收完了请求数据</code>），而且这里的探测动作就是单线程的开始，一旦探测到则基于接收到的数据开始数据处理阶段，然后返回数据，再继续探测下一个已经接收完请求数据的网络连接。注意，从探测到数据处理再到数据返回，全程单线程。</p><p>从探测到接受完请求数据的网络连接到最终的数据返回，服务器只需要5.1秒，这个时间是我放大N倍后的数据，实际时间远远小于这个，最终的返回数据虽然牵扯到网络，但是网络连接已经建立，这个速度也是非常非常快的，只是比数据处理阶段慢那么一点点。因此单线程方式在效率上其实并不需要担心。</p><h2 id="单线程事件循环"><a href="#单线程事件循环" class="headerlink" title="单线程事件循环"></a>单线程事件循环</h2><h2 id="四、为什么-Redis-网络操作模块和数据存储模块最初并没有使用多线程呢"><a href="#四、为什么-Redis-网络操作模块和数据存储模块最初并没有使用多线程呢" class="headerlink" title="四、为什么 Redis 网络操作模块和数据存储模块最初并没有使用多线程呢?"></a>四、为什么 Redis 网络操作模块和数据存储模块最初并没有使用多线程呢?</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.51cto.com/art/202103/650049.htm">Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a></li><li><a href="https://www.cnblogs.com/myseries/p/11733861.html">Redis 单线程的理解</a></li><li><a href="https://zhuanlan.zhihu.com/p/140927022">Redis 网络通信模块源码分析（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/352557644">Redis 多线程网络模型全面揭秘</a></li><li><a href="https://zhuanlan.zhihu.com/p/345327284">Redis 的通讯协议及事件处理机制</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。&quot;&gt;&lt;a href=&quot;#摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。&quot; class=&quot;headerlink&quot; title=&quot;摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。&quot;&gt;&lt;/a&gt;摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。&quot;&gt;&lt;a href=&quot;#前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。&quot; class=&quot;headerlink&quot; title=&quot;前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。&quot;&gt;&lt;/a&gt;前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（拓展篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:54:00.000Z</published>
    <updated>2021-05-05T08:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（基础篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（进阶篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？<br>2、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>3、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？<br>4、Redis 常见性能问题和解决方案？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（进阶篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（进阶篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:53:50.000Z</published>
    <updated>2021-05-05T08:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（基础篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（拓展篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、说说 Redis 哈希槽的概念？<br>2、Redis 的同步机制了解么？<br>3、是否使用过 Redis 集群，集群的原理是什么？<br>4、Redis 集群方案什么情况下会导致整个集群不可<br>5、Redis 集群的主从复制模型是怎样的？<br>6、Redis 集群会有写操作丢失吗？为什么？<br>7、Redis 集群之间是如何复制的？<br>8、Redis 集群最大节点个数是多少？<br>9、Redis 集群如何选择数据库？<br>10、如何实现集群中的 session 共享存储？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（拓展篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁原理分析与应用</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-05-05T07:54:50.000Z</published>
    <updated>2022-01-17T15:59:28.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是介绍分布式锁相关的内容。"><a href="#摘要：这篇文章主要是介绍分布式锁相关的内容。" class="headerlink" title="摘要：这篇文章主要是介绍分布式锁相关的内容。"></a>摘要：这篇文章主要是介绍分布式锁相关的内容。</h1><hr><h1 id="前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"><a href="#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。" class="headerlink" title="前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"></a>前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。</h1><hr><span id="more"></span><h2 id="分布式锁的使用场景"><a href="#分布式锁的使用场景" class="headerlink" title="分布式锁的使用场景"></a>分布式锁的使用场景</h2><ul><li><p>效率性:使用分布式锁可以避免不同节点重复相同的工作。</p></li><li><p>正确性:分布式锁可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</p></li></ul><h2 id="分布式锁的几种特性"><a href="#分布式锁的几种特性" class="headerlink" title="分布式锁的几种特性"></a>分布式锁的几种特性</h2><ul><li><p>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</p></li><li><p>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</p></li><li><p>锁超时:和本地锁一样支持锁超时，防止死锁。</p></li><li><p>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</p></li><li><p>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</p></li><li><p>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。</p></li></ul><h2 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h2><p>分布式锁有以下几个方式:</p><ul><li>MySql</li><li>Zk</li><li>Redis</li><li>一些自研的分布式锁(Chubby)</li></ul><h3 id="一、基于-Mysql-实现分布式锁"><a href="#一、基于-Mysql-实现分布式锁" class="headerlink" title="一、基于 Mysql 实现分布式锁"></a>一、基于 Mysql 实现分布式锁</h3><p>1、首先，我们需要创建一个锁表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &#96;resource_lock&#96; (</span><br><span class="line">    &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;resource_name&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;资源名称&#39;,</span><br><span class="line">    &#39;node_info&#39; varchar(128) DEFAULT &#39;0&#39; COMMENT &#39;节点信息&#39;,</span><br><span class="line">    &#39;count&#39; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT  &#39;锁的次数，统计可重入锁&#39;,</span><br><span class="line">    &#39;desc&#39; varchar(128) DEFAULT NULL COMMENT &#39;额外的描述信息&#39;,</span><br><span class="line">    &#96;create_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">    &#96;update_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,</span><br><span class="line">    PRIMARY KEY (&#39;id&#39;),</span><br><span class="line">    UNIQUE KEY &#39;un_resource_name&#39; (&#39;resource_name&#39;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、lock</p><p>先进行查询，如果有值，那么需要比较 node_info 是否一致，这里的 node_info 可以用机器 IP 和线程名字来表示，如果一致那么就加可重入锁 count 的值，如果不一致那么就返回 false 。如果没有值那么直接插入一条数据。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加事务，原子性</span><br><span class="line">@Transaction</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断节点信息是否一致</span><br><span class="line">        if (currentNodeInfo &#x3D;&#x3D; resultNodeInfo) &#123;</span><br><span class="line">            &#x2F;&#x2F; 保住锁的可重入性</span><br><span class="line">            update resource_lock set count &#x3D; count + 1 where resource_name &#x3D; &#39;xxx&#39;;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 插入新数据</span><br><span class="line">        insert into resourceLock;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、tryLock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean tryLock(long timeOut) &#123;</span><br><span class="line">    long stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    long endTimeOut &#x3D; stTime + timeOut;</span><br><span class="line"></span><br><span class="line">    while (endTimeOut &gt; stTime) &#123;</span><br><span class="line">        if (mysqlLock.lock()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 休眠3s后重试</span><br><span class="line">        LockSupport.parkNanos(1000 * 1000 * 1000 * 1);</span><br><span class="line">        stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、unlock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Transaction</span><br><span class="line">public boolean unlock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 查询是否有数据</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; count为1那么可以删除，如果大于1那么需要减去1。</span><br><span class="line">        if (count &gt; 1) &#123;</span><br><span class="line">            update count &#x3D; count - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、定时清理因为机器宕机导致的锁未被释放的问题</p><p>启动一个定时任务，当这个锁远超过任务的执行时间，没有被释放我们就可以认定是节点挂了然后将其直接释放。</p><h3 id="二、基于单Redis节点的分布式锁"><a href="#二、基于单Redis节点的分布式锁" class="headerlink" title="二、基于单Redis节点的分布式锁"></a>二、基于单Redis节点的分布式锁</h3><p>首先，Redis客户端为了获取锁，向Redis节点发送如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SET resource_name my_random_value NX PX 30000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。</p><p>注意，在上面的SET命令中：</p><ul><li>my_random_value是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。</li><li>NX表示只有当resource_name对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</li><li>PX 30000表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。</li></ul><p>最后，当客户端完成了对共享资源的操作之后，执行下面的Redis Lua脚本来释放锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">     return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line"> else</span><br><span class="line">     return 0</span><br><span class="line"> end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段Lua脚本在执行的时候要把前面的my_random_value作为 ARGV[1] 的值传进去，把 resource_name 作为 KEYS[1] 的值传进去。</p><p>至此，基于单Redis节点的分布式锁的算法就描述完了。</p><h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><h5 id="第一点：过期时间"><a href="#第一点：过期时间" class="headerlink" title="第一点：过期时间"></a>第一点：过期时间</h5><p>首先第一个问题，这个锁必须要设置一个过期时间。<br>否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了，而且把这个过期时间称为锁的有效时间(lock validity time)。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p><h5 id="第二点：获取锁"><a href="#第二点：获取锁" class="headerlink" title="第二点：获取锁"></a>第二点：获取锁</h5><p>第二个问题，第一步获取锁的操作，网上不少文章把它实现成了两个Redis命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SETNX resource_name my_random_value</span><br><span class="line">EXPIRE resource_name 30</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然这两个命令和前面算法描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。</p><h5 id="第三点：my-random-value"><a href="#第三点：my-random-value" class="headerlink" title="第三点：my_random_value"></a>第三点：my_random_value</h5><p>第三个问题，设置一个随机字符串 my_random_value 是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。</p><p>假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1在某个操作上阻塞了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</li><li>之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。</li></ul><h5 id="第四点：Lua脚本"><a href="#第四点：Lua脚本" class="headerlink" title="第四点：Lua脚本"></a>第四点：Lua脚本</h5><p>第四个问题，释放锁的操作必须使用Lua脚本来实现。释放锁其实包含三步操作：获取、判断和删除，用Lua脚本来实现能保证这三步的原子性。</p><p>否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面第三个问题类似的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1访问共享资源。</li><li>客户端1为了释放锁，先执行’GET’操作获取随机字符串的值。</li><li>客户端1判断随机字符串的值，与预期的值相等。</li><li>客户端1由于某个原因阻塞住了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</li></ul><p>实际上，在上述第三个问题和第四个问题的分析中，如果不是客户端阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。</p><p>这四个问题，只要实现分布式锁的时候加以注意，就都能够被正确处理。</p><p>但除此之外，还有一个问题，是由 failover（故障转移） 引起的，却是基于单Redis节点的分布式锁无法解决的。正是这个问题催生了Redlock的出现。</p><h5 id="多个Redis节点的情况下会产生的问题"><a href="#多个Redis节点的情况下会产生的问题" class="headerlink" title="多个Redis节点的情况下会产生的问题"></a>多个Redis节点的情况下会产生的问题</h5><p>这个问题是这样的。假如Redis节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。</p><p>例如下面的执行序列：</p><ul><li>客户端1从Master获取了锁。</li><li>Master宕机了，存储锁的key还没有来得及同步到Slave上。</li><li>Slave升级为Master。</li><li>客户端2从新的Master获取到了对应同一个资源的锁。</li></ul><p>于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。</p><h4 id="三、分布式锁-Redlock"><a href="#三、分布式锁-Redlock" class="headerlink" title="三、分布式锁 Redlock"></a>三、分布式锁 Redlock</h4><p>前面介绍的基于单Redis节点的分布式锁在failover的时候会产生解决不了的安全性问题，因此antirez提出了新的分布式锁的算法Redlock，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p><p>运行Redlock算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p><p>1、获取当前时间（毫秒数）。</p><p>2、按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</p><p>3、计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p><p>4、如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p><p>5、如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p><p>上面描述的只是获取锁的过程，而释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p><p>由于N个Redis节点中的大多数能正常工作就能保证Redlock正常工作，因此理论上它的可用性更高。我们前面讨论的单Redis节点的分布式锁在failover的时候锁失效的问题，在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟Redis对数据的持久化程度有关。</p><h5 id="节点崩溃可能导致的问题"><a href="#节点崩溃可能导致的问题" class="headerlink" title="节点崩溃可能导致的问题"></a>节点崩溃可能导致的问题</h5><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><p>1、客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</p><p>2、节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</p><p>3、节点C重启后，客户端2锁住了C, D, E，获取锁成功。</p><p>4、这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p>在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez又提出了延迟重启(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><h5 id="客户端应该向所有Redis节点发起释放锁的操作？"><a href="#客户端应该向所有Redis节点发起释放锁的操作？" class="headerlink" title="客户端应该向所有Redis节点发起释放锁的操作？"></a>客户端应该向所有Redis节点发起释放锁的操作？</h5><p>在最后释放锁的时候，antirez在算法描述中特别强调，客户端应该向所有Redis节点发起释放锁的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？</p><p>设想这样一种情况，客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p><h3 id="四、基于zk实现分布式锁"><a href="#四、基于zk实现分布式锁" class="headerlink" title="四、基于zk实现分布式锁"></a>四、基于zk实现分布式锁</h3><p>ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。Zk的数据节点和文件目录类似，所以我们可以用此特性实现分布式锁。</p><p>基本实现步骤如下：</p><p>1、客户端尝试创建一个znode节点，比如/lock。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode已存在），获取锁失败。</p><p>2、持有锁的客户端访问共享资源完成后，将znode删掉，这样其它客户端接下来就能来获取锁了。</p><p>注意：<br>  这里的znode应该被创建成ephemeral的（临时节点）。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除。这保证了锁一定会被释放。</p><h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><p>看起来这个锁相当完美，没有Redlock过期时间的问题，而且能在需要的时候让锁自动释放。但其实也存在这其中也存在问题。</p><p>ZooKeeper是怎么检测出某个客户端已经崩溃了呢？实际上，每个客户端都与ZooKeeper的某台服务器维护着一个Session，这个Session依赖定期的心跳(heartbeat)来维持。如果ZooKeeper长时间收不到客户端的心跳（这个时间称为Sesion的过期时间），那么它就认为Session过期了，通过这个Session所创建的所有的ephemeral类型的znode节点都会被自动删除。</p><p>假如按照下面的顺序执行：</p><p>1、客户端1创建了znode节点/lock，获得了锁。</p><p>2、客户端1进入了长时间的GC pause。</p><p>3、客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。</p><p>4、客户端2创建了znode节点/lock，从而获得了锁。</p><p>5、客户端1从GC pause中恢复过来，它仍然认为自己持有锁。</p><p>由上面的执行顺序，可以发现最后客户端1和客户端2都认为自己持有了锁，冲突了。所以说，用ZooKeeper实现的分布式锁也不一定就是安全的，该有的问题它还是有。</p><h4 id="zk的watch机制"><a href="#zk的watch机制" class="headerlink" title="zk的watch机制"></a>zk的watch机制</h4><p>ZooKeeper有个很特殊的机制–watch机制。这个机制可以这样来使用，比如当客户端试图创建 /lock 节点的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6844903688088059912">https://juejin.cn/post/6844903688088059912</a></li><li>Redlock的算法：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></li><li><a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></li><li>linux的同步IO操作函数: sync、fsync与fdatasync：<a href="https://my.oschina.net/u/1377774/blog/529847">https://my.oschina.net/u/1377774/blog/529847</a></li><li><a href="https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w">https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是介绍分布式锁相关的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是介绍分布式锁相关的内容。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;a href=&quot;#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;/a&gt;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://www.blog.ajie39.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式锁" scheme="https://www.blog.ajie39.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>YAML的常用语法</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/YAML%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/YAML%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2021-05-05T04:26:56.000Z</published>
    <updated>2021-05-05T04:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：主要介绍YAML的常用语法"><a href="#摘要：主要介绍YAML的常用语法" class="headerlink" title="摘要：主要介绍YAML的常用语法"></a>摘要：主要介绍YAML的常用语法</h1><hr><h1 id="前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。"><a href="#前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。" class="headerlink" title="前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。"></a>前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。</h1><hr><span id="more"></span><h1 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h1><h2 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h2><p><strong>诞生</strong></p><p>  YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822。Clark Evans在2001年5月在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。</p><p><strong>命名</strong></p><p>  YAML是<code>&quot;YAML Ain&#39;t a Markup Languag&quot;</code>（YAML不是一种置标语言）的递归缩写。在开发的这种语言时，YAML的意思其实是：Yet Another Markup Language（仍是一种置标语言）。</p><p><strong>功能</strong></p><p>  YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表，标量等资料形态、。它使用空白符号缩排和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种设定档、倾印除错内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。尽管它比较适合用来表达阶层式（hierarchical model）的数据结构，不过也有精致的语法可以表示关联性（relational model）的资料。由于YAML使用空白字符和分行来分隔资料，使得它他特别适合用grep、Python、Perl、Ruby操作。其让人最容易上手的特色是巧妙避开各种封闭符号，如：引号、各种括号等，这些符号在嵌套结构中会变得复杂而难以辨认。</p><p><strong>它的基本语法规则如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 大小写敏感。</span><br><span class="line">- 使用缩进表示层级关系。</span><br><span class="line">- 缩进时不允许使用Tab键，只允许使用空格。</span><br><span class="line">- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可。</span><br></pre></td></tr></table></figure><p><code># 表示注释，从这个字符一直到行尾，都会被解析器忽略。</code></p><p><strong>YAML 支持的数据结构有三种：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</span><br><span class="line">- 数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</span><br><span class="line">- 纯量（scalars）：单个的、不可再分的值</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的一组键值对，使用冒号结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal: pets</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal: &#39;pets&#39; &#125;</span><br></pre></td></tr></table></figure><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash: &#123; name: Steve, foo: bar &#125;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; hash: &#123; name: &#39;Steve&#39;, foo: &#39;bar&#39; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一组连词线开头的行，构成一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Cat</span><br><span class="line">- Dog</span><br><span class="line">- Goldfish</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#39;Cat&#39;, &#39;Dog&#39;, &#39;Goldfish&#39; ]</span><br></pre></td></tr></table></figure><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line"> - Cat</span><br><span class="line"> - Dog</span><br><span class="line"> - Goldfish</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ &#39;Cat&#39;, &#39;Dog&#39;, &#39;Goldfish&#39; ] ]</span><br></pre></td></tr></table></figure><p>数组也可以采用行内表示法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal: [Cat, Dog]</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal: [ &#39;Cat&#39;, &#39;Dog&#39; ] &#125;</span><br></pre></td></tr></table></figure><h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><p>对象和数组可以结合使用，形成复合结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">languages:</span><br><span class="line"> - Ruby</span><br><span class="line"> - Perl</span><br><span class="line"> - Python</span><br><span class="line">websites:</span><br><span class="line"> YAML: yaml.org</span><br><span class="line"> Ruby: ruby-lang.org</span><br><span class="line"> Python: python.org</span><br><span class="line"> Perl: use.perl.org</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; languages: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39; ],</span><br><span class="line">  websites:</span><br><span class="line">   &#123; YAML: &#39;yaml.org&#39;,</span><br><span class="line">     Ruby: &#39;ruby-lang.org&#39;,</span><br><span class="line">     Python: &#39;python.org&#39;,</span><br><span class="line">     Perl: &#39;use.perl.org&#39; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h3><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串</span><br><span class="line">布尔值</span><br><span class="line">整数</span><br><span class="line">浮点数</span><br><span class="line">Null</span><br><span class="line">时间</span><br><span class="line">日期</span><br></pre></td></tr></table></figure><p>数值直接以字面量的形式表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number: 12.30</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; number: 12.30 &#125;</span><br></pre></td></tr></table></figure><p>布尔值用true和false表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isSet: true</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; isSet: true &#125;</span><br></pre></td></tr></table></figure><p>null用~表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent: ~</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; parent: null &#125;</span><br></pre></td></tr></table></figure><p>时间采用 ISO8601 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iso8601: 2001-12-14t21:59:43.10-05:00</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; iso8601: new Date(&#39;2001-12-14t21:59:43.10-05:00&#39;) &#125;</span><br></pre></td></tr></table></figure><p>日期采用复合 iso8601 格式的年、月、日表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date: 1976-07-31</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; date: new Date(&#39;1976-07-31&#39;) &#125;</span><br></pre></td></tr></table></figure><p>YAML 允许使用两个感叹号，强制转换数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e: !!str 123</span><br><span class="line">f: !!str true</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; e: &#39;123&#39;, f: &#39;true&#39; &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是最常见，也是最复杂的一种数据类型。</p><p>字符串默认不使用引号表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: 这是一行字符串</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;这是一行字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>如果字符串之中包含空格或特殊字符，需要放在引号之中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: &#39;内容： 字符串&#39;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;内容: 字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>单引号和双引号都可以使用，双引号不会对特殊字符转义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1: &#39;内容\n字符串&#39;</span><br><span class="line">s2: &quot;内容\n字符串&quot;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; s1: &#39;内容\\n字符串&#39;, s2: &#39;内容\n字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>单引号之中如果还有单引号，必须连续使用两个单引号转义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: &#39;labor&#39;&#39;s day&#39;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;labor\&#39;s day&#39; &#125;</span><br></pre></td></tr></table></figure><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str: 这是一段</span><br><span class="line">  多行</span><br><span class="line">  字符串</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;这是一段 多行 字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this: |</span><br><span class="line">  Foo</span><br><span class="line">  Bar</span><br><span class="line">that: &gt;</span><br><span class="line">  Foo</span><br><span class="line">  Bar</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; this: &#39;Foo\nBar\n&#39;, that: &#39;Foo Bar\n&#39; &#125;</span><br></pre></td></tr></table></figure><p>+表示保留文字块末尾的换行，-表示删除字符串末尾的换行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1: |</span><br><span class="line">  Foo</span><br><span class="line"></span><br><span class="line">s2: |+</span><br><span class="line">  Foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s3: |-</span><br><span class="line">  Foo</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; s1: &#39;Foo\n&#39;, s2: &#39;Foo\n\n\n&#39;, s3: &#39;Foo&#39; &#125;</span><br></pre></td></tr></table></figure><p>字符串之中可以插入 HTML 标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message: |</span><br><span class="line"></span><br><span class="line">  &lt;p style&#x3D;&quot;color: red&quot;&gt;</span><br><span class="line">    段落</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; message: &#39;\n&lt;p style&#x3D;&quot;color: red&quot;&gt;\n  段落\n&lt;&#x2F;p&gt;\n&#39; &#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaults: &amp;defaults</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure><p>等同于下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaults:</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br></pre></td></tr></table></figure><p><code>&amp;</code>用来建立锚点（defaults），<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点。</p><p>下面是另一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- &amp;showell Steve</span><br><span class="line">- Clark</span><br><span class="line">- Brian</span><br><span class="line">- Oren</span><br><span class="line">- *showell</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#39;Steve&#39;, &#39;Clark&#39;, &#39;Brian&#39;, &#39;Oren&#39;, &#39;Steve&#39; ]</span><br></pre></td></tr></table></figure><h3 id="函数和正则表达式的转换"><a href="#函数和正则表达式的转换" class="headerlink" title="函数和正则表达式的转换"></a>函数和正则表达式的转换</h3><p>这是<a href="https://github.com/nodeca/js-yaml">JS-YAML</a>库特有的功能，可以把函数和正则表达式转为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># example.yml</span><br><span class="line">fn: function () &#123; return 1 &#125;</span><br><span class="line">reg: &#x2F;test&#x2F;</span><br></pre></td></tr></table></figure><p>解析上面的 yml 文件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var yaml &#x3D; require(&#39;js-yaml&#39;);</span><br><span class="line">var fs   &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  var doc &#x3D; yaml.load(</span><br><span class="line">    fs.readFileSync(&#39;.&#x2F;example.yml&#39;, &#39;utf8&#39;)</span><br><span class="line">  );</span><br><span class="line">  console.log(doc);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 JavaScript 对象还原到 yaml 文件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var yaml &#x3D; require(&#39;js-yaml&#39;);</span><br><span class="line">var fs   &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  fn: function () &#123; return 1 &#125;,</span><br><span class="line">  reg: &#x2F;test&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    &#39;.&#x2F;example.yml&#39;,</span><br><span class="line">    yaml.dump(obj),</span><br><span class="line">    &#39;utf8&#39;</span><br><span class="line">  );</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：主要介绍YAML的常用语法&quot;&gt;&lt;a href=&quot;#摘要：主要介绍YAML的常用语法&quot; class=&quot;headerlink&quot; title=&quot;摘要：主要介绍YAML的常用语法&quot;&gt;&lt;/a&gt;摘要：主要介绍YAML的常用语法&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot;&gt;&lt;a href=&quot;#前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot; class=&quot;headerlink&quot; title=&quot;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot;&gt;&lt;/a&gt;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    <category term="Blog" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/Blog/"/>
    
    
    <category term="YAML" scheme="https://www.blog.ajie39.top/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>Spring中常用的注解</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Spring%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Spring%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-05-05T04:26:50.000Z</published>
    <updated>2021-05-05T04:26:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：本文主要总结了一些Spring和Spring-MVC中常用的注解。"><a href="#摘要：本文主要总结了一些Spring和Spring-MVC中常用的注解。" class="headerlink" title="摘要：本文主要总结了一些Spring和Spring MVC中常用的注解。"></a>摘要：本文主要总结了一些Spring和Spring MVC中常用的注解。</h1><hr><h1 id="前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。"><a href="#前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。" class="headerlink" title="前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。"></a>前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。</h1><hr><span id="more"></span><h2 id="Spring中常用注解"><a href="#Spring中常用注解" class="headerlink" title="Spring中常用注解"></a>Spring中常用注解</h2><h3 id="1、声明bean的注解"><a href="#1、声明bean的注解" class="headerlink" title="1、声明bean的注解"></a>1、声明bean的注解</h3><ul><li><p>@Component：这个更多对应的是一个组件的概念，如果一个Bean不知道属于哪个层，可以使用@Component注解标注</p><ol><li>@Component作用在类上</li><li>@Component注解作用域默认为singleton</li><li>使用注解配置和类路径扫描时，被@Component注解标注的类会被Spring扫描并注册为Bean</li><li>@Component使用在不确定哪一个层的时候使用，可以作用在任何层次，把普通pojo实例化到spring容器，不推荐使用@Component注解，而应该使用它的扩展，如@Service、@Repository</li><li>@Component使用时没有传参数，Bean名称默认为当前类的类名，首字母小写</li><li>@Component(“serviceBeanId”)或 @Component(value=”serviceBeanId”)使用时传参数，使用value作为Bean名字</li></ol></li><li><p>@Service：对应的是服务层即Service层，其作用是对单条/多条Sql语句进行组合处理，当然如果简单的话就直接调用Dao层的某个方法了</p><ol><li><p>@Service是@Component注解的一个特例，作用在类上</p></li><li><p>@Service注解作用域默认为singleton</p></li><li><p>使用注解配置和类路径扫描时，被@Service注解标注的类会被Spring扫描并注册为Bean</p></li><li><p>@Service用于标注业务层组件,表示定义一个bean</p></li><li><p>@Service使用时没有传参数，Bean名称默认为当前类的类名，首字母小写</p></li><li><p>@Service(“serviceBeanId”)或 @Service(value=”serviceBeanId”)使用时传参数，使用value作为Bean名字</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @service注解举例 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.demo.annotation.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">&quot;UserServiceImpl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@Service(value=&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplWithParam</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;UserServiceImplWithParam&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.DemoApplication;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.annotation.IUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        IUser serviceImpl1 = (UserServiceImpl) context.getBean(<span class="string">&quot;userServiceImpl&quot;</span>);</span><br><span class="line">        System.out.println(serviceImpl1.get());</span><br><span class="line"></span><br><span class="line">        IUser serviceImpl2 = (UserServiceImplWithParam)context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(serviceImpl2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  结果为:</span></span><br><span class="line"><span class="comment">          userServiceImpl</span></span><br><span class="line"><span class="comment">          UserServiceImplWithParam</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>@Repository：对应的是持久层即Dao层，其作用是直接和数据库交互，通常来说一个方法对应一条具体的Sql语句</p><ol><li>@Repository注解作用在类上</li><li>@Repository注解作用域默认为singleton</li><li>使用注解配置和类路径扫描时，被@Reposito注解标注的类会被Spring扫描并注册为Bean</li><li>@Repository注解用于标注数据访问组件，即DAO组件</li><li>@Repository注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* @Repository注解举例 */</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Repository注解默认作用域为singleton</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">UserRepositoryImpl</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Repository注解测试</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepopsitoryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(RepopsitoryApplication.class, args);</span><br><span class="line"></span><br><span class="line">        UserRepositoryImpl userRepositoryImpl1 = (UserRepositoryImpl) context.getBean(<span class="string">&quot;userRepositoryImpl&quot;</span>);</span><br><span class="line">        UserRepositoryImpl userRepositoryImpl2 = (UserRepositoryImpl) context.getBean(<span class="string">&quot;userRepositoryImpl&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;@Repository注解默认作用域为singleton，返回true： &quot;</span> + userRepositoryImpl1.equals(userRepositoryImpl2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果为：<span class="doctag">@Repository</span>注解默认作用域为singleton，返回true：true</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>@Controller：对应的是控制层即MVC设计模式中的控制层，其作用是接收用户请求，根据请求调用不同的Service取数据，并根据需求对数据进行组合、包装返回给前端</p><ol><li>@Controller注解作用在类上</li><li>使用注解配置和类路径扫描时，被@Controller注解标注的类会被Spring扫描并注册为Bean</li><li>@Controller用于标注Web中控制层组件</li><li>被@Controller标注的类负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model返回给对应的View进行展示</li><li>@Controller和@RequestMapping、@RequestParam等一些注解共同处理URL的映射</li></ol></li></ul><h3 id="2、-Bean的属性支持"><a href="#2、-Bean的属性支持" class="headerlink" title="2、@Bean的属性支持"></a>2、@Bean的属性支持</h3><ul><li><p>@Scope：</p><ol><li><p>@Scope作用在类上和方法上</p></li><li><p>@Scope用来配置 spring bean 的作用域，它标识 bean 的作用域</p></li><li><p>@Scope有5中取值：</p><ul><li><p>基本作用域：</p><ol><li>org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_SINGLETON = “singleton”</li><li>org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_PROTOTYPE = “prototype”</li></ol></li><li><p>Web作用域：</p><ol><li>org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST = “request”</li><li>org.springframework.web.context.WebApplicationContext#SCOPE_SESSION = “session”</li><li>org.springframework.web.context.WebApplicationContext#SCOPE_APPLICATION = “application”</li></ol></li><li><p>singleton单例模式：</p><p>Spring 容器中有且只有一个Bean实例，只要Spring容器不销毁或退出，该Bean实例就会一直存活。</p></li><li><p>prototype原型模式：</p><p>每次获取Bean的时候会有一个新的实例，Spring容器不能对返回Bean实例的整个生命周期负责。</p></li><li><p>request模式：</p><p>request只适用于Web程序，每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，当请求结束后，该对象的生命周期即告结束。</p></li><li><p>session模式：</p><p>session只适用于Web程序，session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效。</p></li><li><p>application模式：</p><p>application只适用于Web程序，全局作用域。</p></li></ul></li></ol></li><li><p>@StepScope 在Spring Batch中还有涉及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(value=&quot;step&quot;,proxyMode=TARGET_CLASS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(value=RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> StepScope</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Convenient annotation for step scoped beans that defaults the proxy mode, so that it doesn&#x27;t have to be</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> specified explicitly on every bean definition. Use this on any @Bean that needs to inject @Values from the step</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> context, and any bean that needs to share a lifecycle with a step execution (e.g. an ItemStream). E.g.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@StepScope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Callable&lt;String&gt; <span class="title">value</span><span class="params">(<span class="meta">@Value(&quot;#&#123;stepExecution.stepName&#125;&quot;)</span> <span class="keyword">final</span> String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleCallable(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Marking a @Bean as @StepScope is equivalent to marking it as @Scope(value=&quot;step&quot;, proxyMode=TARGET_CLASS) */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>@PostConstruct：被 @PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的inti()方法。被 @PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。</p></li><li><p>@PreDestory：被 @PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被 @PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前。</p></li></ul><h3 id="3、注入bean的注解"><a href="#3、注入bean的注解" class="headerlink" title="3、注入bean的注解"></a>3、注入bean的注解</h3><ul><li><p>@Autowired：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 源码 */</span></span><br><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> 2. <span class="doctag">@see</span> AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> 3. <span class="doctag">@see</span> Qualifier</span></span><br><span class="line"><span class="comment"> 4. <span class="doctag">@see</span> Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER,</span></span><br><span class="line"><span class="meta">   ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Autowired注解作用在构造函数、方法、方法参数、类字段以及注解上</li><li>@Autowired注解可以实现Bean的自动注入</li></ul><p>原理：</p><p>在Spring Boot应用启动时，Spring容器会自动装载一个org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor处理器，当容器扫描到@Autowired注解时，就会在IoC容器就会找相应类型的Bean，并且实现注入。</p><ol><li>在使用@Autowired注解时，首先在容器中查询对应类型的bean</li><li>如果查询结果Bean刚好为一个，自动注入</li><li>如果查询结果Bean不止一个，通过@Qualifier注解指定自动装配Bean的名称</li><li>如果没有查询到对应类型的Bean，由于默认@Autowired(required=true)，会抛出异常，解决方法是使用@Autoiwired(required=false)</li><li>@Autowired(required=true)意味着依赖是必须的</li><li>@Autowired(required=false)等于告诉 Spring：在找不到匹配 Bean 时也不报错</li></ol><p>使用：</p><p>在Web MVC中控制层（Controller）访问的是业务层（Service），而业务层（Service）访问的是数据层（Dao）,使用@Autowired注解实现注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据层接口，用于访问数据库，返回数据给业务层</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据层接口实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.数据层Bean用<span class="doctag">@Repository</span>标注</span></span><br><span class="line"><span class="comment"> * 2.当前Bean的名称是&quot;autowiredUserDaoImpl&quot;</span></span><br><span class="line"><span class="comment"> * 3.设置当前Bean的为原型模式，即每次获取Bean时都创建一个新实例</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Repository(&quot;autowiredUserDaoImpl&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;@Autowired注解实现自动装配&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务层接口</span></span><br><span class="line"><span class="comment"> * 从数据层获取数据，处理结果返回给控制层</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务层接口实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.数据层Bean用<span class="doctag">@Service</span>标注</span></span><br><span class="line"><span class="comment"> * 2.当前Bean的名称是&quot;autowiredUserServiceImpl&quot;</span></span><br><span class="line"><span class="comment"> * 3.设置当前Bean的为原型模式，即每次获取Bean时都创建一个新实例</span></span><br><span class="line"><span class="comment"> * 4.业务层有一个数据层接口IDao，使用<span class="doctag">@Autowired</span>注解标注</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;autowiredUserServiceImpl&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Autowired</span>实现自动装配</span></span><br><span class="line"><span class="comment">     * Spring IoC容器扫描到<span class="doctag">@Autowired</span>注解会去查询IDao的实现类，并自动注入</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Bean通过注解@Service声明为一个Spring容器管理的Bean，Spring容器会扫描classpath路径下的所有类，找到带有@Service注解的UserServiceImpl类，并根据Spring注解对其进行初始化和增强，命名为autowiredUserServiceImpl。</li><li>Spring容器如果发现此类属性dao也有注解@Autowired，则会从Spring容器中查找一个已经初始化好的IDao的实现类，如果没有找到，则先初始化一个IDao实现类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.chapter1.useannotation.autowired.service.IService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. 控制层</span></span><br><span class="line"><span class="comment"> 2.</span></span><br><span class="line"><span class="comment"> 3. 1.控制层使用<span class="doctag">@RestController</span>注解标注，返回json格式的字符串</span></span><br><span class="line"><span class="comment"> 4. 2.获取业务层返回的数据，输出到客户端</span></span><br><span class="line"><span class="comment"> 5. 3.请求：http:localhost:8080/autowiredController</span></span><br><span class="line"><span class="comment"> 6. */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/autowiredController&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Inject： @Inject支持构造函数、方法和字段注解，也可能使用于静态实例成员。可注解成员可以是任意修饰符（private,package-private,protected,public）。注入顺序：构造函数、字段，然后是方法。父类的字段和方法注入优先于子类的字段和方法，同一类中的字段和方法是没有顺序的。</p><ul><li><p>@Inject注解的构造函数可以是无参或多个参数的构造函数。@Inject每个类中最多注解一个构造函数。</p></li><li><p>在字段注解：</p><ul><li>用@Inject注解</li><li>字段不能是final的</li><li>拥有一个合法的名称</li></ul></li><li><p>在方法上注解：</p><ul><li>用@Inject注解</li><li>不能是抽象方法</li><li>不能声明自身参数类型</li><li>可以有返回结果</li><li>拥有一个合法的名称</li><li>可以有0个或多个参数</li></ul></li></ul></li><li><p>@Resource：@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行，按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;baseDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、java配置类相关注解"><a href="#4、java配置类相关注解" class="headerlink" title="4、java配置类相关注解"></a>4、java配置类相关注解</h3><ul><li><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）。</p></li><li><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）。</p></li><li><p>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）。</p></li><li><p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）。</p></li><li><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解。</p></li></ul><h3 id="5、切面（AOP）相关注解"><a href="#5、切面（AOP）相关注解" class="headerlink" title="5、切面（AOP）相关注解"></a>5、切面（AOP）相关注解</h3><p>Spring支持AspectJ的注解式切面编程。</p><ul><li><p>@Aspect 声明一个切面（类上）：使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><ul><li>@After 在方法执行之后执行（方法上）</li><li>@Before 在方法执行之前执行（方法上）</li><li>@Around 在方法执行之前与之后执行（方法上）</li></ul></li><li><p>@PointCut 声明切点：在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p></li></ul><h3 id="6、-Value注解"><a href="#6、-Value注解" class="headerlink" title="6、@Value注解"></a>6、@Value注解</h3><h4 id="Value-为属性注入值（属性上）"><a href="#Value-为属性注入值（属性上）" class="headerlink" title="@Value 为属性注入值（属性上）"></a>@Value 为属性注入值（属性上）</h4><p>支持如下方式的注入：</p><ol><li>注入普通字符：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;Michael Jackson&quot;)</span></span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><ol start="2"><li>注入操作系统属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;os.name&#x27;]&#125;&quot;)</span></span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><ol start="3"><li>注入表达式结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;T(java.lang.Math).random() * 100&#125;&quot;)</span></span><br><span class="line">String randomNumber;</span><br></pre></td></tr></table></figure><ol start="4"><li>注入其他bean属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;domeClass.name&#125;&quot;)</span></span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><ol start="5"><li>注入文件资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;classpath:com/hello/hello/text.txt&quot;)</span></span><br><span class="line">String Resource file;</span><br></pre></td></tr></table></figure><ol start="6"><li>注入网站资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;http://www.cznovel.com&quot;)</span></span><br><span class="line">Resource url;</span><br></pre></td></tr></table></figure><ol start="7"><li>注入配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span></span><br><span class="line">String bookname;</span><br></pre></td></tr></table></figure><h4 id="注入配置使用方法"><a href="#注入配置使用方法" class="headerlink" title="注入配置使用方法"></a>注入配置使用方法</h4><p>①. 编写配置文件（test.properties）</p><p>②. @PropertySource加载配置文件（类上）</p><p>③. 还需要配置一个PropertySourcesPlaceholderConfigurer的bean</p><h3 id="7、环境切换"><a href="#7、环境切换" class="headerlink" title="7、环境切换"></a>7、环境切换</h3><ul><li>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</li><li>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</li></ul><h3 id="8、异步相关"><a href="#8、异步相关" class="headerlink" title="8、异步相关"></a>8、异步相关</h3><ul><li>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</li><li>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</li></ul><h3 id="9、定时任务相关"><a href="#9、定时任务相关" class="headerlink" title="9、定时任务相关"></a>9、定时任务相关</h3><ul><li>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）</li><li>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</li></ul><h3 id="10、-Enable-注解说明"><a href="#10、-Enable-注解说明" class="headerlink" title="10、@Enable*注解说明"></a>10、@Enable*注解说明</h3><p>这些注解主要用来开启对xxx的支持：</p><ul><li><p>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</p></li><li><p>@EnableAsync 开启异步方法的支持</p></li><li><p>@EnableScheduling 开启计划任务的支持</p></li><li><p>@EnableWebMvc 开启Web MVC的配置支持</p></li><li><p>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</p></li><li><p>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</p></li><li><p>@EnableTransactionManagement 开启注解式事务的支持</p></li><li><p>@EnableTransactionManagement 开启注解式事务的支持</p></li><li><p>@EnableCaching 开启注解式的缓存支持</p></li></ul><h3 id="11、测试相关注解"><a href="#11、测试相关注解" class="headerlink" title="11、测试相关注解"></a>11、测试相关注解</h3><ul><li>@RunWith 运行器，Spring中通常用于对JUnit的支持</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br></pre></td></tr></table></figure><ul><li>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes=&#123;TestConfig.class&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="Spring-MVC中常用注解"><a href="#Spring-MVC中常用注解" class="headerlink" title="Spring MVC中常用注解"></a>Spring MVC中常用注解</h2><ol><li><p>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p></li><li><p>@Controller 声明该类为SpringMVC中的Controller</p></li><li><p>@RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p></li><li><p>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p></li><li><p>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p></li><li><p>@PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p></li><li><p>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p></li><li><p>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，这对所有注解了 @RequestMapping的控制器内的方法有效。</p></li><li><p>@ExceptionHandler 用于全局处理控制器里的异常</p></li><li><p>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p></li><li><p>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的 @RequestMapping都能获得在此处设置的键值对。</p></li></ol><h2 id="其它注解"><a href="#其它注解" class="headerlink" title="其它注解"></a>其它注解</h2><ol><li><p>@SpringBootApplication： @SpringBootApplication是一个复合注解，包括@ComponentScan，和@SpringBootConfiguration，@EnableAutoConfiguration。</p><ul><li><p>@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名。</p></li><li><p>@EnableAutoConfiguration的作用启动自动的配置，@EnableAutoConfiguration注解的意思就是Springboot根据你添加的jar包来配置你项目的默认配置，比如根据spring-boot-starter-web ，来判断你的项目是否需要添加了webmvc和tomcat，就会自动的帮你配置web项目中所需要的默认配置。在下面博客会具体分析这个注解，快速入门的demo实际没有用到该注解。</p></li><li><p>@ComponentScan，扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。是以前的<a href="context:component-scan">context:component-scan</a>（以前使用在xml中使用的标签，用来扫描包配置的平行支持）。所以本demo中的User为何会被spring容器管理。</p></li></ul></li><li><p>@RestController</p></li></ol><p>Spring4之后新加入的注解，原来返回json需要@ResponseBody和@Controller配合。</p><p>即@RestController是@ResponseBody和@Controller的组合注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello&quot;,method= RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello&quot;,method= RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@Slf4j</li></ol><p>@slf4j注解用于打印日志，如果注解@Slf4j注入后找不到变量log，那就给IDE安装lombok插件</p><p>安装步骤：</p><p>Settings→Plugins→Browse repositories→lombok plugin</p><ol start="3"><li>@Override</li></ol><p>如果想重写父类的方法，比如toString()方法的话，在方法前面加上@Override 系统可以帮你检查方法的正确性。它说明了被标注的方法重载了父类的方法，起到了断言的作用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：本文主要总结了一些Spring和Spring-MVC中常用的注解。&quot;&gt;&lt;a href=&quot;#摘要：本文主要总结了一些Spring和Spring-MVC中常用的注解。&quot; class=&quot;headerlink&quot; title=&quot;摘要：本文主要总结了一些Spring和Spring MVC中常用的注解。&quot;&gt;&lt;/a&gt;摘要：本文主要总结了一些Spring和Spring MVC中常用的注解。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。&quot;&gt;&lt;a href=&quot;#前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。&quot; class=&quot;headerlink&quot; title=&quot;前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。&quot;&gt;&lt;/a&gt;前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="Spring" scheme="https://www.blog.ajie39.top/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.blog.ajie39.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>python之操作Excel模块</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/python%E4%B9%8B%E6%93%8D%E4%BD%9CExcel%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/python%E4%B9%8B%E6%93%8D%E4%BD%9CExcel%E6%A8%A1%E5%9D%97/</id>
    <published>2021-05-05T04:26:48.000Z</published>
    <updated>2021-05-05T04:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：python操作Excel文件，第三方模块汇总。"><a href="#摘要：python操作Excel文件，第三方模块汇总。" class="headerlink" title="摘要：python操作Excel文件，第三方模块汇总。"></a>摘要：python操作Excel文件，第三方模块汇总。</h1><hr><h1 id="前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。"><a href="#前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。" class="headerlink" title="前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。"></a>前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。</h1><hr><span id="more"></span><h2 id="常见库简介"><a href="#常见库简介" class="headerlink" title="常见库简介"></a>常见库简介</h2><h3 id="1-xlrd"><a href="#1-xlrd" class="headerlink" title="1.xlrd"></a>1.xlrd</h3><p>xlrd是一个从Excel文件读取数据和格式化信息的库，支持.xls以及.xlsx文件。<br><a href="http://xlrd.readthedocs.io/en/latest/">http://xlrd.readthedocs.io/en/latest/</a><br>    1、xlrd支持.xls，.xlsx文件的读<br>    2、通过设置on_demand变量使open_workbook()函数只加载那些需要的sheet，从而节省时间和内存（该方法对.xlsx文件无效）。<br>    3、xlrd.Book对象有一个unload_sheet方法，它将从内存中卸载工作表，由工作表索引或工作表名称指定（该方法对.xlsx文件无效）</p><h3 id="2-xlwt"><a href="#2-xlwt" class="headerlink" title="2.xlwt"></a>2.xlwt</h3><p>xlwt是一个用于将数据和格式化信息写入旧Excel文件的库（如.xls）。<br><a href="https://xlwt.readthedocs.io/en/latest/">https://xlwt.readthedocs.io/en/latest/</a><br>    1、xlwt支持.xls文件写。</p><h3 id="3-xlutils"><a href="#3-xlutils" class="headerlink" title="3.xlutils"></a>3.xlutils</h3><p>xlutils是一个处理Excel文件的库，依赖于xlrd和xlwt。<br><a href="http://xlutils.readthedocs.io/en/latest/">http://xlutils.readthedocs.io/en/latest/</a><br>    1、xlutils支持.xls文件。<br>    2、支持Excel操作。</p><h3 id="4-xlwings"><a href="#4-xlwings" class="headerlink" title="4.xlwings"></a>4.xlwings</h3><p>xlwings是一个可以实现从Excel调用Python，也可在python中调用Excel的库。<br><a href="http://docs.xlwings.org/en/stable/index.html">http://docs.xlwings.org/en/stable/index.html</a><br>    1、xlwings支持.xls读，支持.xlsx文件读写。<br>    2、支持Excel操作。<br>    3、支持VBA。<br>    4、强大的转换器可以处理大部分数据类型，包括在两个方向上的numpy array和pandas DataFrame。</p><h3 id="5-openpyxl"><a href="#5-openpyxl" class="headerlink" title="5.openpyxl"></a>5.openpyxl</h3><p>openpyxl是一个用于读取和编写Excel 2010 xlsx/xlsm/xltx/xltm文件的库。<br><a href="https://openpyxl.readthedocs.io/en/stable/">https://openpyxl.readthedocs.io/en/stable/</a><br>    1、openpyxl支持.xlsx文件的读写。<br>    2、支持Excel操作。<br>    3、加载大.xlsx文件可以使用read_only模式。<br>    4、写入大.xlsx文件可以使用write_only模式。</p><h3 id="6-xlsxwriter"><a href="#6-xlsxwriter" class="headerlink" title="6.xlsxwriter"></a>6.xlsxwriter</h3><p>xlsxwriter是一个用于创建Excel .xlsx文件的库。<br><a href="https://xlsxwriter.readthedocs.io/">https://xlsxwriter.readthedocs.io/</a><br>    1、xlswriter支持.xlsx文件的写。<br>    2、支持VBA。<br>    3、写入大.xlsx文件时使用内存优化模式。</p><h3 id="7-win32com"><a href="#7-win32com" class="headerlink" title="7.win32com"></a>7.win32com</h3><p>win32com库存在于pywin32中，是一个读写和处理Excel文件的库。<br><a href="http://pythonexcels.com/python-excel-mini-cookbook/">http://pythonexcels.com/python-excel-mini-cookbook/</a><br>    1、win32com支持.xls，.xlsx文件的读写，支持.xlsx文件的写。<br>    2、支持Excel操作。</p><h3 id="8-DataNitro"><a href="#8-DataNitro" class="headerlink" title="8.DataNitro"></a>8.DataNitro</h3><p>DataNitro是一个内嵌在Excel中的插件。<br><a href="https://datanitro.com/docs/">https://datanitro.com/docs/</a> <br>    1、DataNitro支持.xls，.xlsx文件的读写。<br>    2、支持Excel操作。<br>    3、支持VBA。<br>    4、收费</p><h3 id="9-pandas"><a href="#9-pandas" class="headerlink" title="9.pandas"></a>9.pandas</h3><p>pandas通过对Excel文件的读写实现数据输入输出<br><a href="http://pandas.pydata.org/">http://pandas.pydata.org/</a><br>    1、pandas支持.xls，.xlsx文件的读写。<br>    2、支持只加载每个表的单一工作页。</p><table><thead><tr><th></th><th>win</th><th>MAC</th><th>Py2</th><th>Py3</th><th>.xls</th><th>.xlsx</th><th>读</th><th>写</th><th>修改</th></tr></thead><tbody><tr><td>xlrd</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td></tr><tr><td>xlwt</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>xlutils</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td><td>&chi;</td><td>&radic;</td></tr><tr><td>xlwings</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>openpyxl</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>xlswriter</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&chi;</td></tr><tr><td>win32com</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>DataNitro</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr><tr><td>pandas</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td></tr></tbody></table><h3 id="提醒及注意："><a href="#提醒及注意：" class="headerlink" title="提醒及注意："></a>提醒及注意：</h3><p>xlutils 仅支持 xls 文件，即2003以下版本；<br>win32com 与 DataNitro 仅支持 windows 系统；<br>xlwings 安装成功后，如果运行提示报错“ImportError: no module named win32api”，请再安装 pypiwin32 或者 pywin32 包；<br>win32com 不是独立的扩展库，而是集成在其他库中，安装 pypiwin32 或者 pywin32 包即可使用；<br>DataNitro 是 Excel 的插件，安装需到官网下载。</p><h2 id="基本功能："><a href="#基本功能：" class="headerlink" title="基本功能："></a>基本功能：</h2><p>由于设计目的不同，每个模块通常着重于某一方面功能，各有所长。</p><h3 id="1-xlwings"><a href="#1-xlwings" class="headerlink" title="1.xlwings"></a>1.xlwings</h3><p>可结合 VBA 实现对 Excel 编程，强大的数据输入分析能力，同时拥有丰富的接口，结合 pandas/numpy/matplotlib 轻松应对 Excel 数据处理工作。</p><h3 id="2-openpyxl"><a href="#2-openpyxl" class="headerlink" title="2.openpyxl"></a>2.openpyxl</h3><p>简单易用，功能广泛，单元格格式/图片/表格/公式/筛选/批注/文件保护等等功能应有尽有，图表功能是其一大亮点，缺点是对 VBA 支持的不够好。</p><h3 id="3-pandas"><a href="#3-pandas" class="headerlink" title="3.pandas"></a>3.pandas</h3><p>数据处理是 pandas 的立身之本，Excel 作为 pandas 输入/输出数据的容器。</p><h3 id="4-win32com"><a href="#4-win32com" class="headerlink" title="4.win32com"></a>4.win32com</h3><p>从命名上就可以看出，这是一个处理 windows 应用的扩展，Excel 只是该库能实现的一小部分功能。该库还支持 office 的众多操作。需要注意的是，该库不单独存在，可通过安装 pypiwin32 或者 pywin32 获取。</p><h3 id="5-xlsxwriter"><a href="#5-xlsxwriter" class="headerlink" title="5.xlsxwriter"></a>5.xlsxwriter</h3><p>拥有丰富的特性，支持图片/表格/图表/筛选/格式/公式等，功能与openpyxl相似，优点是相比 openpyxl 还支持 VBA 文件导入，迷你图等功能，缺点是不能打开/修改已有文件，意味着使用 xlsxwriter 需要从零开始。</p><h3 id="6-DataNitro"><a href="#6-DataNitro" class="headerlink" title="6.DataNitro"></a>6.DataNitro</h3><p>作为插件内嵌到 Excel 中，可完全替代 VBA，在 Excel 中使用 python 脚本。既然被称为 Excel 中的 python，协同其他 python 库亦是小事一桩。然而，这是付费插件…</p><h3 id="7-xlutils"><a href="#7-xlutils" class="headerlink" title="7.xlutils"></a>7.xlutils</h3><p>基于 xlrd/xlwt，老牌 python 包，算是该领域的先驱，功能特点中规中矩，比较大的缺点是仅支持 xls 文件。</p><h2 id="读写测试"><a href="#读写测试" class="headerlink" title="读写测试"></a>读写测试</h2><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>用例1. 读.xls文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例2. 读.xlsx文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例3. 读.xls文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例4. 读.xlsx文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例5. 写.xls文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例6. 写.xlsx文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例7. 写.xls文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例8. 写.xlsx文件的整个表（表有1个分页，页有2000行1200列的整数）。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th>测试模块</th><th>用例1</th><th>用例2</th><th>用例3</th><th>用例4</th><th>用例5</th><th>用例6</th><th>用例7</th><th>用例8</th></tr></thead><tbody><tr><td>xlrd</td><td>5.77</td><td>98.06</td><td>1.28</td><td>19.72</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td></td></tr><tr><td>xlwt</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>20.33</td><td>&mdash;</td><td>4.06</td><td>&mdash;</td></tr><tr><td>xlwings</td><td>1.57</td><td>11.91</td><td>2.01</td><td>3.09</td><td>&mdash;</td><td>44.00</td><td>&mdash;</td><td>9.30</td></tr><tr><td>openpyxl</td><td>&mdash;</td><td>321.70/0.01</td><td>&mdash;</td><td>42.42/0.01</td><td>&mdash;</td><td>2109.93/135.5</td><td>&mdash;</td><td>31.84/25.0</td></tr><tr><td>xlsxwriter</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>152.28</td><td>&mdash;</td><td>24.09</td></tr><tr><td>win32com</td><td>0.37</td><td>10.16</td><td>0.36</td><td>2.26</td><td>&mdash;</td><td>32.48</td><td>&mdash;</td><td>26.78</td></tr><tr><td>pandas</td><td>32.34</td><td>553.15</td><td>1.82</td><td>22.42</td><td>34.66</td><td>40.43</td><td>6.92</td><td>8.02</td></tr></tbody></table><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>1.xlwt和pandas每个工作页最多写入256列，因此测试用例修改为每页有2000行256列的整数.<br>2.xlutils读写依赖于xlrd和xlwt，不单独测试。<br>3.openpyxl测试两种模式，一是普通加载写入，二是read_only/write_only模式下的加载写入。<br>4.DataNitro要收费，且需依托Excel使用，本次不测试。</p><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>  单从读写的性能上考虑，win32com的性能是最好的，xlwings其次。</p><p>  openpyxl虽然操作Excel的功能强大，但读写性能过于糟糕，尤其是写大表时，会占用大量内存（把我的4G内存用完了），开启read_only和write_only模式后对其性能有大幅提升，尤其是对读的性能提升很大，使其几乎不耗时（0.01秒有点夸张，不过确实是加载上了）。pandas把Excel当作数据读写的容器，为其强大的数据分析服务，因此读写性能表现中规中矩，但其对Excel文件兼容性是最好的，支持读写.xls，.xlsx文件，且支持只读表中单一工作页。同样支持此功能的库还有xlrd，但xlrd只支持读，并不支持写，且性能不突出，需要配合xlutils进行Excel操作，并使用xlwt保存数据，而xlwt只能写入.xls文件（另一个可以写入.xls文件的库是pandas，且这两个写入的Excel文件最多只能有256列，其余库就我目前的了解均只能写入.xlsx文件），性能一般。xlsxwriter功能单一，一般用来创建.xlsx文件，写入性能中庸。win32com拥有最棒的读写性能，但该库存在于pywin32的库中，自身没有完善的文档，使用略吃力。xlwings拥有和win32com不相伯仲的读写性能，强大的转换器可以处理大部分数据类型，包括二维的numpy array和pandas DataFrame，可以轻松搞定数据分析的工作。</p><p>  综合考虑，xlwings的表现最佳，正如其名，xlwings——Make Excel Fly！</p><h3 id="便捷性比较"><a href="#便捷性比较" class="headerlink" title="便捷性比较"></a>便捷性比较</h3><p>    本测试目前只是针对Excel文件的读写，并未涉及Excel操作，单从读写的便捷性来讲，各库的表现难分上下，但是win32com和xlwings这两个库可以在程序运行时实时在打开的Excel文件中进行操作，实现过程的可视化，其次xlwings的数据结构转换器使其可以快速的为Excel文件添加二维数据结构而不需要在Excel文件中重定位数据的行和列，因此从读写的便捷性来比较，仍是xlwings胜出。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>最后，附上一些演示代码，大家可自行体会下不同模块的使用。</p><h3 id="6-1-xlwings基本代码"><a href="#6-1-xlwings基本代码" class="headerlink" title="6.1 xlwings基本代码"></a>6.1 xlwings基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment">#连接到excel</span></span><br><span class="line">workbook = xw.Book(<span class="string">r&#x27;path/myexcel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">#连接到指定单元格</span></span><br><span class="line">data_range = workbook.sheets(<span class="string">&#x27;Sheet1&#x27;</span>).<span class="built_in">range</span>(<span class="string">&#x27;A1&#x27;</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">data_range.value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">workbook.save()</span><br></pre></td></tr></table></figure><h3 id="6-2-xlsxwriter基本代码"><a href="#6-2-xlsxwriter基本代码" class="headerlink" title="6.2 xlsxwriter基本代码"></a>6.2 xlsxwriter基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlsxwriter <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment">#新建excel</span></span><br><span class="line">workbook  = xw.Workbook(<span class="string">&#x27;myexcel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">#新建工作薄</span></span><br><span class="line">worksheet = workbook.add_worksheet()</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">worksheet.write(<span class="string">&#x27;A1&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#关闭保存</span></span><br><span class="line">workbook.close()</span><br></pre></td></tr></table></figure><h3 id="6-3-xlutils基本代码import-xlrd-读取数据"><a href="#6-3-xlutils基本代码import-xlrd-读取数据" class="headerlink" title="6.3 xlutils基本代码import xlrd #读取数据"></a>6.3 xlutils基本代码import xlrd #读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt <span class="comment">#写入数据</span></span><br><span class="line"><span class="keyword">import</span> xlutils <span class="comment">#操作excel</span></span><br><span class="line"><span class="comment">#----xlrd库</span></span><br><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#获取表单</span></span><br><span class="line">worksheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">data = worksheet.cell_value(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#----xlwt库</span></span><br><span class="line"><span class="comment">#新建excel</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"><span class="comment">#添加工作薄</span></span><br><span class="line">sh = wb.add_sheet(<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">sh.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">wb.save(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#----xlutils库</span></span><br><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">book = xlrd.open_workbook(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#复制一份</span></span><br><span class="line">new_book = xlutils.copy(book)</span><br><span class="line"><span class="comment">#拿到工作薄</span></span><br><span class="line">worksheet = new_book.getsheet(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">worksheet.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;new data&#x27;</span>)</span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">new_book.save()</span><br></pre></td></tr></table></figure><h3 id="6-4-win32com基本代码"><a href="#6-4-win32com基本代码" class="headerlink" title="6.4 win32com基本代码"></a>6.4 win32com基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32com.client <span class="keyword">as</span> wc</span><br><span class="line"><span class="comment">#启动Excel应用</span></span><br><span class="line">excel_app = wc.Dispatch(<span class="string">&#x27;Excel.Application&#x27;</span>)</span><br><span class="line"><span class="comment">#连接excel</span></span><br><span class="line">workbook = excel_app.Workbooks.Open(<span class="string">r&#x27;e:/myexcel.xlsx&#x27;</span> )</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">workbook.Worksheets(<span class="string">&#x27;Sheet1&#x27;</span>).Cells(<span class="number">1</span>,<span class="number">1</span>).Value = <span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment">#关闭并保存</span></span><br><span class="line">workbook.SaveAs(<span class="string">&#x27;newexcel.xlsx&#x27;</span>)</span><br><span class="line">excel_app.Application.Quit()</span><br></pre></td></tr></table></figure><h3 id="6-5-openpyxl基本代码"><a href="#6-5-openpyxl基本代码" class="headerlink" title="6.5 openpyxl基本代码"></a>6.5 openpyxl基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">workbook = openpyxl.Workbook()</span><br><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">sheet = workbook.activesheet[<span class="string">&#x27;A1&#x27;</span>]=<span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">workbook.save(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-6-DataNitro基本代码"><a href="#6-6-DataNitro基本代码" class="headerlink" title="6.6 DataNitro基本代码"></a>6.6 DataNitro基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单一单元格赋值</span></span><br><span class="line">Cell(<span class="string">&#x27;A1&#x27;</span>).value = <span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment">#单元区域赋值</span></span><br><span class="line">CellRange(<span class="string">&#x27;A1:B2&#x27;</span>).value = <span class="string">&#x27;data&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="openpyxl具体使用"><a href="#openpyxl具体使用" class="headerlink" title="openpyxl具体使用"></a>openpyxl具体使用</h3><h4 id="1、-创建一个excel-文件，并写入不同类的内容"><a href="#1、-创建一个excel-文件，并写入不同类的内容" class="headerlink" title="1、 创建一个excel 文件，并写入不同类的内容"></a>1、 创建一个excel 文件，并写入不同类的内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件对象</span></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 获取第一个sheet</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第1行第A列，写入数字23333</span></span><br><span class="line">ws[<span class="string">&#x27;A1&#x27;</span>] = <span class="number">23333</span></span><br><span class="line"><span class="comment"># 写入中文（unicode中文也可以）</span></span><br><span class="line">ws[<span class="string">&#x27;B1&#x27;</span>] = <span class="string">&quot;你好！&quot;</span>+<span class="string">&quot;欢迎使用openpyxl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在下一行，写入多个单元格</span></span><br><span class="line">ws.append([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入一个当前时间</span></span><br><span class="line">ws[<span class="string">&#x27;A2&#x27;</span>] = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入一个自定义的时间格式</span></span><br><span class="line">ws[<span class="string">&#x27;A3&#x27;</span>] = time.strftime(<span class="string">&#x27;%Y&#123;y&#125;%m&#123;m&#125;%d&#123;d&#125;%H&#123;h&#125;%M&#123;f&#125;%S&#123;s&#125;&#x27;</span>, time.localtime()).<span class="built_in">format</span>(y=<span class="string">&#x27;年&#x27;</span>, m=<span class="string">&#x27;月&#x27;</span>, d=<span class="string">&#x27;日&#x27;</span>, h=<span class="string">&#x27;时&#x27;</span>, f=<span class="string">&#x27;分&#x27;</span>, s=<span class="string">&#x27;秒&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件，注意文件覆盖</span></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br><span class="line"><span class="comment"># 关闭流</span></span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="2、创建sheet"><a href="#2、创建sheet" class="headerlink" title="2、创建sheet"></a>2、创建sheet</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># 设定一个sheet的名字</span></span><br><span class="line">ws1.title = <span class="string">&quot;sheet1 Title&quot;</span></span><br><span class="line"><span class="comment"># 设定sheet的插入位置 默认插在后面</span></span><br><span class="line">ws2 = wb.create_sheet(<span class="string">&quot;Mysheet&quot;</span>, <span class="number">0</span>)</span><br><span class="line">ws2.title = <span class="string">&quot;Mysheet&quot;</span></span><br><span class="line"><span class="comment"># 设定sheet的标签的背景颜色</span></span><br><span class="line">ws1.sheet_properties.tabColor = <span class="string">&quot;1072BA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个sheet对象</span></span><br><span class="line"><span class="built_in">print</span>(wb[<span class="string">&quot;sheet1 Title&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(wb[<span class="string">&quot;Mysheet&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取全部sheet的名字，遍历sheet名字</span></span><br><span class="line"><span class="built_in">print</span>(wb.sheetnames)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> wb.sheetnames:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> wb:</span><br><span class="line">    <span class="built_in">print</span>(sheet.title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将sheet1中的A1单元格赋值为zeke</span></span><br><span class="line">wb[<span class="string">&quot;sheet1 Title&quot;</span> ][<span class="string">&quot;A1&quot;</span>] = <span class="string">&quot;zeke&quot;</span></span><br><span class="line"><span class="comment"># 复制一个sheet</span></span><br><span class="line">source = wb[<span class="string">&quot;sheet1 Title&quot;</span>]</span><br><span class="line">target = wb.copy_worksheet(source)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test2.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="3、操作单元格"><a href="#3、操作单元格" class="headerlink" title="3、操作单元格"></a>3、操作单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;Sheet1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将A1单元格赋值为123.11</span></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">123.11</span></span><br><span class="line"><span class="comment"># 将B2单元格赋值为你好</span></span><br><span class="line">ws1[<span class="string">&quot;B2&quot;</span>] = <span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="comment"># 将第4行第2列的单元赋值为10</span></span><br><span class="line">temp = ws1.cell(row=<span class="number">4</span>, column=<span class="number">2</span>, value=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A1&quot;</span>].value)</span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;B2&quot;</span>].value)</span><br><span class="line"><span class="built_in">print</span>(temp.value)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test3.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="4、操作已存在的文件"><a href="#4、操作已存在的文件" class="headerlink" title="4、操作已存在的文件"></a>4、操作已存在的文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开test5.xlsx文件</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test5.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 猜测格式类型</span></span><br><span class="line">wb.guess_types = <span class="literal">True</span></span><br><span class="line">ws = wb.active</span><br><span class="line">ws[<span class="string">&quot;A1&quot;</span>] = <span class="string">&quot;12%&quot;</span></span><br><span class="line"><span class="built_in">print</span>(ws[<span class="string">&quot;A1&quot;</span>].value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意如果原文件有一些图片或者图标，则保存的时候可能会导致图片丢失</span></span><br><span class="line">wb.save(<span class="string">&quot;test5.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="5、操作批量的单元格"><a href="#5、操作批量的单元格" class="headerlink" title="5、操作批量的单元格"></a>5、操作批量的单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;Sheet&quot;</span>)</span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">1</span></span><br><span class="line">ws1[<span class="string">&quot;A2&quot;</span>] = <span class="number">2</span></span><br><span class="line">ws1[<span class="string">&quot;A3&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;B1&quot;</span>] = <span class="number">4</span></span><br><span class="line">ws1[<span class="string">&quot;B2&quot;</span>] = <span class="number">5</span></span><br><span class="line">ws1[<span class="string">&quot;B3&quot;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;C1&quot;</span>] = <span class="number">7</span></span><br><span class="line">ws1[<span class="string">&quot;C2&quot;</span>] = <span class="number">8</span></span><br><span class="line">ws1[<span class="string">&quot;C3&quot;</span>] = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作单列</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> ws1[<span class="string">&quot;A&quot;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从A列到C列,获取每一个值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A:C&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> ws1[<span class="string">&quot;A:C&quot;</span>]:</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> column:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第1行到第3行，获取每一个值</span></span><br><span class="line">row_range = ws1[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(row_range)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> row_range:</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第1行到第3行，从第1列到第3列</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws1.iter_rows(min_row=<span class="number">1</span>, min_col=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有行</span></span><br><span class="line"><span class="built_in">print</span>(ws1.rows)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws1.rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有列</span></span><br><span class="line"><span class="built_in">print</span>(ws1.columns)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ws1.columns:</span><br><span class="line">    <span class="built_in">print</span>(col)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test4.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="6、获取所有的行-列-对象："><a href="#6、获取所有的行-列-对象：" class="headerlink" title="6、获取所有的行(列)对象："></a>6、获取所有的行(列)对象：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开test5.xlsx文件</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test5.xlsx&#x27;</span>)</span><br><span class="line">ws = wb.active</span><br><span class="line">rows = []</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows():</span><br><span class="line">    rows.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有行</span></span><br><span class="line"><span class="built_in">print</span>(rows)</span><br><span class="line"><span class="comment"># 获取第一行</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一行第一列的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一行第一列的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>][<span class="number">0</span>].value)</span><br><span class="line"><span class="comment"># 获取最后行 print rows[-1]</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取第后一行和最后一列的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>][<span class="built_in">len</span>(rows[<span class="number">0</span>]) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取第后一行和最后一列的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>][<span class="built_in">len</span>(rows[<span class="number">0</span>]) - <span class="number">1</span>].value)</span><br><span class="line"></span><br><span class="line">cols = []</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ws.iter_cols():</span><br><span class="line">    cols.append(col)</span><br><span class="line"><span class="comment"># 所有列</span></span><br><span class="line"><span class="built_in">print</span>(cols)</span><br><span class="line"><span class="comment"># 获取第一列</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一列的第一行的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一列的第一行的值</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>][<span class="number">0</span>].value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 获取最后一列</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>] )</span><br><span class="line"><span class="comment"># 获取最后一列的最后一行的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>][<span class="built_in">len</span>(cols[<span class="number">0</span>]) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取最后一列的最后一行的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>][<span class="built_in">len</span>(cols[<span class="number">0</span>]) - <span class="number">1</span>].value)</span><br><span class="line"></span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="7、使用公式"><a href="#7、使用公式" class="headerlink" title="7、使用公式"></a>7、使用公式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br><span class="line">ws1 = wb.active</span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">1</span></span><br><span class="line">ws1[<span class="string">&quot;A2&quot;</span>] = <span class="number">2</span></span><br><span class="line">ws1[<span class="string">&quot;A3&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A4&quot;</span>] = <span class="string">&quot;=SUM(1, 1)&quot;</span></span><br><span class="line">ws1[<span class="string">&quot;A5&quot;</span>] = <span class="string">&quot;=SUM(A1:A3)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印的是公式内容，不是公式计算后的值,程序无法取到计算后的值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A4&quot;</span>].value)</span><br><span class="line"><span class="comment"># 打印的是公式内容，不是公式计算后的值,程序无法取到计算后的值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A5&quot;</span>].value)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="8、合并单元格"><a href="#8、合并单元格" class="headerlink" title="8、合并单元格"></a>8、合并单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line">ws.merge_cells(<span class="string">&#x27;A2:D2&#x27;</span>)</span><br><span class="line"><span class="comment"># 合并后的单元格，脚本单独执行拆分操作会报错，需要重新执行合并操作再拆分</span></span><br><span class="line">ws.unmerge_cells(<span class="string">&#x27;A2:D2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ws.merge_cells(start_row=<span class="number">2</span>, start_column=<span class="number">1</span>, end_row=<span class="number">2</span>, end_column=<span class="number">4</span>)</span><br><span class="line">ws.unmerge_cells(start_row=<span class="number">2</span>, start_column=<span class="number">1</span>, end_row=<span class="number">2</span>, end_column=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/zeke-python-road/p/8986318.html">https://www.cnblogs.com/zeke-python-road/p/8986318.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：python操作Excel文件，第三方模块汇总。&quot;&gt;&lt;a href=&quot;#摘要：python操作Excel文件，第三方模块汇总。&quot; class=&quot;headerlink&quot; title=&quot;摘要：python操作Excel文件，第三方模块汇总。&quot;&gt;&lt;/a&gt;摘要：python操作Excel文件，第三方模块汇总。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot;&gt;&lt;a href=&quot;#前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot; class=&quot;headerlink&quot; title=&quot;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot;&gt;&lt;/a&gt;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/categories/python/"/>
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/tags/python/"/>
    
  </entry>
  
</feed>
