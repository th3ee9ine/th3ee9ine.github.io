<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教练，我想学技术!</title>
  
  <subtitle>会写一点Java、Go、Python、Vue的后端菜鸡</subtitle>
  <link href="https://www.blog.ajie39.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.ajie39.top/"/>
  <updated>2022-06-18T07:00:07.892Z</updated>
  <id>https://www.blog.ajie39.top/</id>
  
  <author>
    <name>th3ee9ine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 协程与通道（channel）</title>
    <link href="https://www.blog.ajie39.top/2022/06/17/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%AE%A1%E9%81%93%EF%BC%88channel%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/06/17/Go%E5%8D%8F%E7%A8%8B%E4%B8%8E%E7%AE%A1%E9%81%93%EF%BC%88channel%EF%BC%89/</id>
    <published>2022-06-16T16:40:38.340Z</published>
    <updated>2022-06-18T07:00:07.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：协程与通道（channel）的内容。</h1><hr><span id="more"></span><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Go 语言为构建并发程序的基本代码块是协程 (goroutine) 与通道 (channel)。他们需要语言、编译器和 runtime 的支持。</p><p>Go 语言提供的垃圾回收器对并发编程至关重要。</p><p><strong>不要通过共享内存来通信，而通过通信来共享内存。</strong></p><p>通信强制协作。</p><h3 id="1、线程与进程"><a href="#1、线程与进程" class="headerlink" title="1、线程与进程"></a>1、线程与进程</h3><p><strong>进程</strong> 是对运行时程序的封装，是 <strong>系统进行资源调度和分配的的基本单位</strong>，实现了操作系统的并发。</p><p><strong>线程是进程的子任务</strong>，是 <strong>CPU调度和分派的基本单位</strong>，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。</p><p>每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。</p><p>每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</p><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p><p>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p><p>进程是资源分配的最小单位，线程是CPU调度的最小单位；</p><h3 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h3><p>并发：并发（Concurrent）在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。在同一时间点，任务并不会同时运行。</p><p>并行（Parallel）：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。在同一时间点，任务一定是同时运行。</p><h3 id="3、go语言中的协程"><a href="#3、go语言中的协程" class="headerlink" title="3、go语言中的协程"></a>3、go语言中的协程</h3><p>在 Go 中，应用程序并发处理的部分被称作 goroutines（协程），它可以进行更有效的 <strong>并发运算</strong>。</p><p>在协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的；协程调度器在 Go 运行时很好的完成了这个工作。</p><p><strong>协程工作在相同的地址空间</strong>中，所以共享内存的方式一定是同步的；这个可以使用 sync 包来实现，不过我们很不鼓励这样做：Go 使用 channels 来同步协程。</p><p>当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。</p><p>协程是轻量的，比线程更轻。它们痕迹非常不明显（使用少量的内存和资源）：使用 4K 的栈内存就可以在堆中创建它们。并且它们<strong>对栈进行了分割</strong>，从而动态的增加（或缩减）内存的使用；<strong>栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。</strong></p><p>协程是通过使用 <strong>关键字 go 调用（或执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）</strong> 。</p><p>这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：go sum(bigArray)，在后台计算总和。</p><p>协程的栈会根据需要进行伸缩，不会出现栈溢出；开发者无需关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数也不会得到任何的返回值。</p><p>任何 Go 程序都必须有的 main() 函数也可以看做是一个协程，尽管它并没有通过 go 来启动。协程可以在程序初始化的过程中运行（在 init() 函数中）。</p><p>在一个协程中，比如它需要进行非常密集的运算，你可以在运算循环中周期的使用 runtime.Gosched()：这会让出处理器，允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。使用 Gosched() 可以使计算均匀分布，使通信不至于迟迟得不到响应。</p><p>在其他语言中，比如 C#，Lua 或者 Python 都有协程的概念。这个名字表明它和 Go 协程有些相似，不过有两点不同：</p><ul><li>Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的</li><li>Go 协程通过通道来通信；协程通过让出和恢复操作来通信</li></ul><p>一个简单的示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;In main()&quot;)</span><br><span class="line">    go longWait()</span><br><span class="line">    go shortWait()</span><br><span class="line">    fmt.Println(&quot;About to sleep in main()&quot;)</span><br><span class="line">    &#x2F;&#x2F; sleep works with a Duration in nanoseconds (ns) !</span><br><span class="line">    time.Sleep(10 * 1e9)</span><br><span class="line">    fmt.Println(&quot;At the end of main()&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func longWait() &#123;</span><br><span class="line">    fmt.Println(&quot;Beginning longWait()&quot;)</span><br><span class="line">    time.Sleep(5 * 1e9) &#x2F;&#x2F; sleep for 5 seconds</span><br><span class="line">    fmt.Println(&quot;End of longWait()&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func shortWait() &#123;</span><br><span class="line">    fmt.Println(&quot;Beginning shortWait()&quot;)</span><br><span class="line">    time.Sleep(2 * 1e9) &#x2F;&#x2F; sleep for 2 seconds</span><br><span class="line">    fmt.Println(&quot;End of shortWait()&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、协程间的信道"><a href="#二、协程间的信道" class="headerlink" title="二、协程间的信道"></a>二、协程间的信道</h2><p>Go 有一个特殊的类型，通道（channel），像是通道（管道），可以通过它们发送类型化的数据在协程之间通信，可以避开所有内存共享导致的坑；通道的通信方式保证了同步性。</p><p>同一时间只有一个协程可以访问数据，所以不会出现数据竞争。数据的归属（可以读写数据的能力）被传递。</p><p>通道服务于通信的两个目的：</p><ul><li>值的交换</li><li>同步的保证了两个计算（协程）任何时候都是可知状态。</li></ul><p>通常使用这样的格式来声明通道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier chan datatype</span><br></pre></td></tr></table></figure><p>未初始化的通道的值是 nil。</p><p>通道 <strong>只能传输一种类型的数据</strong>，比如 chan int 或者 chan string，所有的类型都可以用于通道，空接口 interface{} 也可以。甚至可以（有时非常有用）创建通道的通道。</p><p>通道实际上是类型化消息的队列：使数据得以传输。它是 <strong>先进先出（FIFO）</strong>* 的结构所以可以保证发送给他们的元素的顺序（有些人知道，通道可以比作 Unix shells 中的双向管道（two-way pipe））。</p><p>通道也是引用类型，所以我们使用 make() 函数来给它分配内存。这里先声明了一个字符串通道 ch1，然后创建了它（实例化）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ch1 chan string</span><br><span class="line">ch1 &#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">或者函数通道：funcChan :&#x3D; chan func()</span><br></pre></td></tr></table></figure><p>所以通道是对象的第一类型：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。</p><h3 id="1、通信操作符-lt"><a href="#1、通信操作符-lt" class="headerlink" title="1、通信操作符 &lt;-"></a>1、通信操作符 &lt;-</h3><p>这个操作符直观的标示了数据的传输：信息按照箭头的方向流动。</p><p>流向通道（发送）:</p><p>ch &lt;- int1 表示：用通道 ch 发送变量 int1（双目运算符，中缀 = 发送）</p><p>从通道流出（接收）：</p><p>int2 := &lt;- ch 表示：变量 int2 从通道 ch（一元运算的前缀操作符，前缀 = 接收）接收数据（获取新值）</p><p>&lt;- ch 可以单独调用获取通道的（下一个）值，当前值会被丢弃，但是可以用来验证，所以以下代码是合法的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if &lt;-ch !&#x3D; 1000 &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道的命名通常以 ch 开头或者包含 chan。</p><p>简单示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch :&#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">    go sendData(ch)</span><br><span class="line">    go getData(ch)</span><br><span class="line"></span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sendData(ch chan string) &#123;</span><br><span class="line">    ch &lt;- &quot;Washington&quot;</span><br><span class="line">    ch &lt;- &quot;Tripoli&quot;</span><br><span class="line">    ch &lt;- &quot;London&quot;</span><br><span class="line">    ch &lt;- &quot;Beijing&quot;</span><br><span class="line">    ch &lt;- &quot;Tokio&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData(ch chan string) &#123;</span><br><span class="line">    var input string</span><br><span class="line">    &#x2F;&#x2F; time.Sleep(2e9)</span><br><span class="line">    for &#123;</span><br><span class="line">        input &#x3D; &lt;-ch</span><br><span class="line">        fmt.Printf(&quot;%s &quot;, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Washington Tripoli London Beijing Tokio</span><br></pre></td></tr></table></figure><p>如果注释掉 time.Sleep(1e9) , sendData() 会来不及输出。</p><p>我们发现协程之间的同步非常重要：</p><ul><li>main () 等待了 1 秒让两个协程完成，如果不这样，sendData () 就没有机会输出。</li><li>getData () 使用了无限循环：它随着 sendData () 的发送完成和 ch 变空也结束了。</li></ul><p>如果我们移除一个或所有 go 关键字，程序无法运行，Go 运行时会抛出 panic。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---- Error run E:&#x2F;Go&#x2F;Goboek&#x2F;code examples&#x2F;chapter 14&#x2F;goroutine2.exe with code Crashed</span><br><span class="line">---- Program exited with code -2147483645: panic: all goroutines are asleep-deadlock!</span><br></pre></td></tr></table></figure><p>为什么会这样呢？</p><p>因为运行时会检查所有的协程（也许只有一个是这种情况）是否在等待（可以读取或者写入某个通道），意味着程序无法处理。这是死锁（deadlock）形式，运行时可以检测到这种情况。</p><p>注意：<strong>不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。</strong></p><h3 id="2、通道阻塞"><a href="#2、通道阻塞" class="headerlink" title="2、通道阻塞"></a>2、通道阻塞</h3><p>默认情况下，通信是 <strong>同步且无缓冲</strong> 的：<strong>在有接收者接收数据之前，发送不会结束</strong>。</p><p>可以想象一个无缓冲的通道在没有空间来保存数据的时候：<strong>必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。</strong></p><p>所以通道的发送（接收）操作在对方准备好之前是 <strong>阻塞</strong> 的：</p><p>1）对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：<strong>新的输入无法在通道非空的情况下传入</strong> 。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。</p><p>2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：<strong>如果通道中没有数据，接收者就阻塞了</strong> 。</p><p>下面的例子验证了以上理论，一个协程在无限循环中给通道发送整数数据。不过因为没有接收者，只输出了一个数字 0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch1 :&#x3D; make(chan int)</span><br><span class="line">    go pump(ch1)       &#x2F;&#x2F; pump hangs</span><br><span class="line">    fmt.Println(&lt;-ch1) &#x2F;&#x2F; prints only 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump(ch chan int) &#123;</span><br><span class="line">    for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为通道解除阻塞，可以定义 suck 函数来在无限循环中读取通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func suck(ch chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、通过一个（或多个）通道交换数据进行协程同步"><a href="#3、通过一个（或多个）通道交换数据进行协程同步" class="headerlink" title="3、通过一个（或多个）通道交换数据进行协程同步"></a>3、通过一个（或多个）通道交换数据进行协程同步</h3><p>通信是一种同步形式：通过通道，两个协程在通信（协程会和）中某刻同步交换数据。无缓冲通道成为了多个协程同步的完美工具。</p><p>甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态。Go 运行时会检查并 panic，停止程序。死锁几乎完全是由糟糕的设计导致的。</p><p>无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道。</p><p>解释为什么下边这个程序会导致 panic：所有的协程都休眠了 - 死锁！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func f1(in chan int) &#123;</span><br><span class="line">    fmt.Println(&lt;-in)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    out :&#x3D; make(chan int)</span><br><span class="line">    out &lt;- 2</span><br><span class="line">    go f1(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无缓冲的 channel 收发都是阻塞的，上面的代码在 main 方法里发送 2（out &lt;- 2），那么就会一直被阻塞着不往下进行。</p><p>解决办法有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一种：将 f1(out) 方法提前</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    out :&#x3D; make(chan int)</span><br><span class="line">    go f1(out)</span><br><span class="line">    out &lt;- 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种：out 使用带缓冲的 channel</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    out :&#x3D; make(chan int, 1)</span><br><span class="line">    out &lt;- 2</span><br><span class="line">    go f1(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、同步通道-使用带缓冲的通道"><a href="#4、同步通道-使用带缓冲的通道" class="headerlink" title="4、同步通道-使用带缓冲的通道"></a>4、同步通道-使用带缓冲的通道</h3><p>一个无缓冲通道只能包含 1 个元素，有时显得很局限。我们给通道提供了一个缓存，可以在扩展的 make 命令中设置它的容量，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf :&#x3D; 100</span><br><span class="line">ch1 :&#x3D; make(chan string, buf)</span><br></pre></td></tr></table></figure><p>buf 是通道可以同时容纳的元素（这里是 string）个数。</p><p>在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。</p><p>缓冲容量和类型无关，所以可以给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 cap 函数可以返回缓冲区的容量。</p><p>如果 <strong>容量大于 0</strong> ，通道就是 <strong>异步的</strong> 了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会 <strong>按照发送的顺序被接收</strong> 。如果 <strong>容量是 0 或者未设置</strong> ，通信仅在 <strong>收发双方准备好（同步）</strong> 的情况下才可以成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D;make(chan type, value)</span><br><span class="line"></span><br><span class="line">value &#x3D;&#x3D; 0 -&gt; synchronous, unbuffered (阻塞）</span><br><span class="line">value &gt; 0 -&gt; asynchronous, buffered（非阻塞）取决于 value 元素</span><br></pre></td></tr></table></figure><p>若使用通道的缓冲，你的程序会在“请求”激增的时候表现更好：更具弹性，专业术语叫：更具有伸缩性（scalable）。要在首要位置使用无缓冲通道来设计算法，只在不确定的情况下使用缓冲。</p><h3 id="5、协程中用通道输出结果"><a href="#5、协程中用通道输出结果" class="headerlink" title="5、协程中用通道输出结果"></a>5、协程中用通道输出结果</h3><p>为了知道计算何时完成，可以通过信道回报。在例子 go sum(bigArray) 中，要这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">go sum(bigArray, ch) &#x2F;&#x2F; bigArray puts the calculated sum on ch</span><br><span class="line">&#x2F;&#x2F; .. do something else for a while</span><br><span class="line">sum :&#x3D; &lt;- ch &#x2F;&#x2F; wait for, and retrieve the sum</span><br></pre></td></tr></table></figure><p>也可以使用通道来达到同步的目的，这个很有效的用法在传统计算机中称为信号量（semaphore）。 或者换个方式：通过通道发送信号告知处理已经完成（在协程中）。</p><p>在其他协程运行时让 main 程序无限阻塞的通常做法是在 main 函数的最后放置一个 {}。</p><p>也可以使用通道让 main 程序等待协程完成，就是所谓的信号量模式。</p><h3 id="6、信号量模式"><a href="#6、信号量模式" class="headerlink" title="6、信号量模式"></a>6、信号量模式</h3><p>下边的片段阐明：协程通过在通道 ch 中放置一个值来处理结束的信号。main 协程等待 &lt;-ch 直到从中获取到值。</p><p>我们期望从这个通道中获取返回的结果，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func compute(ch chan int)&#123;</span><br><span class="line">    ch &lt;- someComputation() &#x2F;&#x2F; when it completes, signal on the channel.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    ch :&#x3D; make(chan int)     &#x2F;&#x2F; allocate a channel.</span><br><span class="line">    go compute(ch)        &#x2F;&#x2F; stat something in a goroutines</span><br><span class="line">    doSomethingElseForAWhile()</span><br><span class="line">    result :&#x3D; &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个信号也可以是其他的，不返回结果，比如下面这个协程中的匿名函数（lambda）协程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int)</span><br><span class="line">go func()&#123;</span><br><span class="line">    &#x2F;&#x2F; doSomething</span><br><span class="line">    ch &lt;- 1 &#x2F;&#x2F; Send a signal; value does not matter</span><br><span class="line">&#125;()</span><br><span class="line">doSomethingElseForAWhile()</span><br><span class="line">&lt;- ch    &#x2F;&#x2F; Wait for goroutine to finish; discard sent value.</span><br></pre></td></tr></table></figure><p>或者等待两个协程完成，每一个都会对切片 s 的一部分进行排序，片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">done :&#x3D; make(chan bool)</span><br><span class="line">&#x2F;&#x2F; doSort is a lambda function, so a closure which knows the channel done:</span><br><span class="line">doSort :&#x3D; func(s []int)&#123;</span><br><span class="line">    sort(s)</span><br><span class="line">    done &lt;- true</span><br><span class="line">&#125;</span><br><span class="line">i :&#x3D; pivot(s)</span><br><span class="line">go doSort(s[:i])</span><br><span class="line">go doSort(s[i:])</span><br><span class="line">&lt;-done</span><br><span class="line">&lt;-done</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下边的代码，用完整的信号量模式对长度为 N 的 float64 切片进行了 N 个 doSomething() 计算并同时完成，通道 sem 分配了相同的长度（且包含空接口类型的元素），待所有的计算都完成后，发送信号（通过放入值）。 在循环中从通道 sem 不停的接收数据来等待所有的协程完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Empty interface &#123;&#125;</span><br><span class="line">var empty Empty</span><br><span class="line">...</span><br><span class="line">data :&#x3D; make([]float64, N)</span><br><span class="line">res :&#x3D; make([]float64, N)</span><br><span class="line">sem :&#x3D; make(chan Empty, N)</span><br><span class="line">...</span><br><span class="line">for i, xi :&#x3D; range data &#123;</span><br><span class="line">    go func (i int, xi float64) &#123;</span><br><span class="line">        res[i] &#x3D; doSomething(i, xi)</span><br><span class="line">        sem &lt;- empty</span><br><span class="line">    &#125; (i, xi)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; wait for goroutines to finish</span><br><span class="line">for i :&#x3D; 0; i &lt; N; i++ &#123; &lt;-sem &#125;</span><br></pre></td></tr></table></figure><p>注意闭合：i、xi 都是作为参数传入闭合函数的，从外层循环中隐藏了变量 i 和 xi。让每个协程有一份 i 和 xi 的拷贝；另外，for 循环的下一次迭代会更新所有协程中 i 和 xi 的值。切片 res 没有传入闭合函数，因为协程不需要单独拷贝一份。切片 res 也在闭合函数中但并不是参数。</p><h3 id="7、实现并行的-for-循环"><a href="#7、实现并行的-for-循环" class="headerlink" title="7、实现并行的 for 循环"></a>7、实现并行的 for 循环</h3><p>下面的代码中，for 循环的每一个迭代是并行完成的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i, v :&#x3D; range data &#123;</span><br><span class="line">    go func (i int, v float64) &#123;</span><br><span class="line">        doSomething(i, v)</span><br><span class="line">        ...</span><br><span class="line">    &#125; (i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for 循环中并行计算迭代可能带来很好的性能提升。不过所有的迭代都必须是独立完成的。有些语言比如 Fortress 或者其他并行框架以不同的结构实现了这种方式，在 Go 中用协程实现起来非常容易。</p><h3 id="8、用带缓冲通道实现一个信号量"><a href="#8、用带缓冲通道实现一个信号量" class="headerlink" title="8、用带缓冲通道实现一个信号量"></a>8、用带缓冲通道实现一个信号量</h3><p>信号量是实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题，比如没有实现信号量的 sync 的 Go 包，使用带缓冲的通道可以轻松实现：</p><ul><li>带缓冲通道的容量和要同步的资源容量相同</li><li>通道的长度（当前存放的元素个数）与当前资源被使用的数量相同</li><li>容量减去通道的长度就是未处理的资源个数（标准信号量的整数值）</li></ul><p>不用管通道中存放的是什么，只关注长度；因此我们创建了一个长度可变但容量为 0（字节）的通道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Empty interface &#123;&#125;</span><br><span class="line">type semaphore chan Empty</span><br></pre></td></tr></table></figure><p>将可用资源的数量 N 来初始化信号量 semaphore：sem = make(semaphore, N)</p><p>然后直接对信号量进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; acquire n resources</span><br><span class="line">func (s semaphore) P(n int) &#123;</span><br><span class="line">    e :&#x3D; new(Empty)</span><br><span class="line">    for i :&#x3D; 0; i &lt; n; i++ &#123;</span><br><span class="line">        s &lt;- e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; release n resouces</span><br><span class="line">func (s semaphore) V(n int) &#123;</span><br><span class="line">    for i:&#x3D; 0; i &lt; n; i++&#123;</span><br><span class="line">        &lt;- s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用来实现一个互斥的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* mutexes *&#x2F;</span><br><span class="line">func (s semaphore) Lock() &#123;</span><br><span class="line">    s.P(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s semaphore) Unlock()&#123;</span><br><span class="line">    s.V(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* signal-wait *&#x2F;</span><br><span class="line">func (s semaphore) Wait(n int) &#123;</span><br><span class="line">    s.P(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s semaphore) Signal() &#123;</span><br><span class="line">    s.V(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="习惯用法：通道工厂模式"><a href="#习惯用法：通道工厂模式" class="headerlink" title="习惯用法：通道工厂模式"></a>习惯用法：通道工厂模式</h4><p>编程中常见的另外一种模式如下：不将通道作为参数传递给协程，而用函数来生成一个通道并返回（工厂角色）；函数内有个匿名函数被协程调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    stream :&#x3D; pump()</span><br><span class="line">    go suck(stream)</span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump() chan int &#123;</span><br><span class="line">    ch :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func suck(ch chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、给通道使用-for-循环"><a href="#10、给通道使用-for-循环" class="headerlink" title="10、给通道使用 for 循环"></a>10、给通道使用 for 循环</h3><p>for 循环的 range 语句可以用在通道 ch 上，便可以从通道中获取值，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for v :&#x3D; range ch &#123;</span><br><span class="line">    fmt.Printf(&quot;The value is %v\n&quot;, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它从指定通道中读取数据直到通道关闭，才继续执行下边的代码。很明显，另外一个协程必须写入 ch（不然代码就阻塞在 for 循环了），而且必须在写入完成后才关闭。</p><p>完整代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    suck(pump())</span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump() chan int &#123;</span><br><span class="line">    ch :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func suck(ch chan int) &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for v :&#x3D; range ch &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="习惯用法：通道迭代模式"><a href="#习惯用法：通道迭代模式" class="headerlink" title="习惯用法：通道迭代模式"></a>习惯用法：通道迭代模式</h4><p>从包含了地址索引字段 items 的容器给通道填入元素。为容器的类型定义一个方法 Iter()，返回一个只读的通道 items，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (c *container) Iter () &lt;- chan items &#123;</span><br><span class="line">    ch :&#x3D; make(chan item)</span><br><span class="line">    go func () &#123;</span><br><span class="line">        for i:&#x3D; 0; i &lt; c.Len(); i++&#123;    &#x2F;&#x2F; or use a for-range loop</span><br><span class="line">            ch &lt;- c.items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在协程里，一个 for 循环迭代容器 c 中的元素（对于树或图的算法，这种简单的 for 循环可以替换为深度优先搜索）。</p><p>调用这个方法的代码可以这样迭代容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for x :&#x3D; range container.Iter() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>可以运行在自己的协程中，所以上边的迭代用到了一个通道和两个协程（可能运行在两个线程上）。就有了一个特殊的生产者-消费者模式。</p><p>如果程序在协程给通道写完值之前结束，协程不会被回收；设计如此。这种行为看起来是错误的，但是通道是一种线程安全的通信。</p><p>在这种情况下，协程尝试写入一个通道，而这个通道永远不会被读取，这可能是个 bug 而并非期望它被静默的回收。</p><h4 id="习惯用法：生产者消费者模式"><a href="#习惯用法：生产者消费者模式" class="headerlink" title="习惯用法：生产者消费者模式"></a>习惯用法：生产者消费者模式</h4><p>假设你有 Produce() 函数来产生 Consume 函数需要的值。它们都可以运行在独立的协程中，生产者在通道中放入给消费者读取的值。整个处理过程可以替换为无限循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">    Consume(Produce())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、通道的方向"><a href="#11、通道的方向" class="headerlink" title="11、通道的方向"></a>11、通道的方向</h3><p>通道类型可以用注解来表示它只发送或者只接收：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var send_only chan&lt;- int         &#x2F;&#x2F; channel can only receive data</span><br><span class="line">var recv_only &lt;-chan int        &#x2F;&#x2F; channel can only send data</span><br></pre></td></tr></table></figure><p>只接收的通道（&lt;-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。</p><p><strong>通道创建的时候都是双向的</strong> ，但也可以分配有方向的通道变量，就像以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var c &#x3D; make(chan int) &#x2F;&#x2F; bidirectional</span><br><span class="line">go source(c)</span><br><span class="line">go sink(c)</span><br><span class="line"></span><br><span class="line">func source(ch chan&lt;- int)&#123;</span><br><span class="line">    for &#123; ch &lt;- 1 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sink(ch &lt;-chan int) &#123;</span><br><span class="line">    for &#123; &lt;-ch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管道和选择器模式"><a href="#管道和选择器模式" class="headerlink" title="管道和选择器模式"></a>管道和选择器模式</h4><p>协程处理它从通道接收的数据并发送给输出通道：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sendChan :&#x3D; make(chan int)</span><br><span class="line">reciveChan :&#x3D; make(chan string)</span><br><span class="line">go processChannel(sendChan, receiveChan)</span><br><span class="line"></span><br><span class="line">func processChannel(in &lt;-chan int, out chan&lt;- string) &#123;</span><br><span class="line">    for inValue :&#x3D; range in &#123;</span><br><span class="line">        result :&#x3D; ... &#x2F;&#x2F;&#x2F; processing inValue</span><br><span class="line">    out &lt;- result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用方向注解来限制协程对通道的操作。</p><h4 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h4><p>这里有一个来自 Go 指导的很赞的例子，打印了输出的素数，使用选择器（‘筛’）作为它的算法。每个 prime 都有一个选择器，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Copyright 2009 The Go Authors. All rights reserved.</span><br><span class="line">&#x2F;&#x2F; Use of this source code is governed by a BSD-style</span><br><span class="line">&#x2F;&#x2F; license that can be found in the LICENSE file.package main</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;.</span><br><span class="line">func generate(ch chan int) &#123;</span><br><span class="line">    for i :&#x3D; 2; ; i++ &#123;</span><br><span class="line">        ch &lt;- i &#x2F;&#x2F; Send &#39;i&#39; to channel &#39;ch&#39;.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Copy the values from channel &#39;in&#39; to channel &#39;out&#39;,</span><br><span class="line">&#x2F;&#x2F; removing those divisible by &#39;prime&#39;.</span><br><span class="line">func filter(in, out chan int, prime int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        i :&#x3D; &lt;-in &#x2F;&#x2F; Receive value of new variable &#39;i&#39; from &#39;in&#39;.</span><br><span class="line">        if i%prime !&#x3D; 0 &#123;</span><br><span class="line">            out &lt;- i &#x2F;&#x2F; Send &#39;i&#39; to channel &#39;out&#39;.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The prime sieve: Daisy-chain filter processes together.</span><br><span class="line">func main() &#123;</span><br><span class="line">    ch :&#x3D; make(chan int) &#x2F;&#x2F; Create a new channel.</span><br><span class="line">    go generate(ch)      &#x2F;&#x2F; Start generate() as a goroutine.</span><br><span class="line">    for &#123;</span><br><span class="line">        prime :&#x3D; &lt;-ch</span><br><span class="line">        fmt.Print(prime, &quot; &quot;)</span><br><span class="line">        ch1 :&#x3D; make(chan int)</span><br><span class="line">        go filter(ch, ch1, prime)</span><br><span class="line">        ch &#x3D; ch1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协程 filter(in, out chan int, prime int) 拷贝整数到输出通道，丢弃掉可以被 prime 整除的数字。然后每个 prime 又开启了一个新的协程，生成器和选择器并发请求。</p><h4 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h4><p>第二个版本引入了上边的习惯用法：函数 sieve、generate 和 filter 都是工厂；它们创建通道并返回，而且使用了协程的 lambda 函数。main 函数现在短小清晰：它调用 sieve() 返回了包含素数的通道，然后通过 fmt.Println(&lt;-primes) 打印出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Copyright 2009 The Go Authors. All rights reserved.</span><br><span class="line">&#x2F;&#x2F; Use of this source code is governed by a BSD-style</span><br><span class="line">&#x2F;&#x2F; license that can be found in the LICENSE file.</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Send the sequence 2, 3, 4, ... to returned channel</span><br><span class="line">func generate() chan int &#123;</span><br><span class="line">    ch :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for i :&#x3D; 2; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Filter out input values divisible by &#39;prime&#39;, send rest to returned channel</span><br><span class="line">func filter(in chan int, prime int) chan int &#123;</span><br><span class="line">    out :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            if i :&#x3D; &lt;-in; i%prime !&#x3D; 0 &#123;</span><br><span class="line">                out &lt;- i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sieve() chan int &#123;</span><br><span class="line">    out :&#x3D; make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        ch :&#x3D; generate()</span><br><span class="line">        for &#123;</span><br><span class="line">            prime :&#x3D; &lt;-ch</span><br><span class="line">            ch &#x3D; filter(ch, prime)</span><br><span class="line">            out &lt;- prime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    primes :&#x3D; sieve()</span><br><span class="line">    for &#123;</span><br><span class="line">        fmt.Println(&lt;-primes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、协程的同步：关闭通道-测试阻塞的通道"><a href="#三、协程的同步：关闭通道-测试阻塞的通道" class="headerlink" title="三、协程的同步：关闭通道-测试阻塞的通道"></a>三、协程的同步：关闭通道-测试阻塞的通道</h2><p>通道可以被显式的关闭；尽管它们和文件不同：不必每次都关闭。只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道。</p><p>只有发送者需要关闭通道，接收者永远不会需要。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch :&#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">    go sendData(ch)</span><br><span class="line">    go getData(ch)</span><br><span class="line"></span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sendData(ch chan string) &#123;</span><br><span class="line">    ch &lt;- &quot;Washington&quot;</span><br><span class="line">    ch &lt;- &quot;Tripoli&quot;</span><br><span class="line">    ch &lt;- &quot;London&quot;</span><br><span class="line">    ch &lt;- &quot;Beijing&quot;</span><br><span class="line">    ch &lt;- &quot;Tokio&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getData(ch chan string) &#123;</span><br><span class="line">    var input string</span><br><span class="line">    &#x2F;&#x2F; time.Sleep(2e9)</span><br><span class="line">    for &#123;</span><br><span class="line">        input &#x3D; &lt;-ch</span><br><span class="line">        fmt.Printf(&quot;%s &quot;, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如何在通道的 sendData() 完成的时候发送一个信号，getData() 又如何检测到通道是否关闭或阻塞？</p><p>第一个问题可以通过函数 close(ch) 来完成：这个将通道标记为无法通过发送操作 &lt;- 接受更多的值；给已经关闭的通道发送或者再次关闭都会导致运行时的 panic。在创建一个通道后使用 defer 语句是个不错的办法（类似这种情况）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan float64)</span><br><span class="line">defer close(ch)</span><br></pre></td></tr></table></figure><p>第二个问题可以使用逗号，ok 操作符：用来检测通道是否被关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">v, ok :&#x3D; &lt;-ch   &#x2F;&#x2F; ok is true if v received value</span><br><span class="line"></span><br><span class="line">通常和 if 语句一起使用：</span><br><span class="line"></span><br><span class="line">if v, ok :&#x3D; &lt;-ch; ok &#123;</span><br><span class="line">  process(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者在 for 循环中接收的时候，当关闭或者阻塞的时候使用 break：</span><br><span class="line"></span><br><span class="line">v, ok :&#x3D; &lt;-ch</span><br><span class="line">if !ok &#123;</span><br><span class="line">  break</span><br><span class="line">&#125;</span><br><span class="line">process(v)</span><br><span class="line"></span><br><span class="line">使用 for-range 语句来读取通道是更好的办法，因为这会自动检测通道是否关闭：</span><br><span class="line"></span><br><span class="line">for input :&#x3D; range ch &#123;</span><br><span class="line">    process(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、使用-select-切换协程"><a href="#四、使用-select-切换协程" class="headerlink" title="四、使用 select 切换协程"></a>四、使用 select 切换协程</h2><p>从不同的并发执行的协程中获取值可以通过关键字 select 来完成，它和 switch 控制语句非常相似也被称作通信开关；它的行为像是 “你准备好了吗” 的 <strong>轮询机制</strong>；select 监听进入通道的数据，也可以是用通道发送值的时候。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case u:&#x3D; &lt;- ch1:</span><br><span class="line">        ...</span><br><span class="line">case v:&#x3D; &lt;- ch2:</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">default: &#x2F;&#x2F; no value ready to be received</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default 语句是可选的；fallthrough 行为，和普通的 switch 相似，是不允许的。在任何一个 case 中执行 break 或者 return，select 就结束了。</span><br></pre></td></tr></table></figure><p>select 做的就是：选择处理列出的多个通信情况中的一个。</p><ul><li>如果都阻塞了，会等待直到其中一个可以处理</li><li>如果多个可以处理，随机选择一个</li><li>如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。</li><li>在 select 中使用发送操作并且有 default 可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞。</li></ul><p>在 select 中使用发送操作并且有 default 可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞。</p><p>select 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 break 语句使循环退出。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ch1 :&#x3D; make(chan int)</span><br><span class="line">    ch2 :&#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">    go pump1(ch1)</span><br><span class="line">    go pump2(ch2)</span><br><span class="line">    go suck(ch1, ch2)</span><br><span class="line"></span><br><span class="line">    time.Sleep(1e9)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump1(ch chan int) &#123;</span><br><span class="line">    for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">        ch &lt;- i * 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pump2(ch chan int) &#123;</span><br><span class="line">    for i :&#x3D; 0; ; i++ &#123;</span><br><span class="line">        ch &lt;- i + 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func suck(ch1, ch2 chan int) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case v :&#x3D; &lt;-ch1:</span><br><span class="line">            fmt.Printf(&quot;Received on channel 1: %d\n&quot;, v)</span><br><span class="line">        case v :&#x3D; &lt;-ch2:</span><br><span class="line">            fmt.Printf(&quot;Received on channel 2: %d\n&quot;, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面例子中有 2 个通道 ch1 和 ch2，三个协程 pump1()、pump2() 和 suck()。 这是一个典型的生产者消费者模式。</p><p>在无限循环中，ch1 和 ch2 通过 pump1() 和 pump2() 填充整数；suck() 也是在无限循环中轮询输入的，通过 select 语句获取 ch1 和 ch2 的整数并输出。</p><p>选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。</p><h4 id="习惯用法：后台服务模式"><a href="#习惯用法：后台服务模式" class="headerlink" title="习惯用法：后台服务模式"></a>习惯用法：后台服务模式</h4><p>服务通常是用后台协程中的无限循环实现的，在循环中使用 select 获取并处理通道中的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Backend goroutine.</span><br><span class="line">func backend() &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case cmd :&#x3D; &lt;-ch1:</span><br><span class="line">            &#x2F;&#x2F; Handle ...</span><br><span class="line">        case cmd :&#x3D; &lt;-ch2:</span><br><span class="line">            ...</span><br><span class="line">        case cmd :&#x3D; &lt;-chStop:</span><br><span class="line">            &#x2F;&#x2F; stop server</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序的其他地方给通道 ch1，ch2 发送数据，比如：通道 stop 用来清理结束服务程序。</p><p>另一种方式（但是不太灵活）就是（客户端）在 chRequest 上提交请求，后台协程循环这个通道，使用 switch 根据请求的行为来分别处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func backend() &#123;</span><br><span class="line">    for req :&#x3D; range chRequest &#123;</span><br><span class="line">        switch req.Subjext() &#123;</span><br><span class="line">            case A1:  &#x2F;&#x2F; Handle case ...</span><br><span class="line">            case A2:  &#x2F;&#x2F; Handle case ...</span><br><span class="line">            default:</span><br><span class="line">              &#x2F;&#x2F; Handle illegal request ..</span><br><span class="line">              &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、通道、超时和计时器（Ticker）"><a href="#五、通道、超时和计时器（Ticker）" class="headerlink" title="五、通道、超时和计时器（Ticker）"></a>五、通道、超时和计时器（Ticker）</h2><p>time 包中有一些有趣的功能可以和通道组合使用。</p><p>其中就包含了 time.Ticker 结构体，这个对象以指定的时间间隔重复的向通道 C 发送时间值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Ticker struct &#123;</span><br><span class="line">    C &lt;-chan Time &#x2F;&#x2F; the channel on which the ticks are delivered.</span><br><span class="line">    &#x2F;&#x2F; contains filtered or unexported fields</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间间隔的单位是 ns（纳秒，int64），在工厂函数 time.NewTicker 中以 Duration 类型的参数传入：func Newticker(dur) *Ticker。</p><p>在协程周期性的执行一些事情（打印状态日志，输出，计算等等）的时候非常有用。</p><p>调用 Stop() 使计时器停止，在 defer 语句中使用。这些都很好的适应 select 语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ticker :&#x3D; time.NewTicker(updateInterval)</span><br><span class="line">defer ticker.Stop()</span><br><span class="line">...</span><br><span class="line">select &#123;</span><br><span class="line">case u:&#x3D; &lt;-ch1:</span><br><span class="line">    ...</span><br><span class="line">case v:&#x3D; &lt;-ch2:</span><br><span class="line">    ...</span><br><span class="line">case &lt;-ticker.C:</span><br><span class="line">    logState(status) &#x2F;&#x2F; call some logging function logState</span><br><span class="line">default: &#x2F;&#x2F; no value ready to be received</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>time.Tick() 函数声明为 Tick(d Duration) &lt;-chan Time，当你想返回一个通道而不必关闭它的时候这个函数非常有用：它以 d 为周期给返回的通道发送时间，d 是纳秒数。</p><p>如果需要像下边的代码一样，限制处理频率（函数 client.Call() 是一个 RPC 调用，这里暂不赘述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">rate_per_sec :&#x3D; 10</span><br><span class="line">var dur Duration &#x3D; 1e9 &#x2F; rate_per_sec</span><br><span class="line">chRate :&#x3D; time.Tick(dur) &#x2F;&#x2F; a tick every 1&#x2F;10th of a second</span><br><span class="line">for req :&#x3D; range requests &#123;</span><br><span class="line">    &lt;- chRate &#x2F;&#x2F; rate limit our Service.Method RPC calls</span><br><span class="line">    go client.Call(&quot;Service.Method&quot;, req, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时器（Timer）结构体看上去和计时器（Ticker）结构体的确很像（构造为 NewTimer(d Duration)），但是它只发送一次时间，在 Dration d 之后。</p><p>还有 time.After(d) 函数，声明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func After(d Duration) &lt;-chan Time</span><br></pre></td></tr></table></figure><p>在 Duration d 之后，当前时间被发到返回的通道；所以它和 NewTimer(d).C 是等价的；它类似 Tick()，但是 After() 只发送一次时间。</p><p>下边有个很具体的示例，很好的阐明了 select 中 default 的作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    tick :&#x3D; time.Tick(1e8)</span><br><span class="line">    boom :&#x3D; time.After(5e8)</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-tick:</span><br><span class="line">            fmt.Println(&quot;tick.&quot;)</span><br><span class="line">        case &lt;-boom:</span><br><span class="line">            fmt.Println(&quot;BOOM!&quot;)</span><br><span class="line">            return</span><br><span class="line">        default:</span><br><span class="line">            fmt.Println(&quot;    .&quot;)</span><br><span class="line">            time.Sleep(5e7)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单超时模式"><a href="#简单超时模式" class="headerlink" title="简单超时模式"></a>简单超时模式</h3><h4 id="第一种形式"><a href="#第一种形式" class="headerlink" title="第一种形式"></a>第一种形式</h4><p>要从通道 ch 中接收数据，但是最多等待 1 秒。先创建一个信号通道，然后启动一个 lambda 协程，协程在给通道发送数据之前是休眠的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeout :&#x3D; make(chan bool, 1)</span><br><span class="line">go func() &#123;</span><br><span class="line">        time.Sleep(1e9) &#x2F;&#x2F; one second</span><br><span class="line">        timeout &lt;- true</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>然后使用 select 语句接收 ch 或者 timeout 的数据：如果 ch 在 1 秒内没有收到数据，就选择到了 timeout 分支并放弃了 ch 的读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">    case &lt;-ch:</span><br><span class="line">        &#x2F;&#x2F; a read from ch has occured</span><br><span class="line">    case &lt;-timeout:</span><br><span class="line">        &#x2F;&#x2F; the read from ch has timed out</span><br><span class="line">        break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种形式，取消耗时很长的同步调用"><a href="#第二种形式，取消耗时很长的同步调用" class="headerlink" title="第二种形式，取消耗时很长的同步调用"></a>第二种形式，取消耗时很长的同步调用</h4><p>也可以使用 time.After() 函数替换 timeout-channel。可以在 select 中通过 time.After() 发送的超时信号来停止协程的执行。</p><p>以下代码，在 timeoutNs 纳秒后执行 select 的 timeout 分支后，执行 client.Call 的协程也随之结束，不会给通道 ch 返回值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan error, 1)</span><br><span class="line">go func() &#123; ch &lt;- client.Call(&quot;Service.Method&quot;, args, &amp;reply) &#125; ()</span><br><span class="line">select &#123;</span><br><span class="line">case resp :&#x3D; &lt;-ch</span><br><span class="line">    &#x2F;&#x2F; use resp and reply</span><br><span class="line">case &lt;-time.After(timeoutNs):</span><br><span class="line">    &#x2F;&#x2F; call timed out</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意缓冲大小设置为 1 是必要的，可以避免协程死锁以及确保超时的通道可以被垃圾回收。</p><p>此外，需要注意在有多个 case 符合条件时，select 对 case 的选择是伪随机的。</p><p>如果上面的代码稍作修改如下，则 select 语句可能不会在定时器超时信号到来时立刻选中 time.After(timeoutNs) 对应的 case，因此协程可能不会严格按照定时器设置的时间结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch :&#x3D; make(chan int, 1)</span><br><span class="line">go func() &#123; for &#123; ch &lt;- 1 &#125; &#125; ()</span><br><span class="line">L:</span><br><span class="line">for &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case &lt;-ch:</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">    case &lt;-time.After(timeoutNs):</span><br><span class="line">        &#x2F;&#x2F; call timed out</span><br><span class="line">        break L</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三种形式，取消耗时很长的同步调用"><a href="#第三种形式，取消耗时很长的同步调用" class="headerlink" title="第三种形式，取消耗时很长的同步调用"></a>第三种形式，取消耗时很长的同步调用</h4><p>假设程序从多个复制的数据库同时读取。只需要一个答案，需要接收首先到达的答案，Query 函数获取数据库的连接切片并请求。</p><p>并行请求每一个数据库并返回收到的第一个响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func Query(conns []conn, query string) Result &#123;</span><br><span class="line">    ch :&#x3D; make(chan Result, 1)</span><br><span class="line">    for _, conn :&#x3D; range conns &#123;</span><br><span class="line">        go func(c Conn) &#123;</span><br><span class="line">            select &#123;</span><br><span class="line">            case ch &lt;- c.DoQuery(query):</span><br><span class="line">            default:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(conn)</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次声明，结果通道 ch 必须是带缓冲的：以保证第一个发送进来的数据有地方可以存放，确保放入的首个数据总会成功，所以第一个到达的值会被获取而与执行的顺序无关。</p><p>正在执行的协程总是可以使用 runtime.Goexit() 来停止。</p><h2 id="六、协程和恢复（recover）"><a href="#六、协程和恢复（recover）" class="headerlink" title="六、协程和恢复（recover）"></a>六、协程和恢复（recover）</h2><p>一个用到 recover 的程序，停掉了服务器内部一个失败的协程而不影响其他协程的工作。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func server(workChan &lt;-chan *Work) &#123;</span><br><span class="line">    for work :&#x3D; range workChan &#123;</span><br><span class="line">        go safelyDo(work)   &#x2F;&#x2F; start the goroutine for that work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func safelyDo(work *Work) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">            log.Printf(&quot;Work failed with %s in %v&quot;, err, work)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的代码，如果 do(work) 发生 panic，错误会被记录且协程会退出并释放，而其他协程不受影响。</p><h2 id="七、新旧模型对比：任务和worker"><a href="#七、新旧模型对比：任务和worker" class="headerlink" title="七、新旧模型对比：任务和worker"></a>七、新旧模型对比：任务和worker</h2><p>假设我们需要处理很多任务；一个 worker 处理一项任务。任务可以被定义为一个结构体（具体的细节在这里并不重要）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Task struct &#123;</span><br><span class="line">    &#x2F;&#x2F; some state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>旧模式：使用共享内存进行同步</p><p>由各个任务组成的任务池共享内存；为了同步各个 worker 以及避免资源竞争，我们需要对任务池进行加锁保护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Pool struct &#123;</span><br><span class="line">    Mu      sync.Mutex</span><br><span class="line">    Tasks   []Task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Mutex(是互斥锁：它用来在代码中保护临界区资源：同一时间只有一个 go 协程（goroutine）可以进入该临界区。</p><p>如果出现了同一时间多个 go 协程都进入了该临界区，则会产生竞争：Pool 结构就不能保证被正确更新。</p><p>在传统的模式中（经典的面向对象的语言中应用得比较多，比如 C++,JAVA,C#)，worker 代码可能这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func Worker(pool *Pool) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        pool.Mu.lock()</span><br><span class="line">        &#x2F;&#x2F; begin critical section:</span><br><span class="line">        task :&#x3D; pool.Task[0]        &#x2F;&#x2F; take the first task</span><br><span class="line">        pool.Tasks &#x3D; pool.Task[1:]  &#x2F;&#x2F; update the pool of tasks</span><br><span class="line">        &#x2F;&#x2F; end critical section</span><br><span class="line">        pool.Mu.Unlock()</span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这些 worker 有许多都可以并发执行；他们可以在 go 协程中启动。</span><br><span class="line"></span><br><span class="line">一个 worker 先将 pool 锁定，从 pool 获取第一项任务，再解锁和处理任务。</span><br><span class="line"></span><br><span class="line">加锁保证了同一时间只有一个 go 协程可以进入到 pool 中：一项任务有且只能被赋予一个 worker。</span><br><span class="line"></span><br><span class="line">如果不加锁，则工作协程可能会在 task:&#x3D;pool.Task[0] 发生切换，</span><br><span class="line">导致 pool.Tasks&#x3D;pool.Task[1:] 结果异常：一些 worker 获取不到任务，而一些任务可能被多个 worker 得到。</span><br><span class="line"></span><br><span class="line">加锁实现同步的方式在工作协程比较少时可以工作的很好，但是当工作协程数量很大，任务量也很多时，</span><br><span class="line">处理效率将会因为频繁的加锁（解锁）开销而降低。当工作协程数增加到一个阈值时，程序效率会急剧下降，这就成为了瓶颈。</span><br></pre></td></tr></table></figure><h3 id="使用通道进行同步"><a href="#使用通道进行同步" class="headerlink" title="使用通道进行同步"></a>使用通道进行同步</h3><p>使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker 在协程中启动，其数量 N 应该根据任务数量进行调整。</p><p>主线程扮演着 Master 节点角色，可能写成如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    pending, done :&#x3D; make(chan *Task), make(chan *Task)</span><br><span class="line">    go sendWork(pending)       &#x2F;&#x2F; put tasks with work on the channel</span><br><span class="line">    for i :&#x3D; 0; i &lt; N; i++ &#123;   &#x2F;&#x2F; start N goroutines to do work</span><br><span class="line">        go Worker(pending, done)</span><br><span class="line">    &#125;</span><br><span class="line">    consumeWork(done)          &#x2F;&#x2F; continue with the processed tasks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worker 的逻辑比较简单：从 pending 通道拿任务，处理后将其放到 done 通道中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func Worker(in, out chan *Task) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        t :&#x3D; &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并不使用锁：从通道得到新任务的过程没有任何竞争。</p><p>随着任务数量增加，worker 数量也应该相应增加，同时性能并不会像第一种方式那样下降明显。</p><p>在 pending 通道中存在一份任务的拷贝，第一个 worker 从 pending 通道中获得第一个任务并进行处理，这里并不存在竞争（对一个通道读数据和写数据的整个过程是原子性的)。</p><p>某一个任务会在哪一个 worker 中被执行是不可知的，反过来也是。</p><p>worker 数量的增多也会增加通信的开销，这会对性能有轻微的影响。</p><p>对于任何可以建模为 Master-Worker 范例的问题，一个类似于 worker 使用通道进行通信和交互、Master 进行整体协调的方案都能完美解决。</p><p>如果系统部署在多台机器上，各个机器上执行 Worker 协程，Master 和 Worker 之间使用 netchan 或者 RPC 进行通信。</p><h3 id="怎么选择是该使用锁还是通道？"><a href="#怎么选择是该使用锁还是通道？" class="headerlink" title="怎么选择是该使用锁还是通道？"></a>怎么选择是该使用锁还是通道？</h3><p>通道是一个较新的概念，本节我们着重强调了在 go 协程里通道的使用，但这并不意味着经典的锁方法就不能使用。</p><p>go 语言让你可以根据实际问题进行选择：创建一个优雅、简单、可读性强、在大多数场景性能表现都能很好的方案。如果你的问题适合使用锁，也不要忌讳使用它。</p><p>go 语言注重实用，什么方式最能解决你的问题就用什么方式，而不是强迫你使用一种编码风格。下面列出一个普遍的经验法则：</p><ul><li>使用锁的情景：<ul><li>访问共享数据结构中的缓存信息</li><li>保存应用程序上下文和状态信息数据</li></ul></li><li>使用通道的情景：<ul><li>与异步操作的结果进行交互</li><li>分发任务</li><li>传递数据所有权</li></ul></li></ul><p>当你发现你的锁使用规则变得很复杂时，可以反省使用通道会不会使问题变得简单些。</p><h2 id="八、惰性生成器的实现"><a href="#八、惰性生成器的实现" class="headerlink" title="八、惰性生成器的实现"></a>八、惰性生成器的实现</h2><p>生成器是指当被调用时返回一个序列中下一个值的函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generateInteger() &#x3D;&gt; 0</span><br><span class="line">generateInteger() &#x3D;&gt; 1</span><br><span class="line">generateInteger() &#x3D;&gt; 2</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>生成器每次返回的是序列中下一个值而非整个序列；这种特性也称之为惰性求值：只在你需要时进行求值，同时保留相关变量资源（内存和 cpu）：这是一项在需要时对表达式进行求值的技术。</p><p>例如，生成一个无限数量的偶数序列：要产生这样一个序列并且在一个一个的使用可能会很困难，而且内存会溢出！但是一个含有通道和 go 协程的函数能轻易实现这个需求。</p><p>通过巧妙地使用空接口、闭包和高阶函数，我们能实现一个通用的惰性生产器的工厂函数 BuildLazyEvaluator（这个应该放在一个工具包中实现）。</p><p>工厂函数需要一个函数和一个初始状态作为输入参数，返回一个无参、返回值是生成序列的函数。</p><p>传入的函数需要计算出下一个返回值以及下一个状态参数。在工厂函数中，创建一个通道和无限循环的 go 协程。 返回值被放到了该通道中，返回函数稍后被调用时从该通道中取得该返回值。每当取得一个值时，下一个值即被计算。</p><p>在下面的例子中，定义了一个 evenFunc 函数，其是一个惰性生成函数：在 main 函数中，我们创建了前 10 个偶数，每个都是通过调用 even() 函数取得下一个值的。</p><p>为此，我们需要在 BuildLazyIntEvaluator 函数中具体化我们的生成函数，然后我们能够基于此做出定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Any interface&#123;&#125;</span><br><span class="line">type EvalFunc func(Any) (Any, Any)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    evenFunc :&#x3D; func(state Any) (Any, Any) &#123;</span><br><span class="line">        os :&#x3D; state.(int)</span><br><span class="line">        ns :&#x3D; os + 2</span><br><span class="line">        return os, ns</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    even :&#x3D; BuildLazyIntEvaluator(evenFunc, 0)</span><br><span class="line"></span><br><span class="line">    for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;%vth even: %v\n&quot;, i, even())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BuildLazyEvaluator(evalFunc EvalFunc, initState Any) func() Any &#123;</span><br><span class="line">    retValChan :&#x3D; make(chan Any)</span><br><span class="line">    loopFunc :&#x3D; func() &#123;</span><br><span class="line">        var actState Any &#x3D; initState</span><br><span class="line">        var retVal Any</span><br><span class="line">        for &#123;</span><br><span class="line">            retVal, actState &#x3D; evalFunc(actState)</span><br><span class="line">            retValChan &lt;- retVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    retFunc :&#x3D; func() Any &#123;</span><br><span class="line">        return &lt;- retValChan</span><br><span class="line">    &#125;</span><br><span class="line">    go loopFunc()</span><br><span class="line">    return retFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BuildLazyIntEvaluator(evalFunc EvalFunc, initState Any) func() int &#123;</span><br><span class="line">    ef :&#x3D; BuildLazyEvaluator(evalFunc, initState)</span><br><span class="line">    return func() int &#123;</span><br><span class="line">        return ef().(int)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、实现-Futures-模式"><a href="#九、实现-Futures-模式" class="headerlink" title="九、实现 Futures 模式"></a>九、实现 Futures 模式</h2><p>所谓 Futures 就是指：有时候在你使用某一个值之前需要先对其进行计算。这种情况下，你就可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕了。</p><p>Futures 模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于 Futures 需要返回一个值。</p><p>假设我们有一个矩阵类型，我们需要计算两个矩阵 A 和 B 乘积的逆，首先我们通过函数 Inverse(M) 分别对其进行求逆运算，在将结果相乘。</p><p>如下函数 InverseProduct() 实现了如上过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func InverseProduct(a Matrix, b Matrix) &#123;</span><br><span class="line">    a_inv :&#x3D; Inverse(a)</span><br><span class="line">    b_inv :&#x3D; Inverse(b)</span><br><span class="line">    return Product(a_inv, b_inv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，a 和 b 的求逆矩阵需要先被计算。 那么为什么在计算 b 的逆矩阵时，需要等待 a 的逆计算完成呢？</p><p>显然不必要，这两个求逆运算其实可以并行执行的。换句话说，调用 Product 函数只需要等到 a_inv 和 b_inv 的计算完成。</p><p>如下代码实现了并行计算方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func InverseProduct(a Matrix, b Matrix) &#123;</span><br><span class="line">    a_inv_future :&#x3D; InverseFuture(a)   &#x2F;&#x2F; start as a goroutine</span><br><span class="line">    b_inv_future :&#x3D; InverseFuture(b)   &#x2F;&#x2F; start as a goroutine</span><br><span class="line">    a_inv :&#x3D; &lt;-a_inv_future</span><br><span class="line">    b_inv :&#x3D; &lt;-b_inv_future</span><br><span class="line">    return Product(a_inv, b_inv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InverseFuture 函数起了一个 goroutine 协程，在其执行闭包运算，该闭包会将矩阵求逆结果放入到 future 通道中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func InverseFuture(a Matrix) &#123;</span><br><span class="line">    future :&#x3D; make(chan Matrix)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        future &lt;- Inverse(a)</span><br><span class="line">    &#125;()</span><br><span class="line">    return future</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、客户端-服务端模式"><a href="#十、客户端-服务端模式" class="headerlink" title="十、客户端-服务端模式"></a>十、客户端-服务端模式</h2><p>Client-server 类的应用是协程（goroutine）和频道（channel）的大显身手的闪光点。</p><p>客户端可以是任何一种运行在任何设备上的，且需要来自服务端信息的一种程序，所以它需要发送请求。</p><p>服务端接收请求，做一些处理，然后把给客户端发送响应信息。在通常情况下，就是多个客户端（很多请求）对一个（或几个）服务端。</p><p>一个常见例子就是我们使用的发送网页请求的客户端浏览器。然后一个 web 服务器将响应网页发回给浏览器。</p><p>在 Go 中，服务端通常会在一个协程（goroutine）里操作对一个客户端的响应，所以协程和客户端请求是一一对应的。</p><p>一种典型的做法就是客户端请求本身包含了一个频道（channel），服务端可以用它来发送响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Request struct &#123;</span><br><span class="line">    a, b   int</span><br><span class="line">    replyc chan int &#x2F;&#x2F; 请求中的回复频道</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type binOp func(a, b int) int</span><br><span class="line"></span><br><span class="line">func run(op binOp, req *Request) &#123;</span><br><span class="line">    req.replyc &lt;- op(req.a, req.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func server(op binOp, service chan *Request) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        req :&#x3D; &lt;-service &#x2F;&#x2F; 请求到达这里</span><br><span class="line">        &#x2F;&#x2F; 开启请求的 Goroutine ：</span><br><span class="line">        go run(op, req) &#x2F;&#x2F; 不要等待 op</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func startServer(op binOp) chan *Request &#123;</span><br><span class="line">    reqChan :&#x3D; make(chan *Request)</span><br><span class="line">    go server(op, reqChan)</span><br><span class="line">    return reqChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    adder :&#x3D; startServer(func(a, b int) int &#123; return a + b &#125;)</span><br><span class="line">    const N &#x3D; 100</span><br><span class="line">    var reqs [N]Request</span><br><span class="line"></span><br><span class="line">    for i :&#x3D; 0; i &lt; N; i++ &#123;</span><br><span class="line">        req :&#x3D; &amp;reqs[i]</span><br><span class="line">        req.a &#x3D; i</span><br><span class="line">        req.b &#x3D; i + N</span><br><span class="line">        req.replyc &#x3D; make(chan int)</span><br><span class="line">        adder &lt;- req</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 校验：</span><br><span class="line">    for i :&#x3D; N - 1; i &gt;&#x3D; 0; i-- &#123; &#x2F;&#x2F; 顺序无所谓</span><br><span class="line">        if &lt;-reqs[i].replyc !&#x3D; N+2*i &#123;</span><br><span class="line">            fmt.Println(&quot;fail at&quot;, i)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fmt.Println(&quot;Request &quot;, i, &quot;is ok!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;done&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、限制并发数"><a href="#十一、限制并发数" class="headerlink" title="十一、限制并发数"></a>十一、限制并发数</h2><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">&#x2F;&#x2F; 10 * 1024 * 1024</span><br><span class="line">AvailableMemory &#x3D; 10 &lt;&lt; 20</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 10 * 1024</span><br><span class="line">AverageMemoryPerRequest &#x3D; 10 &lt;&lt; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1024</span><br><span class="line">MAXREQS &#x3D; AvailableMemory &#x2F; AverageMemoryPerRequest</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var sem &#x3D; make(chan int, MAXREQS)</span><br><span class="line"></span><br><span class="line">type Request struct &#123;</span><br><span class="line">a, b   int</span><br><span class="line">replyc chan int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func process(r *Request) &#123;</span><br><span class="line">&#x2F;&#x2F; Do something 做任何事</span><br><span class="line">&#x2F;&#x2F; 可能需要很长时间并使用大量内存或CPU</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handle(r *Request) &#123;</span><br><span class="line">process(r)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 信号完成：开始启用下一个请求</span><br><span class="line">&#x2F;&#x2F; 将 sem 的缓冲区释放一个位置</span><br><span class="line">&lt;-sem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Server(queue chan *Request) &#123;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">sem &lt;- 1</span><br><span class="line">&#x2F;&#x2F; 当通道已满（1024 个请求被激活）的时候将被阻塞</span><br><span class="line">&#x2F;&#x2F; 所以停在这里等待，直到 sem 有容量（被释放），才能继续去处理请求</span><br><span class="line">&#x2F;&#x2F; (doesn’t matter what we put in it)</span><br><span class="line">request :&#x3D; &lt;-queue</span><br><span class="line">go handle(request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">queue :&#x3D; make(chan *Request)</span><br><span class="line"></span><br><span class="line">go Server(queue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，程序中的协程通过使用缓冲通道（这个通道作为一个 semaphore 被使用）来调整资源的使用，实现了对内存等有限资源的优化。</p><h2 id="十二、链式操作（重点！！！！）"><a href="#十二、链式操作（重点！！！！）" class="headerlink" title="十二、链式操作（重点！！！！）"></a>十二、链式操作（重点！！！！）</h2><p>下面的程序演示了启动大量的协程是多么的容易。它发生在 mian 函数的 for 循环中。在循环之后，向 rightmost 通道中插入 0，在不到 1.5s 的时间执行了 100000 个协程，并将结果 100000 打印。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;flag&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ngoroutine &#x3D; flag.Int(&quot;n&quot;, 100000, &quot;how many goroutines&quot;)</span><br><span class="line"></span><br><span class="line">func f(left, right chan int) &#123;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(&quot;left:&quot;, left, &quot;    right:&quot;, right)</span><br><span class="line">left &lt;- 1 + &lt;-right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">flag.Parse()</span><br><span class="line">leftmost :&#x3D; make(chan int)</span><br><span class="line"></span><br><span class="line">var left, right chan int &#x3D; nil, leftmost</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; *ngoroutine; i++ &#123;</span><br><span class="line">left, right &#x3D; right, make(chan int)</span><br><span class="line">&#x2F;&#x2F;fmt.Println(&quot;left:&quot;, left, &quot;    right:&quot;, right)</span><br><span class="line">go f(left, right)</span><br><span class="line">&#125;</span><br><span class="line">right &lt;- 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; start the chaining 开始链接</span><br><span class="line">x :&#x3D; &lt;-leftmost &#x2F;&#x2F; wait for completion 等待完成</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#x2F;&#x2F; 结果： 100000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个很有意思的点：在没有运行程序之前，我认为leftmost的结果为1，认为只在最初做了一次赋值，实际结果为100000（无缓存信道，具有同步阻塞的特性），这个是为什么呢？</p><ul><li>1.主线程的right &lt;- 0，right不是最初循环的那个right，而是最终循环的right</li><li>2.for循环中最初的go f(left, right)因为没有发送者一直处于等待状态</li><li>3.当主线程的right &lt;- 0执行时，类似于递归函数在最内层产生返回值一般</li></ul><h2 id="十三、多核运算"><a href="#十三、多核运算" class="headerlink" title="十三、多核运算"></a>十三、多核运算</h2><p>假设我们的 CPU 核数是 NCPU 个： const NCPU = 4 // 例如：4 代表 4 核处理器，我们将计算划分为 NCPU 部分，每部分与其他部分并行运行。</p><p>下面是一个简单的示例（我们忽略具体的参数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func DoAll() &#123;</span><br><span class="line">sem :&#x3D; make(chan int, NCPU)</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; NCPU; i++ &#123;</span><br><span class="line">&#x2F;&#x2F; Buffering optional but sensible. 合理的缓冲区选项（个人理解就是和 CPU 的核心数相同）</span><br><span class="line">go DoPart(sem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待 NCPU 任务完成，释放通道 sem 的缓冲区</span><br><span class="line">for i :&#x3D; 0; i &lt; NCPU; i++ &#123;</span><br><span class="line">&lt;-sem &#x2F;&#x2F; 等待一个任务完成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全部完成。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DoPart(sem chan int) &#123;</span><br><span class="line">&#x2F;&#x2F; 进行计算的部分</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">sem &lt;- 1 &#x2F;&#x2F; 发送一个这部分已经完成的信号，用来释放 sem 的缓冲区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">runtime.GOMAXPROCS &#x3D; NCPU</span><br><span class="line">DoAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 DoAll() 生成一个通道 sem ，在此基础上完成每一个并行计算；在 for 循环中启动 NCPU 个协程，每一个协程执行全部工作的 1/NCPU 。通过 sem 发送每一个协程中 DoPart() 完成的信号。</p><p>DoAll() 中用一个 for 循环来等待所有（NCPU 个）协程完成计算： 通道 sem 的行为就像一个 semaphore（信号量）；这个代码展示了一个典型的信号量模式。</p><p>在当前的运行模式下，你还必须设置 GOMAXPROCS 为 NCPU。</p><h2 id="十四、多核运算处理大量数据"><a href="#十四、多核运算处理大量数据" class="headerlink" title="十四、多核运算处理大量数据"></a>十四、多核运算处理大量数据</h2><p>假设我们必须处理 <strong>大量的彼此独立的数据项</strong> ，通过一个输入通道进入，并且全部处理完成后放到一个输出通道，就像一个工厂的管道。每个数据项的处理也许会涉及多个步骤： 预处理 / 步骤 A / 步骤 B / … / 后期处理</p><p>一个典型的顺序 <strong>流水线算法</strong> 可以用来解决这个问题，下面示例展示了每一步执行的顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func SerialProcessData (in &lt;- chan *Data, out &lt;- chan *Data) &#123;</span><br><span class="line">    for data :&#x3D; range in &#123;</span><br><span class="line">        tmpA :&#x3D; PreprocessData(data)</span><br><span class="line">        tmpB :&#x3D; ProcessStepA(tmpA)</span><br><span class="line">        tmpC :&#x3D; ProcessStepB(tmpB)</span><br><span class="line">        out &lt;- PostProcessData(tmpC)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次只执行一步，并且每个项目按顺序处理：在第一个项目被处理完并将结果放到输出通道之前第二个项目不会开始。</p><p>如果你仔细想想，你很快就会意识到这样会非常的浪费时间。</p><p>一个更有效的计算是 <strong>让每一个步骤都作为一个协程独立工作</strong> 。每个步骤都从上一步的输出通道获取输入数据。这样可以尽可能的避免时间浪费，并且大部分时间所有的步骤都会繁忙的执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func ParallelProcessData (in &lt;- chan *Data, out &lt;- chan *Data) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; make channels:</span><br><span class="line"></span><br><span class="line">    preOut :&#x3D; make(chan *Data, 100)</span><br><span class="line">    stepAOut :&#x3D; make(chan *Data, 100)</span><br><span class="line">    stepBOut :&#x3D; make(chan *Data, 100)</span><br><span class="line">    stepCOut :&#x3D; make(chan *Data, 100)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; start parallel computations:</span><br><span class="line"></span><br><span class="line">    go PreprocessData(in, preOut)</span><br><span class="line">    go ProcessStepA(preOut, stepAOut)</span><br><span class="line">    go ProcessStepB(stepAOut, stepBOut)</span><br><span class="line">    go ProcessStepC(stepBOut, stepCOut)</span><br><span class="line">    go PostProcessData(stepCOut, out)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道缓冲区可以用于进一步优化整个过程。</p><h2 id="十五、使用-Channel-来并发读取对象"><a href="#十五、使用-Channel-来并发读取对象" class="headerlink" title="十五、使用 Channel 来并发读取对象"></a>十五、使用 Channel 来并发读取对象</h2><p>为了保护一个对象的并发修改，我们可以使用一个后台的协程来顺序执行一个匿名函数，而不是通过同步 互斥锁（Mutex） 进行锁定。</p><p>在下面的程序中，我们有一个 Person 类型，它包含了一个匿名函数类型的通道字段 chF。它在构造器方法 NewPerson 中初始化，用一个协程启动一个 backend() 方法。这个方法在一个无限 for 循环中执行所有被放到 chF 上的函数，有效的序列化他们，从而提供安全的并发访问。</p><p>改变和获取 salary 可以通过一个放在 chF 上的匿名函数来实现，backend() 会顺序执行它们。注意如何在 Salary 方法中的闭合（匿名）函数中去包含 fChan 通道。</p><p>这是一个简化的例子，并且它不应该在这种情况下应用，但是它展示了如何在更复杂的情况下解决问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">Name   string</span><br><span class="line">salary float64</span><br><span class="line">chF    chan func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewPerson(name string, salary float64) *Person &#123;</span><br><span class="line">p :&#x3D; &amp;Person&#123;name, salary, make(chan func())&#125;</span><br><span class="line">go p.backend()</span><br><span class="line">return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) backend() &#123;</span><br><span class="line">for f :&#x3D; range p.chF &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SetSalary 设置 salary.</span><br><span class="line">func (p *Person) SetSalary(sal float64) &#123;</span><br><span class="line">p.chF &lt;- func() &#123; p.salary &#x3D; sal &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Salary 取回 salary.</span><br><span class="line">func (p *Person) Salary() float64 &#123;</span><br><span class="line">fChan :&#x3D; make(chan float64)</span><br><span class="line">p.chF &lt;- func() &#123; fChan &lt;- p.salary &#125;</span><br><span class="line">return &lt;-fChan</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) String() string &#123;</span><br><span class="line">return &quot;Person - name is: &quot; + p.Name + &quot; - salary is: &quot; +</span><br><span class="line">strconv.FormatFloat(p.Salary(), &#39;f&#39;, 2, 64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">bs :&#x3D; NewPerson(&quot;Smith Bill&quot;, 2500.5)</span><br><span class="line">fmt.Println(bs)</span><br><span class="line"></span><br><span class="line">bs.SetSalary(4000.25)</span><br><span class="line">fmt.Println(&quot;Salary changed:&quot;)</span><br><span class="line">fmt.Println(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Person - name is: Smith Bill - salary is: 2500.50</span><br><span class="line"></span><br><span class="line">Salary changed:</span><br><span class="line"></span><br><span class="line">Person - name is: Smith Bill - salary is: 4000.25</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://godoc.murphyyi.com/">《Go入门指南》</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：协程与通道（channel）的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：协程与通道（channel）的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
    <category term="协程" scheme="https://www.blog.ajie39.top/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="channel" scheme="https://www.blog.ajie39.top/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go 入门总结（三）</title>
    <link href="https://www.blog.ajie39.top/2022/06/12/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/06/12/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-06-12T06:36:14.967Z</published>
    <updated>2022-06-13T14:38:19.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：十二到十三章的内容。</h1><hr><span id="more"></span><h2 id="一、读写数据"><a href="#一、读写数据" class="headerlink" title="一、读写数据"></a>一、读写数据</h2><h3 id="1、读取用户的输入"><a href="#1、读取用户的输入" class="headerlink" title="1、读取用户的输入"></a>1、读取用户的输入</h3><p>从键盘和标准输入 os.Stdin 读取输入，最简单的办法是使用 fmt 包提供的 Scan 和 Sscan 开头的函数。请看以下程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">firstName, lastName, s string</span><br><span class="line">i                      int</span><br><span class="line">f                      float32</span><br><span class="line">input                  &#x3D; &quot;56.12 &#x2F; 5212 &#x2F; Go&quot;</span><br><span class="line">format                 &#x3D; &quot;%f &#x2F; %d &#x2F; %s&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;Please enter your full name: &quot;)</span><br><span class="line">fmt.Scanln(&amp;firstName, &amp;lastName)</span><br><span class="line">&#x2F;&#x2F; fmt.Scanf(&quot;%s %s&quot;, &amp;firstName, &amp;lastName)</span><br><span class="line">fmt.Printf(&quot;Hi %s %s!\n&quot;, firstName, lastName) &#x2F;&#x2F; Hi Chris Naegels</span><br><span class="line">fmt.Sscanf(input, format, &amp;f, &amp;i, &amp;s)</span><br><span class="line">fmt.Println(&quot;From the string we read: &quot;, f, i, s)</span><br><span class="line">&#x2F;&#x2F; 输出结果: From the string we read: 56.12 5212 Go</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scanln 扫描来自 <strong>标准输入的文本</strong>，将空格分隔的值依次存放到后续的参数内，直到碰到换行。</p><p>Scanf 与其类似，除了 Scanf 的第一个参数用作格式字符串，用来决定如何读取。</p><p>Sscan 和以 Sscan 开头的函数则是 <strong>从字符串读取</strong>，除此之外，与 Scanf 相同。如果这些函数读取到的结果与您预想的不同，您可以检查成功读入数据的个数和返回的错误。</p><p>您也可以使用 bufio 包提供的缓冲读取（buffered reader）来读取数据。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var inputReader *bufio.Reader</span><br><span class="line">var input string</span><br><span class="line">var err error</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    inputReader &#x3D; bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println(&quot;Please enter some input: &quot;)</span><br><span class="line">    input, err &#x3D; inputReader.ReadString(&#39;\n&#39;)</span><br><span class="line">    if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;The input was: %s\n&quot;, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadString(delim byte)，该方法从输入中读取内容，直到碰到 delim 指定的字符，然后将读取到的内容连同 delim 字符一起放到缓冲区。</p><p>ReadString 返回读取到的字符串，如果碰到错误则返回 nil。如果它一直读到文件结束，则返回读取到的字符串和 io.EOF。如果读取过程中没有碰到 delim 字符，将返回错误 err != nil。</p><h3 id="2、文件读写"><a href="#2、文件读写" class="headerlink" title="2、文件读写"></a>2、文件读写</h3><p>在 Go 语言中，文件使用指向 os.File 类型的指针来表示的，也叫做 <strong>文件句柄</strong> 。</p><p>我们在前面使用到过标准输入 os.Stdin 和标准输出 os.Stdout，他们的类型都是 *os.File。</p><p>让我们来看看下面这个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">inputFile, inputError :&#x3D; os.Open(&quot;input.dat&quot;)</span><br><span class="line">if inputError !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;An error occurred on opening the inputfile\n&quot; +</span><br><span class="line">&quot;Does the file exist?\n&quot; +</span><br><span class="line">&quot;Have you got acces to it?\n&quot;)</span><br><span class="line">return &#x2F;&#x2F; exit the function on error</span><br><span class="line">&#125;</span><br><span class="line">defer inputFile.Close()</span><br><span class="line"></span><br><span class="line">inputReader :&#x3D; bufio.NewReader(inputFile)</span><br><span class="line">for &#123;</span><br><span class="line">inputString, readerError :&#x3D; inputReader.ReadString(&#39;\n&#39;)</span><br><span class="line">fmt.Printf(&quot;The input was: %s&quot;, inputString)</span><br><span class="line">if readerError &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">在之前的例子中，我们看到，Unix 和 Linux 的行结束符是 \n，而 Windows 的行结束符是 \r\n。</span><br><span class="line"></span><br><span class="line">在使用 ReadString 和 ReadBytes 方法的时候，我们不需要关心操作系统的类型，直接使用 \n 就可以了。</span><br><span class="line"></span><br><span class="line">另外，我们也可以使用 ReadLine() 方法来实现相同的功能。</span><br><span class="line"></span><br><span class="line">一旦读取到文件末尾，变量 readerError 的值将变成非空（事实上，常量 io.EOF 的值是 true），我们就会执行 return 语句从而退出循环。</span><br></pre></td></tr></table></figure><h4 id="1）将整个文件的内容读到一个字符串里"><a href="#1）将整个文件的内容读到一个字符串里" class="headerlink" title="1）将整个文件的内容读到一个字符串里"></a>1）将整个文件的内容读到一个字符串里</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&#x2F;ioutil&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">inputFile :&#x3D; &quot;products.txt&quot;</span><br><span class="line">outputFile :&#x3D; &quot;products_copy.txt&quot;</span><br><span class="line">buf, err :&#x3D; ioutil.ReadFile(inputFile)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, &quot;File Error: %s\n&quot;, err)</span><br><span class="line">&#x2F;&#x2F; panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%s\n&quot;, string(buf))</span><br><span class="line">err &#x3D; ioutil.WriteFile(outputFile, buf, 0644) &#x2F;&#x2F; oct, not hex</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">panic(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）带缓冲的读取"><a href="#2）带缓冲的读取" class="headerlink" title="2）带缓冲的读取"></a>2）带缓冲的读取</h4><p>在很多情况下，文件的内容是 <strong>不按行划分的，或者干脆就是一个二进制文件</strong> 。在这种情况下，ReadString() 就无法使用了，我们可以使用 bufio.Reader 的 Read()，它只接收一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf :&#x3D; make([]byte, 1024)</span><br><span class="line">...</span><br><span class="line">n, err :&#x3D; inputReader.Read(buf)</span><br><span class="line">if (n &#x3D;&#x3D; 0) &#123; break&#125;</span><br><span class="line"></span><br><span class="line">变量 n 的值表示读取到的字节数。</span><br></pre></td></tr></table></figure><h4 id="3）按列读取文件中的数据"><a href="#3）按列读取文件中的数据" class="headerlink" title="3）按列读取文件中的数据"></a>3）按列读取文件中的数据</h4><p>如果数据是按列排列并用空格分隔的，你可以使用 fmt 包提供的以 FScan 开头的一系列函数来读取他们。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    file, err :&#x3D; os.Open(&quot;products2.txt&quot;)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">    &#125;</span><br><span class="line">    defer file.Close()</span><br><span class="line"></span><br><span class="line">    var col1, col2, col3 []string</span><br><span class="line">    for &#123;</span><br><span class="line">        var v1, v2, v3 string</span><br><span class="line">        _, err :&#x3D; fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)</span><br><span class="line">        &#x2F;&#x2F; scans until newline</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        col1 &#x3D; append(col1, v1)</span><br><span class="line">        col2 &#x3D; append(col2, v2)</span><br><span class="line">        col3 &#x3D; append(col3, v3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(col1)</span><br><span class="line">    fmt.Println(col2)</span><br><span class="line">    fmt.Println(col3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* products2.txt</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">[1 4 7]</span><br><span class="line">[2 5 8]</span><br><span class="line">[3 6 9]</span><br></pre></td></tr></table></figure><h4 id="4）compress-包：读取压缩文件"><a href="#4）compress-包：读取压缩文件" class="headerlink" title="4）compress 包：读取压缩文件"></a>4）compress 包：读取压缩文件</h4><p>compress 包提供了读取压缩文件的功能，支持的压缩文件格式为：bzip2、flate、gzip、lzw 和 zlib。</p><p>下面的程序展示了如何读取一个 gzip 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;compress&#x2F;gzip&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fName :&#x3D; &quot;MyFile.gz&quot;</span><br><span class="line">    var r *bufio.Reader</span><br><span class="line">    fi, err :&#x3D; os.Open(fName)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, &quot;%v, Can&#39;t open %s: error: %s\n&quot;, os.Args[0], fName,</span><br><span class="line">            err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    &#125;</span><br><span class="line">    fz, err :&#x3D; gzip.NewReader(fi)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        r &#x3D; bufio.NewReader(fi)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        r &#x3D; bufio.NewReader(fz)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        line, err :&#x3D; r.ReadString(&#39;\n&#39;)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            fmt.Println(&quot;Done reading file&quot;)</span><br><span class="line">            os.Exit(0)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5）写文件"><a href="#5）写文件" class="headerlink" title="5）写文件"></a>5）写文件</h4><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main () &#123;</span><br><span class="line">    &#x2F;&#x2F; var outputWriter *bufio.Writer</span><br><span class="line">    &#x2F;&#x2F; var outputFile *os.File</span><br><span class="line">    &#x2F;&#x2F; var outputError os.Error</span><br><span class="line">    &#x2F;&#x2F; var outputString string</span><br><span class="line">    outputFile, outputError :&#x3D; os.OpenFile(&quot;output.dat&quot;, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line">    if outputError !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;An error occurred with file opening or creation\n&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer outputFile.Close()</span><br><span class="line"></span><br><span class="line">    outputWriter :&#x3D; bufio.NewWriter(outputFile)</span><br><span class="line">    outputString :&#x3D; &quot;hello world!\n&quot;</span><br><span class="line"></span><br><span class="line">    for i:&#x3D;0; i&lt;10; i++ &#123;</span><br><span class="line">        outputWriter.WriteString(outputString)</span><br><span class="line">    &#125;</span><br><span class="line">    outputWriter.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以只写模式打开文件 output.dat，如果文件不存在则自动创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">outputFile, outputError :&#x3D; os.OpenFile(“output.dat”, os.O_WRONLY|os.O_CREATE, 0666)</span><br><span class="line"></span><br><span class="line">可以看到，OpenFile 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符 “|” 连接），使用的文件权限。</span><br><span class="line"></span><br><span class="line">在读文件的时候，文件的权限是被忽略的，所以在使用 OpenFile 时传入的第三个参数可以用 0。</span><br><span class="line"></span><br><span class="line">而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。</span><br></pre></td></tr></table></figure><p>我们通常会用到以下标志：</p><ul><li>os.O_RDONLY：只读。</li><li>os.O_WRONLY：只写。</li><li>os.O_CREATE：创建：如果指定文件不存在，就创建该文件。</li><li>os.O_TRUNC：截断：如果指定文件已存在，就将该文件的长度截为 0。</li></ul><p>使用其他函数如何写文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    os.Stdout.WriteString(&quot;hello, world\n&quot;)</span><br><span class="line">    f, _ :&#x3D; os.OpenFile(&quot;test&quot;, os.O_CREATE|os.O_WRONLY, 0)</span><br><span class="line">    defer f.Close()</span><br><span class="line">    f.WriteString(&quot;hello, world in a file\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用 os.Stdout.WriteString(“hello, world\n”)，我们可以输出到屏幕。</span><br><span class="line"></span><br><span class="line">我们以只写模式创建或打开文件 “test”，并且忽略了可能发生的错误：f, _ :&#x3D; os.OpenFile(“test”, os.O_CREATE|os.O_WRONLY, 0)</span><br><span class="line"></span><br><span class="line">我们不使用缓冲区，直接将内容写入文件：f.WriteString()</span><br></pre></td></tr></table></figure><h3 id="3、文件拷贝"><a href="#3、文件拷贝" class="headerlink" title="3、文件拷贝"></a>3、文件拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    CopyFile(&quot;target.txt&quot;, &quot;source.txt&quot;)</span><br><span class="line">    fmt.Println(&quot;Copy done!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CopyFile(dstName, srcName string) (written int64, err error) &#123;</span><br><span class="line">    src, err :&#x3D; os.Open(srcName)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err :&#x3D; os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer dst.Close()</span><br><span class="line"></span><br><span class="line">    return io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 defer 的使用：当打开目标文件时发生了错误，那么 defer 仍然能够确保 src.Close() 执行。如果不这么做，文件会一直保持打开状态并占用资源。</p><h3 id="4、从命令行读取参数"><a href="#4、从命令行读取参数" class="headerlink" title="4、从命令行读取参数"></a>4、从命令行读取参数</h3><h4 id="1）os-包"><a href="#1）os-包" class="headerlink" title="1）os 包"></a>1）os 包</h4><p>os 包中有一个 string 类型的切片变量 os.Args，用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">who :&#x3D; &quot;Alice &quot;</span><br><span class="line">if len(os.Args) &gt; 1 &#123;</span><br><span class="line">who +&#x3D; strings.Join(os.Args[1:], &quot; &quot;)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(os.Args[:])</span><br><span class="line">fmt.Println(&quot;Good Morning&quot;, who)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 IDE 或编辑器中直接运行这个程序输出：Good Morning Alice</p><p>但是我们在命令行加入参数，像这样：os_args John Bill Marc Luke，将得到这样的输出：Good Morning Alice John Bill Marc Luke</p><p>这个命令行参数会放置在切片 os.Args[] 中（以空格分隔），从索引 1 开始（os.Args[0] 放的是程序本身的名字，在本例中是 os_args）。函数 strings.Join 以空格为间隔连接这些参数。</p><h4 id="2）flag-包"><a href="#2）flag-包" class="headerlink" title="2）flag 包"></a>2）flag 包</h4><p>flag 包有一个扩展功能用来解析命令行选项。但是通常被用来替换基本常量，例如，在某些情况下我们希望在命令行给常量一些不一样的值。</p><p>在 flag 包中一个 Flag 被定义成一个含有如下字段的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Flag struct &#123;</span><br><span class="line">    Name     string &#x2F;&#x2F; name as it appears on command line</span><br><span class="line">    Usage    string &#x2F;&#x2F; help message</span><br><span class="line">    Value    Value  &#x2F;&#x2F; value as set</span><br><span class="line">    DefValue string &#x2F;&#x2F; default value (as text); for usage message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的程序模拟了 Unix 的 echo 功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;flag&quot; &#x2F;&#x2F; command line option parser</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var NewLine &#x3D; flag.Bool(&quot;n&quot;, false, &quot;print newline&quot;) &#x2F;&#x2F; echo -n flag, of type *bool</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    Space   &#x3D; &quot; &quot;</span><br><span class="line">    Newline &#x3D; &quot;\n&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.PrintDefaults()</span><br><span class="line">    flag.Parse() &#x2F;&#x2F; Scans the arg list and sets up flags</span><br><span class="line">    var s string &#x3D; &quot;&quot;</span><br><span class="line">    for i :&#x3D; 0; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        if i &gt; 0 &#123;</span><br><span class="line">            s +&#x3D; &quot; &quot;</span><br><span class="line">            if *NewLine &#123; &#x2F;&#x2F; -n is parsed, flag becomes true</span><br><span class="line">                s +&#x3D; Newline</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s +&#x3D; flag.Arg(i)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">添加参数：A B C</span><br><span class="line">输出：A B C</span><br><span class="line"></span><br><span class="line">添加参数：-n A B C</span><br><span class="line">输出：</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>方法说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag.Parse() 扫描参数列表（或者常量列表）并设置 flag, flag.Arg(i) 表示第 i 个参数。Parse() 之后 flag.Arg(i) 全部可用，flag.Arg(0) 就是第一个真实的 flag，而不是像 os.Args(0) 放置程序的名字。</span><br><span class="line"></span><br><span class="line">flag.Narg() 返回参数的数量。解析后 flag 或常量就可用了。</span><br><span class="line"></span><br><span class="line">flag.Bool() 定义了一个默认值是 false 的 flag：当在命令行出现了第一个参数（这里是 “n”），flag 被设置成 true（NewLine 是 *bool 类型）。flag 被解引用到 *NewLine，所以当值是 true 时将添加一个 newline（”\n”）。</span><br><span class="line"></span><br><span class="line">flag.PrintDefaults() 打印 flag 的使用帮助信息。</span><br><span class="line"></span><br><span class="line">flag.VisitAll(fn func(*Flag)) 是另一个有用的功能：按照字典顺序遍历 flag，并且对每个标签调用 fn。</span><br></pre></td></tr></table></figure><h3 id="5、用-buffer-读取文件"><a href="#5、用-buffer-读取文件" class="headerlink" title="5、用 buffer 读取文件"></a>5、用 buffer 读取文件</h3><p>在下面的例子中，我们结合使用了缓冲读取文件和命令行 flag 解析这两项技术。</p><p>如果不加参数，那么你输入什么屏幕就打印什么。</p><p>参数被认为是文件名，如果文件存在的话就打印文件内容到屏幕。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func cat(r *bufio.Reader) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        buf, err :&#x3D; r.ReadBytes(&#39;\n&#39;)</span><br><span class="line">        if err &#x3D;&#x3D; io.EOF &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(os.Stdout, &quot;%s&quot;, buf)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    if flag.NArg() &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        cat(bufio.NewReader(os.Stdin))</span><br><span class="line">    &#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err :&#x3D; os.Open(flag.Arg(i))</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, &quot;%s:error reading from %s: %s\n&quot;, os.Args[0], flag.Arg(i), err.Error())</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        cat(bufio.NewReader(f))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、用切片读写文件"><a href="#6、用切片读写文件" class="headerlink" title="6、用切片读写文件"></a>6、用切片读写文件</h3><p>切片提供了 Go 中处理 I/O 缓冲的标准方式，下面 cat 函数中，在一个切片缓冲内使用无限 for 循环（直到文件尾部 EOF）读取文件，并写入到标准输出（os.Stdout）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func cat(f *os.File) &#123;</span><br><span class="line">    const NBUF &#x3D; 512</span><br><span class="line">    var buf [NBUF]byte</span><br><span class="line">    for &#123;</span><br><span class="line">        switch nr, err :&#x3D; f.Read(buf[:]); true &#123;</span><br><span class="line">        case nr &lt; 0:</span><br><span class="line">            fmt.Fprintf(os.Stderr, &quot;cat: error reading: %s\n&quot;, err.Error())</span><br><span class="line">            os.Exit(1)</span><br><span class="line">        case nr &#x3D;&#x3D; 0: &#x2F;&#x2F; EOF</span><br><span class="line">            return</span><br><span class="line">        case nr &gt; 0:</span><br><span class="line">            if nw, ew :&#x3D; os.Stdout.Write(buf[0:nr]); nw !&#x3D; nr &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, &quot;cat: error writing: %s\n&quot;, ew.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    flag.Parse() &#x2F;&#x2F; Scans the arg list and sets up flags</span><br><span class="line">    if flag.NArg() &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        cat(os.Stdin)</span><br><span class="line">    &#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err :&#x3D; os.Open(flag.Arg(i))</span><br><span class="line">        if f &#x3D;&#x3D; nil &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, &quot;cat: can&#39;t open %s: error %s\n&quot;, flag.Arg(i), err)</span><br><span class="line">            os.Exit(1)</span><br><span class="line">        &#125;</span><br><span class="line">        cat(f)</span><br><span class="line">        f.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、使用接口的实际例子：fmt-Fprintf"><a href="#7、使用接口的实际例子：fmt-Fprintf" class="headerlink" title="7、使用接口的实际例子：fmt.Fprintf"></a>7、使用接口的实际例子：fmt.Fprintf</h3><p>下面例子很好的阐述了 io 包中的接口概念。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;bufio&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; unbuffered</span><br><span class="line">    fmt.Fprintf(os.Stdout, &quot;%s\n&quot;, &quot;hello world! - unbuffered&quot;)</span><br><span class="line">    &#x2F;&#x2F; buffered: os.Stdout implements io.Writer</span><br><span class="line">    buf :&#x3D; bufio.NewWriter(os.Stdout)</span><br><span class="line">    &#x2F;&#x2F; and now so does buf.</span><br><span class="line">    fmt.Fprintf(buf, &quot;%s\n&quot;, &quot;hello world! - buffered&quot;)</span><br><span class="line">    buf.Flush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">hello world! - unbuffered</span><br><span class="line">hello world! - buffered</span><br></pre></td></tr></table></figure><p>下面是 fmt.Fprintf() 函数的实际签名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Fprintf(w io.Writer, format string, a ...interface&#123;&#125;) (n int, err error)</span><br></pre></td></tr></table></figure><p>其不是写入一个文件，而是写入一个 io.Writer 接口类型的变量，下面是 Writer 接口在 io 包中的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Writer interface &#123;</span><br><span class="line">    Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fmt.Fprintf() 依据指定的格式向第一个参数内写入字符串，第一参数必须实现了 io.Writer 接口。</p><p>Fprintf() 能够写入任何类型，只要其实现了 Write 方法，包括 os.Stdout, 文件（例如 os.File），管道，网络连接，通道等等，<br>同样的也可以使用 bufio 包中缓冲写入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bufio 包中定义了 type Writer struct&#123;...&#125;</span><br><span class="line"></span><br><span class="line">bufio.Writer 实现了 Write 方法：</span><br><span class="line"></span><br><span class="line">func (b *Writer) Write(p []byte) (nn int, err error)</span><br><span class="line"></span><br><span class="line">它还有一个工厂函数：传给它一个 io.Writer 类型的参数，它会返回一个缓冲的 bufio.Writer 类型的 io.Writer:</span><br><span class="line"></span><br><span class="line">func NewWriter(wr io.Writer) (b *Writer)</span><br><span class="line"></span><br><span class="line">其适合任何形式的缓冲写入。</span><br></pre></td></tr></table></figure><p>在缓冲写入的最后千万 **不要忘了使用 Flush()**，否则最后的输出不会被写入。</p><h3 id="8、JSON-数据格式"><a href="#8、JSON-数据格式" class="headerlink" title="8、JSON 数据格式"></a>8、JSON 数据格式</h3><p>通过把数据转换成纯文本，使用命名的字段来标注，让其具有可读性。这样的数据格式可以通过网络传输，而且是与平台无关的，任何类型的应用都能够读取和输出，不与操作系统和编程语言的类型相关。</p><p>下面是一些术语说明：</p><ul><li>数据结构 –&gt; 指定格式 = 序列化 或 编码（传输之前）</li><li>指定格式 –&gt; 数据格式 = 反序列化 或 解码（传输之后）</li></ul><p>序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure）</p><p>编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。</p><h4 id="1）序列化"><a href="#1）序列化" class="headerlink" title="1）序列化"></a>1）序列化</h4><p>Go 语言的 json 包可以让你在程序中方便的读取和写入 JSON 数据。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Address struct &#123;</span><br><span class="line">Type    string</span><br><span class="line">City    string</span><br><span class="line">Country string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type VCard struct &#123;</span><br><span class="line">FirstName string</span><br><span class="line">LastName  string</span><br><span class="line">Addresses []*Address</span><br><span class="line">Remark    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">pa :&#x3D; &amp;Address&#123;&quot;private&quot;, &quot;Aartselaar&quot;, &quot;Belgium&quot;&#125;</span><br><span class="line">wa :&#x3D; &amp;Address&#123;&quot;work&quot;, &quot;Boom&quot;, &quot;Belgium&quot;&#125;</span><br><span class="line">vc :&#x3D; VCard&#123;&quot;Jan&quot;, &quot;Kersschot&quot;, []*Address&#123;pa, wa&#125;, &quot;none&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; fmt.Printf(&quot;%v: \n&quot;, vc) &#x2F;&#x2F; &#123;Jan Kersschot [0x126d2b80 0x126d2be0] none&#125;:</span><br><span class="line">&#x2F;&#x2F; JSON format:</span><br><span class="line">js, _ :&#x3D; json.Marshal(vc)</span><br><span class="line">fmt.Printf(&quot;JSON format: %s&quot;, js)</span><br><span class="line">&#x2F;&#x2F; using an encoder:</span><br><span class="line">file, _ :&#x3D; os.OpenFile(&quot;vcard.json&quot;, os.O_CREATE|os.O_WRONLY, 0666)</span><br><span class="line">defer file.Close()</span><br><span class="line">enc :&#x3D; json.NewEncoder(file)</span><br><span class="line">err :&#x3D; enc.Encode(vc)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">log.Println(&quot;Error in encoding json&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json.Marshal() 的函数签名是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Marshal(v interface&#123;&#125;) ([]byte, error)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">出于安全考虑，在 web 应用中最好使用 json.MarshalforHTML() 函数，其对数据执行 HTML 转码，所以文本可以被安全地嵌在 HTML &lt;script&gt; 标签中。</span><br><span class="line"></span><br><span class="line">json.NewEncoder() 的函数签名是 func NewEncoder(w io.Writer) *Encoder，返回的 Encoder 类型的指针可调用方法 Encode(v interface&#123;&#125;)，将数据对象 v 的 json 编码写入 io.Writer w 中。</span><br></pre></td></tr></table></figure><p>JSON 与 Go 类型对应如下：</p><ul><li>bool 对应 JSON 的 booleans</li><li>float64 对应 JSON 的 numbers</li><li>string 对应 JSON 的 strings</li><li>nil 对应 JSON 的 null</li></ul><p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：</p><ul><li>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map [string] T（T 是 json 包中支持的任何类型）</li><li>Channel，复杂类型和函数类型不能被编码</li><li>不支持循环数据结构；它将引起序列化进入一个无限循环</li><li>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</li></ul><h4 id="2）反序列化"><a href="#2）反序列化" class="headerlink" title="2）反序列化"></a>2）反序列化</h4><p>UnMarshal() 的函数签名是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Unmarshal(data []byte, v interface&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">把 JSON 解码为数据结构</span><br></pre></td></tr></table></figure><p>上面的例子编码后的数据为 Json ，对其解码时，我们首先创建结构 VCard 用来保存解码的数据：var v VCard 并调用 json.Unmarshal(js, &amp;v)，解析 [] byte 中的 JSON 数据并将结果存入指针 &amp;v 指向的值。</p><p>虽然反射能够让 JSON 字段去尝试匹配目标结构字段；但是只有真正匹配上的字段才会填充数据。字段没有匹配不会报错，而是直接忽略掉。</p><h5 id="解码任意的数据"><a href="#解码任意的数据" class="headerlink" title="解码任意的数据"></a>解码任意的数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json 包使用 map[string]interface&#123;&#125; 和 []interface&#123;&#125; 储存任意的 JSON 对象和数组。</span><br><span class="line"></span><br><span class="line">其可以被反序列化为任何的 JSON blob 存储到接口值中。</span><br></pre></td></tr></table></figure><p>来看这个 JSON 数据，被存储在变量 b 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b :&#x3D; []byte(&#96;&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;&#96;)</span><br></pre></td></tr></table></figure><p>不用理解这个数据的结构，我们可以直接使用 Unmarshal 把这个数据编码并保存在接口值中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f interface&#123;&#125;</span><br><span class="line">err :&#x3D; json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure><p>f 指向的值是一个 map，key 是一个字符串，value 是自身存储作为空接口类型的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map[string]interface&#123;&#125; &#123;</span><br><span class="line">    &quot;Name&quot;: &quot;Wednesday&quot;,</span><br><span class="line">    &quot;Age&quot;:  6,</span><br><span class="line">    &quot;Parents&quot;: []interface&#123;&#125; &#123;</span><br><span class="line">        &quot;Gomez&quot;,</span><br><span class="line">        &quot;Morticia&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要访问这个数据，我们可以使用类型断言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m :&#x3D; f.(map[string]interface&#123;&#125;)</span><br></pre></td></tr></table></figure><p>我们可以通过 for range 语法和 type switch 来访问其实际类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for k, v :&#x3D; range m &#123;</span><br><span class="line">    switch vv :&#x3D; v.(type) &#123;</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Println(k, &quot;is string&quot;, vv)</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Println(k, &quot;is int&quot;, vv)</span><br><span class="line"></span><br><span class="line">    case []interface&#123;&#125;:</span><br><span class="line">        fmt.Println(k, &quot;is an array:&quot;)</span><br><span class="line">        for i, u :&#x3D; range vv &#123;</span><br><span class="line">            fmt.Println(i, u)</span><br><span class="line">        &#125;</span><br><span class="line">    default:</span><br><span class="line">        fmt.Println(k, &quot;is of a type I don’t know how to handle&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，你可以处理未知的 JSON 数据，同时可以确保类型安全。完整代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b :&#x3D; []byte(&#96;&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;&#96;)</span><br><span class="line"></span><br><span class="line">var f interface&#123;&#125;</span><br><span class="line">err :&#x3D; json.Unmarshal(b, &amp;f)</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;err：&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m :&#x3D; f.(map[string]interface&#123;&#125;)</span><br><span class="line"></span><br><span class="line">for k, v :&#x3D; range m &#123;</span><br><span class="line">switch vv :&#x3D; v.(type) &#123;</span><br><span class="line">case string:</span><br><span class="line">fmt.Println(k, &quot;is string&quot;, vv)</span><br><span class="line">case int:</span><br><span class="line">fmt.Println(k, &quot;is int&quot;, vv)</span><br><span class="line">case float64:</span><br><span class="line">fmt.Println(k, &quot;is float64&quot;, vv)</span><br><span class="line">case []interface&#123;&#125;:</span><br><span class="line">fmt.Println(k, &quot;is an array:&quot;)</span><br><span class="line">for i, u :&#x3D; range vv &#123;</span><br><span class="line">fmt.Println(i, u)</span><br><span class="line">&#125;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(k, &quot;is of a type I don’t know how to handle&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： <strong>如果反序列化不指定结构体类型或者变量类型，则JSON中的数字类型，默认被反序列化成float64类型。</strong></p><h5 id="解码数据到结构"><a href="#解码数据到结构" class="headerlink" title="解码数据到结构"></a>解码数据到结构</h5><p>如果我们事先知道 JSON 数据，我们可以定义一个适当的结构并对 JSON 数据反序列化。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type FamilyMember struct &#123;</span><br><span class="line">Name    string</span><br><span class="line">Age     int</span><br><span class="line">Parents []string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b :&#x3D; []byte(&#96;&#123;&quot;Name&quot;: &quot;Wednesday&quot;, &quot;Age&quot;: 6, &quot;Parents&quot;: [&quot;Gomez&quot;, &quot;Morticia&quot;]&#125;&#96;)</span><br><span class="line"></span><br><span class="line">var m FamilyMember</span><br><span class="line">err :&#x3D; json.Unmarshal(b, &amp;m)</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Println(&quot;err：&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3）编码和解码流"><a href="#3）编码和解码流" class="headerlink" title="3）编码和解码流"></a>3）编码和解码流</h4><p>json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func NewDecoder(r io.Reader) *Decoder</span><br><span class="line">func NewEncoder(w io.Writer) *Encoder</span><br></pre></td></tr></table></figure><p>要想把 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件（或者任何实现 io.Writer 的类型），并调用 Encode ()；反过来与其对应的是使用 json.Decoder 和 Decode () 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func NewDecoder(r io.Reader) *Decoder</span><br><span class="line">func (dec *Decoder) Decode(v interface&#123;&#125;) error</span><br></pre></td></tr></table></figure><p>来看下接口是如何对实现进行抽象的：</p><ul><li>数据结构可以是任何类型，只要其实现了某种接口，目标或源数据要能够被编码就必须实现 io.Writer 或 io.Reader 接口。</li><li>由于 Go 语言中到处都实现了 Reader 和 Writer，因此 Encoder 和 Decoder 可被应用的场景非常广泛，例如读取或写入 HTTP 连接、websockets 或文件。</li></ul><h3 id="9、XML-数据格式"><a href="#9、XML-数据格式" class="headerlink" title="9、XML 数据格式"></a>9、XML 数据格式</h3><p>如同 json 包一样，XML 也有 Marshal() 和 UnMarshal() 从 XML 中编码和解码数据。</p><p>和 JSON 的方式一样，XML 数据可以序列化为结构，或者从结构反序列化为 XML 数据。</p><p>encoding/xml 包实现了一个简单的 XML 解析器（SAX），用来解析 XML 数据内容。例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding&#x2F;xml&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var t, token xml.Token</span><br><span class="line">var err error</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">input :&#x3D; &quot;&lt;Person&gt;&lt;FirstName&gt;Laura&lt;&#x2F;FirstName&gt;&lt;LastName&gt;Lynn&lt;&#x2F;LastName&gt;&lt;&#x2F;Person&gt;&quot;</span><br><span class="line">inputReader :&#x3D; strings.NewReader(input)</span><br><span class="line">p :&#x3D; xml.NewDecoder(inputReader)</span><br><span class="line"></span><br><span class="line">for t, err &#x3D; p.Token(); err &#x3D;&#x3D; nil; t, err &#x3D; p.Token() &#123;</span><br><span class="line">switch token :&#x3D; t.(type) &#123;</span><br><span class="line">case xml.StartElement:</span><br><span class="line">name :&#x3D; token.Name.Local</span><br><span class="line">fmt.Printf(&quot;Token name: %s\n&quot;, name)</span><br><span class="line">for _, attr :&#x3D; range token.Attr &#123;</span><br><span class="line">attrName :&#x3D; attr.Name.Local</span><br><span class="line">attrValue :&#x3D; attr.Value</span><br><span class="line">fmt.Printf(&quot;An attribute is: %s %s\n&quot;, attrName, attrValue)</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">case xml.EndElement:</span><br><span class="line">fmt.Println(&quot;End of token&quot;)</span><br><span class="line">case xml.CharData:</span><br><span class="line">content :&#x3D; string([]byte(token))</span><br><span class="line">fmt.Printf(&quot;This is the content: %v\n&quot;, content)</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">default:</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Token name: Person</span><br><span class="line">Token name: FirstName</span><br><span class="line">This is the content: Laura</span><br><span class="line">End of token</span><br><span class="line">Token name: LastName</span><br><span class="line">This is the content: Lynn</span><br><span class="line">End of token</span><br><span class="line">End of token</span><br></pre></td></tr></table></figure><p>包中定义了若干 XML 标签类型：StartElement，Chardata（这是从开始标签到结束标签之间的实际文本），EndElement，Comment，Directive 或 ProcInst。</p><p>包中同样定义了一个结构解析器：</p><ul><li>NewParser 方法持有一个 io.Reader（这里具体类型是 strings.NewReader）并生成一个解析器类型的对象。</li><li>Token() 方法返回输入流里的下一个 XML token。在输入流的结尾处，会返回（nil，io.EOF）。</li></ul><p>XML 文本被循环处理直到 Token() 返回一个错误，因为已经到达文件尾部，再没有内容可供处理了。通过一个 type-switch 可以根据一些 XML 标签进一步处理。Chardata 中的内容只是一个 [] byte，通过字符串转换让其变得可读性强一些。</p><h3 id="10、用-Gob-传输数据"><a href="#10、用-Gob-传输数据" class="headerlink" title="10、用 Gob 传输数据"></a>10、用 Gob 传输数据</h3><p>Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；可以在 encoding 包中找到。这种格式的数据简称为 Gob （即 Go binary 的缩写）。类似于 Python 的 “pickle” 和 Java 的 “Serialization”。</p><p>Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。</p><p>它和 JSON 或 XML 有什么不同呢？</p><ul><li>Gob 特定地用于纯 Go 的环境中，例如，两个用 Go 写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。</li><li>Gob 不是可外部定义，语言无关的编码方式。因此它的首选格式是二进制，而不是像 JSON 和 XML 那样的文本格式。</li><li>Gob 并不是一种不同于 Go 的语言，而是在编码和解码过程中用到了 Go 的反射。</li><li>Gob 文件或流是完全自描述的：里面包含的所有类型都有一个对应的描述，并且总是可以用 Go 解码，而不需要了解文件的内容。</li><li>只有可导出的字段会被编码，零值会被忽略。</li><li>在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。</li><li>当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作：解码客户端会继续识别以前存在的字段。</li><li>提供了很大的灵活性，比如在发送者看来，整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。</li></ul><p>假如在发送者这边有一个有结构 T：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type T struct &#123; X, Y, Z int &#125;</span><br><span class="line">var t &#x3D; T&#123;X: 7, Y: 0, Z: 8&#125;</span><br></pre></td></tr></table></figure><p>而在接收者这边可以用一个结构体 U 类型的变量 u 来接收这个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type U struct &#123; X, Y *int8 &#125;</span><br><span class="line">var u U</span><br></pre></td></tr></table></figure><p>在接收者中，X 的值是 7，Y 的值是 0（Y 的值并没有从 t 中传递过来，因为它是零值）。</p><p>和 JSON 的使用方式一样，Gob 使用通用的 io.Writer 接口，通过 NewEncoder() 函数创建 Encoder 对象并调用 Encode()；相反的过程使用通用的 io.Reader 接口，通过 NewDecoder() 函数创建 Decoder 对象并调用 Decode。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bytes&quot;</span><br><span class="line">&quot;encoding&#x2F;gob&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type P struct &#123;</span><br><span class="line">X, Y, Z int</span><br><span class="line">Name    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Q struct &#123;</span><br><span class="line">X, Y *int32</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; Initialize the encoder and decoder.  Normally enc and dec would be</span><br><span class="line">&#x2F;&#x2F; bound to network connections and the encoder and decoder would</span><br><span class="line">&#x2F;&#x2F; run in different processes.</span><br><span class="line">var network bytes.Buffer        &#x2F;&#x2F; Stand-in for a network connection</span><br><span class="line">enc :&#x3D; gob.NewEncoder(&amp;network) &#x2F;&#x2F; Will write to network.</span><br><span class="line">dec :&#x3D; gob.NewDecoder(&amp;network) &#x2F;&#x2F; Will read from network.</span><br><span class="line">&#x2F;&#x2F; Encode (send) the value.</span><br><span class="line">err :&#x3D; enc.Encode(P&#123;3, 4, 5, &quot;Pythagoras&quot;&#125;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">log.Fatal(&quot;encode error:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Decode (receive) the value.</span><br><span class="line">var q Q</span><br><span class="line">err &#x3D; dec.Decode(&amp;q)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">log.Fatal(&quot;decode error:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%q: &#123;%d,%d&#125;\n&quot;, q.Name, *q.X, *q.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&quot;Pythagoras&quot;: &#123;3,4&#125;</span><br></pre></td></tr></table></figure><h3 id="11、Go-中的密码学"><a href="#11、Go-中的密码学" class="headerlink" title="11、Go 中的密码学"></a>11、Go 中的密码学</h3><ul><li>hash 包：实现了 adler32、crc32、crc64 和 fnv 校验。</li><li>crypto 包：实现了其它的 hash 算法，比如 md4、md5、sha1 等。以及完整地实现了 aes、blowfish、rc4、rsa、xtea 等加密算法。</li></ul><p>使用 sha1 示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;crypto&#x2F;sha1&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">hasher :&#x3D; sha1.New()</span><br><span class="line">io.WriteString(hasher, &quot;test&quot;)</span><br><span class="line">b :&#x3D; []byte&#123;&#125;</span><br><span class="line">fmt.Printf(&quot;Result: %x\n&quot;, hasher.Sum(b))</span><br><span class="line">fmt.Printf(&quot;Result: %d\n&quot;, hasher.Sum(b))</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">hasher.Reset()</span><br><span class="line">data :&#x3D; []byte(&quot;We shall overcome!&quot;)</span><br><span class="line">n, err :&#x3D; hasher.Write(data)</span><br><span class="line">if n !&#x3D; len(data) || err !&#x3D; nil &#123;</span><br><span class="line">log.Printf(&quot;Hash write error: %v &#x2F; %v&quot;, n, err)</span><br><span class="line">&#125;</span><br><span class="line">checksum :&#x3D; hasher.Sum(b)</span><br><span class="line">fmt.Printf(&quot;Result: %x\n&quot;, checksum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Result: a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</span><br><span class="line">Result: [169 74 143 229 204 177 155 166 28 76 8 115 211 145 233 135 152 47 187 211]</span><br><span class="line">Result: e2222bfc59850bbb00a722e764a555603bb59b2a</span><br></pre></td></tr></table></figure><p>通过调用 sha1.New() 创建了一个新的 hash.Hash 对象，用来计算 SHA1 校验值。</p><h2 id="二、错误处理与测试"><a href="#二、错误处理与测试" class="headerlink" title="二、错误处理与测试"></a>二、错误处理与测试</h2><p>Go 没有像 Java 和 .NET 那样的 try/catch 异常机制：不能执行抛异常操作。但是有一套 defer-panic-and-recover 机制。</p><p>Go 通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值 —— 如果返回 nil，则没有错误发生 —— 并且主调（calling）函数总是应该检查收到的错误。</p><p><strong>永远不要忽略错误，否则可能会导致程序崩溃！！</strong></p><p>处理错误并且在函数发生错误的地方给用户返回错误信息：照这样处理就算真的出了问题，你的程序也能继续运行并且通知给用户。</p><p><strong>panic and recover 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</strong></p><p>在前面的章节中我们了解了 Go 检查和报告错误条件的惯有方式：</p><ul><li>产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 nil 就是成功，非 nil 就是发生了错误。</li><li>为了防止发生错误时正在执行的函数（如果有必要的话甚至会是整个程序）被中止，在调用函数后必须检查错误。</li></ul><h3 id="1、错误处理"><a href="#1、错误处理" class="headerlink" title="1、错误处理"></a>1、错误处理</h3><p>Go 有一个预先定义的 error 接口类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">    Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误值用来表示异常状态。errors 包中有一个 errorString 结构体实现了 error 接口。当程序处于错误状态时可以用 os.Exit(1) 来中止运行。</p><p><strong>命名规范：错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。</strong></p><h4 id="1）定义错误"><a href="#1）定义错误" class="headerlink" title="1）定义错误"></a>1）定义错误</h4><p>任何时候当你需要一个新的错误类型，都可以用 errors（必须先 import）包的 errors.New 函数接收合适的错误信息来创建，像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err :&#x3D; errors.New(&quot;math - square root of negative number&quot;)</span><br></pre></td></tr></table></figure><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var errNotFound &#x3D; errors.New(&quot;Not found error&quot;)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;error: %v&quot;, errNotFound)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Not found error</span><br></pre></td></tr></table></figure><p>在大部分情况下自定义错误结构类型很有意义的，可以包含除了（低层级的）错误信息以外的其它有用信息，例如，正在进行的操作（打开文件等），全路径或名字。看下面例子中 os.Open 操作触发的 PathError 错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; PathError records an error and the operation and file path that caused it.</span><br><span class="line">type PathError struct &#123;</span><br><span class="line">    Op string    &#x2F;&#x2F; &quot;open&quot;, &quot;unlink&quot;, etc.</span><br><span class="line">    Path string  &#x2F;&#x2F; The associated file.</span><br><span class="line">    Err error  &#x2F;&#x2F; Returned by the system call.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *PathError) String() string &#123;</span><br><span class="line">    return e.Op + &quot; &quot; + e.Path + &quot;: &quot;+ e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有不同错误条件可能发生，那么对实际的错误使用类型断言或类型判断（type-switch）是很有用的，并且可以根据错误场景做一些补救和恢复操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  err !&#x3D; nil</span><br><span class="line">if e, ok :&#x3D; err.(*os.PathError); ok &#123;</span><br><span class="line">    &#x2F;&#x2F; remedy situation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或：</span><br><span class="line"></span><br><span class="line">switch err :&#x3D; err.(type) &#123;</span><br><span class="line">    case ParseError:</span><br><span class="line">        PrintParseError(err)</span><br><span class="line">    case PathError:</span><br><span class="line">        PrintPathError(err)</span><br><span class="line">    ...</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;Not a special error, just %s\n&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）用-fmt-创建错误对象"><a href="#2）用-fmt-创建错误对象" class="headerlink" title="2）用 fmt 创建错误对象"></a>2）用 fmt 创建错误对象</h4><p>通常你想要返回包含错误参数的更有信息量的字符串，例如：可以用 fmt.Errorf() 来实现：它和 fmt.Printf () 完全一样，接收有一个或多个格式占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func testFmt(f int) (int, error) &#123;</span><br><span class="line">if f &lt; 0 &#123;</span><br><span class="line">return 0, fmt.Errorf(&quot;math: square root of negative number %g&quot;, f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return f, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">_, err :&#x3D; testFmt(-1)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、运行时异常和-panic"><a href="#2、运行时异常和-panic" class="headerlink" title="2、运行时异常和 panic"></a>2、运行时异常和 panic</h3><p>当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发运行时 panic，伴随着程序的崩溃抛出一个 runtime.Error 接口类型的值。这个错误值有个 RuntimeError() 方法用于区别普通错误。</p><p>panic 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 panic 函数产生一个中止程序的运行时错误。panic 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;Starting the program&quot;)</span><br><span class="line">    panic(&quot;A severe error occurred: stopping the program!&quot;)</span><br><span class="line">    fmt.Println(&quot;Ending the program&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go panicking：</p><p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，<strong>所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者</strong>。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 panicking。</p><p>标准库中有许多包含 Must 前缀的函数，像 regexp.MustComplie 和 template.Must；当正则表达式或模板中转入的转换字符串导致错误时，这些函数会 panic。</p><h3 id="3、从-panic-中恢复（Recover）"><a href="#3、从-panic-中恢复（Recover）" class="headerlink" title="3、从 panic 中恢复（Recover）"></a>3、从 panic 中恢复（Recover）</h3><p>正如名字一样，这个（recover）内建函数被用于从 panic 或 错误场景中恢复：<strong>让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行</strong>。</p><p>recover <strong>只能在 defer 修饰的函数中使用</strong>：用于取得 panic 调用中传递过来的错误值，<strong>如果是正常执行，调用 recover 会返回 nil，且没有其它效果。</strong></p><p>总结：<strong>panic 会导致栈被展开直到 defer 修饰的 recover () 被调用或者程序中止。</strong></p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func protect(g func()) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">log.Println(&quot;done&quot;)</span><br><span class="line">&#x2F;&#x2F; Println executes normally even if there is a panic</span><br><span class="line">if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">log.Printf(&quot;run time panic: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">log.Println(&quot;start&quot;)</span><br><span class="line">g() &#x2F;&#x2F;   possible runtime-error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">protect(func() &#123;</span><br><span class="line">panic(&quot;run error&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defer-panic-recover机制"><a href="#defer-panic-recover机制" class="headerlink" title="defer-panic-recover机制"></a>defer-panic-recover机制</h4><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func badCall() &#123;</span><br><span class="line">panic(&quot;bad end&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if e :&#x3D; recover(); e !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;Panicing %s\r\n&quot;, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">badCall()</span><br><span class="line">fmt.Printf(&quot;After bad call\r\n&quot;) &#x2F;&#x2F; &lt;-- wordt niet bereikt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;Calling test\r\n&quot;)</span><br><span class="line">test()</span><br><span class="line">fmt.Printf(&quot;Test completed\r\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer-panic-recover 在某种意义上也是一种像 if，for 这样的控制流机制。</p><p>Go 标准库中许多地方都用了这个机制，例如，json 包中的解码和 regexp 包中的 Complie 函数。Go 库的原则是即使在包的内部使用了 panic，在它的对外接口（API）中也必须用 recover 处理成返回显式的错误。</p><h3 id="4、自定义包中的错误处理和-panicking"><a href="#4、自定义包中的错误处理和-panicking" class="headerlink" title="4、自定义包中的错误处理和 panicking"></a>4、自定义包中的错误处理和 panicking</h3><p>这是所有自定义包实现者应该遵守的最佳实践：</p><ul><li>1）在包内部，总是应该从 panic 中 recover：不允许显式的超出包范围的 panic ()</li><li>2）向包的调用者返回错误值（而不是 panic）。</li></ul><p>我们有一个简单的 parse 包用来把输入的字符串解析为整数切片；这个包有自己特殊的 ParseError。当没有东西需要转换或者转换成整数失败时，这个包会 panic（在函数 fields2numbers 中）。但是可导出的 Parse 函数会从 panic 中 recover 并用所有这些信息返回一个错误给调用者。</p><p>为了演示这个过程，在 panic_recover.go 中 调用了 parse 包；不可解析的字符串会导致错误并被打印出来。</p><p>parse.go 代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; parse.go</span><br><span class="line">package parse</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A ParseError indicates an error in converting a word into an integer.</span><br><span class="line">type ParseError struct &#123;</span><br><span class="line">    Index int      &#x2F;&#x2F; The index into the space-separated list of words.</span><br><span class="line">    Word  string   &#x2F;&#x2F; The word that generated the parse error.</span><br><span class="line">    Err error &#x2F;&#x2F; The raw error that precipitated this error, if any.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; String returns a human-readable error message.</span><br><span class="line">func (e *ParseError) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;pkg parse: error parsing %q as int&quot;, e.Word)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Parse parses the space-separated words in in put as integers.</span><br><span class="line">func Parse(input string) (numbers []int, err error) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if r :&#x3D; recover(); r !&#x3D; nil &#123;</span><br><span class="line">            var ok bool</span><br><span class="line">            err, ok &#x3D; r.(error)</span><br><span class="line">            if !ok &#123;</span><br><span class="line">                err &#x3D; fmt.Errorf(&quot;pkg: %v&quot;, r)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fields :&#x3D; strings.Fields(input)</span><br><span class="line">    numbers &#x3D; fields2numbers(fields)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fields2numbers(fields []string) (numbers []int) &#123;</span><br><span class="line">    if len(fields) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">        panic(&quot;no words to parse&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    for idx, field :&#x3D; range fields &#123;</span><br><span class="line">        num, err :&#x3D; strconv.Atoi(field)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            panic(&amp;ParseError&#123;idx, field, err&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        numbers &#x3D; append(numbers, num)</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic_package.go 代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; panic_package.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;.&#x2F;parse&#x2F;parse&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var examples &#x3D; []string&#123;</span><br><span class="line">            &quot;1 2 3 4 5&quot;,</span><br><span class="line">            &quot;100 50 25 12.5 6.25&quot;,</span><br><span class="line">            &quot;2 + 2 &#x3D; 4&quot;,</span><br><span class="line">            &quot;1st class&quot;,</span><br><span class="line">            &quot;&quot;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for _, ex :&#x3D; range examples &#123;</span><br><span class="line">        fmt.Printf(&quot;Parsing %q:\n  &quot;, ex)</span><br><span class="line">        nums, err :&#x3D; parse.Parse(ex)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            fmt.Println(err) &#x2F;&#x2F; here String() method from ParseError is used</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(nums)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Parsing &quot;1 2 3 4 5&quot;:</span><br><span class="line">  [1 2 3 4 5]</span><br><span class="line">Parsing &quot;100 50 25 12.5 6.25&quot;:</span><br><span class="line">  pkg parse: error parsing &quot;12.5&quot; as int</span><br><span class="line">Parsing &quot;2 + 2 &#x3D; 4&quot;:</span><br><span class="line">  pkg parse: error parsing &quot;+&quot; as int</span><br><span class="line">Parsing &quot;1st class&quot;:</span><br><span class="line">  pkg parse: error parsing &quot;1st&quot; as int</span><br><span class="line">Parsing &quot;&quot;:</span><br><span class="line">  pkg: no words to parse</span><br></pre></td></tr></table></figure><h3 id="5、一种用闭包处理错误的模式"><a href="#5、一种用闭包处理错误的模式" class="headerlink" title="5、一种用闭包处理错误的模式"></a>5、一种用闭包处理错误的模式</h3><p>每当函数返回时，我们应该检查是否有错误发生：但是这会导致重复乏味的代码。</p><p>结合 defer/panic/recover 机制和闭包可以得到一个我们马上要讨论的更加优雅的模式。不过这个模式只有当所有的函数都是同一种签名时可用，这样就有相当大的限制。</p><p>一个很好的使用它的例子是 web 应用，所有的处理函数都是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func handler1(w http.ResponseWriter, r *http.Request) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>假设所有的函数都有这样的签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func f(a type1, b type2)</span><br></pre></td></tr></table></figure><p>参数的数量和类型是不相关的。</p><p>我们给这个类型一个名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fType1 &#x3D; func f(a type1, b type2)</span><br></pre></td></tr></table></figure><p>在我们的模式中使用了两个帮助函数：</p><p>1）check：这是用来检查是否有错误和 panic 发生的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func check(err error) &#123; if err !&#x3D; nil &#123; panic(err) &#125; &#125;</span><br></pre></td></tr></table></figure><p>2）errorhandler：这是一个包装函数。接收一个 fType1 类型的函数 fn 并返回一个调用 fn 的函数。里面就包含有 defer/recover 机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func errorHandler(fn fType1) fType1 &#123;</span><br><span class="line">    return func(a type1, b type2) &#123;</span><br><span class="line">        defer func() &#123;</span><br><span class="line">            if err, ok :&#x3D; recover().(error); ok &#123;</span><br><span class="line">                log.Printf(“run time panic: %v”, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        fn(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当错误发生时会 recover 并打印在日志中；除了简单的打印，应用也可以用 template 包为用户生成自定义的输出。check () 函数会在所有的被调函数中调用，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func f1(a type1, b type2) &#123;</span><br><span class="line">    ...</span><br><span class="line">    f, _, err :&#x3D; &#x2F;&#x2F; call function&#x2F;method</span><br><span class="line">    check(err)</span><br><span class="line">    t, err :&#x3D; &#x2F;&#x2F; call function&#x2F;method</span><br><span class="line">    check(err)</span><br><span class="line">    _, err2 :&#x3D; &#x2F;&#x2F; call function&#x2F;method</span><br><span class="line">    check(err2)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种机制，所有的错误都会被 recover，并且调用函数后的错误检查代码也被简化为调用 check (err) 即可。</p><p>在这种模式下，不同的错误处理必须对应不同的函数类型；它们（错误处理）可能被隐藏在错误处理包内部。</p><p>可选的更加通用的方式是用一个空接口类型的切片作为参数和返回值。</p><h3 id="6、启动外部命令和程序"><a href="#6、启动外部命令和程序" class="headerlink" title="6、启动外部命令和程序"></a>6、启动外部命令和程序</h3><p>os 包有一个 StartProcess 函数可以调用或启动外部系统命令和二进制可执行文件；它的第一个参数是要运行的进程，第二个参数用来传递选项或参数，第三个参数是含有系统环境基本信息的结构体。</p><p>这个函数返回被启动进程的 id（pid），或者启动失败返回错误。</p><p>exec 包中也有同样功能的更简单的结构体和函数；主要是 exec.Command(name string, arg …string) 和 Run()。首先需要用系统命令或可执行文件的名字创建一个 Command 对象，然后用这个对象作为接收者调用 Run()。</p><p>下面的程序（因为是执行 Linux 命令，只能在 Linux 下面运行）演示了它们的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 1) os.StartProcess &#x2F;&#x2F;</span><br><span class="line">&#x2F;*********************&#x2F;</span><br><span class="line">&#x2F;* Linux: *&#x2F;</span><br><span class="line">env :&#x3D; os.Environ()</span><br><span class="line">procAttr :&#x3D; &amp;os.ProcAttr&#123;</span><br><span class="line">Env: env,</span><br><span class="line">Files: []*os.File&#123;</span><br><span class="line">os.Stdin,</span><br><span class="line">os.Stdout,</span><br><span class="line">os.Stderr,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1st example: list files</span><br><span class="line">pid, err :&#x3D; os.StartProcess(&quot;&#x2F;bin&#x2F;ls&quot;, []string&#123;&quot;ls&quot;, &quot;-l&quot;&#125;, procAttr)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">fmt.Printf(&quot;Error %v starting process!&quot;, err) &#x2F;&#x2F;</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;The process id is %v&quot;, pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The process id is &amp;&#123;2054 0&#125;total 2056</span><br><span class="line">-rwxr-xr-x 1 ivo ivo 1157555 2011-07-04 16:48 Mieken_exec</span><br><span class="line">-rw-r--r-- 1 ivo ivo    2124 2011-07-04 16:48 Mieken_exec.go</span><br><span class="line">-rw-r--r-- 1 ivo ivo   18528 2011-07-04 16:48 Mieken_exec_go_.6</span><br><span class="line">-rwxr-xr-x 1 ivo ivo  913920 2011-06-03 16:13 panic.exe</span><br><span class="line">-rw-r--r-- 1 ivo ivo     180 2011-04-11 20:39 panic.go</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2nd example: show all processes</span><br><span class="line">pid, err &#x3D; os.StartProcess(&quot;&#x2F;bin&#x2F;ps&quot;, []string&#123;&quot;-e&quot;, &quot;-opid,ppid,comm&quot;&#125;, procAttr)</span><br><span class="line"></span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;Error %v starting process!&quot;, err)  &#x2F;&#x2F;</span><br><span class="line">        os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;The process id is %v&quot;, pid)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 2) exec.Run &#x2F;&#x2F;</span><br><span class="line">&#x2F;***************&#x2F;</span><br><span class="line">&#x2F;&#x2F; Linux:  OK, but not for ls ?</span><br><span class="line">&#x2F;&#x2F; cmd :&#x3D; exec.Command(&quot;ls&quot;, &quot;-l&quot;)  &#x2F;&#x2F; no error, but doesn&#39;t show anything ?</span><br><span class="line">&#x2F;&#x2F; cmd :&#x3D; exec.Command(&quot;ls&quot;)        &#x2F;&#x2F; no error, but doesn&#39;t show anything ?</span><br><span class="line">    cmd :&#x3D; exec.Command(&quot;gedit&quot;)  &#x2F;&#x2F; this opens a gedit-window</span><br><span class="line">    err &#x3D; cmd.Run()</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;Error %v executing command!&quot;, err)</span><br><span class="line">        os.Exit(1)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;The command is %v&quot;, cmd)</span><br><span class="line">&#x2F;&#x2F; The command is &amp;&#123;&#x2F;bin&#x2F;ls [ls -l] []  &lt;nil&gt; &lt;nil&gt; &lt;nil&gt; 0xf840000210 &lt;nil&gt; true [0xf84000ea50 0xf84000e9f0 0xf84000e9c0] [0xf84000ea50 0xf84000e9f0 0xf84000e9c0] [] [] 0xf8400128c0&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; in Windows: uitvoering: Error fork&#x2F;exec &#x2F;bin&#x2F;ls: The system cannot find the path specified. starting process!</span><br></pre></td></tr></table></figure><h3 id="7、Go-中的单元测试和基准测试"><a href="#7、Go-中的单元测试和基准测试" class="headerlink" title="7、Go 中的单元测试和基准测试"></a>7、Go 中的单元测试和基准测试</h3><p>首先所有的包都应该有一定的必要文档，然后同样重要的是对包的测试。</p><p>名为 testing 的包被专门用来进行自动化测试，日志和错误报告。并且还包含一些基准测试函数的功能。</p><p>备注：gotest 是 Unix bash 脚本，所以在 Windows 下你需要配置 MINGW 环境（参见 2.5 节）；在 Windows 环境下把所有的 pkg/linux_amd64 替换成 pkg/windows。</p><p>对一个包做（单元）测试，需要写一些可以频繁（每次更新后）执行的小块测试单元来检查代码的正确性。</p><p>于是我们必须写一些 Go 源文件来测试代码。测试程序必须属于被测试的包，并且文件名满足这种形式 *_test.go，所以测试代码和包中的业务代码是分开的。</p><p>_test 程序不会被普通的 Go 编译器编译，所以当放应用部署到生产环境时它们不会被部署；只有 gotest 会编译所有的程序：普通程序和测试程序。</p><p>测试文件中必须导入 “testing” 包，并写一些名字以 TestZzz 打头的全局函数，这里的 Zzz 是被测试函数的字母描述，如 TestFmtInterface，TestPayEmployees 等。</p><p>测试函数必须有这种形式的头部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func TestAbcde(t *testing.T)</span><br></pre></td></tr></table></figure><p>T 是传给测试函数的结构类型，用来管理测试状态，支持格式化测试日志，如 t.Log，t.Error，t.ErrorF 等。</p><p>在函数的结尾把输出跟想要的结果对比，如果不等就打印一个错误。成功的测试则直接返回。</p><p>用下面这些函数来通知测试失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）func (t *T) Fail()</span><br><span class="line">  标记测试函数为失败，然后继续执行（剩下的测试）。</span><br><span class="line">2）func (t *T) FailNow()</span><br><span class="line">  标记测试函数为失败并中止执行；文件中别的测试也被略过，继续执行下一个文件。</span><br><span class="line">3）func (t *T) Log(args ...interface&#123;&#125;)</span><br><span class="line">  args 被用默认的格式格式化并打印到错误日志中。</span><br><span class="line">4）func (t *T) Fatal(args ...interface&#123;&#125;)</span><br><span class="line">  结合 先执行 3），然后执行 2）的效果。</span><br></pre></td></tr></table></figure><p>运行 go test 来编译测试程序，并执行程序中所有的 TestZZZ 函数。如果所有的测试都通过会打印出 PASS。</p><p>gotest 可以接收一个或多个函数程序作为参数，并指定一些选项。</p><p>结合 –chatty 或 -v 选项，每个执行的测试函数以及测试状态会被打印。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go test fmt_test.go --chatty</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN fmt.TestFlagParser</span><br><span class="line">--- PASS: fmt.TestFlagParser</span><br><span class="line">&#x3D;&#x3D;&#x3D; RUN fmt.TestArrayPrinter</span><br><span class="line">--- PASS: fmt.TestArrayPrinter</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>testing 包中有一些类型和函数可以用来做简单的基准测试；测试代码中必须包含以 BenchmarkZzz 打头的函数并接收一个 *testing.B 类型的参数，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkReverse(b *testing.B) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令 go test –test.bench=.* 会运行所有的基准测试函数。代码中的函数会被调用 N 次（N 是非常大的数，如 N = 1000000），并展示 N 的值和函数执行的平均时间，单位为 ns（纳秒，ns/op）。</p><p>如果是用 testing.Benchmark 调用这些函数，直接运行程序即可。</p><p>测试用例至少应该包括：</p><ul><li>正常的用例</li><li>反面的用例（错误的输入，如用负数或字母代替数字，没有输入等）</li><li>边界检查用例（如果参数的取值范围是 0 到 1000，检查 0 和 1000 的情况）</li></ul><h4 id="测试的具体例子"><a href="#测试的具体例子" class="headerlink" title="测试的具体例子"></a>测试的具体例子</h4><p>even_main.go 的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;even&#x2F;even&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i:&#x3D;0; i&lt;&#x3D;100; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;Is the integer %d even? %v\n&quot;, i, even.Even(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>even/even.go 的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package even</span><br><span class="line"></span><br><span class="line">func Even(i int) bool &#123;     &#x2F;&#x2F; Exported function</span><br><span class="line">    return i%2 &#x3D;&#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Odd(i int) bool &#123;      &#x2F;&#x2F; Exported function</span><br><span class="line">    return i%2 !&#x3D; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>oddeven_test.go 的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package even</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestEven(t *testing.T) &#123;</span><br><span class="line">    if !Even(10) &#123;</span><br><span class="line">        t.Log(&quot; 10 must be even!&quot;)</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">    if Even(7) &#123;</span><br><span class="line">        t.Log(&quot; 7 is not even!&quot;)</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestOdd(t *testing.T) &#123;</span><br><span class="line">    if !Odd(11) &#123;</span><br><span class="line">        t.Log(&quot; 11 must be odd!&quot;)</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">    if Odd(10) &#123;</span><br><span class="line">        t.Log(&quot; 10 is not odd!&quot;)</span><br><span class="line">        t.Fail()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://learnku.com/docs/the-way-to-go">Go 入门指南</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：十二到十三章的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：十二到十三章的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go 入门总结（二）</title>
    <link href="https://www.blog.ajie39.top/2022/05/07/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/05/07/go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-05-07T07:10:19.400Z</published>
    <updated>2022-06-12T06:29:56.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：六到十一章的内容。</h1><hr><span id="more"></span><h2 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h2><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><h4 id="1）特性"><a href="#1）特性" class="headerlink" title="1）特性"></a>1）特性</h4><ul><li>函数是基本的代码块。</li><li>Go 是编译型语言，所以函数编写的顺序是无关紧要的。</li><li>最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。</li><li>DRY 原则：即不要重复你自己（Don’t Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次。</li><li>当函数执行到代码块最后一行（} 之前）或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数。</li><li>函数可以将其他函数调用作为它的参数，只要这个被调用函数的返回值个数、返回值类型和返回值的顺序与调用函数所需求的实参是一致的，例如：f1(f2(a, b))。</li><li>Go不允许函数重载。</li></ul><h4 id="2）不同类型的函数"><a href="#2）不同类型的函数" class="headerlink" title="2）不同类型的函数"></a>2）不同类型的函数</h4><p>Go 里面有三种类型的函数：</p><ul><li>普通的带有名字的函数</li><li>匿名函数或者 lambda 函数</li><li>方法</li></ul><p>除了 main ()、init () 函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为<strong>函数签名</strong>。</p><h4 id="3）语法"><a href="#3）语法" class="headerlink" title="3）语法"></a>3）语法</h4><p>函数基本语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数被调用的基本格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pack1.Function(arg1, arg2, …, argn)</span><br></pre></td></tr></table></figure><p>Function 是 pack1 包里面的一个函数，括号里的是被调用函数的 <strong>实参</strong>（argument）：这些值被传递给被调用函数的 <strong>形参</strong>。函数被调用的时候，这些实参将被复制（简单而言）然后传递给被调用函数。</p><p>函数一般是在其他函数里面被调用的，这个其他函数被称为调用函数（calling function）。函数能多次调用其他函数，这些被调用函数按顺序（简单而言）执行，理论上，函数调用其他函数的次数是无限制的（直到函数调用栈被耗尽）。</p><h4 id="4）方法"><a href="#4）方法" class="headerlink" title="4）方法"></a>4）方法</h4><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><p>Go语言中的 ​​方法（Method）​​ 是一种作用于特定类型变量的函数。这种特定类型变量叫做 ​​接收者（Receiver）​​。接收者的概念就类似于其他语言中的 ​​this​​ 或者 ​​self​​。</p><p>方法的定义格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">  &#x2F;&#x2F; 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在go语言中，没有类的概念但是可以给类型（结构体，自定义类型）定义方法。所谓方法就是定义了接受者的函数，<strong>方法和函数的写法只有一个区别</strong>，那就是 <strong>方法在 func 和标识符之间多了一个参数——接受者定义在func关键字和函数名之间</strong>。</p><p>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</p><p>方法的接收者什么时候适合指向结构体的指针而不是结构体值？</p><p>以C语言为例，我们知道在C中如果对一个指针变量进行修改，那么它的“副本”们也都会被修改。所以在Go中，如果你的方法是需要对结构体本身修改的，请使用指针作为接收器。否则，以值为接收器，改动将无效（类似slice，map特殊结构体）。你的结构体很大，用一个指针传递，会节约资源。为统一起见，如果你的大多方法以指针为接收器，请把其他方法也优先以指针作为接收器，不然调用时可能会提示该方法不属于某结构体的乌龙错误。</p><h4 id="5）函数类型"><a href="#5）函数类型" class="headerlink" title="5）函数类型"></a>5）函数类型</h4><p>函数也可以以申明的方式被使用，作为一个函数类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明 Greeting 函数类型</span><br><span class="line">type Greeting func(name string) string</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义方法</span><br><span class="line">func (g Greeting) say(n string) &#123;</span><br><span class="line">fmt.Println(g(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GO 是类C语言，也就是面向过程语言。<a href="https://go.dev/doc/faq#ancestors">见此</a><br>以C语言为例，它是没有类这种概念的，只有结构体。<br>在C中，编写一个结构体的方法，我们通常采用以下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func(s *Student, id int)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把第一个参数做为该方法的 <strong>“类对象”</strong>，也称为 <strong>接受者</strong>，receiver。<br>而 <strong>Go只是把C语言中的第一个参数放到方法前面</strong> 而已，所以它并不是用来类型转换的，而是一个接收者，<strong>说明该方法属于哪个结构体</strong>。</p><h3 id="2、传递变长参数"><a href="#2、传递变长参数" class="headerlink" title="2、传递变长参数"></a>2、传递变长参数</h3><p>如果函数的最后一个参数是采用 …type 的形式，那么这个函数就可以处理一个变长的参数，这个长度可以为 0，这样的函数称为变长函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func myFunc(a, b, arg ...int) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受一个类似某个类型的 slice 的参数，该参数可以通过 for 循环结构迭代。</p><p>如果参数被存储在一个 slice 类型的变量 slice 中，则可以通过 slice… 的形式来传递参数调用变参函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    x :&#x3D; min(1, 3, 2, 0)</span><br><span class="line">    fmt.Printf(&quot;The minimum is: %d\n&quot;, x)</span><br><span class="line">    slice :&#x3D; []int&#123;7,9,3,5,1&#125;</span><br><span class="line">    x &#x3D; min(slice...)</span><br><span class="line">    fmt.Printf(&quot;The minimum in the slice is: %d&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func min(s ...int) int &#123;</span><br><span class="line">    if len(s)&#x3D;&#x3D;0 &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    min :&#x3D; s[0]</span><br><span class="line">    for _, v :&#x3D; range s &#123;</span><br><span class="line">        if v &lt; min &#123;</span><br><span class="line">            min &#x3D; v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、defer-和追踪"><a href="#3、defer-和追踪" class="headerlink" title="3、defer 和追踪"></a>3、defer 和追踪</h3><p>关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数（为什么要在返回之后才执行这些语句？因为 return 语句同样可以包含一些操作，而不是单纯地返回某个值）。</p><p>关键字 defer 的用法类似于面向对象编程语言 Java 和 C# 的 finally 语句块，它一般用于释放某些已分配的资源。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    function1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func function1() &#123;</span><br><span class="line">    fmt.Printf(&quot;In function1 at the top\n&quot;)</span><br><span class="line">    defer function2()</span><br><span class="line">    fmt.Printf(&quot;In function1 at the bottom!\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func function2() &#123;</span><br><span class="line">    fmt.Printf(&quot;function2: Deferred until the end of the calling function!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">In Function1 at the top</span><br><span class="line">In Function1 at the bottom!</span><br><span class="line">Function2: Deferred until the end of the calling function!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 defer 的语句同样可以接受参数，下面这个例子就会在执行 defer 语句时打印 0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func a() &#123;</span><br><span class="line">    i :&#x3D; 0</span><br><span class="line">    defer fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func f() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">        defer fmt.Printf(&quot;%d &quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">4 3 2 1 0</span><br></pre></td></tr></table></figure><h4 id="1）使用-defer-语句实现代码追踪"><a href="#1）使用-defer-语句实现代码追踪" class="headerlink" title="1）使用 defer 语句实现代码追踪"></a>1）使用 defer 语句实现代码追踪</h4><p>一个基础但十分实用的实现代码执行追踪的方案就是在进入和离开某个函数打印相关的消息，即可以提炼为下面两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func trace(s string) &#123; fmt.Println(&quot;entering:&quot;, s) &#125;</span><br><span class="line">func untrace(s string) &#123; fmt.Println(&quot;leaving:&quot;, s) &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func trace(s string)   &#123; fmt.Println(&quot;entering:&quot;, s) &#125;</span><br><span class="line">func untrace(s string) &#123; fmt.Println(&quot;leaving:&quot;, s) &#125;</span><br><span class="line"></span><br><span class="line">func a() &#123;</span><br><span class="line">    trace(&quot;a&quot;)</span><br><span class="line">    defer untrace(&quot;a&quot;)</span><br><span class="line">    fmt.Println(&quot;in a&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func b() &#123;</span><br><span class="line">    trace(&quot;b&quot;)</span><br><span class="line">    defer untrace(&quot;b&quot;)</span><br><span class="line">    fmt.Println(&quot;in b&quot;)</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）使用-defer-语句来记录函数的参数与返回值"><a href="#2）使用-defer-语句来记录函数的参数与返回值" class="headerlink" title="2）使用 defer 语句来记录函数的参数与返回值"></a>2）使用 defer 语句来记录函数的参数与返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;io&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func func1(s string) (n int, err error) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        log.Printf(&quot;func1(%q) &#x3D; %d, %v&quot;, s, n, err)</span><br><span class="line">    &#125;()</span><br><span class="line">    return 7, io.EOF</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    func1(&quot;Go&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Output: 2011&#x2F;10&#x2F;04 10:46:11 func1(&quot;Go&quot;) &#x3D; 7, EOF</span><br></pre></td></tr></table></figure><h3 id="4、内置函数"><a href="#4、内置函数" class="headerlink" title="4、内置函数"></a>4、内置函数</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>close</td><td>用于管道通信</td></tr><tr><td>len、cap</td><td>len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td></tr><tr><td>new、make</td><td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new (type)、make (type)。new (T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make (T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作 new () 是一个函数，不要忘记它的括号</td></tr><tr><td>copy、append</td><td>用于复制和连接切片</td></tr><tr><td>panic、recover</td><td>两者均用于错误处理机制</td></tr><tr><td>print、println</td><td>底层打印函数，在部署环境中建议使用 fmt 包</td></tr><tr><td>complex、real、imag</td><td>用于创建和操作复数</td></tr></tbody></table><h3 id="5、将函数作为参数"><a href="#5、将函数作为参数" class="headerlink" title="5、将函数作为参数"></a>5、将函数作为参数</h3><p>函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。</p><p>例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    callback(1, Add)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Add(a, b int) &#123;</span><br><span class="line">    fmt.Printf(&quot;The sum of %d and %d is: %d\n&quot;, a, b, a+b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func callback(y int, f func(int, int)) &#123;</span><br><span class="line">    f(y, 2) &#x2F;&#x2F; this becomes Add(1, 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The sum of 1 and 2 is: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、匿名函数（闭包，函数式语言的术语）"><a href="#6、匿名函数（闭包，函数式语言的术语）" class="headerlink" title="6、匿名函数（闭包，函数式语言的术语）"></a>6、匿名函数（闭包，函数式语言的术语）</h3><p>当我们不希望给函数起名字的时候，可以使用匿名函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func(x, y int) int &#123; return x + y &#125;。</span><br><span class="line"></span><br><span class="line">这样的一个函数不能够独立存在（编译器会返回错误：non-declaration statement outside function body），但可以被赋值于某个变量，即保存函数的地址到变量中：</span><br><span class="line"></span><br><span class="line">fplus :&#x3D; func(x, y int) int &#123; return x + y &#125;</span><br><span class="line"></span><br><span class="line">然后通过变量名对函数进行调用：fplus(3,4)。</span><br></pre></td></tr></table></figure><p>当然，也可以直接对匿名函数进行调用：func(x, y int) int { return x + y } (3, 4)。</p><p>具体语法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func() &#123;</span><br><span class="line">    sum :&#x3D; 0</span><br><span class="line">    for i :&#x3D; 1; i &lt;&#x3D; 1e6; i++ &#123;</span><br><span class="line">        sum +&#x3D; i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>表示参数列表的第一对括号必须紧挨着关键字 func，因为匿名函数没有名称。花括号 {} 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。</p><p>具体例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;</span><br><span class="line">func f() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 4; i++ &#123;</span><br><span class="line">        g :&#x3D; func(i int) &#123; fmt.Printf(&quot;%d &quot;, i) &#125; &#x2F;&#x2F;此例子中只是为了演示匿名函数可分配不同的内存地址，在现实开发中，不应该把该部分信息放置到循环中。</span><br><span class="line">        g(i)</span><br><span class="line">        fmt.Printf(&quot; - g is of type %T and has value %v\n&quot;, g, g)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到变量 g 代表的是 func(int)，变量的值是一个内存地址。</p><p>所以我们实际上拥有的是一个函数值：匿名函数可以被赋值给变量并作为值使用。</p><h2 id="二、数组与切片"><a href="#二、数组与切片" class="headerlink" title="二、数组与切片"></a>二、数组与切片</h2><h3 id="1、数组（概念和java相同，略过）"><a href="#1、数组（概念和java相同，略过）" class="headerlink" title="1、数组（概念和java相同，略过）"></a>1、数组（概念和java相同，略过）</h3><p>Go 语言中的数组是一种 值类型（不像 C/C++ 中是指向首元素的指针），所以可以通过 new() 来创建： var arr1 = new([5]int)。</p><p>那么这种方式和 var arr2 [5]int 的区别是什么呢？arr1 的类型是 *[5]int，而 arr2 的类型是 [5]int。</p><p>这样的结果就是当把一个数组赋值给另一个时，需要再做一次数组内存的拷贝操作。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 :&#x3D; *arr1</span><br><span class="line">arr2[2] &#x3D; 100</span><br></pre></td></tr></table></figure><p>这样两个数组就有了不同的值，在赋值后修改 arr2 不会对 arr1 生效。</p><p>所以在函数中数组作为参数传入时，如 func1(arr2)，会产生一次数组拷贝，func1 方法不会修改原始的数组 arr2。</p><p>如果你想修改原数组，那么 arr2 必须通过 &amp; 操作符以引用方式传过来，例如 func1 (&amp;arr2），例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func f(a [3]int) &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">a[0] &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func fp(a *[3]int) &#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">a[0] &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var ar [3]int</span><br><span class="line">f(ar)   &#x2F;&#x2F; passes a copy of ar</span><br><span class="line">fp(&amp;ar) &#x2F;&#x2F; passes a pointer to ar</span><br><span class="line">fmt.Println(ar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1）数组初始化"><a href="#1）数组初始化" class="headerlink" title="1）数组初始化"></a>1）数组初始化</h4><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; var arrAge &#x3D; [5]int&#123;18, 20, 15, 22, 16&#125;</span><br><span class="line">&#x2F;&#x2F; var arrLazy &#x3D; [...]int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="line">&#x2F;&#x2F; var arrLazy &#x3D; []int&#123;5, 6, 7, 8, 22&#125;</span><br><span class="line">var arrKeyValue &#x3D; [5]string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; var arrKeyValue &#x3D; []string&#123;3: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; len(arrKeyValue); i++ &#123;</span><br><span class="line">fmt.Printf(&quot;Person at %d is %s\n&quot;, i, arrKeyValue[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2）将数组传递给函数"><a href="#2）将数组传递给函数" class="headerlink" title="2）将数组传递给函数"></a>2）将数组传递给函数</h4><p>把一个大数组传递给函数会消耗很多内存。有两种方法可以避免这种现象：</p><ul><li>传递数组的指针</li><li>使用数组的切片</li></ul><h5 id="传递数组的指针"><a href="#传递数组的指针" class="headerlink" title="传递数组的指针"></a>传递数组的指针</h5><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">array :&#x3D; [3]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; Sum(&amp;array) &#x2F;&#x2F; Note the explicit address-of operator</span><br><span class="line">&#x2F;&#x2F; to pass a pointer to the array</span><br><span class="line">fmt.Printf(&quot;The sum of the array is: %f&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Sum(a *[3]float64) (sum float64) &#123;</span><br><span class="line">for _, v :&#x3D; range *a &#123; &#x2F;&#x2F; derefencing *a to get back to the array is not necessary!</span><br><span class="line">sum +&#x3D; v</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">The sum of the array is: 24.600000</span><br></pre></td></tr></table></figure><p>但这在 Go 中并不常用，通常使用切片。</p><h5 id="使用数组的切片"><a href="#使用数组的切片" class="headerlink" title="使用数组的切片"></a>使用数组的切片</h5><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">array :&#x3D; [3]float64&#123;7.0, 8.5, 9.1&#125;</span><br><span class="line">x :&#x3D; sum(array[:])</span><br><span class="line">fmt.Printf(&quot;The sum of the array is: %f&quot;, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sum(a []float64) float64 &#123;</span><br><span class="line">s :&#x3D; 0.0</span><br><span class="line">for i :&#x3D; 0; i &lt; len(a); i++ &#123;</span><br><span class="line">s +&#x3D; a[i]</span><br><span class="line">&#125;</span><br><span class="line">return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、切片"><a href="#2、切片" class="headerlink" title="2、切片"></a>2、切片</h3><h4 id="1）概念"><a href="#1）概念" class="headerlink" title="1）概念"></a>1）概念</h4><p>切片（slice）是对数组一个 <strong>连续片段的引用（该数组我们称之为相关数组，通常是匿名的）</strong>，所以 <strong>切片是一个引用类型</strong>（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。</p><p>特点如下所示：</p><ul><li>切片是一个引用类型</li><li>切片是可索引的，并且可以由 len() 函数获取长度。</li><li>给定项的切片索引可能比相关数组的相同元素的索引小。</li><li>和数组不同的是，切片的长度可以在运行时修改，最小为 0 ，最大为相关数组的长度：切片是一个长度可变的数组。</li><li>切片提供了计算容量的函数 cap() 可以测量切片最长可以达到多少：它等于切片从第一个元素开始，到相关数组末尾的元素个数。对于 切片 s 来说该不等式永远成立：0 &lt;= len(s) &lt;= cap(s)。</li><li>多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</li></ul><p>声明切片的格式，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier []type（不需要说明长度）</span><br></pre></td></tr></table></figure><p>一个切片在未初始化之前默认为 nil，长度为 0。</p><p>切片的初始化格式，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var slice1 []type &#x3D; arr1[start:end]</span><br></pre></td></tr></table></figure><p>这表示 slice1 是由数组 arr1 从 start 索引到 end-1 索引之间的元素构成的子集（切分数组，start:end 被称为 slice 表达式）。所以 slice1[0] 就等于 arr1[start]。这可以在 arr1 被填充前就定义好。</p><p>如果某个人写：var slice1 []type = arr1[:] 那么 slice1 就等于完整的 arr1 数组（所以这种表示方式是 arr1[0:len(arr1)] 的一种缩写）。另外一种表述方式是：slice1 = &amp;arr1。</p><p>arr1[2:] 和 arr1[2:len(arr1)] 相同，都包含了数组从第三个到最后的所有元素。</p><p>arr1[:3] 和 arr1[0:3] 相同，包含了从第一个到第三个元素（不包括第四个 / 不包含下标为三的元素）。</p><p>如果你想去掉 slice1 的最后一个元素，只要 slice1 = slice1[:len(slice1)-1]。</p><p>一个由数字 1、2、3 组成的切片可以这么生成：s := [3]int{1,2,3}[:] 甚至更简单的 s := []int{1,2,3}。</p><p>s2 := s[:] 是用切片组成的切片，拥有相同的元素，但是 <strong>仍然指向相同的相关数组</strong>。</p><p>一个切片 s 可以这样扩展到它的大小上限：s = s[:cap(s)]，如果再扩大的话就会导致运行时错误。</p><p>切片也可以用类似数组的方式初始化：var x = []int{2, 3, 5, 7, 11}。这样就创建了一个长度为 5 的数组并且创建了一个相关切片。</p><h4 id="2）切片的内存结构"><a href="#2）切片的内存结构" class="headerlink" title="2）切片的内存结构"></a>2）切片的内存结构</h4><p>切片在内存中的组织方式实际上是一个有 3 个域的结构体：</p><ul><li>指向相关数组的指针</li><li>切片长度：切片的长度就是它所包含的元素个数。</li><li>切片容量：切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</li></ul><p>一个长度为 2，容量为 4 的切片 y，如下所示：</p><p><img src="/img/image/blog/20220604/%E5%88%87%E7%89%87%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="切片内存结构"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[0] &#x3D; 3 且 y[1] &#x3D; 5。</span><br></pre></td></tr></table></figure><p>切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。</p><p>注意: <strong>绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针！！</strong></p><h4 id="3）创建切片"><a href="#3）创建切片" class="headerlink" title="3）创建切片"></a>3）创建切片</h4><p>当相关数组还没有定义时，我们可以使用 make () 函数来创建一个切片 同时创建好相关数组：var slice1 []type = make([]type, len)。</p><p>也可以简写为 slice1 := make([]type, len)，这里 len 是数组的长度并且也是 slice 的初始长度。</p><p>所以定义 s2 := make([]int, 10)，那么 cap(s2) == len(s2) == 10。</p><p>make 接受 2 个参数：元素的类型以及切片的元素个数。</p><p>如果你想创建一个 slice1，它不占用整个数组，而只是占用以 len 为个数个项，那么只要：slice1 := make([]type, len, cap)。</p><p>make 的使用方式是：func make([]T, len, cap)，其中 cap 是可选参数。</p><p>所以下面两种方法可以生成相同的切片:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make([]int, 50, 100)</span><br><span class="line">new([100]int)[0:50]</span><br></pre></td></tr></table></figure><p>使用 make 方法生成的切片的内存结构，如下图所示：</p><p><img src="/img/image/blog/20220604/make%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90%E7%9A%84%E5%88%87%E7%89%87%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="make方法生成的切片的内存结构"></p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var slice1 []int &#x3D; make([]int, 10)</span><br><span class="line">    &#x2F;&#x2F; load the array&#x2F;slice:</span><br><span class="line">    for i :&#x3D; 0; i &lt; len(slice1); i++ &#123;</span><br><span class="line">        slice1[i] &#x3D; 5 * i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; print the slice:</span><br><span class="line">    for i :&#x3D; 0; i &lt; len(slice1); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;Slice at %d is %d\n&quot;, i, slice1[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;\nThe length of slice1 is %d\n&quot;, len(slice1))</span><br><span class="line">    fmt.Printf(&quot;The capacity of slice1 is %d\n&quot;, cap(slice1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4）new-和-make-的区别"><a href="#4）new-和-make-的区别" class="headerlink" title="4）new () 和 make () 的区别"></a>4）new () 和 make () 的区别</h4><p>看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</p><ul><li>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 * T 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体；它相当于 &amp;T{}。</li><li>make(T) 返回一个类型为 T 的初始值，它只适用于 3 种内建的引用类型：切片、map 和 channel。</li></ul><p>换言之，new 函数分配内存，make 函数初始化；下图给出了区别：</p><p><img src="/img/image/blog/20220604/new%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="new和make的区别"></p><h4 id="5）多维切片"><a href="#5）多维切片" class="headerlink" title="5）多维切片"></a>5）多维切片</h4><p>Go语言中同样允许使用多维切片，声明一个多维数组的语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sliceName [][]...[]sliceType</span><br></pre></td></tr></table></figure><p>下面以二维切片为例，声明一个二维切片并赋值，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;声明一个二维切片</span><br><span class="line">var slice [][]int</span><br><span class="line">&#x2F;&#x2F;为二维切片赋值</span><br><span class="line">slice &#x3D; [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125;</span><br><span class="line">上面的代码也可以简写为下面的样子。</span><br><span class="line">&#x2F;&#x2F; 声明一个二维整型切片并赋值</span><br><span class="line">slice :&#x3D; [][]int&#123;&#123;10&#125;, &#123;100, 200&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; 为第一个切片追加值为 20 的元素</span><br><span class="line">slice[0] &#x3D; append(slice[0], 20)</span><br></pre></td></tr></table></figure><h4 id="6）遍历切片"><a href="#6）遍历切片" class="headerlink" title="6）遍历切片"></a>6）遍历切片</h4><p>语法如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ix, value :&#x3D; range slice1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var slice1 []int &#x3D; make([]int, 4)</span><br><span class="line"></span><br><span class="line">    slice1[0] &#x3D; 1</span><br><span class="line">    slice1[1] &#x3D; 2</span><br><span class="line">    slice1[2] &#x3D; 3</span><br><span class="line">    slice1[3] &#x3D; 4</span><br><span class="line"></span><br><span class="line">    for ix, value :&#x3D; range slice1 &#123;</span><br><span class="line">        fmt.Printf(&quot;Slice at %d is: %d\n&quot;, ix, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果你只需要索引，你可以忽略第二个变量</span><br><span class="line">    for ix :&#x3D; range slice1 &#123;</span><br><span class="line">        fmt.Printf(&quot;%d&quot;, ix)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历多维切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for row :&#x3D; range screen &#123;</span><br><span class="line">    for column :&#x3D; range screen[row] &#123;</span><br><span class="line">        screen[row][column] &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7）切片的追加"><a href="#7）切片的追加" class="headerlink" title="7）切片的追加"></a>7）切片的追加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func append(s[]T, x ...T) []T</span><br></pre></td></tr></table></figure><p>其中 append 方法将 0 个或多个具有相同类型 s 的元素追加到切片后面并且返回新的切片；追加的元素必须和原切片的元素同类型。如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。append 方法总是返回成功，除非系统内存耗尽了。</p><p>如果你想将切片 y 追加到切片 x 后面，只要将第二个参数扩展成一个列表即可：x = append(x, y…)。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">sl3 :&#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line">sl3 &#x3D; append(sl3, 4, 5, 6)</span><br><span class="line">fmt.Println(sl3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8）切片的复制"><a href="#8）切片的复制" class="headerlink" title="8）切片的复制"></a>8）切片的复制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func copy(dst, src []T) int</span><br></pre></td></tr></table></figure><p>copy 方法将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数。</p><p>源地址和目标地址可能会有重叠。拷贝个数是 src 和 dst 的长度最小值。如果 src 是字符串那么元素类型就是 byte。如果你还想继续使用 src，在拷贝结束后执行 src = dst。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">sl_from :&#x3D; []int&#123;1, 2, 3&#125;</span><br><span class="line">sl_to :&#x3D; make([]int, 10)</span><br><span class="line"></span><br><span class="line">n :&#x3D; copy(sl_to, sl_from)</span><br><span class="line">fmt.Println(sl_to)</span><br><span class="line">fmt.Printf(&quot;Copied %d elements\n&quot;, n) &#x2F;&#x2F; n &#x3D;&#x3D; 3</span><br><span class="line"></span><br><span class="line">st :&#x3D; &quot;stest&quot;</span><br><span class="line">st_arr :&#x3D; make([]byte, 100)</span><br><span class="line">copy(st_arr, st)</span><br><span class="line"></span><br><span class="line">test :&#x3D; string(st_arr)</span><br><span class="line">fmt.Println(test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、Map"><a href="#三、Map" class="headerlink" title="三、Map"></a>三、Map</h2><p>map 是引用类型，可以使用如下声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map1 map[keytype]valuetype</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">var map1 map[string]int</span><br></pre></td></tr></table></figure><ul><li>在声明的时候不需要知道 map 的长度，map 是可以动态增长的。</li><li>未初始化的 map 的值是 nil。</li><li>key 可以是任意可以用 == 或者！= 操作符比较的类型，比如 string、int、float。</li><li>切片和结构体不能作为 key (译者注：含有数组切片的结构体不能作为 key，只包含内建类型的 struct 是可以作为 key 的，但是指针和接口类型可以。)</li><li>value 可以是任意类型的；通过使用空接口类型，我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言。</li><li>map 传递给函数的代价很小：在 32 位机器上占 4 个字节，64 位机器上占 8 个字节，无论实际上存储了多少数据。</li><li>map 也可以用函数作为自己的值，这样就可以用来做分支结构：key 用来选择要执行的函数。</li></ul><h3 id="1）map初始化"><a href="#1）map初始化" class="headerlink" title="1）map初始化"></a>1）map初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var map1 &#x3D; make(map[keytype]valuetype)</span><br><span class="line"></span><br><span class="line">或者简写为：map1 :&#x3D; make(map[keytype]valuetype)</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">mapCreated :&#x3D; make(map[string]float32)</span><br><span class="line"></span><br><span class="line">相当于：mapCreated :&#x3D; map[string]float32&#123;&#125;。</span><br></pre></td></tr></table></figure><p>注意：<strong>不要使用 new，永远用 make 来构造 map</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果你错误的使用 new () 分配了一个引用对象，你会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：</span><br><span class="line"></span><br><span class="line">mapCreated :&#x3D; new(map[string]float32)</span><br><span class="line"></span><br><span class="line">接下来当我们调用：mapCreated[&quot;key1&quot;] &#x3D; 4.5 的时候，编译器会报错：</span><br><span class="line"></span><br><span class="line">invalid operation: mapCreated[&quot;key1&quot;] (index of type *map[string]float32).</span><br></pre></td></tr></table></figure><h3 id="2）map容量"><a href="#2）map容量" class="headerlink" title="2）map容量"></a>2）map容量</h3><p>和数组不同，map 可以根据新增的 key-value 对动态的伸缩，因此它不存在固定长度或者最大限制。</p><p>但是你也可以选择标明 map 的初始容量 capacity，就像这样：make(map[keytype]valuetype, cap)。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map2 :&#x3D; make(map[string]float32, 100)</span><br></pre></td></tr></table></figure><p>当 map 增长到容量上限的时候，如果再增加新的 key-value 对，map 的大小会自动加 1。所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明</p><h3 id="3）用切片作为-map-的值"><a href="#3）用切片作为-map-的值" class="headerlink" title="3）用切片作为 map 的值"></a>3）用切片作为 map 的值</h3><p>既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理 unix 机器上的所有进程，以父进程（pid 为整型）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为 value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp1 :&#x3D; make(map[int][]int)</span><br><span class="line">mp2 :&#x3D; make(map[int]*[]int)</span><br></pre></td></tr></table></figure><h3 id="4）测试键值对是否存在及删除元素"><a href="#4）测试键值对是否存在及删除元素" class="headerlink" title="4）测试键值对是否存在及删除元素"></a>4）测试键值对是否存在及删除元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val1, isPresent &#x3D; map1[key1]</span><br></pre></td></tr></table></figure><p>isPresent 返回一个 bool 值：如果 key1 存在于 map1，val1 就是 key1 对应的 value 值，并且 isPresent 为 true；如果 key1 不存在，val1 就是一个空值，并且 isPresent 会返回 false。</p><p>如果你只是想判断某个 key 是否存在而不关心它对应的值到底是多少，你可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, ok :&#x3D; map1[key1] &#x2F;&#x2F; 如果key1存在则ok &#x3D;&#x3D; true，否则ok为false</span><br></pre></td></tr></table></figure><p>或者和 if 混合使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if _, ok :&#x3D; map1[key1]; ok &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 map1 中删除 key1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(map1, key1)</span><br></pre></td></tr></table></figure><p>如果 key1 不存在，该操作不会产生错误。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var value int</span><br><span class="line">    var isPresent bool</span><br><span class="line"></span><br><span class="line">    map1 :&#x3D; make(map[string]int)</span><br><span class="line">    map1[&quot;New Delhi&quot;] &#x3D; 55</span><br><span class="line">    map1[&quot;Beijing&quot;] &#x3D; 20</span><br><span class="line">    map1[&quot;Washington&quot;] &#x3D; 25</span><br><span class="line">    value, isPresent &#x3D; map1[&quot;Beijing&quot;]</span><br><span class="line">    if isPresent &#123;</span><br><span class="line">        fmt.Printf(&quot;The value of \&quot;Beijing\&quot; in map1 is: %d\n&quot;, value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Printf(&quot;map1 does not contain Beijing&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value, isPresent &#x3D; map1[&quot;Paris&quot;]</span><br><span class="line">    fmt.Printf(&quot;Is \&quot;Paris\&quot; in map1 ?: %t\n&quot;, isPresent)</span><br><span class="line">    fmt.Printf(&quot;Value is: %d\n&quot;, value)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; delete an item:</span><br><span class="line">    delete(map1, &quot;Washington&quot;)</span><br><span class="line">    value, isPresent &#x3D; map1[&quot;Washington&quot;]</span><br><span class="line">    if isPresent &#123;</span><br><span class="line">        fmt.Printf(&quot;The value of \&quot;Washington\&quot; in map1 is: %d\n&quot;, value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println(&quot;map1 does not contain Washington&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">The value of &quot;Beijing&quot; in map1 is: 20</span><br><span class="line">Is &quot;Paris&quot; in map1 ?: false</span><br><span class="line">Value is: 0</span><br><span class="line">map1 does not contain Washington</span><br></pre></td></tr></table></figure><h3 id="5）for-range-的配套用法"><a href="#5）for-range-的配套用法" class="headerlink" title="5）for-range 的配套用法"></a>5）for-range 的配套用法</h3><p>遍历 map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value :&#x3D; range map1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个返回值 key 是 map 中的 key 值，第二个返回值则是该 key 对应的 value 值；<strong>这两个都是仅 for 循环内部可见的局部变量</strong>。其中第一个返回值 key 值是一个可选元素。如果你只关心值，可以这么使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _, value :&#x3D; range map1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只想获取 key，你可以这么使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key :&#x3D; range map1 &#123;</span><br><span class="line">    fmt.Printf(&quot;key is: %d\n&quot;, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    map1 :&#x3D; make(map[int]float32)</span><br><span class="line">    map1[1] &#x3D; 1.0</span><br><span class="line">    map1[2] &#x3D; 2.0</span><br><span class="line">    map1[3] &#x3D; 3.0</span><br><span class="line">    map1[4] &#x3D; 4.0</span><br><span class="line">    for key, value :&#x3D; range map1 &#123;</span><br><span class="line">        fmt.Printf(&quot;key is: %d - value is: %f\n&quot;, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">key is: 3 - value is: 3.000000</span><br><span class="line">key is: 1 - value is: 1.000000</span><br><span class="line">key is: 4 - value is: 4.000000</span><br><span class="line">key is: 2 - value is: 2.000000</span><br></pre></td></tr></table></figure><p>注意：<strong>map 不是按照 key 的顺序排列的，也不是按照 value 的序排列的。</strong></p><h3 id="6）map-的排序"><a href="#6）map-的排序" class="headerlink" title="6）map 的排序"></a>6）map 的排序</h3><p>map 默认是无序的，不管是按照 key 还是按照 value 默认都不排序。</p><p>如果你想为 map 排序，需要将 key（或者 value）拷贝到一个切片，再对切片排序，然后可以使用切片的 for-range 方法打印出所有的 key 和 value。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    barVal &#x3D; map[string]int&#123;&quot;alpha&quot;: 34, &quot;bravo&quot;: 56, &quot;charlie&quot;: 23,</span><br><span class="line">                            &quot;delta&quot;: 87, &quot;echo&quot;: 56, &quot;foxtrot&quot;: 12,</span><br><span class="line">                            &quot;golf&quot;: 34, &quot;hotel&quot;: 16, &quot;indio&quot;: 87,</span><br><span class="line">                            &quot;juliet&quot;: 65, &quot;kili&quot;: 43, &quot;lima&quot;: 98&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(&quot;unsorted:&quot;)</span><br><span class="line">    for k, v :&#x3D; range barVal &#123;</span><br><span class="line">        fmt.Printf(&quot;Key: %v, Value: %v &#x2F; &quot;, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    keys :&#x3D; make([]string, len(barVal))</span><br><span class="line">    i :&#x3D; 0</span><br><span class="line">    for k, _ :&#x3D; range barVal &#123;</span><br><span class="line">        keys[i] &#x3D; k</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(keys)</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(&quot;sorted:&quot;)</span><br><span class="line">    for _, k :&#x3D; range keys &#123;</span><br><span class="line">        fmt.Printf(&quot;Key: %v, Value: %v &#x2F; &quot;, k, barVal[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">unsorted:</span><br><span class="line">Key: bravo, Value: 56 &#x2F; Key: echo, Value: 56 &#x2F; Key: indio, Value: 87 &#x2F; Key: juliet, Value: 65 &#x2F; Key: alpha, Value: 34 &#x2F; Key: charlie, Value: 23 &#x2F; Key: delta, Value: 87 &#x2F; Key: foxtrot, Value: 12 &#x2F; Key: golf, Value: 34 &#x2F; Key: hotel, Value: 16 &#x2F; Key: kili, Value: 43 &#x2F; Key: lima, Value: 98 &#x2F;</span><br><span class="line">sorted:</span><br><span class="line">Key: alpha, Value: 34 &#x2F; Key: bravo, Value: 56 &#x2F; Key: charlie, Value: 23 &#x2F; Key: delta, Value: 87 &#x2F; Key: echo, Value: 56 &#x2F; Key: foxtrot, Value: 12 &#x2F; Key: golf, Value: 34 &#x2F; Key: hotel, Value: 16 &#x2F; Key: indio, Value: 87 &#x2F; Key: juliet, Value: 65 &#x2F; Key: kili, Value: 43 &#x2F; Key: lima, Value: 98 &#x2F;</span><br></pre></td></tr></table></figure><h3 id="7）map-类型的切片"><a href="#7）map-类型的切片" class="headerlink" title="7）map 类型的切片"></a>7）map 类型的切片</h3><p>假设我们想获取一个 map 类型的切片，我们必须使用两次 make() 函数，第一次分配切片，第二次分配 切片中每个 map 元素。例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; Version A:</span><br><span class="line">    items :&#x3D; make([]map[int]int, 5)</span><br><span class="line">    for i:&#x3D; range items &#123;</span><br><span class="line">        items[i] &#x3D; make(map[int]int, 1)</span><br><span class="line">        items[i][1] &#x3D; 2</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;Version A: Value of items: %v\n&quot;, items)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Version B: NOT GOOD!</span><br><span class="line">    items2 :&#x3D; make([]map[int]int, 5)</span><br><span class="line">    for _, item :&#x3D; range items2 &#123;</span><br><span class="line">        item &#x3D; make(map[int]int, 1) &#x2F;&#x2F; item 只是切片元素的副本。</span><br><span class="line">        item[1] &#x3D; 2 &#x2F;&#x2F; 这个“项目”将在下一次迭代中丢失。</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;Version B: Value of items: %v\n&quot;, items2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、结构体"><a href="#四、结构体" class="headerlink" title="四、结构体"></a>四、结构体</h2><p>结构体定义的一般方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type identifier struct &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 new 创建一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">var t *T &#x3D; new(T)</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">var t *T</span><br><span class="line">t &#x3D; new(T)</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">t :&#x3D; new(T)</span><br></pre></td></tr></table></figure><p>上面的语句表示，变量 t 是一个指向 T 的指针，此时结构体字段的值是它们所属类型的零值。</p><p>声明 var t T 也会给 t 分配内存，并零值化内存，但是这个时候 t 是类型 T。在这几种方式中，t 通常被称做类型 T 的一个实例（instance）或对象（object）。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type struct1 struct &#123;</span><br><span class="line">    i1  int</span><br><span class="line">    f1  float32</span><br><span class="line">    str string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    ms :&#x3D; new(struct1)</span><br><span class="line">    ms.i1 &#x3D; 10</span><br><span class="line">    ms.f1 &#x3D; 15.5</span><br><span class="line">    ms.str&#x3D; &quot;Chris&quot;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;The int is: %d\n&quot;, ms.i1)</span><br><span class="line">    fmt.Printf(&quot;The float is: %f\n&quot;, ms.f1)</span><br><span class="line">    fmt.Printf(&quot;The string is: %s\n&quot;, ms.str)</span><br><span class="line">    fmt.Println(ms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The int is: 10</span><br><span class="line">The float is: 15.500000</span><br><span class="line">The string is: Chris</span><br><span class="line">&amp;&#123;10 15.5 Chris&#125;</span><br></pre></td></tr></table></figure><p>就像在面向对象语言所作的那样，可以使用点号符给字段赋值：structname.fieldname = value。</p><p>同样的，使用点号符可以获取结构体字段的值：structname.fieldname。</p><p>在 Go 语言中这叫 选择器（selector）。无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的 <strong>选择器符（selector-notation）</strong> 来引用结构体的字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type myStruct struct &#123; i int &#125;</span><br><span class="line">var v myStruct    &#x2F;&#x2F; v是结构体类型变量</span><br><span class="line">var p *myStruct   &#x2F;&#x2F; p是指向一个结构体类型变量的指针</span><br><span class="line">v.i</span><br><span class="line">p.i</span><br></pre></td></tr></table></figure><h3 id="1）初始化一个结构体"><a href="#1）初始化一个结构体" class="headerlink" title="1）初始化一个结构体"></a>1）初始化一个结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 此时ms的类型是 *struct1</span><br><span class="line">ms :&#x3D; &amp;struct1&#123;10, 15.5, &quot;Chris&quot;&#125;</span><br><span class="line"></span><br><span class="line">var ms struct1</span><br><span class="line">ms &#x3D; struct1&#123;10, 15.5, &quot;Chris&quot;&#125;</span><br></pre></td></tr></table></figure><p>混合字面量语法（composite literal syntax）&amp;struct1{a, b, c} 是一种简写，底层仍然会调用 new ()，这里值的顺序必须按照字段顺序来写。</p><p>表达式 new(Type) 和 &amp;Type{} 是等价的。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Interval struct &#123;</span><br><span class="line">    start int</span><br><span class="line">    end   int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">初始化方式：</span><br><span class="line"></span><br><span class="line">intr :&#x3D; Interval&#123;0, 3&#125;            (A)</span><br><span class="line">intr :&#x3D; Interval&#123;end:5, start:1&#125;  (B)</span><br><span class="line">intr :&#x3D; Interval&#123;end:5&#125;           (C)</span><br></pre></td></tr></table></figure><h3 id="2）结构体类型的内存布局"><a href="#2）结构体类型的内存布局" class="headerlink" title="2）结构体类型的内存布局"></a>2）结构体类型的内存布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Point struct &#123; x, y int &#125;</span><br></pre></td></tr></table></figure><p>使用 new 初始化：</p><p><img src="/img/image/blog/20220604/%E4%BD%BF%E7%94%A8new%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="使用new初始化"></p><p>作为结构体字面量初始化：</p><p><img src="/img/image/blog/20220604/%E4%BD%9C%E4%B8%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="作为结构体字面量初始化"></p><h4 id="3）三种不同的调用方式"><a href="#3）三种不同的调用方式" class="headerlink" title="3）三种不同的调用方式"></a>3）三种不同的调用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    firstName   string</span><br><span class="line">    lastName    string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func upPerson(p *Person) &#123;</span><br><span class="line">    p.firstName &#x3D; strings.ToUpper(p.firstName)</span><br><span class="line">    p.lastName &#x3D; strings.ToUpper(p.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1-struct as a value type:</span><br><span class="line">    var pers1 Person</span><br><span class="line">    pers1.firstName &#x3D; &quot;Chris&quot;</span><br><span class="line">    pers1.lastName &#x3D; &quot;Woodward&quot;</span><br><span class="line">    upPerson(&amp;pers1)</span><br><span class="line">    fmt.Printf(&quot;The name of the person is %s %s\n&quot;, pers1.firstName, pers1.lastName)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2—struct as a pointer:</span><br><span class="line">    pers2 :&#x3D; new(Person)</span><br><span class="line">    pers2.firstName &#x3D; &quot;Chris&quot;</span><br><span class="line">    pers2.lastName &#x3D; &quot;Woodward&quot;</span><br><span class="line">    (*pers2).lastName &#x3D; &quot;Woodward&quot;  &#x2F;&#x2F; 这是合法的</span><br><span class="line">    upPerson(pers2)</span><br><span class="line">    fmt.Printf(&quot;The name of the person is %s %s\n&quot;, pers2.firstName, pers2.lastName)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3—struct as a literal:</span><br><span class="line">    pers3 :&#x3D; &amp;Person&#123;&quot;Chris&quot;,&quot;Woodward&quot;&#125;</span><br><span class="line">    upPerson(pers3)</span><br><span class="line">    fmt.Printf(&quot;The name of the person is %s %s\n&quot;, pers3.firstName, pers3.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line"></span><br><span class="line">The name of the person is CHRIS WOODWARD</span><br><span class="line">The name of the person is CHRIS WOODWARD</span><br><span class="line">The name of the person is CHRIS WOODWARD</span><br></pre></td></tr></table></figure><h3 id="4）结构体转换"><a href="#4）结构体转换" class="headerlink" title="4）结构体转换"></a>4）结构体转换</h3><p>Go 中的类型转换遵循严格的规则。当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型，它们可以互相转换，同时需要注意其中非法赋值或转换引起的编译错误。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type number struct &#123;</span><br><span class="line">    f float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type nr number   &#x2F;&#x2F; alias type</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a :&#x3D; number&#123;5.0&#125;</span><br><span class="line">    b :&#x3D; nr&#123;5.0&#125;</span><br><span class="line">    &#x2F;&#x2F; var i float32 &#x3D; b   &#x2F;&#x2F; compile-error: cannot use b (type nr) as type float32 in assignment</span><br><span class="line">    &#x2F;&#x2F; var i &#x3D; float32(b)  &#x2F;&#x2F; compile-error: cannot convert b (type nr) to type float32</span><br><span class="line">    &#x2F;&#x2F; var c number &#x3D; b    &#x2F;&#x2F; compile-error: cannot use b (type nr) as type number in assignment</span><br><span class="line">    &#x2F;&#x2F; needs a conversion:</span><br><span class="line">    var c &#x3D; number(b)</span><br><span class="line">    fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">&#123;5&#125; &#123;5&#125; &#123;5&#125;</span><br></pre></td></tr></table></figure><h3 id="5）使用工厂方法创建结构体实例"><a href="#5）使用工厂方法创建结构体实例" class="headerlink" title="5）使用工厂方法创建结构体实例"></a>5）使用工厂方法创建结构体实例</h3><p>Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂” 方法。为了方便通常会为类型定义一个工厂，按惯例，工厂的名字以 new 或 New 开头。假设定义了如下的 File 结构体类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type File struct &#123;</span><br><span class="line">    fd      int     &#x2F;&#x2F; 文件描述符</span><br><span class="line">    name    string  &#x2F;&#x2F; 文件名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是这个结构体类型对应的工厂方法，它返回一个指向结构体实例的指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func NewFile(fd int, name string) *File &#123;</span><br><span class="line">    if fd &lt; 0 &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &amp;File&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这样调用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f :&#x3D; NewFile(10, &quot;.&#x2F;test.txt&quot;)</span><br></pre></td></tr></table></figure><p>在 Go 语言中常常像上面这样在工厂方法里使用初始化来简便的实现构造函数。</p><p>如果 File 是一个结构体类型，那么表达式 new(File) 和 &amp;File{} 是等价的。</p><p>我们可以说是工厂实例化了类型的一个对象，就像在基于类的 OOP 语言中那样。</p><p>如果想知道结构体类型 T 的一个实例占用了多少内存，可以使用：size := unsafe.Sizeof(T{})。</p><h3 id="5）如何强制使用工厂方法"><a href="#5）如何强制使用工厂方法" class="headerlink" title="5）如何强制使用工厂方法"></a>5）如何强制使用工厂方法</h3><p>通过应用可见性规则就可以禁止使用 new 函数，强制用户使用工厂方法，从而使类型变成私有的，就像在面向对象语言中那样。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package factory</span><br><span class="line"></span><br><span class="line">type matrix struct &#123;</span><br><span class="line">id   int</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewMatrix(id int, name string) *matrix &#123;</span><br><span class="line">m :&#x3D; matrix&#123;id, name&#125;</span><br><span class="line">return &amp;m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在其他包里使用工厂方法：</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;test1&#x2F;main&#x2F;factory&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F;wrong :&#x3D; new(matrix.matrix)     &#x2F;&#x2F; 编译失败（matrix 是私有的）</span><br><span class="line">right :&#x3D; factory.NewMatrix(1, &quot;tst&quot;) &#x2F;&#x2F; 实例化 matrix 的唯一方式</span><br><span class="line"></span><br><span class="line">fmt.Println(right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面的例子说明了在映射上使用 new 和 make 的区别以及可能发生的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Foo map[string]string</span><br><span class="line">type Bar struct &#123;</span><br><span class="line">    thingOne string</span><br><span class="line">    thingTwo int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; OK</span><br><span class="line">    y :&#x3D; new(Bar)</span><br><span class="line">    (*y).thingOne &#x3D; &quot;hello&quot;</span><br><span class="line">    (*y).thingTwo &#x3D; 1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; NOT OK</span><br><span class="line">    z :&#x3D; make(Bar) &#x2F;&#x2F; 编译错误：cannot make type Bar</span><br><span class="line">    (*z).thingOne &#x3D; &quot;hello&quot;</span><br><span class="line">    (*z).thingTwo &#x3D; 1</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; OK</span><br><span class="line">    x :&#x3D; make(Foo)</span><br><span class="line">    x[&quot;x&quot;] &#x3D; &quot;goodbye&quot;</span><br><span class="line">    x[&quot;y&quot;] &#x3D; &quot;world&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; NOT OK</span><br><span class="line">    u :&#x3D; new(Foo)</span><br><span class="line">    (*u)[&quot;x&quot;] &#x3D; &quot;goodbye&quot; &#x2F;&#x2F; 运行时错误!! panic: assignment to entry in nil map</span><br><span class="line">    (*u)[&quot;y&quot;] &#x3D; &quot;world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试图 make() 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 new() 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 new(Foo) 返回的是一个指向 nil 的指针，它尚未被分配内存。所以在使用 map 时要特别谨慎。</p><h3 id="6）带标签的结构体"><a href="#6）带标签的结构体" class="headerlink" title="6）带标签的结构体"></a>6）带标签的结构体</h3><p>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 reflect 能获取它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type TagType struct &#123; &#x2F;&#x2F; tags</span><br><span class="line">    field1 bool   &quot;An important answer&quot;</span><br><span class="line">    field2 string &quot;The name of the thing&quot;</span><br><span class="line">    field3 int    &quot;How much there are&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    tt :&#x3D; TagType&#123;true, &quot;Barak Obama&quot;, 1&#125;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 3; i++ &#123;</span><br><span class="line">        refTag(tt, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func refTag(tt TagType, ix int) &#123;</span><br><span class="line">    ttType :&#x3D; reflect.TypeOf(tt)</span><br><span class="line">    ixField :&#x3D; ttType.Field(ix)</span><br><span class="line">    fmt.Printf(&quot;%v\n&quot;, ixField.Tag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">An important answer</span><br><span class="line">The name of the thing</span><br><span class="line">How much there are</span><br></pre></td></tr></table></figure><h3 id="7）匿名字段和内嵌结构体"><a href="#7）匿名字段和内嵌结构体" class="headerlink" title="7）匿名字段和内嵌结构体"></a>7）匿名字段和内嵌结构体</h3><p>结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type innerS struct &#123;</span><br><span class="line">in1 int</span><br><span class="line">in2 int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type outerS struct &#123;</span><br><span class="line">b      int</span><br><span class="line">c      float32</span><br><span class="line">int    &#x2F;&#x2F; anonymous field</span><br><span class="line">innerS &#x2F;&#x2F;anonymous field</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">outer :&#x3D; new(outerS)</span><br><span class="line">outer.b &#x3D; 6</span><br><span class="line">outer.c &#x3D; 7.5</span><br><span class="line">outer.int &#x3D; 60</span><br><span class="line">outer.in1 &#x3D; 5</span><br><span class="line">outer.in2 &#x3D; 10</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;outer.b is: %d\n&quot;, outer.b)</span><br><span class="line">fmt.Printf(&quot;outer.c is: %f\n&quot;, outer.c)</span><br><span class="line">fmt.Printf(&quot;outer.int is: %d\n&quot;, outer.int)</span><br><span class="line">fmt.Printf(&quot;outer.in1 is: %d\n&quot;, outer.in1)</span><br><span class="line">fmt.Printf(&quot;outer.in2 is: %d\n&quot;, outer.in2)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用结构体字面量</span><br><span class="line">outer2 :&#x3D; outerS&#123;6, 7.5, 60, innerS&#123;5, 10&#125;&#125;</span><br><span class="line">fmt.Println(&quot;outer2 is:&quot;, outer2)</span><br><span class="line">fmt.Println(&quot;outer2.innerS is:&quot;, outer2.innerS)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">outer.b is: 6</span><br><span class="line">outer.c is: 7.500000</span><br><span class="line">outer.int is: 60</span><br><span class="line">outer.in1 is: 5</span><br><span class="line">outer.in2 is: 10</span><br><span class="line">outer2 is: &#123;6 7.5 60 &#123;5 10&#125;&#125;</span><br><span class="line">outer2.innerS is: &#123;5 10&#125;</span><br></pre></td></tr></table></figure><p>通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：<strong>在一个结构体中对于每一种数据类型只能有一个匿名字段。</strong></p><h3 id="8）命名冲突"><a href="#8）命名冲突" class="headerlink" title="8）命名冲突"></a>8）命名冲突</h3><p>当两个字段拥有相同的名字（可能是继承来的名字）时该怎么办呢？</p><ul><li>外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；</li><li>如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。</li></ul><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type A struct&#123; a int &#125;</span><br><span class="line">type B struct&#123; a, b int &#125;</span><br><span class="line">type D struct &#123;</span><br><span class="line">B</span><br><span class="line">b int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type C struct &#123;</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c :&#x3D; C&#123;A&#123;1&#125;, B&#123;2, 3&#125;&#125;</span><br><span class="line">&#x2F;&#x2F;fmt.Println(c.a) &#x2F;&#x2F; ambiguous selector c.a 编译错误</span><br><span class="line">fmt.Println(c.A.a)</span><br><span class="line">d :&#x3D; D&#123;B&#123;1, 3&#125;, 2&#125;</span><br><span class="line">fmt.Println(d.b) &#x2F;&#x2F; 这个是允许的，会加载 D.b</span><br><span class="line">fmt.Println(d.B.b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h2><p>Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。</p><p>定义方法的一般格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (recv receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">recv 就像是面向对象语言中的 this 或 self，但是 Go 中并没有这两个关键字。随个人喜好，你可以使用 this 或 self 作为 receiver 的名字。</span><br></pre></td></tr></table></figure><p>接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。</p><p>但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：invalid receiver type…。</p><p>最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。</p><p><strong>一个类型加上它的方法等价于面向对象中的一个类。</strong></p><p>一个重要的区别是：在 Go 中，<strong>类型的代码</strong> 和绑定在它上面的 <strong>方法的代码</strong> 可以不放置在一起，它们 <strong>可以存在在不同的源文件</strong>，唯一的要求是： <strong>它们必须是同一个包的。</strong></p><p>因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (a *denseMatrix) Add(b Matrix) Matrix</span><br><span class="line">func (a *sparseMatrix) Add(b Matrix) Matrix</span><br></pre></td></tr></table></figure><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type TwoInts struct &#123;</span><br><span class="line">a int</span><br><span class="line">b int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AddThem 结构体上的简单方法的例子</span><br><span class="line">func (tn *TwoInts) AddThem() int &#123;</span><br><span class="line">return tn.a + tn.b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AddToParam 结构体上的简单方法的例子</span><br><span class="line">func (tn *TwoInts) AddToParam(param int) int &#123;</span><br><span class="line">return tn.a + tn.b + param</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IntVector []int</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Sum 非结构体类型上方法的例子</span><br><span class="line">func (v IntVector) Sum() (s int) &#123;</span><br><span class="line">for _, x :&#x3D; range v &#123;</span><br><span class="line">s +&#x3D; x</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">two1 :&#x3D; new(TwoInts)</span><br><span class="line">two1.a &#x3D; 12</span><br><span class="line">two1.b &#x3D; 10</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;The sum is: %d\n&quot;, two1.AddThem())</span><br><span class="line">fmt.Printf(&quot;Add them to the param: %d\n&quot;, two1.AddToParam(20))</span><br><span class="line"></span><br><span class="line">two2 :&#x3D; TwoInts&#123;3, 4&#125;</span><br><span class="line">fmt.Printf(&quot;The sum is: %d\n&quot;, two2.AddThem())</span><br><span class="line"></span><br><span class="line">fmt.Println(IntVector&#123;1, 2, 3&#125;.Sum()) &#x2F;&#x2F; 输出是6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;container&#x2F;list&quot;</span><br><span class="line"></span><br><span class="line">func (p *list.List) Iter() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    lst :&#x3D; new(list.List)</span><br><span class="line">    for _&#x3D; range lst.Iter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译错误：cannot define new methods on non-local type list.List</span><br></pre></td></tr></table></figure><p><strong>类型和作用在它上面定义的方法必须在同一个包里定义，这就是为什么不能在 int、float 或类似这些的类型上定义方法。</strong></p><p>但是有一个间接的方式：可以先定义该类型（比如：int 或 float）的别名类型，然后再为别名类型定义方法。或者像下面这样将它作为匿名类型嵌入在一个新的结构体中。当然方法只在这个别名类型上有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type myTime struct &#123;</span><br><span class="line">time.Time &#x2F;&#x2F;anonymous field</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t myTime) first3Chars() string &#123;</span><br><span class="line">return t.Time.String()[0:3]</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">m :&#x3D; myTime&#123;time.Now()&#125;</span><br><span class="line">&#x2F;&#x2F; 调用匿名Time上的String方法</span><br><span class="line">fmt.Println(&quot;Full time now:&quot;, m.String())</span><br><span class="line">&#x2F;&#x2F; 调用myTime.first3Chars</span><br><span class="line">fmt.Println(&quot;First 3 chars:&quot;, m.first3Chars())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Full time now: 2022-06-09 14:09:56.3957554 +0800 CST m&#x3D;+0.025340201</span><br><span class="line">First 3 chars: 202</span><br></pre></td></tr></table></figure><h3 id="1）函数和方法的区别"><a href="#1）函数和方法的区别" class="headerlink" title="1）函数和方法的区别"></a>1）函数和方法的区别</h3><p>函数将变量作为参数：Function1(recv)</p><p>方法在变量上被调用：recv.Method1()</p><p>在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。</p><p>不要忘记 Method1 后边的括号 ()，否则会引发编译器错误：method recv.Method1 is not an expression, must be called</p><p>接收者必须有一个显式的名字，这个名字必须在方法中被使用。</p><p>receiver_type 叫做 （接收者）基本类型，这个类型必须在和方法同样的包中被声明。</p><p>在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。</p><p>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</p><h3 id="2）指针或值作为接收者"><a href="#2）指针或值作为接收者" class="headerlink" title="2）指针或值作为接收者"></a>2）指针或值作为接收者</h3><p>鉴于性能的原因，recv 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。</p><p>如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type B struct &#123;</span><br><span class="line">    thing int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *B) change() &#123; b.thing &#x3D; 1 &#125;</span><br><span class="line"></span><br><span class="line">func (b B) write() string &#123; return fmt.Sprint(b) &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var b1 B &#x2F;&#x2F; b1是值</span><br><span class="line">    b1.change()</span><br><span class="line">    fmt.Println(b1.write())</span><br><span class="line"></span><br><span class="line">    b2 :&#x3D; new(B) &#x2F;&#x2F; b2是指针</span><br><span class="line">    b2.change()</span><br><span class="line">    fmt.Println(b2.write())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&#123;1&#125;</span><br><span class="line">&#123;1&#125;</span><br></pre></td></tr></table></figure><p>指针方法和值方法都可以在指针或非指针上被调用。</p><p>如下面程序所示，类型 List 在值上有一个方法 Len()，在指针上有一个方法 Append()，但是可以看到两个方法都可以在两种类型的变量上被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type List []int</span><br><span class="line"></span><br><span class="line">func (l List) Len() int        &#123; return len(l) &#125;</span><br><span class="line">func (l *List) Append(val int) &#123; *l &#x3D; append(*l, val) &#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 值</span><br><span class="line">    var lst List</span><br><span class="line">    lst.Append(1)</span><br><span class="line">    fmt.Printf(&quot;%v (len: %d)&quot;, lst, lst.Len()) &#x2F;&#x2F; [1] (len: 1)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指针</span><br><span class="line">    plst :&#x3D; new(List)</span><br><span class="line">    plst.Append(2)</span><br><span class="line">    fmt.Printf(&quot;%v (len: %d)&quot;, plst, plst.Len()) &#x2F;&#x2F; &amp;[2] (len: 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）方法和未导出字段"><a href="#3）方法和未导出字段" class="headerlink" title="3）方法和未导出字段"></a>3）方法和未导出字段</h3><p>如果类型 Person 被明确的导出了，但是它的字段没有被导出。则 p.firstName 就是错误的。该如何在另一个程序中修改或者只是读取一个 Person 的名字呢？</p><p>这可以通过面向对象语言一个众所周知的技术来完成：提供 getter 和 setter 方法。对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名。</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package person</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    firstName string</span><br><span class="line">    lastName  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) FirstName() string &#123;</span><br><span class="line">    return p.firstName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) SetFirstName(newName string) &#123;</span><br><span class="line">    p.firstName &#x3D; newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;.&#x2F;person&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    p :&#x3D; new(person.Person)</span><br><span class="line">    &#x2F;&#x2F; p.firstName undefined</span><br><span class="line">    &#x2F;&#x2F; (cannot refer to unexported field or method firstName)</span><br><span class="line">    &#x2F;&#x2F; p.firstName &#x3D; &quot;Eric&quot;</span><br><span class="line">    p.SetFirstName(&quot;Eric&quot;)</span><br><span class="line">    fmt.Println(p.FirstName()) &#x2F;&#x2F; Output: Eric</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）内嵌类型的方法和继承"><a href="#4）内嵌类型的方法和继承" class="headerlink" title="4）内嵌类型的方法和继承"></a>4）内嵌类型的方法和继承</h3><p>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 继承 了这些方法：将父类型放在子类型中来实现亚型。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果，也类似 Ruby 中的混入（mixin）。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Point struct &#123;</span><br><span class="line">    x, y float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Point) Abs() float64 &#123;</span><br><span class="line">    return math.Sqrt(p.x*p.x + p.y*p.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type NamedPoint struct &#123;</span><br><span class="line">    Point</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    n :&#x3D; &amp;NamedPoint&#123;Point&#123;3, 4&#125;, &quot;Pythagoras&quot;&#125;</span><br><span class="line">    fmt.Println(n.Abs()) &#x2F;&#x2F; 打印5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法 “晋升” 成为了外层类型的方法。</p><p>当然类型可以有只作用于本身实例而不作用于内嵌 “父” 类型上的方法，可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。</p><p>基于上面的代码，加上如下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (n *NamedPoint) Abs() float64 &#123;</span><br><span class="line">    return n.Point.Abs() * 100.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在 fmt.Println(n.Abs()) 会打印 500。</span><br></pre></td></tr></table></figure><p><strong>结构体内嵌和自己在同一个包中的结构体时，可以彼此访问对方所有的字段和方法。</strong></p><h3 id="5）如何在类型中嵌入功能"><a href="#5）如何在类型中嵌入功能" class="headerlink" title="5）如何在类型中嵌入功能"></a>5）如何在类型中嵌入功能</h3><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Log struct &#123;</span><br><span class="line">msg string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Customer struct &#123;</span><br><span class="line">Name string</span><br><span class="line">log  *Log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; shorter</span><br><span class="line">c :&#x3D; &amp;Customer&#123;&quot;Barak Obama&quot;, &amp;Log&#123;&quot;1 - Yes we can!&quot;&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; fmt.Println(c) &amp;&#123;Barak Obama 1 - Yes we can!&#125;</span><br><span class="line">c.Log().Add(&quot;2 - After me the world will be a better place!&quot;)</span><br><span class="line">&#x2F;&#x2F;fmt.Println(c.log)</span><br><span class="line">fmt.Println(c.Log())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *Log) Add(s string) &#123;</span><br><span class="line">l.msg +&#x3D; &quot;\n&quot; + s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *Log) String() string &#123;</span><br><span class="line">return l.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *Customer) Log() *Log &#123;</span><br><span class="line">return c.log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">1 - Yes we can!</span><br><span class="line">2 - After me the world will be a better place!</span><br></pre></td></tr></table></figure><h3 id="6）多重继承"><a href="#6）多重继承" class="headerlink" title="6）多重继承"></a>6）多重继承</h3><p>多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++ 和 Python 例外）。</p><p>因为在类继承层次中，多重继承会给编译器引入额外的复杂度。</p><p>但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。</p><p>作为一个例子，假设有一个类型 CameraPhone，通过它可以 Call()，也可以 TakeAPicture()，但是第一个方法属于类型 Phone，第二个方法属于类型 Camera。</p><p>只要嵌入这两个类型就可以解决问题，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Camera struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (c *Camera) TakeAPicture() string &#123;</span><br><span class="line">    return &quot;Click&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Phone struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (p *Phone) Call() string &#123;</span><br><span class="line">    return &quot;Ring Ring&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type CameraPhone struct &#123;</span><br><span class="line">    Camera</span><br><span class="line">    Phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    cp :&#x3D; new(CameraPhone)</span><br><span class="line">    fmt.Println(&quot;Our new CameraPhone exhibits multiple behaviors...&quot;)</span><br><span class="line">    fmt.Println(&quot;It exhibits behavior of a Camera: &quot;, cp.TakeAPicture())</span><br><span class="line">    fmt.Println(&quot;It works like a Phone too: &quot;, cp.Call())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Our new CameraPhone exhibits multiple behaviors...</span><br><span class="line">It exhibits behavior of a Camera:  Click</span><br><span class="line">It works like a Phone too:  Ring Ring</span><br></pre></td></tr></table></figure><h3 id="7）类型的-String-方法和格式化描述符"><a href="#7）类型的-String-方法和格式化描述符" class="headerlink" title="7）类型的 String() 方法和格式化描述符"></a>7）类型的 String() 方法和格式化描述符</h3><p>如果类型定义了 String() 方法，它会被用在 fmt.Printf() 中生成默认的输出：等同于使用格式化描述符 %v 产生的输出。还有 fmt.Print() 和 fmt.Println() 也会自动使用 String() 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type TwoInts struct &#123;</span><br><span class="line">    a int</span><br><span class="line">    b int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    two1 :&#x3D; new(TwoInts)</span><br><span class="line">    two1.a &#x3D; 12</span><br><span class="line">    two1.b &#x3D; 10</span><br><span class="line">    fmt.Printf(&quot;two1 is: %v\n&quot;, two1)</span><br><span class="line">    fmt.Println(&quot;two1 is:&quot;, two1)</span><br><span class="line">    fmt.Printf(&quot;two1 is: %T\n&quot;, two1)</span><br><span class="line">    fmt.Printf(&quot;two1 is: %#v\n&quot;, two1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (tn *TwoInts) String() string &#123;</span><br><span class="line">    return &quot;(&quot; + strconv.Itoa(tn.a) + &quot;&#x2F;&quot; + strconv.Itoa(tn.b) + &quot;)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">two1 is: (12&#x2F;10)</span><br><span class="line">two1 is: (12&#x2F;10)</span><br><span class="line">two1 is: *main.TwoInts</span><br><span class="line">two1 is: &amp;main.TwoInts&#123;a:12, b:10&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子也可以看到，格式化描述符 %T 会给出类型的完全规格，%#v 会给出实例的完整输出，包括它的字段。</p><p>注意：<strong>不要在 String() 方法里面调用涉及 String() 方法的方法，它会导致意料之外的错误</strong></p><p>比如下面的例子，它导致了一个无限迭代（递归）调用（TT.String() 调用 fmt.Sprintf，而 fmt.Sprintf 又会反过来调用 TT.String()…），很快就会导致内存溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type TT float64</span><br><span class="line"></span><br><span class="line">func (t TT) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;%v&quot;, t)</span><br><span class="line">&#125;</span><br><span class="line">t. String()</span><br></pre></td></tr></table></figure><h3 id="8）垃圾回收和-SetFinalizer"><a href="#8）垃圾回收和-SetFinalizer" class="headerlink" title="8）垃圾回收和 SetFinalizer"></a>8）垃圾回收和 SetFinalizer</h3><p>Go 开发者不需要写代码来释放程序中不再使用的变量和结构占用的内存，在 Go 运行时中有一个独立的进程，即垃圾收集器（GC），会处理这些事情，它搜索不再使用的变量然后释放它们的内存。</p><p>通过调用 runtime.GC() 函数可以显式的触发 GC，但这只在某些罕见的场景下才有用，比如当内存资源不足时调用 runtime.GC()，它会在此函数执行的点上立即释放一大片内存，此时程序可能会有短时的性能下降（因为 GC 进程在执行）。</p><p>如果想知道当前的内存状态，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m runtime.MemStats</span><br><span class="line">runtime.ReadMemStats(&amp;m)</span><br><span class="line">fmt.Printf(&quot;%d Kb\n&quot;, m.Alloc &#x2F; 1024)</span><br></pre></td></tr></table></figure><p>如果需要在一个对象 obj 被从内存移除前执行一些特殊操作，比如写到日志文件中，可以通过如下方式调用函数来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.SetFinalizer(obj, func(obj *typeObj))</span><br></pre></td></tr></table></figure><h2 id="六、接口"><a href="#六、接口" class="headerlink" title="六、接口"></a>六、接口</h2><p>接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。</p><p>通过如下格式定义接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Namer interface &#123;</span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点如下：</p><ul><li>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。</li><li>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</li><li>一个类型可以实现多个接口。</li><li>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</li></ul><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Shaper interface &#123;</span><br><span class="line">    Area() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">    side float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sq *Square) Area() float32 &#123;</span><br><span class="line">    return sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    sq1 :&#x3D; new(Square)</span><br><span class="line">    sq1.side &#x3D; 5</span><br><span class="line"></span><br><span class="line">    var areaIntf Shaper</span><br><span class="line">    areaIntf &#x3D; sq1</span><br><span class="line">    &#x2F;&#x2F; shorter,without separate declaration:</span><br><span class="line">    &#x2F;&#x2F; areaIntf :&#x3D; Shaper(sq1)</span><br><span class="line">    &#x2F;&#x2F; or even:</span><br><span class="line">    &#x2F;&#x2F; areaIntf :&#x3D; sq1</span><br><span class="line">    fmt.Printf(&quot;The square has area: %f\n&quot;, areaIntf.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The square has area: 25.000000</span><br></pre></td></tr></table></figure><p>现在接口变量包含一个指向 Square 变量的引用，通过它可以调用 Square 上的方法 Area()。</p><p>当然也可以直接在 Square 的实例上调用此方法，但是在接口实例上调用此方法更令人兴奋，它使此方法更具有一般性。接口变量里包含了接收者实例的值和指向对应方法表的指针。</p><p>如果 Square 没有实现 Area() 方法，编译器将会给出清晰的错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use sq1 (type *Square) as type Shaper in assignment:</span><br><span class="line">*Square does not implement Shaper (missing Area method)</span><br></pre></td></tr></table></figure><p>如果 Shaper 有另外一个方法 Perimeter()，但是 Square 没有实现它，即使没有人在 Square 实例上调用这个方法，编译器也会给出上面同样的错误。</p><h3 id="1）接口命名"><a href="#1）接口命名" class="headerlink" title="1）接口命名"></a>1）接口命名</h3><p>接口的名字由方法名加 er 后缀组成，例如 Printer、Reader、Writer、Logger、Converter 等等。</p><p>还有一些不常用的方式（当后缀 er 不合适时），比如 Recoverable，此时接口名以 able 结尾，或者以 I 开头（像 .NET 或 Java 中那样）。</p><h3 id="2）接口值"><a href="#2）接口值" class="headerlink" title="2）接口值"></a>2）接口值</h3><p>不像大多数面向对象编程语言，在 Go 语言中接口可以有值，一个接口类型的变量或一个接口值 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ai Namer</span><br><span class="line"></span><br><span class="line">ai 是一个多字（multiword）数据结构，它的值是 nil。它本质上是一个指针。</span><br><span class="line"></span><br><span class="line">指向接口值的指针是非法的，它们不仅一点用也没有，还会导致代码错误。</span><br></pre></td></tr></table></figure><h3 id="3）多态"><a href="#3）多态" class="headerlink" title="3）多态"></a>3）多态</h3><p>多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Shaper interface &#123;</span><br><span class="line">Area() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">side float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sq *Square) Area() float32 &#123;</span><br><span class="line">return sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Rectangle struct &#123;</span><br><span class="line">length, width float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r Rectangle) Area() float32 &#123;</span><br><span class="line">return r.length * r.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">rectangle :&#x3D; Rectangle&#123;3, 5&#125;</span><br><span class="line">square :&#x3D; &amp;Square&#123;5&#125;</span><br><span class="line"></span><br><span class="line">shapers :&#x3D; []Shaper&#123;rectangle, square&#125;</span><br><span class="line"></span><br><span class="line">for _, shaper :&#x3D; range shapers &#123;</span><br><span class="line">fmt.Println(&quot;Shape details:&quot;, shaper)</span><br><span class="line">fmt.Println(&quot;Area of this shape is:&quot;, shaper.Area())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">Shape details: &#123;3 5&#125;</span><br><span class="line">Area of this shape is: 15</span><br><span class="line">Shape details: &amp;&#123;5&#125;</span><br><span class="line">Area of this shape is: 25</span><br></pre></td></tr></table></figure><h3 id="4）接口嵌套接口"><a href="#4）接口嵌套接口" class="headerlink" title="4）接口嵌套接口"></a>4）接口嵌套接口</h3><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type ReadWrite interface &#123;</span><br><span class="line">    Read(b Buffer) bool</span><br><span class="line">    Write(b Buffer) bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Lock interface &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type File interface &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）类型断言：如何检测和转换接口变量的类型"><a href="#5）类型断言：如何检测和转换接口变量的类型" class="headerlink" title="5）类型断言：如何检测和转换接口变量的类型"></a>5）类型断言：如何检测和转换接口变量的类型</h3><p>一个接口类型的变量 varI 中可以包含任何类型的值，必须有一种方式来检测它的 <strong>动态</strong> 类型，即运行时在变量中存储的值的实际类型。</p><p>通常我们可以使用 类型断言 来测试在某个时刻 varI 是否包含类型 T 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v :&#x3D; varI.(T)       &#x2F;&#x2F; unchecked type assertion</span><br><span class="line"></span><br><span class="line">if v, ok :&#x3D; varI.(T); ok &#123;  &#x2F;&#x2F; checked type assertion</span><br><span class="line">    Process(v)</span><br><span class="line">    return</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; varI is not of type T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>varI 必须是一个接口变量，否则编译器会报错：invalid type assertion: varI.(T) (non-interface type (type of varI) on left) 。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Shaper interface &#123;</span><br><span class="line">Area() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">side float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Circle struct &#123;</span><br><span class="line">radius float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sq *Square) Area() float32 &#123;</span><br><span class="line">return sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ci *Circle) Area() float32 &#123;</span><br><span class="line">return ci.radius * ci.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var areaIntf Shaper</span><br><span class="line">sq1 :&#x3D; new(Square)</span><br><span class="line">sq1.side &#x3D; 5</span><br><span class="line"></span><br><span class="line">areaIntf &#x3D; sq1</span><br><span class="line">&#x2F;&#x2F; Is Square the type of areaIntf?</span><br><span class="line">if t, ok :&#x3D; areaIntf.(*Square); ok &#123;</span><br><span class="line">fmt.Printf(&quot;The type of areaIntf is: %T\n&quot;, t)</span><br><span class="line">&#125;</span><br><span class="line">if u, ok :&#x3D; areaIntf.(*Circle); ok &#123;</span><br><span class="line">fmt.Printf(&quot;The type of areaIntf is: %T\n&quot;, u)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;areaIntf does not contain a variable of type Circle&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">The type of areaIntf is: *main.Square</span><br><span class="line">areaIntf does not contain a variable of type Circle</span><br></pre></td></tr></table></figure><h3 id="5）类型判断：type-switch"><a href="#5）类型判断：type-switch" class="headerlink" title="5）类型判断：type-switch"></a>5）类型判断：type-switch</h3><p>接口变量的类型也可以使用一种特殊形式的 switch 来检测：type-switch。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func classifier(items ...interface&#123;&#125;) &#123;</span><br><span class="line">for i, x :&#x3D; range items &#123;</span><br><span class="line">switch x.(type) &#123;</span><br><span class="line">case bool:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a bool\n&quot;, i)</span><br><span class="line">case float64:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a float64\n&quot;, i)</span><br><span class="line">case int, int64:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a int\n&quot;, i)</span><br><span class="line">case nil:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a nil\n&quot;, i)</span><br><span class="line">case string:</span><br><span class="line">fmt.Printf(&quot;Param #%d is a string\n&quot;, i)</span><br><span class="line">default:</span><br><span class="line">fmt.Printf(&quot;Param #%d is unknown\n&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">classifier(13, -14.3, &quot;BELGIUM&quot;, complex(1, 2), nil, false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6）测试一个值是否实现了某个接口"><a href="#6）测试一个值是否实现了某个接口" class="headerlink" title="6）测试一个值是否实现了某个接口"></a>6）测试一个值是否实现了某个接口</h3><p>假定 v 是一个值，然后我们想测试它是否实现了 Stringer 接口，可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Stringer interface &#123;</span><br><span class="line">String() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Square struct &#123;</span><br><span class="line">st string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *Square) String() string &#123;</span><br><span class="line">return s.st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var v Stringer &#x3D; &amp;Square&#123;&quot;value&quot;&#125;</span><br><span class="line">if sv, ok :&#x3D; v.(Stringer); ok &#123;</span><br><span class="line">fmt.Printf(&quot;v implements String(): %s\n&quot;, sv.String()) &#x2F;&#x2F; note: sv, not v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7）使用方法集与接口"><a href="#7）使用方法集与接口" class="headerlink" title="7）使用方法集与接口"></a>7）使用方法集与接口</h3><p>作用于变量上的方法实际上是不区分变量到底是指针还是值的。</p><p>当碰到接口类型值时，这会变得有点复杂，原因是接口变量中存储的具体值是不可寻址的。</p><p>参考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type List []int</span><br><span class="line"></span><br><span class="line">func (l List) Len() int &#123;</span><br><span class="line">return len(l)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (l *List) Append(val int) &#123;</span><br><span class="line">*l &#x3D; append(*l, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Appender interface &#123;</span><br><span class="line">Append(int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CountInto(a Appender, start, end int) &#123;</span><br><span class="line">for i :&#x3D; start; i &lt;&#x3D; end; i++ &#123;</span><br><span class="line">a.Append(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Lener interface &#123;</span><br><span class="line">Len() int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func LongEnough(l Lener) bool &#123;</span><br><span class="line">return l.Len()*10 &gt; 42</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; A bare value</span><br><span class="line">var lst List</span><br><span class="line">&#x2F;&#x2F; compiler error:</span><br><span class="line">&#x2F;&#x2F; cannot use lst (type List) as type Appender in argument to CountInto:</span><br><span class="line">&#x2F;&#x2F;       List does not implement Appender (Append method has pointer receiver)</span><br><span class="line">&#x2F;&#x2F; CountInto(lst, 1, 10)</span><br><span class="line">if LongEnough(lst) &#123; &#x2F;&#x2F; VALID:Identical receiver type</span><br><span class="line">fmt.Printf(&quot;- lst is long enough\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A pointer value</span><br><span class="line">plst :&#x3D; new(List)</span><br><span class="line">CountInto(plst, 1, 10) &#x2F;&#x2F;VALID:Identical receiver type</span><br><span class="line">if LongEnough(plst) &#123;</span><br><span class="line">&#x2F;&#x2F; VALID: a *List can be dereferenced for the receiver</span><br><span class="line">fmt.Printf(&quot;- plst is long enough\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 lst 上调用 CountInto 时会导致一个编译器错误，因为 CountInto 需要一个 Appender，而它的方法 Append 只定义在指针上。 在 lst 上调用 LongEnough 是可以的因为 ‘Len’ 定义在值上。</p><p>在 plst 上调用 CountInto 是可以的，因为 CountInto 需要一个 Appender，并且它的方法 Append 定义在指针上。 在 plst 上调用 LongEnough 也是可以的，因为指针会被自动解引用。</p><p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p><p>总结：</p><p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的：</p><ul><li>指针方法可以通过指针调用</li><li>值方法可以通过值调用</li><li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul><p>Go 语言规范定义了接口方法集的调用规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</span><br><span class="line">类型 T 的可调用方法集包含接受者为 T 的所有方法</span><br><span class="line">类型 T 的可调用方法集不包含接受者为 *T 的方法</span><br></pre></td></tr></table></figure><h3 id="8）相同方法集的接口"><a href="#8）相同方法集的接口" class="headerlink" title="8）相同方法集的接口"></a>8）相同方法集的接口</h3><p>如果有多个接口，且这些接口里的方法定义相同，则类型可以互相转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type day struct &#123;</span><br><span class="line">num       int</span><br><span class="line">shortName string</span><br><span class="line">longName  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type dayArray struct &#123;</span><br><span class="line">data []*day</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *dayArray) Len() int           &#123; return len(p.data) &#125;</span><br><span class="line">func (p *dayArray) Less(i, j int) bool &#123; return p.data[i].num &lt; p.data[j].num &#125;</span><br><span class="line">func (p *dayArray) Swap(i, j int)      &#123; p.data[i], p.data[j] &#x3D; p.data[j], p.data[i] &#125;</span><br><span class="line"></span><br><span class="line">type Sorter interface &#123;</span><br><span class="line">Len() int</span><br><span class="line">Less(i, j int) bool</span><br><span class="line">Swap(i, j int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var c sort.Interface &#x3D; new(dayArray)</span><br><span class="line"></span><br><span class="line">if _, ok :&#x3D; c.(sort.Interface); ok &#123;</span><br><span class="line">fmt.Println(&quot;c implements sort.Interface&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if _, ok :&#x3D; c.(Sorter); ok &#123;</span><br><span class="line">fmt.Println(&quot;c implements Sorter&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">c implements sort.Interface</span><br><span class="line">c implements Sorter</span><br></pre></td></tr></table></figure><h3 id="9）使用-sort-Interface-接口排序"><a href="#9）使用-sort-Interface-接口排序" class="headerlink" title="9）使用 sort.Interface 接口排序"></a>9）使用 sort.Interface 接口排序</h3><p>一个很好的例子是来自标准库的 sort 包，要对一组数字或字符串排序，只需要实现三个方法：</p><ul><li>反映元素个数的 Len() 方法</li><li>比较第 i 和 j 个元素的 Less(i, j) 方法</li><li>交换第 i 和 j 个元素的 Swap(i, j) 方法</li></ul><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sort&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type day struct &#123;</span><br><span class="line">num       int</span><br><span class="line">shortName string</span><br><span class="line">longName  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type dayArray struct &#123;</span><br><span class="line">data []*day</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *dayArray) Len() int           &#123; return len(p.data) &#125;</span><br><span class="line">func (p *dayArray) Less(i, j int) bool &#123; return p.data[i].num &lt; p.data[j].num &#125;</span><br><span class="line">func (p *dayArray) Swap(i, j int)      &#123; p.data[i], p.data[j] &#x3D; p.data[j], p.data[i] &#125;</span><br><span class="line"></span><br><span class="line">func days() &#123;</span><br><span class="line">Sunday :&#x3D; day&#123;0, &quot;SUN&quot;, &quot;Sunday&quot;&#125;</span><br><span class="line">Monday :&#x3D; day&#123;1, &quot;MON&quot;, &quot;Monday&quot;&#125;</span><br><span class="line">Tuesday :&#x3D; day&#123;2, &quot;TUE&quot;, &quot;Tuesday&quot;&#125;</span><br><span class="line">Wednesday :&#x3D; day&#123;3, &quot;WED&quot;, &quot;Wednesday&quot;&#125;</span><br><span class="line">Thursday :&#x3D; day&#123;4, &quot;THU&quot;, &quot;Thursday&quot;&#125;</span><br><span class="line">Friday :&#x3D; day&#123;5, &quot;FRI&quot;, &quot;Friday&quot;&#125;</span><br><span class="line">Saturday :&#x3D; day&#123;6, &quot;SAT&quot;, &quot;Saturday&quot;&#125;</span><br><span class="line">data :&#x3D; []*day&#123;&amp;Tuesday, &amp;Thursday, &amp;Wednesday, &amp;Sunday, &amp;Monday, &amp;Friday, &amp;Saturday&#125;</span><br><span class="line">a :&#x3D; dayArray&#123;data&#125;</span><br><span class="line">sort.Sort(&amp;a)</span><br><span class="line">if !sort.IsSorted(&amp;a) &#123;</span><br><span class="line">panic(&quot;fail&quot;)</span><br><span class="line">&#125;</span><br><span class="line">for _, d :&#x3D; range data &#123;</span><br><span class="line">fmt.Printf(&quot;%s &quot;, d.longName)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">days()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10）Go-中的面向对象"><a href="#10）Go-中的面向对象" class="headerlink" title="10）Go 中的面向对象"></a>10）Go 中的面向对象</h3><p>我们总结一下前面看到的：Go 没有类，而是松耦合的类型、方法对接口的实现。</p><p>OO(面向对象) 语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？</p><h4 id="封装（数据隐藏）"><a href="#封装（数据隐藏）" class="headerlink" title="封装（数据隐藏）"></a>封装（数据隐藏）</h4><p>Go 和别的 OO(面向对象) 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层（Go可见性规则）:</p><ul><li><p>1）包范围内的：通过标识符首字母小写，对象只在它所在的包内可见</p></li><li><p>2）可导出的：通过标识符首字母大写，对象对所在包以外也可见</p></li></ul><h4 id="类型只拥有自己所在包中定义的方法"><a href="#类型只拥有自己所在包中定义的方法" class="headerlink" title="类型只拥有自己所在包中定义的方法"></a>类型只拥有自己所在包中定义的方法</h4><ul><li>继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现</li><li>多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且：接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。</li></ul><h3 id="11）接口与动态类型"><a href="#11）接口与动态类型" class="headerlink" title="11）接口与动态类型"></a>11）接口与动态类型</h3><p>在经典的面向对象语言（像 C++，Java 和 C#）中数据和方法被封装为 类 的概念：类包含它们两者，并且不能剥离。</p><p>Go 没有类：数据（结构体或更一般的类型）和方法是一种松耦合的正交关系。</p><p>Go 中的接口跟 Java/C# 类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：<strong>任何提供了接口方法实现代码的类型都隐式地实现了该接口，而不用显式地声明。</strong></p><p>和其它语言相比，Go 是唯一结合了接口值，<strong>静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。</strong> 该特性允许我们在不改变已有的代码的情况下定义和使用新接口。</p><p>接收一个（或多个）接口类型作为参数的函数，其实参数可以是任何实现了该接口的类型。<strong>实现了某个接口的类型可以被传给任何以此接口为参数的函数。</strong></p><p>类似于 Python 和 Ruby 这类动态语言中的 动态类型（duck typing）；这意味着对象可以根据提供的方法被处理（例如，作为参数传递给函数），而忽略它们的实际类型：<strong>它们能做什么比它们是什么更重要。</strong></p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type IDuck interface &#123;</span><br><span class="line">Quack()</span><br><span class="line">Walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DuckDance(duck IDuck) &#123;</span><br><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 3; i++ &#123;</span><br><span class="line">duck.Quack()</span><br><span class="line">duck.Walk()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Bird struct &#123;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Bird) Quack() &#123;</span><br><span class="line">fmt.Println(&quot;I am quacking!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (b *Bird) Walk() &#123;</span><br><span class="line">fmt.Println(&quot;I am walking!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b :&#x3D; new(Bird)</span><br><span class="line">DuckDance(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">I am quacking!</span><br><span class="line">I am walking!</span><br><span class="line">I am quacking!</span><br><span class="line">I am walking!</span><br><span class="line">I am quacking!</span><br><span class="line">I am walking!</span><br></pre></td></tr></table></figure><h4 id="动态方法调用"><a href="#动态方法调用" class="headerlink" title="动态方法调用"></a>动态方法调用</h4><p>像 Python，Ruby 这类语言，动态类型是延迟绑定的（在运行时进行）：<strong>方法只是用参数和变量简单地调用，然后在运行时才解析</strong>（它们很可能有像 responds_to 这样的方法来检查对象是否可以响应某个方法，但是这也意味着更大的编码量和更多的测试工作）。</p><p>Go 的实现与此相反，通常需要编译器静态检查的支持：<strong>当变量被赋值给一个接口类型的变量时，编译器会检查其是否实现了该接口的所有函数。</strong> 如果方法调用作用于像 interface{} 这样的 “泛型” 上，你可以通过类型断言来检查变量是否实现了相应接口。</p><p>例如，你用不同的类型表示 XML 输出流中的不同实体。然后我们为 XML 定义一个如下的 “写” 接口（甚至可以把它定义为私有接口）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type xmlWriter interface &#123;</span><br><span class="line">    WriteXML(w io.Writer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以实现适用于该流类型的任何变量的 StreamXML 函数，并用类型断言检查传入的变量是否实现了该接口；如果没有，我们就调用内建的 encodeToXML 来完成相应工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Exported XML streaming function.</span><br><span class="line">func StreamXML(v interface&#123;&#125;, w io.Writer) error &#123;</span><br><span class="line">    if xw, ok :&#x3D; v.(xmlWriter); ok &#123;</span><br><span class="line">        &#x2F;&#x2F; It’s an  xmlWriter, use method of asserted type.</span><br><span class="line">        return xw.WriteXML(w)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; No implementation, so we have to use our own function (with perhaps reflection):</span><br><span class="line">    return encodeToXML(v, w)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Internal XML encoding function.</span><br><span class="line">func encodeToXML(v interface&#123;&#125;, w io.Writer) error &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 Go 提供了动态语言的优点，却没有其他动态语言在运行时可能发生错误的缺点。</p><h4 id="接口的提取"><a href="#接口的提取" class="headerlink" title="接口的提取"></a>接口的提取</h4><p>提取接口 是非常有用的设计模式，可以减少需要的类型和方法数量，而且不需要像传统的基于类的面向对象语言那样维护整个的类层次结构。</p><p>Go 接口可以让开发者找出自己写的程序中的类型。假设有一些拥有共同行为的对象，并且开发者想要抽象出这些行为，这时就可以创建一个接口来使用。</p><p>所以你不用提前设计出所有的接口；<strong>整个设计可以持续演进，而不用废弃之前的决定。类型要实现某个接口，它本身不用改变，你只需要在这个类型上实现新的方法。</strong></p><h4 id="显式地指明类型实现了某个接口"><a href="#显式地指明类型实现了某个接口" class="headerlink" title="显式地指明类型实现了某个接口"></a>显式地指明类型实现了某个接口</h4><p>如果你希望满足某个接口的类型显式地声明它们实现了这个接口，你可以向接口的方法集中添加一个具有描述性名字的方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Fooer interface &#123;</span><br><span class="line">    Foo()</span><br><span class="line">    ImplementsFooer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型 Bar 必须实现 ImplementsFooer 方法来满足 Footer 接口，以清楚地记录这个事实。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Bar struct&#123;&#125;</span><br><span class="line">func (b Bar) ImplementsFooer() &#123;&#125;</span><br><span class="line">func (b Bar) Foo() &#123;&#125;</span><br></pre></td></tr></table></figure><p>大部分代码并不使用这样的约束，因为它限制了接口的实用性。</p><p>但是有些时候，这样的约束在大量相似的接口中被用来解决歧义。</p><h4 id="空接口和函数重载"><a href="#空接口和函数重载" class="headerlink" title="空接口和函数重载"></a>空接口和函数重载</h4><p>在之前的学习中，我们看到函数重载是不被允许的。在 Go 语言中函数重载可以用 可变参数 …T 作为函数 <strong>最后一个参数</strong> 来实现。</p><p>如果我们把 T 换为空接口，那么可以知道任何类型的变量都是满足 T (空接口）类型的，这样就允许我们传递任何数量任何类型的参数给函数，即重载的实际含义。</p><p>函数 fmt.Printf 就是这样做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(format string, a ...interface&#123;&#125;) (n int, errno error)</span><br><span class="line"></span><br><span class="line">这个函数通过枚举 slice 类型的实参动态确定所有参数的类型。并查看每个类型是否实现了 String() 方法，如果是就用于产生输出信息。</span><br></pre></td></tr></table></figure><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Task struct &#123;</span><br><span class="line">    Command string</span><br><span class="line">    *log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类型的工厂方法像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func NewTask(command string, logger *log.Logger) *Task &#123;</span><br><span class="line">    return &amp;Task&#123;command, logger&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 log.Logger 实现了 Log() 方法后，Task 的实例 task 就可以调用该方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task.Log()</span><br></pre></td></tr></table></figure><p>类型可以通过继承多个接口来提供像 多重继承 一样的特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type ReaderWriter struct &#123;</span><br><span class="line">    *io.Reader</span><br><span class="line">    *io.Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面概述的原理被应用于整个 Go 包，多态用得越多，代码就相对越少。这被认为是 Go 编程中的重要的最佳实践。</p><p>有用的接口可以在开发的过程中被归纳出来。添加新接口非常容易，因为已有的类型不用变动（仅仅需要实现新接口的方法）。</p><h2 id="七、空接口"><a href="#七、空接口" class="headerlink" title="七、空接口"></a>七、空接口</h2><p>空接口或者最小接口 不包含任何方法，它对实现不做任何要求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Any interface &#123;&#125;</span><br></pre></td></tr></table></figure><p>任何其他类型都实现了空接口（它不仅仅像 Java/C# 中 Object 引用类型），any 或 Any 是空接口一个很好的别名或缩写。</p><p>空接口类似 Java/C# 中所有类的基类： Object 类，二者的目标也很相近。</p><p>可以给一个空接口类型的变量 var val interface {} 赋任何类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">var i &#x3D; 5</span><br><span class="line">var str &#x3D; &quot;ABC&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Any interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var val Any</span><br><span class="line">    val &#x3D; 5</span><br><span class="line">    fmt.Printf(&quot;val has the value: %v\n&quot;, val)</span><br><span class="line">    val &#x3D; str</span><br><span class="line">    fmt.Printf(&quot;val has the value: %v\n&quot;, val)</span><br><span class="line">    pers1 :&#x3D; new(Person)</span><br><span class="line">    pers1.name &#x3D; &quot;Rob Pike&quot;</span><br><span class="line">    pers1.age &#x3D; 55</span><br><span class="line">    val &#x3D; pers1</span><br><span class="line">    fmt.Printf(&quot;val has the value: %v\n&quot;, val)</span><br><span class="line">    switch t :&#x3D; val.(type) &#123;</span><br><span class="line">    case int:</span><br><span class="line">        fmt.Printf(&quot;Type int %T\n&quot;, t)</span><br><span class="line">    case string:</span><br><span class="line">        fmt.Printf(&quot;Type string %T\n&quot;, t)</span><br><span class="line">    case bool:</span><br><span class="line">        fmt.Printf(&quot;Type boolean %T\n&quot;, t)</span><br><span class="line">    case *Person:</span><br><span class="line">        fmt.Printf(&quot;Type pointer to Person %T\n&quot;, t)</span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;Unexpected type %T&quot;, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">val has the value: 5</span><br><span class="line">val has the value: ABC</span><br><span class="line">val has the value: &amp;&#123;Rob Pike 55&#125;</span><br><span class="line">Type pointer to Person *main.Person</span><br></pre></td></tr></table></figure><p>在上面的例子中，接口变量 val 被依次赋予一个 int，string 和 Person 实例的值，然后使用 type-switch 来测试它的实际类型。</p><p>每个 interface {} 变量在内存中占据两个字长：</p><ul><li>一个用来存储它包含的类型。</li><li>另一个用来存储它包含的数据或者指向数据的指针。</li></ul><h3 id="1）构建通用类型或包含不同类型变量的数组"><a href="#1）构建通用类型或包含不同类型变量的数组" class="headerlink" title="1）构建通用类型或包含不同类型变量的数组"></a>1）构建通用类型或包含不同类型变量的数组</h3><p>在之前的例子中我们看到了能被搜索和排序的 int 数组、float 数组以及 string 数组，那么对于其他类型的数组呢，是不是我们必须得自己编程实现它们？</p><p>现在我们知道该怎么做了，就是通过使用空接口。让我们给空接口定一个别名类型 Element：type Element interface{}</p><p>然后定义一个容器类型的结构体 Vector，它包含一个 Element 类型元素的切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Element interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">type Vector struct &#123;</span><br><span class="line">    a []Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector 里能放任何类型的变量，因为任何类型都实现了空接口，实际上 Vector 里放的每个元素可以是不同类型的变量。我们为它定义一个 At() 方法用于返回第 i 个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p *Vector) At(i int) Element &#123;</span><br><span class="line">    return p.a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定一个 Set() 方法用于设置第 i 个元素的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p *Vector) Set(i int, e Element) &#123;</span><br><span class="line">    p.a[i] &#x3D; e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector 中存储的所有元素都是 Element 类型，要得到它们的原始类型（unboxing：拆箱）需要用到类型断言。</p><p>注意：<strong>The compiler rejects assertions guaranteed to fail，类型断言总是在运行时才执行，因此它会产生运行时错误。</strong></p><p>练习：创建一个 Miner 接口并实现一些必要的操作。函数 Min 接受一个 Miner 类型变量的集合，然后计算并返回集合中最小的元素。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Element interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">type Miner interface &#123;</span><br><span class="line">Len() int</span><br><span class="line">ElemIx(ix int) Element</span><br><span class="line">Less(i, j int) bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IntArray []int</span><br><span class="line"></span><br><span class="line">func (p IntArray) Len() int              &#123; return len(p) &#125;</span><br><span class="line">func (p IntArray) ElemIx(ix int) Element &#123; return p[ix] &#125;</span><br><span class="line">func (p IntArray) Less(i, j int) bool    &#123; return p[i] &lt; p[j] &#125;</span><br><span class="line"></span><br><span class="line">func Min(data Miner) Element &#123;</span><br><span class="line">min :&#x3D; data.ElemIx(0)</span><br><span class="line">for i :&#x3D; 1; i &lt; data.Len(); i++ &#123;</span><br><span class="line">if data.Less(i, i-1) &#123;</span><br><span class="line">min &#x3D; data.ElemIx(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">intarr :&#x3D; IntArray&#123;1, 2, 3, 5, -1&#125;</span><br><span class="line">fmt.Println(Min(intarr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2）复制数据切片至空接口切片"><a href="#2）复制数据切片至空接口切片" class="headerlink" title="2）复制数据切片至空接口切片"></a>2）复制数据切片至空接口切片</h3><p>假设你有一个 myType 类型的数据切片，你想将切片中的数据复制到一个空接口切片中，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var dataSlice []myType &#x3D; FuncReturnSlice()</span><br><span class="line">var interfaceSlice []interface&#123;&#125; &#x3D; dataSlice</span><br></pre></td></tr></table></figure><p>可惜不能这么做，编译时会出错：cannot use dataSlice (type []myType) as type []interface { } in assignment。</p><p><strong>原因是它们俩在内存中的布局是不一样的。</strong></p><p>必须使用 for-range 语句来一个一个显式地复制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var dataSlice []myType &#x3D; FuncReturnSlice()</span><br><span class="line">var interfaceSlice []interface&#123;&#125; &#x3D; make([]interface&#123;&#125;, len(dataSlice))</span><br><span class="line">for i, d :&#x3D; range dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] &#x3D; d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）通用类型的节点数据结构"><a href="#3）通用类型的节点数据结构" class="headerlink" title="3）通用类型的节点数据结构"></a>3）通用类型的节点数据结构</h3><p>列表和树这样的数据结构，在它们的定义中使用了一种叫节点的递归结构体类型，节点包含一个某种类型的数据字段。现在可以使用空接口作为数据字段的类型，这样我们就能写出通用的代码。</p><p>下面是实现一个二叉树的部分代码：通用定义、用于创建空节点的 NewNode 方法，及设置数据的 SetData 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Node struct &#123;</span><br><span class="line">le   *Node</span><br><span class="line">data interface&#123;&#125;</span><br><span class="line">ri   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewNode(left, right *Node) *Node &#123;</span><br><span class="line">return &amp;Node&#123;left, nil, right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *Node) SetData(data interface&#123;&#125;) &#123;</span><br><span class="line">n.data &#x3D; data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">root :&#x3D; NewNode(nil, nil)</span><br><span class="line">root.SetData(&quot;root node&quot;)</span><br><span class="line">&#x2F;&#x2F; make child (leaf) nodes:</span><br><span class="line">a :&#x3D; NewNode(nil, nil)</span><br><span class="line">a.SetData(&quot;left node&quot;)</span><br><span class="line">b :&#x3D; NewNode(nil, nil)</span><br><span class="line">b.SetData(&quot;right node&quot;)</span><br><span class="line">root.le &#x3D; a</span><br><span class="line">root.ri &#x3D; b</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）接口到接口"><a href="#3）接口到接口" class="headerlink" title="3）接口到接口"></a>3）接口到接口</h3><p>一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法。</p><p>这个转换是在运行时进行检查的，转换失败会导致一个运行时错误：这是 ‘Go’ 语言动态的一面，可以拿它和 Ruby 和 Python 这些动态语言相比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type AbsInterface interface &#123;</span><br><span class="line">Abs() interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SqrInterface interface &#123;</span><br><span class="line">Sqr() float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Point struct &#123;</span><br><span class="line">value int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Point) Abs() interface&#123;&#125; &#123;</span><br><span class="line">return math.Abs(float64(p.value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Point) Sqr() float32 &#123;</span><br><span class="line">return float32(p.value * p.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var ai AbsInterface</span><br><span class="line">var si SqrInterface</span><br><span class="line"></span><br><span class="line">pp :&#x3D; new(Point) &#x2F;&#x2F; say *Point implements Abs, Sqr</span><br><span class="line">pp.value &#x3D; -5</span><br><span class="line">var empty interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">empty &#x3D; pp &#x2F;&#x2F; everything satisfies empty</span><br><span class="line">fmt.Println(empty)</span><br><span class="line">ai &#x3D; empty.(AbsInterface) &#x2F;&#x2F; underlying value pp implements Abs()</span><br><span class="line">fmt.Println(ai.Abs())</span><br><span class="line">&#x2F;&#x2F; (runtime failure otherwise)</span><br><span class="line">si &#x3D; ai.(SqrInterface) &#x2F;&#x2F; *Point has Sqr() even though AbsInterface doesn’t</span><br><span class="line">fmt.Println(si.Sqr())</span><br><span class="line">empty &#x3D; si &#x2F;&#x2F; *Point implements empty set</span><br><span class="line">fmt.Println(empty)</span><br><span class="line">&#x2F;&#x2F; Note: statically checkable so type assertion not necessary.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">&amp;&#123;-5&#125;</span><br><span class="line">5</span><br><span class="line">25</span><br><span class="line">&amp;&#123;-5&#125;</span><br></pre></td></tr></table></figure><h2 id="八、反射"><a href="#八、反射" class="headerlink" title="八、反射"></a>八、反射</h2><p>反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。</p><p>反射可以在运行时检查类型和变量，例如它的大小、方法和 动态的调用这些方法。这对于没有源代码的包尤其有用。</p><p>变量的最基本信息就是类型和值：反射包的 Type 用来表示一个 Go 类型，反射包的 Value 为 Go 值提供了反射接口。</p><p>两个简单的函数，reflect.TypeOf 和 reflect.ValueOf，返回被检查对象的类型和值。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x 被定义为</span><br><span class="line">var x float64 &#x3D; 3.4</span><br><span class="line"></span><br><span class="line">reflect.TypeOf(x) 返回 float64</span><br><span class="line"></span><br><span class="line">reflect.ValueOf(x) 返回 &lt;float64 Value&gt;</span><br></pre></td></tr></table></figure><p>实际上，反射是通过检查一个接口的值，变量首先被转换成空接口。这从下面两个函数签名能够很明显的看出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func TypeOf(i interface&#123;&#125;) Type</span><br><span class="line">func ValueOf(i interface&#123;&#125;) Value</span><br></pre></td></tr></table></figure><p>接口的值包含一个 type 和 value。</p><p>反射可以从接口值反射到对象，也可以从对象反射回接口值。</p><p>reflect.Type 和 reflect.Value 都有许多方法用于检查和操作它们。一个重要的例子是 Value 有一个 Type 方法返回 reflect.Value 的 Type。另一个是 Type 和 Value 都有 Kind 方法返回一个常量来表示类型：Uint、Float64、Slice 等等。同样 Value 有叫做 Int 和 Float 的方法可以获取存储在内部的值（跟 int64 和 float64 一样）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Invalid Kind &#x3D; iota</span><br><span class="line">Bool</span><br><span class="line">Int</span><br><span class="line">Int8</span><br><span class="line">Int16</span><br><span class="line">Int32</span><br><span class="line">Int64</span><br><span class="line">Uint</span><br><span class="line">Uint8</span><br><span class="line">Uint16</span><br><span class="line">Uint32</span><br><span class="line">Uint64</span><br><span class="line">Uintptr</span><br><span class="line">Float32</span><br><span class="line">Float64</span><br><span class="line">Complex64</span><br><span class="line">Complex128</span><br><span class="line">Array</span><br><span class="line">Chan</span><br><span class="line">Func</span><br><span class="line">Interface</span><br><span class="line">Map</span><br><span class="line">Ptr</span><br><span class="line">Slice</span><br><span class="line">String</span><br><span class="line">Struct</span><br><span class="line">UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于 float64 类型的变量 x，如果 v:=reflect.ValueOf(x)，那么 v.Kind() 返回 reflect.Float64 ，所以下面的表达式是 true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.Kind() &#x3D;&#x3D; reflect.Float64</span><br></pre></td></tr></table></figure><p>Kind 总是返回底层类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type MyInt int</span><br><span class="line">var m MyInt &#x3D; 5</span><br><span class="line">v :&#x3D; reflect.ValueOf(m)</span><br><span class="line"></span><br><span class="line">方法 v.Kind() 返回 reflect.Int。</span><br><span class="line">变量 v 的 Interface() 方法可以得到还原（接口）值，所以可以这样打印 v 的值：fmt.Println(v.Interface())</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var x float64 &#x3D; 3.4</span><br><span class="line">    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))</span><br><span class="line">    v :&#x3D; reflect.ValueOf(x)</span><br><span class="line">    fmt.Println(&quot;value:&quot;, v)</span><br><span class="line">    fmt.Println(&quot;type:&quot;, v.Type())</span><br><span class="line">    fmt.Println(&quot;kind:&quot;, v.Kind())</span><br><span class="line">    fmt.Println(&quot;value:&quot;, v.Float())</span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Printf(&quot;value is %5.2e\n&quot;, v.Interface())</span><br><span class="line">    y :&#x3D; v.Interface().(float64)</span><br><span class="line">    fmt.Println(y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">type: float64</span><br><span class="line">value: 3.4</span><br><span class="line">type: float64</span><br><span class="line">kind: float64</span><br><span class="line">value: 3.4</span><br><span class="line">3.4</span><br><span class="line">value is 3.40e+00</span><br><span class="line">3.4</span><br></pre></td></tr></table></figure><h3 id="1）通过反射修改-设置-值"><a href="#1）通过反射修改-设置-值" class="headerlink" title="1）通过反射修改 (设置) 值"></a>1）通过反射修改 (设置) 值</h3><p>假设我们要把 x 的值改为 3.1415。Value 有一些方法可以完成这个任务，但是必须小心使用：v.SetFloat(3.1415)。</p><p>这将产生一个错误：reflect.Value.SetFloat using unaddressable value。</p><p>为什么会这样呢？问题的原因是 v 不是可设置的（这里并不是说值不可寻址）。是否可设置是 Value 的一个属性，并且不是所有的反射值都有这个属性：可以使用 CanSet() 方法测试是否可设置。</p><p>在例子中我们看到 v.CanSet() 返回 false： settability of v: false</p><p>当 v := reflect.ValueOf(x) 函数通过传递一个 x 拷贝创建了 v，那么 v 的改变并不能更改原始的 x。要想 v 的更改能作用到 x，那就必须传递 x 的地址 v = reflect.ValueOf(&amp;x)。</p><p>通过 Type () 我们看到 v 现在的类型是 *float64 并且仍然是不可设置的。</p><p>要想让其可设置我们需要使用 Elem() 函数，这间接的使用指针：v = v.Elem()</p><p>现在 v.CanSet() 返回 true 并且 v.SetFloat(3.1415) 设置成功了！</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var x float64 &#x3D; 3.4</span><br><span class="line">    v :&#x3D; reflect.ValueOf(x)</span><br><span class="line">    &#x2F;&#x2F; setting a value:</span><br><span class="line">    &#x2F;&#x2F; v.SetFloat(3.1415) &#x2F;&#x2F; Error: will panic: reflect.Value.SetFloat using unaddressable value</span><br><span class="line">    fmt.Println(&quot;settability of v:&quot;, v.CanSet())</span><br><span class="line">    v &#x3D; reflect.ValueOf(&amp;x) &#x2F;&#x2F; Note: take the address of x.</span><br><span class="line">    fmt.Println(&quot;type of v:&quot;, v.Type())</span><br><span class="line">    fmt.Println(&quot;settability of v:&quot;, v.CanSet())</span><br><span class="line">    v &#x3D; v.Elem()</span><br><span class="line">    fmt.Println(&quot;The Elem of v is: &quot;, v)</span><br><span class="line">    fmt.Println(&quot;settability of v:&quot;, v.CanSet())</span><br><span class="line">    v.SetFloat(3.1415) &#x2F;&#x2F; this works!</span><br><span class="line">    fmt.Println(v.Interface())</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">settability of v: false</span><br><span class="line">type of v: *float64</span><br><span class="line">settability of v: false</span><br><span class="line">The Elem of v is:  &lt;float64 Value&gt;</span><br><span class="line">settability of v: true</span><br><span class="line">3.1415</span><br><span class="line">&lt;float64 Value&gt;</span><br></pre></td></tr></table></figure><h3 id="2）反射结构体"><a href="#2）反射结构体" class="headerlink" title="2）反射结构体"></a>2）反射结构体</h3><p>NumField() 方法返回结构体内的字段数量；通过一个 for 循环用索引取得每个字段的值 Field(i)。</p><p>我们同样能够调用签名在结构体上的方法，例如，使用索引 n 来调用：Method(n).Call(nil)。</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type NotknownType struct &#123;</span><br><span class="line">    s1, s2, s3 string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n NotknownType) String() string &#123;</span><br><span class="line">    return n.s1 + &quot; - &quot; + n.s2 + &quot; - &quot; + n.s3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; variable to investigate:</span><br><span class="line">var secret interface&#123;&#125; &#x3D; NotknownType&#123;&quot;Ada&quot;, &quot;Go&quot;, &quot;Oberon&quot;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    value :&#x3D; reflect.ValueOf(secret) &#x2F;&#x2F; &lt;main.NotknownType Value&gt;</span><br><span class="line">    typ :&#x3D; reflect.TypeOf(secret)    &#x2F;&#x2F; main.NotknownType</span><br><span class="line">    &#x2F;&#x2F; alternative:</span><br><span class="line">    &#x2F;&#x2F;typ :&#x3D; value.Type()  &#x2F;&#x2F; main.NotknownType</span><br><span class="line">    fmt.Println(typ)</span><br><span class="line">    knd :&#x3D; value.Kind() &#x2F;&#x2F; struct</span><br><span class="line">    fmt.Println(knd)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; iterate through the fields of the struct:</span><br><span class="line">    for i :&#x3D; 0; i &lt; value.NumField(); i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;Field %d: %v\n&quot;, i, value.Field(i))</span><br><span class="line">        &#x2F;&#x2F; error: panic: reflect.Value.SetString using value obtained using unexported field</span><br><span class="line">        &#x2F;&#x2F;value.Field(i).SetString(&quot;C#&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; call the first method, which is String():</span><br><span class="line">    results :&#x3D; value.Method(0).Call(nil)</span><br><span class="line">    fmt.Println(results) &#x2F;&#x2F; [Ada - Go - Oberon]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">main.NotknownType</span><br><span class="line">struct</span><br><span class="line">Field 0: Ada</span><br><span class="line">Field 1: Go</span><br><span class="line">Field 2: Oberon</span><br><span class="line">[Ada - Go - Oberon]</span><br></pre></td></tr></table></figure><p>但是如果尝试更改一个值，会得到一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect.Value.SetString using value obtained using unexported field</span><br></pre></td></tr></table></figure><p>这是因为结构体中 <strong>只有被导出字段（首字母大写）才是可设置的。</strong></p><p>来看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type T struct &#123;</span><br><span class="line">    A int</span><br><span class="line">    B string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    t :&#x3D; T&#123;23, &quot;skidoo&quot;&#125;</span><br><span class="line">    s :&#x3D; reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    typeOfT :&#x3D; s.Type()</span><br><span class="line">    for i :&#x3D; 0; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">        f :&#x3D; s.Field(i)</span><br><span class="line">        fmt.Printf(&quot;%d: %s %s &#x3D; %v\n&quot;, i,</span><br><span class="line">            typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">    &#125;</span><br><span class="line">    s.Field(0).SetInt(77)</span><br><span class="line">    s.Field(1).SetString(&quot;Sunset Strip&quot;)</span><br><span class="line">    fmt.Println(&quot;t is now&quot;, t)</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">0: A int &#x3D; 23</span><br><span class="line">1: B string &#x3D; skidoo</span><br><span class="line">t is now &#123;77 Sunset Strip&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://learnku.com/docs/the-way-to-go">Go 入门指南</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：六到十一章的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：六到十一章的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
    <category term="go基础" scheme="https://www.blog.ajie39.top/tags/go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Go 入门总结（一）</title>
    <link href="https://www.blog.ajie39.top/2022/03/06/Go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2022/03/06/Go%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-03-06T06:50:08.425Z</published>
    <updated>2022-05-07T07:24:49.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。"><a href="#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。" class="headerlink" title="摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。"></a>摘要：go入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结其中：一到五章的内容。</h1><hr><span id="more"></span><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1、包相关"><a href="#1、包相关" class="headerlink" title="1、包相关"></a>1、包相关</h3><p>①第一种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;; import &quot;os&quot;</span><br></pre></td></tr></table></figure><p>②第二种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (&quot;fmt&quot;; &quot;os&quot;)</span><br></pre></td></tr></table></figure><h3 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h3><ul><li>布尔类型：bool</li><li>整数：int、int8、int16、int32、int64</li><li>无符号整数：uint、uint8、uint16、uint32、uint64</li><li>字节：byte(和 uint8 等价)</li><li>Unicode：rune(和 int32 等价)</li><li>整数指针：uintptr(存储 uint32、uint64 的指针)</li><li>浮点数：float32、float64</li><li>复数：complex64、complex128</li><li>字符串类型：string</li><li>值类型：array(数组)、struct(结构化变量)</li><li>引用类型：slice(动态数组)、map、channel(管道)</li><li>接口：interface</li><li>函数：function</li></ul><h3 id="3、函数相关"><a href="#3、函数相关" class="headerlink" title="3、函数相关"></a>3、函数相关</h3><p>函数执行顺序：init —》main</p><p>测试代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;demo&#x2F;com.th3ee9ine&#x2F;servic&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">&#x2F;&#x2F; 先执行</span><br><span class="line">fmt.Println(&quot;初始化.....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">  主函数</span><br><span class="line">*&#x2F;</span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 后执行</span><br><span class="line">fmt.Println(&quot;主函数......&quot;)</span><br><span class="line">fmt.Println(&quot;加法&quot;)</span><br><span class="line">fmt.Println(servic.Add(1, 2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、类型转换"><a href="#4、类型转换" class="headerlink" title="4、类型转换"></a>4、类型转换</h3><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOfTypeB &#x3D; typeB(valueOfTypeA)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 5.0</span><br><span class="line">var b &#x3D; int(a)</span><br></pre></td></tr></table></figure><h3 id="5、Go-程序的一般结构"><a href="#5、Go-程序的一般结构" class="headerlink" title="5、Go 程序的一般结构"></a>5、Go 程序的一般结构</h3><p>一般结构如下：</p><ul><li>在完成包的 import 之后，开始对常量、变量和类型的定义或声明。</li><li>如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li><li>如果当前包是 main 包，则定义 main 函数。</li><li>然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const c &#x3D; &quot;C&quot;</span><br><span class="line"></span><br><span class="line">var v int &#x3D; 5</span><br><span class="line"></span><br><span class="line">type T struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123; &#x2F;&#x2F; initialization of package</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var a int</span><br><span class="line">   Func1()</span><br><span class="line">   &#x2F;&#x2F; ...</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t T) Method1() &#123;</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Func1() &#123; &#x2F;&#x2F; exported function Func1</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、常量、变量"><a href="#6、常量、变量" class="headerlink" title="6、常量、变量"></a>6、常量、变量</h3><h4 id="①常量"><a href="#①常量" class="headerlink" title="①常量"></a>①常量</h4><p>常量使用关键字 const 定义，用于存储不会改变的数据。</p><p>存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const identifier [type] &#x3D; value</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">const PI &#x3D; 3.14159</span><br><span class="line">const NAME string &#x3D; &quot;张三&quot;</span><br><span class="line">const beef, two, c &#x3D; &quot;eat&quot;, 2, &quot;veg&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>②常量枚举</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Unknown &#x3D; 0</span><br><span class="line">    Female &#x3D; 1</span><br><span class="line">    Male &#x3D; 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota 可以被用作枚举值，第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1，例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b &#x3D; iota</span><br><span class="line">    c &#x3D; iota</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="②变量"><a href="#②变量" class="headerlink" title="②变量"></a>②变量</h4><p>声明变量的一般形式是使用 var 关键字，例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var identifier type</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">var a int &#x3D; 15</span><br><span class="line">var i &#x3D; 5</span><br><span class="line">var b bool &#x3D; false</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    a &#x3D; 15</span><br><span class="line">    b &#x3D; false</span><br><span class="line">    city string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">简短形式，使用 :&#x3D; 赋值操作符，例如：</span><br><span class="line"></span><br><span class="line">a, b, c :&#x3D; 5, 7, &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。</span><br><span class="line"></span><br><span class="line">同个变量不可以多次使用 :&#x3D; 赋值操作符。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、运算符"><a href="#7、运算符" class="headerlink" title="7、运算符"></a>7、运算符</h3><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优先级     运算符</span><br><span class="line"> 7      ^ !</span><br><span class="line"> 6      * &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^</span><br><span class="line"> 5      + - | ^</span><br><span class="line"> 4      &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt;&#x3D; &gt;</span><br><span class="line"> 3      &lt;-</span><br><span class="line"> 2      &amp;&amp;</span><br><span class="line"> 1      ||</span><br></pre></td></tr></table></figure><h3 id="8、字符串"><a href="#8、字符串" class="headerlink" title="8、字符串"></a>8、字符串</h3><p>字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。</p><p>Go 支持以下 2 种形式的字面值：</p><p>解释字符串：</p><p>该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\n：换行符</span><br><span class="line">\r：回车符</span><br><span class="line">\t：tab 键</span><br><span class="line">\u 或 \U：Unicode 字符</span><br><span class="line">\\：反斜杠自身</span><br></pre></td></tr></table></figure><p>非解释字符串：</p><p>该类字符串使用反引号括起来，支持换行，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;This is a raw string \n&#96; 中的 &#96;\n\&#96; 会被原样输出。</span><br></pre></td></tr></table></figure><h3 id="9、时间和日期"><a href="#9、时间和日期" class="headerlink" title="9、时间和日期"></a>9、时间和日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var week time.Duration</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">t :&#x3D; time.Now()</span><br><span class="line">fmt.Println(t) &#x2F;&#x2F; e.g. Wed Dec 21 09:52:14 +0100 RST 2011</span><br><span class="line">fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</span><br><span class="line">&#x2F;&#x2F; 21.12.2011</span><br><span class="line">t &#x3D; time.Now().UTC()</span><br><span class="line">fmt.Println(t)          &#x2F;&#x2F; Wed Dec 21 08:52:14 +0000 UTC 2011</span><br><span class="line">fmt.Println(time.Now()) &#x2F;&#x2F; Wed Dec 21 09:52:14 +0100 RST 2011</span><br><span class="line">&#x2F;&#x2F; calculating times:</span><br><span class="line">week &#x3D; 60 * 60 * 24 * 7 * 1e9 &#x2F;&#x2F; must be in nanosec</span><br><span class="line">weekFromNow :&#x3D; t.Add(week)</span><br><span class="line">fmt.Println(weekFromNow) &#x2F;&#x2F; Wed Dec 28 08:52:14 +0000 UTC 2011</span><br><span class="line">&#x2F;&#x2F; formatting times:</span><br><span class="line">fmt.Println(t.Format(time.RFC822))         &#x2F;&#x2F; 21 Dec 11 0852 UTC</span><br><span class="line">fmt.Println(t.Format(time.ANSIC))          &#x2F;&#x2F; Wed Dec 21 08:56:34 2011</span><br><span class="line">fmt.Println(t.Format(&quot;21 Dec 2011 08:52&quot;)) &#x2F;&#x2F; 21 Dec 2011 08:52</span><br><span class="line">s :&#x3D; t.Format(&quot;20060102&quot;)</span><br><span class="line">fmt.Println(t, &quot;&#x3D;&gt;&quot;, s)</span><br><span class="line">&#x2F;&#x2F; Wed Dec 21 08:52:14 +0000 UTC 2011 &#x3D;&gt; 20111221</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、指针"><a href="#10、指针" class="headerlink" title="10、指针"></a>10、指针</h3><p>Go 语言为程序员提供了控制数据结构的指针的能力；但是，你不能进行指针运算。</p><p>Go 语言的取地址符是 &amp;，放到一个变量前使用就会返回相应变量的内存地址。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i1 &#x3D; 5</span><br><span class="line">fmt.Printf(&quot;An integer: %d, it&#39;s location in memory: %p\n&quot;, i1, &amp;i1)</span><br></pre></td></tr></table></figure><p>Go 语言的存地址符是 *，放到一个变量前使用就会返回相应变量的内存地址。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var intP *int &#x3D; &amp;i1</span><br><span class="line"></span><br><span class="line">使用 intP &#x3D; &amp;i1 是合法的，此时 intP 指向 i1。</span><br><span class="line">intP 存储了 i1 的内存地址；它指向了 i1 的位置，它引用了变量 i1。</span><br><span class="line">指针的格式化标识符为 %p。</span><br></pre></td></tr></table></figure><p>一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。</p><p>当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；你可以在指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。</p><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><p>一个指针变量通常缩写为 ptr。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、在书写表达式类似 var p *type 时，切记在 * 号和指针名称间留有一个空格.</span><br><span class="line">因为 var p*type 是语法正确的，但是在更复杂的表达式中，它容易被误认为是一个乘法表达式！</span><br><span class="line"></span><br><span class="line">2、符号 * 可以放在一个指针前，如 *intP，那么它将得到这个指针指向地址上所存储的值；</span><br><span class="line">这被称为反引用（或者内容或者间接引用）操作符；另一种说法是指针转移。</span><br><span class="line"></span><br><span class="line">对于任何一个变量 var， 如下表达式都是正确的：var &#x3D;&#x3D; *(&amp;var)</span><br><span class="line"></span><br><span class="line">3、不能得到一个文字或常量的地址，例如：</span><br><span class="line">const i &#x3D; 5</span><br><span class="line">ptr :&#x3D; &amp;i &#x2F;&#x2F;error: cannot take the address of i</span><br><span class="line">ptr2 :&#x3D; &amp;10 &#x2F;&#x2F;error: cannot take the address of 10</span><br></pre></td></tr></table></figure><p>例子一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var i1 &#x3D; 5</span><br><span class="line">    fmt.Printf(&quot;An integer: %d, its location in memory: %p\n&quot;, i1, &amp;i1)</span><br><span class="line">    var intP *int</span><br><span class="line">    intP &#x3D; &amp;i1</span><br><span class="line">    fmt.Printf(&quot;The value at memory location %p is %d\n&quot;, intP, *intP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    s :&#x3D; &quot;good bye&quot;</span><br><span class="line">    var p *string &#x3D; &amp;s</span><br><span class="line">    *p &#x3D; &quot;ciao&quot;</span><br><span class="line">    fmt.Printf(&quot;Here is the pointer p: %p\n&quot;, p) &#x2F;&#x2F; prints address</span><br><span class="line">    fmt.Printf(&quot;Here is the string *p: %s\n&quot;, *p) &#x2F;&#x2F; prints string</span><br><span class="line">    fmt.Printf(&quot;Here is the string s: %s\n&quot;, s) &#x2F;&#x2F; prints same string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子三：</p><p>对一个空指针的反向引用是不合法的，并且会使程序崩溃：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var p *int &#x3D; nil</span><br><span class="line">*p &#x3D; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; in Windows: stops only with: &lt;exit code&#x3D;&quot;-1073741819&quot; msg&#x3D;&quot;process crashed&quot;&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; runtime error: invalid memory address or nil pointer dereference</span><br></pre></td></tr></table></figure><h2 id="二、控制结构"><a href="#二、控制结构" class="headerlink" title="二、控制结构"></a>二、控制结构</h2><ul><li>if-else 结构</li><li>多返回值函数</li><li>switch 结构</li><li>for (range) 结构</li><li>标签与 goto</li><li>select 结构，用于 channel 的选择</li></ul><h3 id="1、if-else-结构"><a href="#1、if-else-结构" class="headerlink" title="1、if-else 结构"></a>1、if-else 结构</h3><p>关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 } 必须和 else-if 关键字在同一行。这两条规则都是被编译器强制规定的。</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition1 &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125; else if condition2 &#123;</span><br><span class="line">    &#x2F;&#x2F; do something else</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; catch-all or default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 可以包含一个初始化语句（如：给一个变量赋值）。这种写法具有固定的格式（在初始化语句后方必须加上分号）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if initialization; condition &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line">if val :&#x3D; 10; val &gt; max &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但要注意的是，使用简短方式 := 声明的变量的作用域只存在于 if 结构中（在 if 结构的大括号之间，如果使用 if-else 结构则在 else 代码块中变量也会存在）。</p><p>如果变量在 if 结构之前就已经存在，那么在 if 结构中，该变量原来的值会被隐藏。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var first int &#x3D; 10</span><br><span class="line">    var cond int</span><br><span class="line"></span><br><span class="line">    if first &lt;&#x3D; 0 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is less than or equal to 0\n&quot;)</span><br><span class="line">    &#125; else if first &gt; 0 &amp;&amp; first &lt; 5 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is between 0 and 5\n&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;first is 5 or greater\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if cond &#x3D; 5; cond &gt; 10 &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;cond is greater than 10\n&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Printf(&quot;cond is not greater than 10\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、多返回值函数"><a href="#2、多返回值函数" class="headerlink" title="2、多返回值函数"></a>2、多返回值函数</h3><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var orig string &#x3D; &quot;ABC&quot;</span><br><span class="line">    &#x2F;&#x2F; var an int</span><br><span class="line">    var newS string</span><br><span class="line">    &#x2F;&#x2F; var err error</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;The size of ints is: %d\n&quot;, strconv.IntSize)</span><br><span class="line">    &#x2F;&#x2F; anInt, err &#x3D; strconv.Atoi(origStr)</span><br><span class="line">    an, err :&#x3D; strconv.Atoi(orig)</span><br><span class="line">    if err !&#x3D; nil &#123;</span><br><span class="line">        fmt.Printf(&quot;orig %s is not an integer - exiting with error\n&quot;, orig)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;The integer is %d\n&quot;, an)</span><br><span class="line">    an &#x3D; an + 5</span><br><span class="line">    newS &#x3D; strconv.Itoa(an)</span><br><span class="line">    fmt.Printf(&quot;The new string is: %s\n&quot;, newS)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>习惯用法，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value, err :&#x3D; pack1.Function1(param1)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Printf(&quot;An error occured in pack1.Function1 with parameter %v&quot;, param1)</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 未发生错误，继续执行：</span><br></pre></td></tr></table></figure><p>由于本例的函数调用者属于 main 函数，所以程序会直接停止运行。</p><p>如果我们想要在错误发生的同时终止程序的运行，我们可以使用 os 包的 Exit 函数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">    fmt.Printf(&quot;Program stopping with error %v&quot;, err)</span><br><span class="line">    os.Exit(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者将 ok-pattern 的获取放置在 if 语句的初始化部分，然后进行判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if value, ok :&#x3D; readData(); ok &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、switch-结构"><a href="#3、switch-结构" class="headerlink" title="3、switch 结构"></a>3、switch 结构</h3><p>Go 语言中的 switch 结构使用上更加灵活。它接受任意形式的表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch var1 &#123;</span><br><span class="line">    case val1:</span><br><span class="line">        ...</span><br><span class="line">    case val2:</span><br><span class="line">        ...</span><br><span class="line">    default:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 { 必须和 switch 关键字在同一行。</p><p>一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，也就是说您不需要特别使用 break 语句来表示结束。</p><p>因此，程序也不会自动地去执行下一个分支的代码。如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch i &#123;</span><br><span class="line">    case 0: &#x2F;&#x2F; 空分支，只有当 i &#x3D;&#x3D; 0 时才会进入分支</span><br><span class="line">    case 1:</span><br><span class="line">        f() &#x2F;&#x2F; 当 i &#x3D;&#x3D; 0 时函数不会被调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch i &#123;</span><br><span class="line">    case 0: fallthrough</span><br><span class="line">    case 1:</span><br><span class="line">        f() &#x2F;&#x2F; 当 i &#x3D;&#x3D; 0 时函数也会被调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">例一：</span><br><span class="line">var num1 int &#x3D; 100</span><br><span class="line"></span><br><span class="line">switch num1 &#123;</span><br><span class="line">case 98, 99:</span><br><span class="line">fmt.Println(&quot;It&#39;s equal to 98&quot;)</span><br><span class="line">case 100:</span><br><span class="line">fmt.Println(&quot;It&#39;s equal to 100&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;It&#39;s not equal to 98 or 100&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例二：</span><br><span class="line">var num1 int &#x3D; 7</span><br><span class="line"></span><br><span class="line">switch &#123;</span><br><span class="line">case num1 &lt; 0:</span><br><span class="line">fmt.Println(&quot;Number is negative&quot;)</span><br><span class="line">case num1 &gt; 0 &amp;&amp; num1 &lt; 10:</span><br><span class="line">fmt.Println(&quot;Number is between 0 and 10&quot;)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;Number is 10 or greater&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例三:</span><br><span class="line">switch a, b :&#x3D; x[i], y[j]; &#123;</span><br><span class="line">    case a &lt; b: t &#x3D; -1</span><br><span class="line">    case a &#x3D;&#x3D; b: t &#x3D; 0</span><br><span class="line">    case a &gt; b: t &#x3D; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、for-range-结构"><a href="#4、for-range-结构" class="headerlink" title="4、for (range) 结构"></a>4、for (range) 结构</h3><h4 id="第一种形式"><a href="#第一种形式" class="headerlink" title="第一种形式"></a>第一种形式</h4><p>基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for 初始化语句; 条件语句; 修饰语句 &#123;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;This is the %d iteration\n&quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种形式"><a href="#第二种形式" class="headerlink" title="第二种形式"></a>第二种形式</h4><p>基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for 条件语句 &#123;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i int &#x3D; 5</span><br><span class="line"></span><br><span class="line">    for i &gt;&#x3D; 0 &#123;</span><br><span class="line">        i &#x3D; i - 1</span><br><span class="line">        fmt.Printf(&quot;The variable i is now: %d\n&quot;, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三种形式"><a href="#第三种形式" class="headerlink" title="第三种形式"></a>第三种形式</h4><p>无限循环，基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="第四种形式"><a href="#第四种形式" class="headerlink" title="第四种形式"></a>第四种形式</h4><p>for-range 结构，一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ix, val :&#x3D; range coll &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（译者注：如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值）。</p><p>一个字符串是 Unicode 编码的字符（或称之为 rune）集合，因此您也可以用它迭代字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    str :&#x3D; &quot;Go is a beautiful language!&quot;</span><br><span class="line">    fmt.Printf(&quot;The length of str is: %d\n&quot;, len(str))</span><br><span class="line">    for pos, char :&#x3D; range str &#123;</span><br><span class="line">        fmt.Printf(&quot;Character on position %d is: %c \n&quot;, pos, char)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    str2 :&#x3D; &quot;Chinese: 日本語&quot;</span><br><span class="line">    fmt.Printf(&quot;The length of str2 is: %d\n&quot;, len(str2))</span><br><span class="line">    for pos, char :&#x3D; range str2 &#123;</span><br><span class="line">        fmt.Printf(&quot;character %c starts at byte position %d\n&quot;, char, pos)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(&quot;index int(rune) rune    char bytes&quot;)</span><br><span class="line">    for index, rune :&#x3D; range str2 &#123;</span><br><span class="line">        fmt.Printf(&quot;%-2d      %d      %U &#39;%c&#39; % X\n&quot;, index, rune, rune, rune, []byte(string(rune)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、标签与-goto"><a href="#5、标签与-goto" class="headerlink" title="5、标签与 goto"></a>5、标签与 goto</h3><p>for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词（gofmt 会将后续代码自动移至下一行）。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">LABEL1:</span><br><span class="line">    for i :&#x3D; 0; i &lt;&#x3D; 5; i++ &#123;</span><br><span class="line">        for j :&#x3D; 0; j &lt;&#x3D; 5; j++ &#123;</span><br><span class="line">            if j &#x3D;&#x3D; 4 &#123;</span><br><span class="line">                continue LABEL1</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;i is: %d, and j is: %d\n&quot;, i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continue 语句指向 LABEL1，当执行到该语句的时候，就会跳转到 LABEL1 标签的位置。</p><p>您可以看到当 j==4 和 j==5 的时候，没有任何输出：标签的作用对象为外部循环，因此 i 会直接变成下一个循环的值，而此时 j 的值就被重设为 0，即它的初始值。</p><p>如果将 continue 改为 break，则不会只退出内层循环，而是直接退出外层循环了。</p><p>注意：</p><ul><li>标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母</li></ul><p>例子二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">i :&#x3D; 0</span><br><span class="line">HERE:</span><br><span class="line">print(i)</span><br><span class="line">i++</span><br><span class="line">if i &#x3D;&#x3D; 5 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">goto HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot;&gt;&lt;a href=&quot;#摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：go入门相关内容，参考：Go入门指南，主要总结其中：一到五章的内容。&quot;&gt;&lt;/a&gt;摘要：go入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结其中：一到五章的内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/categories/go/"/>
    
    
    <category term="go" scheme="https://www.blog.ajie39.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>git--Fork代码更新与同步</title>
    <link href="https://www.blog.ajie39.top/2022/02/02/git----Fork%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>https://www.blog.ajie39.top/2022/02/02/git----Fork%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%90%8C%E6%AD%A5/</id>
    <published>2022-02-02T13:20:12.729Z</published>
    <updated>2022-02-02T13:39:28.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：记录使用git–Fork代码更新与同步"><a href="#摘要：记录使用git–Fork代码更新与同步" class="headerlink" title="摘要：记录使用git–Fork代码更新与同步"></a>摘要：记录使用git–Fork代码更新与同步</h1><hr><span id="more"></span><h2 id="一、clone-fork的代码"><a href="#一、clone-fork的代码" class="headerlink" title="一、clone fork的代码"></a>一、clone fork的代码</h2><p>git clone xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git clone <a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#105;&#116;&#46;&#112;&#112;&#100;&#97;&#x69;&#x63;&#x6f;&#x72;&#x70;&#46;&#x63;&#111;&#x6d;">&#x67;&#x69;&#x74;&#64;&#103;&#105;&#116;&#46;&#112;&#112;&#100;&#97;&#x69;&#x63;&#x6f;&#x72;&#x70;&#46;&#x63;&#111;&#x6d;</a>:cs-global/phl/cschannel.git</p><h2 id="二、把主仓库加入-remote"><a href="#二、把主仓库加入-remote" class="headerlink" title="二、把主仓库加入 remote"></a>二、把主仓库加入 remote</h2><p>未加入前：</p><p>执行 git remote 则只会有一个仓库</p><p><img src="/img/image/blog/20220202/remote1.png" alt="remote1"></p><p>执行命令，加入主仓库</p><p>git remote add xxxxxname（自定义名字） xxxxxxxxxxxx（主仓库地址）</p><p>例如：</p><p>git remote add main <a href="mailto:&#103;&#105;&#x74;&#64;&#103;&#105;&#116;&#46;&#x70;&#x70;&#100;&#x61;&#x69;&#x63;&#111;&#114;&#112;&#46;&#x63;&#111;&#x6d;">&#103;&#105;&#x74;&#64;&#103;&#105;&#116;&#46;&#x70;&#x70;&#100;&#x61;&#x69;&#x63;&#111;&#114;&#112;&#46;&#x63;&#111;&#x6d;</a>:cs-global/cschannel.git</p><p>再次执行 git remote 命令，则会出现两个选项</p><p><img src="/img/image/blog/20220202/remote2.png" alt="remote2"></p><h2 id="三、同步主仓库分支至本地"><a href="#三、同步主仓库分支至本地" class="headerlink" title="三、同步主仓库分支至本地"></a>三、同步主仓库分支至本地</h2><p>命令：</p><p>git fetch xxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git fetch main</p><h2 id="四、同步主分支代码"><a href="#四、同步主分支代码" class="headerlink" title="四、同步主分支代码"></a>四、同步主分支代码</h2><p>基于 origin/master 分支创建一个临时分支</p><p>例如：</p><p>git branch origin/temp</p><p>然后将 main 分支的代码合并到 origin/temp</p><p>例如：</p><p>git merge main/master<br>解决冲突后，提交代码即可</p><p>注意：</p><p>如果出现如下报错，则需要强制合并</p><p>refusing to merge unrelated histories</p><p>强制合并命令：</p><p>git merge xxxxxxxxxxxxxxxxxxxxxx –allow-unrelated-histories</p><p>例如：</p><p>git merge main/master –allow-unrelated-histories</p><h2 id="五、移除远程分支"><a href="#五、移除远程分支" class="headerlink" title="五、移除远程分支"></a>五、移除远程分支</h2><p>git remote remove xxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git remote remove main</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：记录使用git–Fork代码更新与同步&quot;&gt;&lt;a href=&quot;#摘要：记录使用git–Fork代码更新与同步&quot; class=&quot;headerlink&quot; title=&quot;摘要：记录使用git–Fork代码更新与同步&quot;&gt;&lt;/a&gt;摘要：记录使用git–Fork代码更新与同步&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/categories/git/"/>
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>重写TreeMap的比较器(Comparator)引发的问题（源码分析）</title>
    <link href="https://www.blog.ajie39.top/2022/01/16/%E9%87%8D%E5%86%99TreeMap%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8(Comparator)%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98(%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/"/>
    <id>https://www.blog.ajie39.top/2022/01/16/%E9%87%8D%E5%86%99TreeMap%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8(Comparator)%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98(%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/</id>
    <published>2022-01-16T06:58:04.646Z</published>
    <updated>2022-01-17T12:49:26.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。"><a href="#摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。" class="headerlink" title="摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。"></a>摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。</h1><hr><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>1、给一个无序的map，按照value的值进行排序，value值越小，排在越前面。<br>2、key和value都不为null<br>3、value可能相同<br>4、返回结果为一个相同的有序map</p><p>代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，key=商品id，value=商品剩余库存</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1L</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2L</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="number">3L</span>, <span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，大家可以先想想，如果是你会怎么解决？</p><span id="more"></span><h2 id="我的解决思路"><a href="#我的解决思路" class="headerlink" title="我的解决思路"></a>我的解决思路</h2><p>1、使用TreeMap，因为TreeMap可以对元素进行排序<br>2、重写TreeMap的比较器</p><p>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 承接上面的代码</span></span><br><span class="line"><span class="comment">// 按照 value 排序</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap1 = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long o1, Long o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、如果v1等于v2，则值为0</span></span><br><span class="line">        <span class="comment">// 2、如果v1小于v2，则值为-1</span></span><br><span class="line">        <span class="comment">// 3、如果v1等于v2，则值为1</span></span><br><span class="line">        Integer value1 = map.get(o1);</span><br><span class="line">        Integer value2 = map.get(o2);</span><br><span class="line">        <span class="keyword">return</span> value1.compareTo(value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap1.putAll(map);</span><br><span class="line">System.out.println(treeMap1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>what？为什么我们添加了3个元素，结果少了一个呢？</p><p><img src="/img/image/blog/20220116/%E7%96%91%E9%97%AE.jpg" alt="疑问"></p><h2 id="TreeMap-putAll源码分析"><a href="#TreeMap-putAll源码分析" class="headerlink" title="TreeMap putAll源码分析"></a>TreeMap putAll源码分析</h2><p>让我们来看看 putAll 的具体过程</p><h3 id="1、分析-TreeMap-putAll"><a href="#1、分析-TreeMap-putAll" class="headerlink" title="1、分析 TreeMap.putAll"></a>1、分析 TreeMap.putAll</h3><p>源码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、获取待添加的map的大小</span></span><br><span class="line">    <span class="keyword">int</span> mapSize = map.size();</span><br><span class="line">    <span class="comment">// 二、当前的size大小等于0 且 待添加的map的大小不等于0 且 待添加的map是SortedMap的实现类，则执行以下逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span> &amp;&amp; mapSize!=<span class="number">0</span> &amp;&amp; map <span class="keyword">instanceof</span> SortedMap) &#123;</span><br><span class="line">        <span class="comment">// 1、获取待添加的map的比较器</span></span><br><span class="line">        Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator();</span><br><span class="line">        <span class="comment">// 2、如果两个比较器相同，则执行以下逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (c == comparator || (c != <span class="keyword">null</span> &amp;&amp; c.equals(comparator))) &#123;</span><br><span class="line">            <span class="comment">// 3、修改次数+1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4、基于排序数据的线性时间树构建算法，进行build</span></span><br><span class="line">                buildFromSorted(mapSize, map.entrySet().iterator(),</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三、如果不符合上面的条件，则执行父类的 putAll 方法</span></span><br><span class="line">    <span class="keyword">super</span>.putAll(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面源码，不难看出，我们的数据符合 流程二，但是不符合 流程二-2，所以我们会执行父类的 putAll 方法，即流程三。</p><h3 id="2、分析-AbstractMap-putAll"><a href="#2、分析-AbstractMap-putAll" class="headerlink" title="2、分析 AbstractMap.putAll"></a>2、分析 AbstractMap.putAll</h3><p>TreeMap 继承 AbstractMap，所以 super.putAll(map)，执行的 putAll 为 AbstractMap 的 putAll 方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 m map，将它所有的值，使用put方法，全部添加到当前的map中</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码简单，就是一个遍历添加元素的。</p><p>但是有一个问题，这里的 put 方法执行的是谁的 put 方法呢？</p><ul><li>1、AbstractMap.put</li><li>2、TreeMap.put</li></ul><p>这里大家可以先思考1分钟，然后再继续往下看。</p><p>答案是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行的是 TreeMap.put</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回答错误 or 不知道真实原因的小伙伴，可以去网上搜搜答案，这里是一个很重要的基础知识点哦。</p><h3 id="3、分析-TreeMap-put"><a href="#3、分析-TreeMap-put" class="headerlink" title="3、分析 TreeMap.put"></a>3、分析 TreeMap.put</h3><p>源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、获取根节点</span></span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">// 二、判断跟节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 类型检查 and null 检查</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> TreeMap.Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 三、如果比较器不为空，则执行一下逻辑，即自定义比较器执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 1、将t节点赋值给parent</span></span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 2、比较t节点的key是否与待添加的key相等</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="comment">// 3、如果返回值小于0，则将左子树赋值给t节点，即后续遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="comment">// 4、如果返回值大于0，则将右子树赋值给t节点，即后续遍历右子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 5、如果返回值为0，则覆盖原来的值</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四、如果比较器为空，则执行以下逻辑，即默认执行逻辑</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这部分逻辑，先忽略</span></span><br><span class="line">    &#125;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; e = <span class="keyword">new</span> TreeMap.Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们结合上面的源码和我们自定义的排序器，就可以发现以下问题：</p><p>1、我们比较的是两个 value 的大小，而 value 可能是一样的。</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A81.jpg" alt="比较器1"></p><p>这种情况下，就会覆盖原来的值，这个就是我们执行 putAll 后，元素缺失的原因了。</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A82.jpg" alt="比较器2"></p><p>好了既然问题找到了，那如何解决这个问题呢？</p><p>如果是你，你会怎么解决呢？可以花一分钟时间思考一下，再看后面的内容。</p><h3 id="4、解决-TreeMap-putAll，元素缺失的问题"><a href="#4、解决-TreeMap-putAll，元素缺失的问题" class="headerlink" title="4、解决 TreeMap.putAll，元素缺失的问题"></a>4、解决 TreeMap.putAll，元素缺失的问题</h3><p>我当时想到最直接的方案就是，在 value 相等的情况下，不返回 0，返回1 or -1，这样就可以最简单、最快捷的解决这个问题了。</p><p>修改后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里换了一种写法，是java8的特性，简化了代码（为了偷懒）</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap2 = <span class="keyword">new</span> TreeMap&lt;&gt;((key1, key2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 1、如果v1等于v2，则值为0</span></span><br><span class="line">    <span class="comment">// 2、如果v1小于v2，则值为-1</span></span><br><span class="line">    <span class="comment">// 3、如果v1等于v2，则值为1</span></span><br><span class="line">    Integer value1 = map.get(key1);</span><br><span class="line">    Integer value2 = map.get(key2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value1.compareTo(value2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">treeMap2.putAll(map);</span><br><span class="line">System.out.println(treeMap2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>=<span class="number">10</span>, <span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以发现，3个值都有了，并且是有序的，完美符合需求！好了，关机下班！</p><p><img src="/img/image/blog/20220116/%E5%85%B3%E6%9C%BA%E4%B8%8B%E7%8F%AD.webp" alt="关机下班"></p><p>然而事情并没有结束<strong>（大家可以想一下，这样写会有什么问题呢？）</strong>！</p><h2 id="新的问题出现"><a href="#新的问题出现" class="headerlink" title="新的问题出现"></a>新的问题出现</h2><p>第二天，高高兴兴的写着业务代码、调试逻辑，突然一个<strong>空指针</strong>的报错，出现了。这也太常见了吧，3分钟内解决！</p><p><img src="/img/image/blog/20220116/2000%E5%B9%B4%E4%B9%8B%E5%90%8E.jpeg" alt="2000年之后"></p><p>排查了半天，发现又回到了昨天的修改的那段逻辑了。</p><h3 id="1、TreeMap-get-获取不到值"><a href="#1、TreeMap-get-获取不到值" class="headerlink" title="1、TreeMap.get 获取不到值"></a>1、TreeMap.get 获取不到值</h3><p>简化版代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，key=商品id，value=商品剩余库存</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1L</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2L</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="number">3L</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap2 = <span class="keyword">new</span> TreeMap&lt;&gt;((key1, key2) -&gt; &#123;</span><br><span class="line">    Integer value1 = map.get(key1);</span><br><span class="line">    Integer value2 = map.get(key2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value1.compareTo(value2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap2.putAll(map);</span><br><span class="line">System.out.println(treeMap2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取商品1的剩余数量</span></span><br><span class="line">Integer quantity = treeMap2.get(<span class="number">1L</span>);</span><br><span class="line">System.out.println(quantity);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>=<span class="number">10</span>, <span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个结果令我百思不得其解，只能看看源码咯。</p><h3 id="2、分析-TreeMap-get"><a href="#2、分析-TreeMap-get" class="headerlink" title="2、分析 TreeMap.get"></a>2、分析 TreeMap.get</h3><p>源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据key获取节点</span></span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="comment">// 节点为空则返回null，否则返回节点的 value 值</span></span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、如果比较器不为空，则执行一下逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 1、使用自定义比较器取出key对应的节点</span></span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// 二、如果比较器为空，且key为null，则抛空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">// 三、取出key对应的节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码，我们可以发现，问题肯定就是出现在 getEntryUsingComparator 方法里了。</p><h3 id="2、分析-TreeMap-getEntryUsingComparator"><a href="#2、分析-TreeMap-getEntryUsingComparator" class="headerlink" title="2、分析 TreeMap.getEntryUsingComparator"></a>2、分析 TreeMap.getEntryUsingComparator</h3><p>源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、将key转换成对应的类型</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    K k = (K) key;</span><br><span class="line">    <span class="comment">// 二、获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 三、判断比较器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、遍历map，取出key对应的节点对象</span></span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="comment">// 2、如果小于0，则将左节点的值赋值给p</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="comment">// 3、如果大于0，则将右节点的值赋值给p</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 4、如果等于0，则返回p节点</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合上面的源码，和我们之前自定义的比较器，我们不难发现问题出现在哪里：</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A83.jpg" alt="比较器3"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自定义比较器，没有返回0的情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题找到了，解决吧！<br>加班中，今天到此结束！<br>啊杰，在这里谢谢大家的观看，下次再见。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot;&gt;&lt;a href=&quot;#摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot; class=&quot;headerlink&quot; title=&quot;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot;&gt;&lt;/a&gt;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;1、给一个无序的map，按照value的值进行排序，value值越小，排在越前面。&lt;br&gt;2、key和value都不为null&lt;br&gt;3、value可能相同&lt;br&gt;4、返回结果为一个相同的有序map&lt;/p&gt;
&lt;p&gt;代码如下所示:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 假设，key=商品id，value=商品剩余库存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Map&amp;lt;Long, Integer&amp;gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;2L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;3L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;到这里，大家可以先想想，如果是你会怎么解决？&lt;/p&gt;</summary>
    
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    <category term="Map" scheme="https://www.blog.ajie39.top/tags/Map/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="源码分析" scheme="https://www.blog.ajie39.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Jackson序列化时间类型的数据导致的相关问题</title>
    <link href="https://www.blog.ajie39.top/2021/12/03/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://www.blog.ajie39.top/2021/12/03/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-02T17:17:52.573Z</published>
    <updated>2022-02-04T15:03:56.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。"><a href="#前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。" class="headerlink" title="前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。"></a>前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。</h1><hr><span id="more"></span><h2 id="1、现象"><a href="#1、现象" class="headerlink" title="1、现象"></a>1、现象</h2><p>在开发国际化项目中发现，数据库取出的时间和对象拿到的时间都是一致的，但是通过 postman 调用接口展示的时候，时间和数据库的时间相差8小时。</p><h2 id="2、原因"><a href="#2、原因" class="headerlink" title="2、原因"></a>2、原因</h2><p>SpringBoot 默认使用 Jackson 为序列化工具，Jackson 在没有指定序列化和反序列化形式的情况下，会采用默认的序列化方式。</p><p>其中 date 类型的数据，默认的序列化格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ</span><br><span class="line">例如：</span><br><span class="line"> 2021-06-08T05:43:28.000+0000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中时间的默认时区为UTC+0，在传输的过程中，会以字符串的形式按照上面的格式进行序列化。而国内的时区是 UTC+8，所以最终时间会相差 8小时。</p><p>各个符号解释：</p><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>YYYY</td><td>is the decimal digits of the year 0000 to 9999 in the Gregorian calendar.</td></tr><tr><td>-</td><td>“-“ (hyphen) appears literally twice in the string.</td></tr><tr><td>MM</td><td>is the month of the year from 01 (January) to 12 (December).</td></tr><tr><td>DD</td><td>is the day of the month from 01 to 31.</td></tr><tr><td>T</td><td>“T” appears literally in the string, to indicate the beginning of the time element.</td></tr><tr><td>HH</td><td>is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.</td></tr><tr><td>:</td><td>“:” (colon) appears literally twice in the string.</td></tr><tr><td>mm</td><td>is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.</td></tr><tr><td>ss</td><td>is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.</td></tr><tr><td>.</td><td>“.” (dot) appears literally in the string.</td></tr><tr><td>sss</td><td>is the number of complete milliseconds since the start of the second as three decimal digits.</td></tr><tr><td>Z</td><td>is the time zone offset specified as “Z” (for UTC) or either “+” or “-“ followed by a time expression HH:mm</td></tr></tbody></table><h2 id="3、解决"><a href="#3、解决" class="headerlink" title="3、解决"></a>3、解决</h2><h3 id="①前端拿到这样的数据的时候，需要做如下处理："><a href="#①前端拿到这样的数据的时候，需要做如下处理：" class="headerlink" title="①前端拿到这样的数据的时候，需要做如下处理："></a>①前端拿到这样的数据的时候，需要做如下处理：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Date(&#39;2021-06-08T05:43:28.000+0000&#39;)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">moment(date).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化前后的区别：</p><p><img src="/img/image/blog/20220204/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt="格式化后的效果"></p><h3 id="②如果使用-Fegin-Client"><a href="#②如果使用-Fegin-Client" class="headerlink" title="②如果使用 Fegin Client"></a>②如果使用 Fegin Client</h3><p>需要确认服务端的时间格式，如果没有指定格式，则使用默认格式。</p><p>具体使用：在对应字段加上 @JsonFormat 注解即可，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING, pattern &#x3D; &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;)</span><br><span class="line">private Date inserttime;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="③SpringBoot-全局配置-JsonFormat-date的序列化方式"><a href="#③SpringBoot-全局配置-JsonFormat-date的序列化方式" class="headerlink" title="③SpringBoot 全局配置 JsonFormat date的序列化方式"></a>③SpringBoot 全局配置 JsonFormat date的序列化方式</h3><p>在 application.yml 文件加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ssZ</span><br><span class="line">  mvc:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ssZ</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、其他问题"><a href="#4、其他问题" class="headerlink" title="4、其他问题"></a>4、其他问题</h2><p>①支持 Java 8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-datatype-jsr310&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在添加 JSR-310 模块后, 让 jackson 能够识别出 Java 8 的日期 &amp; 时间类型(pom.xml)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/aerchi/article/details/78717232">https://blog.csdn.net/aerchi/article/details/78717232</a></p><p><a href="https://xiaoym.gitee.io/2021/03/26/spring-boot-code-action-jackson/">https://xiaoym.gitee.io/2021/03/26/spring-boot-code-action-jackson/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。&quot;&gt;&lt;a href=&quot;#前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。&quot; class=&quot;headerlink&quot; title=&quot;前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。&quot;&gt;&lt;/a&gt;前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Jackson" scheme="https://www.blog.ajie39.top/tags/Jackson/"/>
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>算法--排序奇升偶降链表</title>
    <link href="https://www.blog.ajie39.top/2021/11/21/%E6%8E%92%E5%BA%8F%E5%A5%87%E5%8D%87%E5%81%B6%E9%99%8D%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.blog.ajie39.top/2021/11/21/%E6%8E%92%E5%BA%8F%E5%A5%87%E5%8D%87%E5%81%B6%E9%99%8D%E9%93%BE%E8%A1%A8/</id>
    <published>2021-11-21T07:36:47.986Z</published>
    <updated>2021-11-21T07:47:42.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分"><a href="#摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分" class="headerlink" title="摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分"></a>摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分</h1><hr><h1 id="前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。"><a href="#前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。" class="headerlink" title="前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。"></a>前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。</h1><p>输入: 1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;NULL</p><p>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL</p><hr><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：根据奇偶顺序，将链表拆分成两个链表</p><p>第二步：将偶链表，翻转，变成升序链表(这部分可以优化，在第一步拆分链表时，就将链表翻转)</p><p>第三步：排序两个链表</p><p>leetcode 类似题目：</p><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">奇偶链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></p><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ListNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;val=&quot;</span> + val +</span><br><span class="line">                <span class="string">&quot;, next=&quot;</span> + next +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;NULL</span></span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">8</span>,</span><br><span class="line">                <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">6</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>,</span><br><span class="line">                        <span class="keyword">new</span> ListNode(<span class="number">7</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>))))))));</span><br><span class="line">        sortList(listNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">sortList</span><span class="params">(ListNode root)</span> </span>&#123;</span><br><span class="line">        ListNode rootNode = <span class="keyword">new</span> ListNode(root.val, root.next);</span><br><span class="line">        ListNode leftRoot = <span class="keyword">null</span>;</span><br><span class="line">        ListNode leftTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode rightRoot = <span class="keyword">null</span>;</span><br><span class="line">        ListNode rightTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分成两个链表</span></span><br><span class="line">        <span class="keyword">while</span> (rootNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 找出奇数链表</span></span><br><span class="line">                <span class="keyword">if</span> (leftRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    leftTemp.val = rootNode.val;</span><br><span class="line">                    leftRoot = leftTemp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    leftTemp.next = <span class="keyword">new</span> ListNode(rootNode.val);</span><br><span class="line">                    leftTemp = leftTemp.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rightRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rightTemp.val = rootNode.val;</span><br><span class="line">                    rightRoot = rightTemp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 找出偶数链表并翻转链表</span></span><br><span class="line">                    rightRoot = <span class="keyword">new</span> ListNode(rootNode.val, rightTemp);</span><br><span class="line">                    rightTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">                    rightTemp.val = rightRoot.val;</span><br><span class="line">                    rightTemp.next = rightRoot.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rootNode = rootNode.next;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表排序</span></span><br><span class="line">        rootNode = <span class="keyword">null</span>;</span><br><span class="line">        ListNode rootTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> leftNum = leftRoot.val;</span><br><span class="line">               <span class="keyword">if</span> (rightRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">int</span> rightNum = rightRoot.val;</span><br><span class="line">                   <span class="keyword">if</span> (leftNum &gt; rightNum) &#123;</span><br><span class="line">                       ListNode[] listArr = getNode(rootNode, rootTemp, rightRoot);</span><br><span class="line">                       rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">                       rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">                       rightRoot = rightRoot.next;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               ListNode[] listArr = getNode(rootNode, rootTemp, leftRoot);</span><br><span class="line">               rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">               rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">               leftRoot = leftRoot.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode[] listArr = getNode(rootNode, rootTemp, rightRoot);</span><br><span class="line">                rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">                rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">                rightRoot = rightRoot.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rootNode);</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode[] getNode(ListNode rootNode, ListNode rootTemp, ListNode transferNode) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = transferNode.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rootTemp.val = num;</span><br><span class="line">            rootNode = rootTemp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rootTemp.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            rootTemp = rootTemp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;rootNode, rootTemp&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot;&gt;&lt;a href=&quot;#摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot; class=&quot;headerlink&quot; title=&quot;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot;&gt;&lt;/a&gt;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot;&gt;&lt;a href=&quot;#前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot; class=&quot;headerlink&quot; title=&quot;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot;&gt;&lt;/a&gt;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&lt;/h1&gt;&lt;p&gt;输入: 1-&amp;gt;8-&amp;gt;3-&amp;gt;6-&amp;gt;5-&amp;gt;4-&amp;gt;7-&amp;gt;2-&amp;gt;NULL&lt;/p&gt;
&lt;p&gt;输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;NULL&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://www.blog.ajie39.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试题目总结（非完整版，待补充）</title>
    <link href="https://www.blog.ajie39.top/2021/11/14/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2021/11/14/Java%20%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-14T07:21:41.423Z</published>
    <updated>2022-04-27T14:30:29.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言：主要总结这段时间遇到过的常见面试题目。"><a href="#前言：主要总结这段时间遇到过的常见面试题目。" class="headerlink" title="前言：主要总结这段时间遇到过的常见面试题目。"></a>前言：主要总结这段时间遇到过的常见面试题目。</h1><hr><h2 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h2><ul><li>Java 基础</li><li>算法</li><li>多线程</li><li>计算机网络</li><li>JVM</li><li>Mysql</li><li>Redis</li><li>消息中间件：Kafka、RabbitMQ</li><li>SpringBoot、SpringCloud</li><li>分布式系统</li><li>高可用系统</li><li>开放性题目</li></ul><span id="more"></span><h2 id="二、Java-基础"><a href="#二、Java-基础" class="headerlink" title="二、Java 基础"></a>二、Java 基础</h2><ul><li>1、Objects.equals(3L, 3) 返回结果是什么，为什么?</li><li>2、Java 的基本类型有哪些，分别占多少个字符。</li><li>3、重载、重写的区别？</li><li>4、什么时候继承父类？什么时候实现接口？</li><li>5、对象的创建过程。</li><li>6、常见的集合有哪些？它们都有哪些特性？</li><li>7、HashMap 和 HashTable 的区别？</li><li>8、HashTable 为什么是安全的？</li><li>9、Hashtable、ConcurrentHashMap、TreeMap</li><li>10、ArrayList</li><li>11、什么是双亲委派机制（类加载）？</li><li>12、什么是反射机制？反射机制的使用场景有哪些？</li><li>13、Java 8的新特性有哪些？</li></ul><h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><ul><li>冒泡排序、快速排序</li><li>链表翻转</li><li>给一个链表，奇数位为升序，偶数位是降序，从小到大排序。</li><li>如何判断一个链表中是否有环？</li><li>找出两个链表的交点。</li><li>有100杯咖啡，小A一次拿2杯，小B一次拿3杯，使用Java多线程模拟该场景，打印出每次拿完咖啡后，剩余的咖啡数量。</li></ul><p>必刷 LeetCode 题目：</p><ul><li>LeetCode 001. Two Sum</li><li>LeetCode 015. 3Sum (可能会问 LeetCode 18. 4Sum 思路)</li><li>LeetCode 020. Valid Parentheses</li><li>LeetCode 021. Merge Two Sorted Lists</li><li>LeetCode 025. Reverse Nodes in k-Group</li><li>LeetCode 053. Maximum Subarray</li><li>LeetCode 066. Plus One（等价于：高精度加法）</li><li>LeetCode 098. Validate Binary Search Tree</li><li>LeetCode 110. Balanced Binary Tree</li><li>LeetCode 134. Gas Station</li><li>LeetCode 136. Single Number</li><li>LeetCode 137. Single Number II</li><li>LeetCode 146. LRU Cache（变形题：带有过期时间的 LRU 缓存）</li><li>LeetCode 206. Reverse Linked List</li><li>LeetCode 215. Kth Largest Element in an Array（等价于：快速排序）</li><li>LeetCode 232. Implement Queue using Stacks</li><li>LeetCode 328. Odd Even Linked List</li><li>LeetCode 415. Add Strings（等价于：大数加法）</li><li>LeetCode 470：rand7() rand10()</li><li>LeetCode 496. Next Greater Element I（时间复杂度O(n)）</li><li>LeetCode 716. Max Stack（两个栈实现最大栈，要求 pop，push，get_max 都为O(1)）</li><li>LeetCode 860. Lemonade Change</li><li>LeetCode 862. Shortest Subarray with Sum at Least K</li><li>LeetCode 876. Middle of the Linked List</li><li>LeetCode 946. Validate Stack Sequences</li></ul><p>字节算法汇总：<a href="https://leetcode-cn.com/circle/discuss/nBoYGv/">https://leetcode-cn.com/circle/discuss/nBoYGv/</a></p><h2 id="四、多线程"><a href="#四、多线程" class="headerlink" title="四、多线程"></a>四、多线程</h2><ul><li>1、什么是线程？什么事进程？</li><li>2、CAS是什么，用来解决什么问题？</li><li>3、什么是 BIO？什么是 NIO？两者的区别是什么</li><li>4、AQS</li></ul><h2 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a>五、计算机网络</h2><ul><li>1、三次握手、四次挥手</li><li>2、IO模型：NIO、BIO 多路复用</li><li>3、多路复用</li></ul><h2 id="六、JVM"><a href="#六、JVM" class="headerlink" title="六、JVM"></a>六、JVM</h2><ul><li>1、JVM 内存模型</li><li>2、垃圾回收算法有哪些？</li><li>3、jvm 复制算法、标记算法</li><li>4、垃圾回收器</li></ul><h2 id="七、Mysql"><a href="#七、Mysql" class="headerlink" title="七、Mysql"></a>七、Mysql</h2><p>在线练习sql，地址：<a href="https://sqlzoo.net/wiki/SELECT_basics/zh">https://sqlzoo.net/wiki/SELECT_basics/zh</a></p><ul><li>1、有哪些数据库引擎</li><li>2、事务的隔离级别</li><li>3、mysql是如何实现对应的事务隔离级别的</li><li>4、索引优化</li><li>5、哪些情况不走索引</li><li>6、执行一条sql查询的整个过程</li><li>7、如何实现可重复读</li></ul><h2 id="八、Redis"><a href="#八、Redis" class="headerlink" title="八、Redis"></a>八、Redis</h2><ul><li>1、redis 基础数据结构</li><li>2、redis 数据结构的底层实现</li><li>3、redis 持久化方式</li><li>4、AOF追加写操作，文件超过阈值，会如何处理</li><li>5、AOF重写机制</li><li>6、动态字符串的底层实现</li><li>7、redis 使用场景</li></ul><h2 id="九、消息中间件"><a href="#九、消息中间件" class="headerlink" title="九、消息中间件"></a>九、消息中间件</h2><p>Kafka、RabbitMQ</p><ul><li>1、生产一条消息的整个过程</li><li>2、kafka 的存储</li><li>3、kafka 中的一些基本概念</li><li>4、kafka 消费一条消息的过程</li><li>5、kafka 如何保证消息不丢的</li><li>6、生产一条消息的整个过程</li></ul><h2 id="十、SpringBoot、SpringCloud"><a href="#十、SpringBoot、SpringCloud" class="headerlink" title="十、SpringBoot、SpringCloud"></a>十、SpringBoot、SpringCloud</h2><ul><li>1、SpringBoot的启动过程</li><li>2、Spring 中的 SPI 机制是什么？</li><li>3、JDK、Dubbo、Spring 三种 SPI 机制，谁更好？</li><li>4、Spring 自定义注解的实现原理</li></ul><h2 id="十一、分布式系统"><a href="#十一、分布式系统" class="headerlink" title="十一、分布式系统"></a>十一、分布式系统</h2><ul><li>1、分布式事务</li><li>2、微服务相关内容</li><li>3、服务注册发现</li><li>4、GRPC</li></ul><h2 id="十二、高可用系统"><a href="#十二、高可用系统" class="headerlink" title="十二、高可用系统"></a>十二、高可用系统</h2><h2 id="十三、开放性题目"><a href="#十三、开放性题目" class="headerlink" title="十三、开放性题目"></a>十三、开放性题目</h2><ul><li>1、介绍一下自己</li><li>2、项目经历<ul><li>项目中难点、有意思的点</li><li>项目中用到的中间件</li><li>设计思路</li></ul></li><li>3、离职原因</li><li>4、内存占用 100% 排查问题</li><li>5、并发高，会造成什么问题</li><li>6、堆栈溢出</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><ul><li><a href="https://www.cnblogs.com/rocker-pg/p/11635414.html">MySQL索引_组合索引和单列索引</a></li><li>单列索引和组合索引效率问题</li><li>聚簇索引和非聚簇索引</li><li><a href="https://www.php.cn/mysql-tutorials-483811.html">深入了解MySQL中的组合索引，看看与单列索引的区别</a></li><li><a href="https://juejin.cn/post/6844904180440629262">MySQL是如何实现可重复读的</a></li><li><a href="https://zhuanlan.zhihu.com/p/166152616">MySQL 的可重复读到底是怎么实现的？图解 ReadView 机制</a></li><li><a href="https://www.cnblogs.com/mengxinJ/p/14045520.html">一条 sql 的执行过程详解</a></li><li><a href="https://cloud.tencent.com/developer/article/1635488">一条查询SQL的执行过程</a></li><li>mysql 事务隔离级别，及其实现原理</li></ul><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><ul><li><a href="https://segmentfault.com/a/1190000040633029">7张图了解kafka基本概念</a></li><li><a href="https://zhuanlan.zhihu.com/p/366375032">Kafka概念和基本架构</a></li><li><a href="https://segmentfault.com/a/1190000039125247">怎么理解 Kafka 消费者与消费组之间的关系?</a></li><li><a href="https://segmentfault.com/a/1190000037689992">(三)Kafka的生产者原理及使用详解</a></li><li><a href="https://www.zhenchao.org/categories/kafka/">blog-Kafka</a></li><li><a href="https://cloud.tencent.com/developer/article/1618180">Kafka精进 | 一文读懂Producer消息发送机制</a></li><li><a href="https://www.cnblogs.com/frankdeng/p/9310704.html">Kafka（三）Kafka的高可用与生产消费过程解析</a></li><li><a href="https://dunwu.github.io/bigdata-tutorial/kafka/Kafka%E6%B6%88%E8%B4%B9%E8%80%85.html#_1-%E6%B6%88%E8%B4%B9%E8%80%85%E7%AE%80%E4%BB%8B">Kafka 消费者</a></li></ul><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul><li><a href="https://segmentfault.com/a/1190000039208726">Redis专题：万字长文详解持久化原理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言：主要总结这段时间遇到过的常见面试题目。&quot;&gt;&lt;a href=&quot;#前言：主要总结这段时间遇到过的常见面试题目。&quot; class=&quot;headerlink&quot; title=&quot;前言：主要总结这段时间遇到过的常见面试题目。&quot;&gt;&lt;/a&gt;前言：主要总结这段时间遇到过的常见面试题目。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、目录&quot;&gt;&lt;a href=&quot;#一、目录&quot; class=&quot;headerlink&quot; title=&quot;一、目录&quot;&gt;&lt;/a&gt;一、目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java 基础&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;计算机网络&lt;/li&gt;
&lt;li&gt;JVM&lt;/li&gt;
&lt;li&gt;Mysql&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;消息中间件：Kafka、RabbitMQ&lt;/li&gt;
&lt;li&gt;SpringBoot、SpringCloud&lt;/li&gt;
&lt;li&gt;分布式系统&lt;/li&gt;
&lt;li&gt;高可用系统&lt;/li&gt;
&lt;li&gt;开放性题目&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何写容易测试的代码（结尾附带单元测试神器推荐）</title>
    <link href="https://www.blog.ajie39.top/2021/10/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E5%8F%A6%E6%9C%89%E7%A5%9E%E5%99%A8%E5%88%86%E4%BA%AB%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/10/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E5%8F%A6%E6%9C%89%E7%A5%9E%E5%99%A8%E5%88%86%E4%BA%AB%EF%BC%89/</id>
    <published>2021-10-24T16:13:02.000Z</published>
    <updated>2021-12-13T16:24:00.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。"><a href="#摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。" class="headerlink" title="摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。"></a>摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。</h1><hr><h1 id="前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。"><a href="#前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。" class="headerlink" title="前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。"></a>前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。</h1><hr><span id="more"></span><h2 id="关于单元测试"><a href="#关于单元测试" class="headerlink" title="关于单元测试"></a>关于单元测试</h2><h3 id="一、什么是单元测试？"><a href="#一、什么是单元测试？" class="headerlink" title="一、什么是单元测试？"></a>一、什么是单元测试？</h3><p>单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p><p>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是必须的，但也不坏，这牵涉到项目管理的政策决定。</p><p><strong>总结：对于程序单元（软件设计的最小单位）进行正确性检验。</strong></p><h3 id="二、关于编写单元测试的一些声音"><a href="#二、关于编写单元测试的一些声音" class="headerlink" title="二、关于编写单元测试的一些声音"></a>二、关于编写单元测试的一些声音</h3><p>不愿写单元测试的人，千篇一律——这里收集了一些网友们不愿意写单元测试的原因：</p><ul><li>开发时间太紧张了，还要写单元测试？没时间呀！！！有时间我也愿意写。</li><li>我直接进行接口测试、功能测试、集成测试、系统测试。。。不就行了，速度快，而且效率高，要写啥单元测试。</li><li>有测试工程师了，我要写啥单元测试，让测试工程师测试不就好了，分工明确。</li><li>单元测试仅仅是证明这些代码做了什么，写了没有意义呀，这些代码都是我写的，我知道它们是做什么的。</li><li>测试代码的正确性，是测试工程师的工作，如果我找出了所有问题，我的工资可以翻倍吗？</li><li>我在开发环境发布后，通过测试业务，来验证我代码的正确性就好了，不需要通过单元测试。</li></ul><p>总结：</p><ul><li>开发时间太紧张，写单元测试太耗费时间。</li><li>有其他测试流程做了单元测试做的事情，没必要重复劳动。</li><li>开发工程师负责开发，测试工程师负责测试。</li><li>写单元测试对于我没有收益。</li><li>我可以直接执行代码，来验证正确性，没必要通过单元测试。</li><li>代码都是我写的，我知道是做什么的，写单元测试没有意义。</li></ul><h3 id="二、单元测试的好处"><a href="#二、单元测试的好处" class="headerlink" title="二、单元测试的好处"></a>二、单元测试的好处</h3><h4 id="1、适应变更"><a href="#1、适应变更" class="headerlink" title="1、适应变更"></a>1、适应变更</h4><p>单元测试允许程序员在未来重构代码，并且确保模块依然工作正确（复合测试）。这个过程就是为所有函数和方法编写单元测试，一旦变更导致错误发生，借助于单元测试可以快速定位并修复错误。</p><p>可读性强的单元测试可以使程序员方便地检查代码片断是否依然正常工作。良好设计的单元测试案例覆盖程序单元分支和循环条件的所有路径。</p><p>在连续的单元测试环境，通过其固有的持续维护工作，单元测试可以延续用于准确反映当任何变更发生时可执行程序和代码的表现。借助于上述开发实践和单元测试的覆盖，可以分分秒秒维持准确性。</p><p>总结：</p><ul><li>代码变更后，快速的验证业务逻辑是否正确，快速定位问题。一定程度上，缓解不敢更改老旧逻辑的情况。</li></ul><h4 id="2、简化集成"><a href="#2、简化集成" class="headerlink" title="2、简化集成"></a>2、简化集成</h4><p>单元测试消除程序单元的不可靠，采用自底向上的测试路径。通过先测试程序部件再测试部件组装，使集成测试变得更加简单。</p><p>业界对于人工集成测试的必要性存在较大争议。尽管精心设计的单元测试体系看上去实现了集成测试，因为集成测试需要人为评估一些人为因素才能证实的方面，单元测试替代集成测试不可信。一些人认为在足够的自动化测试系统的条件下，人力集成测试组不再是必需的。事实上，真实的需求最终取决于开发产品的特点和使用目标。另外，人工或手动测试很大程度上依赖于组织的可用资源。</p><p>总结：</p><ul><li>在开发过程中，可以屏蔽部分外部依赖，验证程序的正确性。</li></ul><h4 id="3、文档记录"><a href="#3、文档记录" class="headerlink" title="3、文档记录"></a>3、文档记录</h4><p>单元测试提供了系统的一种文档记录。借助于查看单元测试提供的功能和单元测试中如何使用程序单元，开发人员可以直观的理解程序单元的基础API。</p><p>单元测试具体表现了程序单元成功的关键特点。这些特点可以指出正确使用和非正确使用程序单元，也能指出需要捕获的程序单元的负面表现（译注：异常和错误）。尽管很多软件开发环境不仅依赖于代码做为产品文档，在单元测试中和单元测试本身确实文档化了程序单元的上述关键特点。</p><p>另一方面，传统文档易受程序本身实现的影响，并且时效性难以保证（如设计变更、功能扩展等在不太严格时经常不能保持文档同步更新）。</p><ul><li>有助于他人或者自己（在自己遗忘的情况下）快速了解业务逻辑。</li></ul><h4 id="4、表达设计（测试驱动开发）"><a href="#4、表达设计（测试驱动开发）" class="headerlink" title="4、表达设计（测试驱动开发）"></a>4、表达设计（测试驱动开发）</h4><p>在测试驱动开发的软件实践中，单元测试可以取代正式的设计。每一个单元测试案例均可以视为一项类、方法和待观察行为等设计元素。</p><p>不同于其他基于图的设计方法，用单元测试表达设计有一项显著优点：设计文档（单元测试本身）可以用于验证程序实现符合设计。UML可能会遇到这样的问题：尽管图上一个类被命名为Customer，但开发人员可以称其为Wibble，而且系统中没有任何地方会显示出这个差异。基于单元测试设计方法，开发人员不遵循设计要求的解决方案永远不会通过测试。</p><p>当然，单元测试缺乏图的可读性，但UML图可以在自由工具（通常可从IDE扩展获取）中为大多数现代程序语言生成UML图，很难要求采购昂贵的UML设计套装软件。自由工具，类似于基于xUnit框架的工具，测试结果输出到一些可生成供人工识读的图形化工具系统中去。</p><p>总结：</p><ul><li>测试驱动开发，利用单元测试表达接口设计</li></ul><h2 id="如何写好单元测试？"><a href="#如何写好单元测试？" class="headerlink" title="如何写好单元测试？"></a>如何写好单元测试？</h2><p>虚假的标题：如何写好单元测试</p><p>真实的标题：如何写容易测试的代码</p><p>编写单元测试没有任何技巧，只有编写可测试代码的技巧。</p><p><img src="/img/image/blog/20211024/%E9%97%AE%E5%8F%B7.jpeg" alt="问号"></p><p>为什么说编写单元测试没有任何技巧呢？因为单元测试的本质就是验证你代码的正确性，代码如果写的不好、不可被单独测试，那么单元测试也无能为力。单元测试本来就是枯燥的事情，并没有任何捷径。</p><h3 id="一、为什么写容易测试的代码很重要？"><a href="#一、为什么写容易测试的代码很重要？" class="headerlink" title="一、为什么写容易测试的代码很重要？"></a>一、为什么写容易测试的代码很重要？</h3><p>渣男：我在忙，晚点聊</p><p>暖男：我正在开会，大概6.30左右结束，到时候回复你。</p><p>容易测试的代码通常意味：</p><ul><li>更容易理解：更容易理解意图，写出有效的测试case</li><li>更好维护：容易单元测试的代码一般解耦做的更好，便于后期维护</li></ul><p>于是乎，容易测试——》容易理解——》容易维护，三者形成了闭环。</p><p><img src="/img/image/blog/20211024/%E5%AE%B9%E6%98%93%E6%B5%8B%E8%AF%95.png" alt="容易测试"></p><h3 id="二、导致测试不好写的几类问题"><a href="#二、导致测试不好写的几类问题" class="headerlink" title="二、导致测试不好写的几类问题"></a>二、导致测试不好写的几类问题</h3><h4 id="1、复杂的构造函数-or-无参的构造函数"><a href="#1、复杂的构造函数-or-无参的构造函数" class="headerlink" title="1、复杂的构造函数 or 无参的构造函数"></a>1、复杂的构造函数 or 无参的构造函数</h4><p><img src="/img/image/blog/20211024/%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png" alt="复杂的构造函数"></p><h4 id="2、混合业务逻辑和构建依赖对象的逻辑"><a href="#2、混合业务逻辑和构建依赖对象的逻辑" class="headerlink" title="2、混合业务逻辑和构建依赖对象的逻辑"></a>2、混合业务逻辑和构建依赖对象的逻辑</h4><p><img src="/img/image/blog/20211024/%E6%B7%B7%E5%90%88%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%92%8C%E6%9E%84%E5%BB%BA%E4%BE%9D%E8%B5%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%BB%E8%BE%91.png" alt="混合业务逻辑和构建依赖对象的逻辑"></p><h4 id="3、太多、嵌套太深的条件判断语句"><a href="#3、太多、嵌套太深的条件判断语句" class="headerlink" title="3、太多、嵌套太深的条件判断语句"></a>3、太多、嵌套太深的条件判断语句</h4><p><img src="/img/image/blog/20211024/%E5%A4%AA%E5%A4%9A%E3%80%81%E5%B5%8C%E5%A5%97%E5%A4%AA%E6%B7%B1%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5.png" alt="太多、嵌套太深的条件判断语句"></p><h4 id="4、不必要的、太深的继承"><a href="#4、不必要的、太深的继承" class="headerlink" title="4、不必要的、太深的继承"></a>4、不必要的、太深的继承</h4><p><img src="/img/image/blog/20211024/%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E3%80%81%E5%A4%AA%E6%B7%B1%E7%9A%84%E7%BB%A7%E6%89%BF.png" alt="不必要的、太深的继承"></p><h4 id="5、在一个方法内混合纯计算与IO"><a href="#5、在一个方法内混合纯计算与IO" class="headerlink" title="5、在一个方法内混合纯计算与IO"></a>5、在一个方法内混合纯计算与IO</h4><p><img src="/img/image/blog/20211024/%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%86%85%E6%B7%B7%E5%90%88%E7%BA%AF%E8%AE%A1%E7%AE%97%E4%B8%8EIO.png" alt="在一个方法内混合纯计算与IO"></p><h4 id="6、不写毫无价值的单元测试"><a href="#6、不写毫无价值的单元测试" class="headerlink" title="6、不写毫无价值的单元测试"></a>6、不写毫无价值的单元测试</h4><p><img src="/img/image/blog/20211024/%E4%B8%8D%E5%86%99%E6%AF%AB%E6%97%A0%E4%BB%B7%E5%80%BC%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.jpeg" alt="不写毫无价值的单元测试"></p><h3 id="三、让测试更简单的一些建议"><a href="#三、让测试更简单的一些建议" class="headerlink" title="三、让测试更简单的一些建议"></a>三、让测试更简单的一些建议</h3><ul><li>使用依赖注入器(dependency injector), 而不是尝试手动创建 object graph</li><li>坚持单一原则：努力做到能用一句话描述一个 method 的功能</li><li>坚持最少知识原则：只使用直接依赖对象的API，不使用间接依赖对象的API(不要有 .getX().doY())</li><li>警惕使用 static 和 new 关键字</li><li>优先使用组合而不是继承</li><li>使用多态替代复杂的条件语句</li><li>尽量写无副作用的函数</li><li>用 give-when-then（准备、执行、校验） 为每个 test case 做三段式注释</li></ul><h2 id="一些-mock-技巧"><a href="#一些-mock-技巧" class="headerlink" title="一些 mock 技巧"></a>一些 mock 技巧</h2><h3 id="一、推荐使用构造器注入"><a href="#一、推荐使用构造器注入" class="headerlink" title="一、推荐使用构造器注入"></a>一、推荐使用构造器注入</h3><p>推荐阅读文章：</p><p>spring 官方文章：<a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">Setter injection versus constructor injection and the use of @Required</a></p><p>腾讯云专栏：<a href="https://cloud.tencent.com/developer/article/1126880">【Spring】浅谈spring为什么推荐使用构造器注入</a></p><p>使用构造器注入的好处，总结：</p><ul><li>保证依赖不可变（final关键字）</li><li>保证依赖不为空（省去了我们对其检查）</li><li>保证返回客户端（调用）的代码的时候是完全初始化的状态</li><li>避免了循环依赖</li><li>提升了代码的可复用性</li></ul><p>对于单元测试的好处：更容易的 mock 依赖对象</p><h3 id="二、如何mock-Value注解修饰的变量"><a href="#二、如何mock-Value注解修饰的变量" class="headerlink" title="二、如何mock @Value注解修饰的变量"></a>二、如何mock @Value注解修饰的变量</h3><p>参考文章：</p><ul><li><a href="https://my.oschina.net/u/4286379/blog/4455366">编写单测时，使用mock如何解决使用用@Value注解注入的属性</a></li><li><a href="https://stackoverflow.com/questions/23162777/how-do-i-mock-an-autowired-value-field-in-spring-with-mockito">How do I mock an autowired @Value field in Spring with Mockito?</a></li></ul><h3 id="三、如何mock静态方法"><a href="#三、如何mock静态方法" class="headerlink" title="三、如何mock静态方法"></a>三、如何mock静态方法</h3><p>参考文章：</p><ul><li><a href="https://frontbackend.com/java/how-to-mock-static-methods-with-mockito">How to mock static methods with Mockito</a></li><li><a href="https://yanbin.blog/mockito-3-4-0-mock-static-method/">Mockito 3.4.0 开始可 Mock 静态方法</a></li></ul><h3 id="四、如何校验没有返回值的方法"><a href="#四、如何校验没有返回值的方法" class="headerlink" title="四、如何校验没有返回值的方法"></a>四、如何校验没有返回值的方法</h3><p>校验关键逻辑是否都被调用。</p><p><img src="/img/image/blog/20211024/%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="如何校验没有返回值的方法"></p><h2 id="附：单元测试神器"><a href="#附：单元测试神器" class="headerlink" title="附：单元测试神器"></a>附：单元测试神器</h2><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>说起来，这是一个悲伤的故事，公司要求今年第四季度结束前，所有项目的单元测试覆盖率要达到50%。</p><p>于是乎，我开始炸毛了，新项目进度紧张吧，编写单元测试非常耗时，而且还有一堆老旧项目单元测试覆盖率基本为0%，这要慢慢写，不得补到天荒地老？？？？？</p><p>而且在编写单元测试的过程中，其实是有很大一部份内容是重复劳动，作为一名开发者，对于这种重复且量大的工作，肯定第一个想法就是可不可以通过技术手段，减少这部分工作的耗时，以及操作步骤。</p><h3 id="二、神器介绍"><a href="#二、神器介绍" class="headerlink" title="二、神器介绍"></a>二、神器介绍</h3><p><a href="https://weirddev.com/testme/">https://weirddev.com/testme/</a><br><a href="https://squaretest.com/">https://squaretest.com/</a>  付费<br><a href="http://www.evosuite.org/">http://www.evosuite.org/</a><br><a href="https://randoop.github.io/randoop/">https://randoop.github.io/randoop/</a></p><h3 id="三、神器之TestMe"><a href="#三、神器之TestMe" class="headerlink" title="三、神器之TestMe"></a>三、神器之TestMe</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>TestMe 是一款 IntelliJ 插件，用于生成单元测试样板代码。</p><p>TestMe 支持的单元测试模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Unit4 + Mockito</span><br><span class="line">Unit5 + Mockito</span><br><span class="line">TestNG + Mockito</span><br><span class="line">Groovy +Unit4 + Mockito</span><br><span class="line">Spock + Mockito</span><br><span class="line">Spock Parameterized tests+ Mockito</span><br><span class="line">Specs2(Scala) + Mockito</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h5><ul><li>在 Java、Groovy 或 Scala 中自动生成单元测试代码</li><li>为测试类的非原始字段生成模拟</li><li>支持 Mockito 作为 Mock 框架</li><li>支持 JUnit4、JUnit5、TestNG 和 Spock 框架</li><li>为每个可访问的非私有方法生成测试方法，不包括 setter/getter</li><li>为测试方法生成默认输入参数</li><li>生成测试结果断言表达式</li><li>支持的目标测试类语言： Java、Groovy、Scala。</li></ul><p>示例：<br><img src="/img/image/blog/20211024/simple-use-case.gif" alt="&quot;示例&quot;"></p><h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><h5 id="1、-从-IntelliJ-IDEA-中安装最新版本，并重启IDEA"><a href="#1、-从-IntelliJ-IDEA-中安装最新版本，并重启IDEA" class="headerlink" title="1、 从 IntelliJ IDEA 中安装最新版本，并重启IDEA"></a>1、 从 IntelliJ IDEA 中安装最新版本，并重启IDEA</h5><p>在IDEA菜单：Preferences（Ctrl+ Shift+ S） - &gt; Plugins- &gt; Browse repositories…- &gt;搜索：TestMe- &gt;Install Plugin</p><p><img src="/img/image/blog/20211024/TestMe%E6%88%AA%E5%9B%BE01.png" alt="&quot;TestMe截图01&quot;"></p><h5 id="2、生成测试代码模板"><a href="#2、生成测试代码模板" class="headerlink" title="2、生成测试代码模板"></a>2、生成测试代码模板</h5><h6 id="1）选择测试类："><a href="#1）选择测试类：" class="headerlink" title="1）选择测试类："></a>1）选择测试类：</h6><p>选择一个需要测试的类 -》 alt + Insert 跳出如下选择框</p><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%811.png" alt="&quot;生成代码1&quot;"></p><h6 id="2）选择测试工具："><a href="#2）选择测试工具：" class="headerlink" title="2）选择测试工具："></a>2）选择测试工具：</h6><p>并选择 TestMe 后跳出如下选项框</p><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%812.png" alt="&quot;生成代码2&quot;"></p><p>选择你最常用的测试工具即可，我比较常用的是 Unit4 + Mockito，所以我选择的是第一个。</p><h6 id="3）根据生成的测试模板代码修改测试用例"><a href="#3）根据生成的测试模板代码修改测试用例" class="headerlink" title="3）根据生成的测试模板代码修改测试用例"></a>3）根据生成的测试模板代码修改测试用例</h6><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%813.png" alt="&quot;生成代码3&quot;"></p><h5 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h5><p>默认值是为测试的方法参数自动生成的。目前，此行为不可配置。</p><p>作者解释：从某种意义上说，Groovy 测试生成器更健壮，可以使用映射构造函数（在适用时）通过内联 setter 初始化对象。Java 测试生成器尚不支持此类匹配功能，因为为测试参数初始化分配给局部变量会使测试生成模板复杂化。就我个人而言，在进行单元测试时，我总是建议使用 Groovy 而不是 Java。如果您还没有过渡到 Groovy作为您选择的测试代码语言 - 现在是开始的好时机:)</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">维基百科–单元测试</a></p><p><a href="https://testing.googleblog.com/2008/08/by-miko-hevery-so-you-decided-to.html">Writing Testable Code</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot;&gt;&lt;a href=&quot;#摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot; class=&quot;headerlink&quot; title=&quot;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot;&gt;&lt;/a&gt;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot;&gt;&lt;a href=&quot;#前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot; class=&quot;headerlink&quot; title=&quot;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot;&gt;&lt;/a&gt;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="测试" scheme="https://www.blog.ajie39.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="https://www.blog.ajie39.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="开发基础" scheme="https://www.blog.ajie39.top/tags/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（基础篇）</title>
    <link href="https://www.blog.ajie39.top/2021/06/29/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/06/29/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</id>
    <published>2021-06-29T15:25:40.000Z</published>
    <updated>2021-12-13T16:21:40.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（拓展篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（进阶篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、Redis 是什么?<br>2、Redis 的数据类型？<br>3、Redis 是单进程单线程的？<br>4、Redis 的持久化机制有哪些？各自的优缺点？<br>5、Redis 常见性能问题和解决方案：<br>6、Redis 过期键的删除策略？<br>7、Redis 的回收策略（淘汰策略）?<br>8、为什么 Redis 需要把所有数据放到内存中？<br>9、Redis 支持的 Java 客户端都有哪些？<br>10、Jedis 与 Redisson 对比有什么优缺点？<br>12、Pipeline 有什么好处，为什么要用 pipeline？<br>13、怎么理解 Redis 事务？<br>16、Redis 事务相关的命令有哪几个？<br>17、Redis key 的过期时间和永久有效分别怎么设置？<br>18、Redis 如何做内存优化？<br>20、Redis 回收进程如何工作的？<br>21、都有哪些办法可以降低 Redis 的内存使用情况呢？<br>22、Redis 的内存用完了会发生什么？<br>24、查看 Redis 使用情况及状态信息用什么命令？<br>25、怎么测试 Redis 的连通性？<br>28、修改配置不重启 Redis 会实时生效吗？<br>29、使用过 Redis 分布式锁么，它是什么回事？<br>30、使用过 Redis 做异步队列么，你是怎么用的？<br>31、Redis 最适合的场景？</p><h2 id="1、Redis-是什么？"><a href="#1、Redis-是什么？" class="headerlink" title="1、Redis 是什么？"></a>1、Redis 是什么？</h2><p>Redis 是一个 <code>远程内存数据库</code>，它不仅性能强劲，而且还具有 <code>复制特性</code> 以及 <code>为解决问题而生</code> 的独一无二的数据模型。Redis提供了 <code>5种不同类型的数据结构</code>，它可以存储键 (key) 与 5种不同类型的值 (value) 之间的映射(mapping)；可以将存储在内存的键值对数据待久化到硬盘，可以 <code>使用复制特性来扩展读性能</code>，还可以使用 <code>客户端分片来扩展写性能</code>，各式各样的问题都可以很自然地映射到这些数据结构上：Redis的数据结构致力千帮助用户解决问题，而不会像其他数据库那样，要求用户扭曲问题来适应数据库。除此之外，通过 <code>复制</code>、 <code>持久化(persistence)</code> 和 <code>客户端分片(client-side sharding)</code> 等特性，用户可以很方便地将 Redis 扩展成一个能够包含数百GB数据、 每秒处理上百万次请求的系统。</p><h2 id="2、Redis-的数据类型？"><a href="#2、Redis-的数据类型？" class="headerlink" title="2、Redis 的数据类型？"></a>2、Redis 的数据类型？</h2><p>Redis 数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：</p><ul><li>数据库 <code>键</code> 总是一个 <code>字符串对象（string object）</code>；</li><li>Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为 <code>String</code> (字符串)、 <code>List</code> （列表）、<code>Set</code>（集合）、<code>Hash</code>（散列）、<code>Zset</code>（有序集合）。</li></ul><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>String（字符串）</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作。</td></tr><tr><td>List（列表）</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素。</td></tr><tr><td>Set（集合）</td><td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td><td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素。</td></tr><tr><td>Hash（散列）</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对。</td></tr><tr><td>Zset（有序集合）</td><td>字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围或者成员来获取元素。</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1) 简单动态字符串"></a>1) 简单动态字符串</h4><p>​        Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称C<br>字符串），而是自己构建了一种名为 <code>简单动态字符串（simple dynamic string，SDS）</code>的抽象<br>类型，并将 SDS 用作 Redis 的<code>默认字符串</code>表示。</p><p>​        当 Redis 需要的不仅仅是一个字符串字面量，而是一个可以<code>被修改的字符串值</code>时，Redis<br>就会使用 SDS 来表示字符串值，比如在 Redis 的数据库里面，包含字符串值的键值对在底<br>层都是由 SDS 实现的。除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区（buffer）：AOF 模块中的 AOF 缓冲区，以及客户端状态中的输入缓冲区，都是由 SDS 实现的。</p><h4 id="2-SDS-的定义"><a href="#2-SDS-的定义" class="headerlink" title="2) SDS 的定义"></a>2) SDS 的定义</h4><p>SDS 的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">// 记录buf 数组中已使用字节的数量</span></span><br><span class="line"><span class="comment">// 等于SDS 所保存字符串的长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 记录buf 数组中未使用字节的数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图展示了一个 SDS 示例：</p><p><img src="/img/image/blog/20210505/SDS%E7%A4%BA%E4%BE%8B.png" alt="SDS示例"></p><ul><li>free 属性的值为0，表示这个 SDS 没有分配任何未使用空间。</li><li>len 属性的值为5，表示这个 SDS 保存了一个五字节长的字符串。</li><li>buf 属性是一个 <code>char 类型的数组</code>，数组的前五个字节分别保存了 ‘R’、’e’、’d’、’i’、’s’ 五个字符，而最后一个字节则保存了空字符 ‘\0’。</li></ul><p>SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的1 字节空间不计算在SDS 的 len 属性里面，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由SDS 函数自动完成的，所以这个空字符对于 SDS 的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分C 字符串函数库里面的函数。</p><h4 id="3-C-字符串和-SDS-之间的区别"><a href="#3-C-字符串和-SDS-之间的区别" class="headerlink" title="3) C 字符串和 SDS 之间的区别"></a>3) C 字符串和 SDS 之间的区别</h4><table><thead><tr><th align="center">C 字符串</th><th align="center">SDS</th></tr></thead><tbody><tr><td align="center">获取字符串长度的复杂度为O(N)</td><td align="center">获取字符串长度的复杂度为O(1)</td></tr><tr><td align="center">API 是不安全的，可能会造成缓冲区溢出</td><td align="center">API 是安全的，不会造成缓冲区溢出</td></tr><tr><td align="center">修改字符串长度N 次<code>必然</code>需要执行N 次内存重分配</td><td align="center">修改字符串长度N 次<code>最多</code>需要执行N 次内存重分配</td></tr><tr><td align="center">只能保存文本数据</td><td align="center">可以保存文本或者二进制数据</td></tr><tr><td align="center">可以使用所有&lt;string.h&gt; 库中的函数</td><td align="center">可以使用一部分&lt;string.h&gt; 库中的函数</td></tr></tbody></table><h4 id="4-C-字符串和-SDS-之间的区别"><a href="#4-C-字符串和-SDS-之间的区别" class="headerlink" title="4) C 字符串和 SDS 之间的区别"></a>4) C 字符串和 SDS 之间的区别</h4><p>比起C 字符串，SDS 具有以下优点：</p><ul><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出（空间预分配）。</li><li>减少修改字符串长度时所需的内存重分配次数（惰性空间释放）。</li><li>二进制安全。</li><li>兼容部分C 字符串函数。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>在 Redis 5.0 版本引入了一个新的数据类型–Streams(流信息)。它支持消费者组，借鉴 Kafka 设计的支持多播的可持久化消息队列(支持 group，不支持 partition)。</li><li>其他的数据类型的具体内容，这里就不在进行过多的展开了，后面会补上相关文章。</li><li>各个数据类型的存储最大存储大小：<ul><li>String：最大可以存储512M。</li><li>List：元素个数最多为 2^32-1 个，即 4294967295 个。</li><li>Set：元素个数最多为 2^32-1 个，即 4294967295 个。</li><li>Hash：键值对个数最多为 2^32-1 个，即 4294967295 个。</li><li>Zset：同 Sets。</li></ul></li></ul><h2 id="3、Redis-是单进程单线程的？"><a href="#3、Redis-是单进程单线程的？" class="headerlink" title="3、Redis 是单进程单线程的？"></a>3、Redis 是单进程单线程的？</h2><p>​        <code>Redis 服务器</code>使用<code>单线程单进程</code>的方式来处理命令请求， 并与多个客户端进行网络通信。Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><p>​        Redis 服务器是典型的一对多服务器程序： 一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求， 而服务器则接收并处理客户端发送的命令请求， 并向客户端返回命令回复。</p><p>​        对于每个与服务器进行连接的客户端， 服务器都为这些客户端建立了相应的 redis.h/ redisClient 结构（客户端状态），这个结构保存了客户端当前的状态信息． 以及执行相关功能时需要用到的数据结构， 其中包括：</p><ul><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值 (flag)。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制(soft limit) 的时间。</li></ul><p>​    Redis 服务器状态结构的 clients 属性是一个链表。这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历 clients 链表来完成。</p><p>关于 Redis 单线程的相关问题，因为内容较多，全部写到该篇文章中不太合适，所以这里重新写了一篇文章来进行总结 ：</p><p><a href="https://www.blog.ajie39.top/2021/05/08/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84">Redis 是单线程的？？？？你别唬我，我可不是厦（吓）大的</a></p><h2 id="4、Redis-的持久化机制有哪些？各自的优缺点？"><a href="#4、Redis-的持久化机制有哪些？各自的优缺点？" class="headerlink" title="4、Redis 的持久化机制有哪些？各自的优缺点？"></a>4、Redis 的持久化机制有哪些？各自的优缺点？</h2><p>​        Redis 是一个内存数据库，数据都存储在内存中，这也是 Redis 非常快的原因之一。虽然速度提上来了，但是如果数据一直放在内存中，是非常容易丢失的。比如服务器关闭或宕机了，内存中的数据就丢失了。为了解决这一问题，Redis 提供了持久化机制。一种是 RDB 持久化（<strong>原理是将Redis 在内存中的数据库记录定时dump到磁盘上</strong>），另一种是 AOF (append only file) 持久化，（<strong>原理是将 Redis 的操作日志以追加的方式写入文件</strong>）。两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。</p><h4 id="1）RDB（默认）"><a href="#1）RDB（默认）" class="headerlink" title="1）RDB（默认）"></a>1）RDB（默认）</h4><p>RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照 (point-in-time snapshot)。</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><img src="/img/image/blog/20210505/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="RDB持久化过程"></p><p><strong>RDB存在哪些优势？</strong></p><ol><li>一旦采用该方式，那么你的整个 Redis 数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松地将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样可以极大地避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ol><p><strong>RDB的劣势？</strong></p><ol><li>如果你想保证数据的高可用性，即最大限度地避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据将丢失。</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至1秒钟。</li></ol><h4 id="2）AOF"><a href="#2）AOF" class="headerlink" title="2）AOF"></a>2）AOF</h4><p>AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。</p><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF进行重写<strong>，</strong>重写后的新 AOF 文件包含了恢复当前数据集所需的<strong>最小命令集合</strong>。</p><p>AOF 持久化以日志的形式记录服务器所处理的每一个写、删操作（注意查询操作不会被记录）。以文本的方式记录，可以打开文件看到详细的操作记录。</p><p><img src="/img/image/blog/20210505/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="AOF持久化过程"></p><p><strong>AOF的优势？</strong></p><ol><li>该机制可以带来更高的数据安全性，即数据持久性。Redis 中提供了3种同步策略，及每秒同步，每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率非常高。所差的是一旦系统出现宕机现象，那么这一秒种之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，大家都能正确的理解它。</li><li>由于该机制对日志文件的写入操作采用的是 append（在被选元素的结尾插入指定内容） 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。</li><li>如果日志文件过大，Redis可以自动启动 rewrite 机制。即 Reids 以 append 模式不断地修改数据并写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行切换时可以更高的保证数据安全性。</li><li>AOF 包含一个格式清晰，易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ol><p><strong>AOF的劣势？</strong></p><ol><li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件，RDB 在恢复大数据集时速度比AOF 的恢复速度快。</li><li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。总之，每秒同步策略的效率是比较高的。同步禁用策略的效率和 RDB 一样高效。</li></ol><p><strong>二者选择的标准</strong>：就是看系统是愿意牺牲一些性能，换取更高的缓存一致性(AOF)，还是愿意写操作频繁的时候，不启动备份来换取更高的性能。待手动运行save的时候，再做备份(RDB)。RDB 这个就更有些最终一致性的意思了。</p><h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><h5 id="RDB持久化配置"><a href="#RDB持久化配置" class="headerlink" title="RDB持久化配置"></a><strong>RDB持久化配置</strong></h5><p>Redis 会将数据集的快照 dump 到 dump.rdb 文件中。此外，我们也可以通过配置文件来修改Redis 服务器 dump 快照的频率，在打开 redis.conf 文件之后，我们搜索 save 可以看到下面的配置信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save　　900　　1 #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照</span><br><span class="line"></span><br><span class="line">save　　300　　10 #在300秒(5分钟)之后，如果至少有10个key发生变化，则dunp内存快照</span><br><span class="line"></span><br><span class="line">save　　60　　 10000　　#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照</span><br></pre></td></tr></table></figure><h5 id="AOF持久化配置"><a href="#AOF持久化配置" class="headerlink" title="AOF持久化配置"></a><strong>AOF持久化配置</strong></h5><p>在 Redis 的配置文件中存在三种同步方式，它们分别是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendsync always #每次有数据修改发生时都会写入AOF文件</span><br><span class="line"></span><br><span class="line">appendsync everysec #每秒同步一次，该策略为AOF的缺省策略</span><br><span class="line"></span><br><span class="line">appendsync no #从不同步。高效但是数据不会被持久化</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（拓展篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（进阶篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>开发工具汇总</title>
    <link href="https://www.blog.ajie39.top/2021/06/20/%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
    <id>https://www.blog.ajie39.top/2021/06/20/%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</id>
    <published>2021-06-19T18:15:56.000Z</published>
    <updated>2021-06-19T18:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：本文主要总结了自己开发所用的各种工具。"><a href="#摘要：本文主要总结了自己开发所用的各种工具。" class="headerlink" title="摘要：本文主要总结了自己开发所用的各种工具。"></a>摘要：本文主要总结了自己开发所用的各种工具。</h1><hr><h1 id="前言：主要是汇总了一下，自己在开发过程中的各种工具。"><a href="#前言：主要是汇总了一下，自己在开发过程中的各种工具。" class="headerlink" title="前言：主要是汇总了一下，自己在开发过程中的各种工具。"></a>前言：主要是汇总了一下，自己在开发过程中的各种工具。</h1><hr><span id="more"></span><h2 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h2><ul><li>clear 刷新屏幕</li><li>tab 自动补全</li></ul><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><ul><li>打包、跳过测试<br>mvn clean package -Dmaven.test.skip</li><li>执行<br>java -jar *.jar</li><li>退出<br>ctrl + c</li></ul><h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><ul><li><p>Lombok插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lombok官方api：https:&#x2F;&#x2F;projectlombok.org&#x2F;features&#x2F;index.html</span><br><span class="line"></span><br><span class="line">使用lombok之后，省去了许多没必要的get，set，toString，</span><br><span class="line">equals，hashCode代码，简化了代码编写，减少了代码量。</span><br><span class="line"></span><br><span class="line">另外@Data注解的作用相当于 @Getter @Setter</span><br><span class="line">@RequiredArgsConstructor @ToString @EqualsAndHashCode的合集</span><br></pre></td></tr></table></figure></li><li><p>Background Image 背景图片设置插件</p></li><li><p>Maven Helper：展示的pom文件依赖关系<br>使用参考地址：<a href="https://blog.csdn.net/u013870094/article/details/79712500">https://blog.csdn.net/u013870094/article/details/79712500</a></p></li><li><p>Alibaba Java Coding Guidelines 阿里巴巴Java编码准则插件</p></li><li><p>Translation 翻译插件</p></li><li><p>MyBatis Log Plugin 打印mybatis的sql语句</p></li><li><p>Free Mybatis plugin 生成mapper xml文件，快速从代码跳转到mapper及从mapper返回代码<br>使用参考地址：<a href="https://github.com/wuzhizhan/free-idea-mybatis">https://github.com/wuzhizhan/free-idea-mybatis</a></p></li><li><p>protobuf support proto文件插件</p></li><li><p>VisualVM Launcher 查看jvm的情况</p></li><li><p>FindBugs 检测代码中可能的bug及不规范的位置</p></li><li><p>MybatisX MybatisX 辅助 idea 快速开发插件</p></li><li><p>CodeGlance 代码编辑区缩略图插件</p></li><li><p>Kubernetes</p></li><li><p>Zoolytic  zookeeper可视化</p></li></ul><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><ul><li>中文简体语言包：Chinese (Simplified) Language Pack for Visual Studio Code</li><li>PlantUML</li><li>VS Code JavaScript(ES6) snippets：这个插件为 JavaScript、TypeScript、HTML、React 和 Vue 提供了 ES6 的语法支持。</li><li>React-Redux ES6 Snippets</li><li>jQuery Code Snippets</li><li>Path Intellisense：自动路径补全</li><li>Vetur：Vue 的语法高亮、智能感知、Emmet 等。</li><li>Debugger for Chrome</li><li>Markdown All in One</li></ul><h2 id="一些工具类网站"><a href="#一些工具类网站" class="headerlink" title="一些工具类网站"></a>一些工具类网站</h2><ul><li>PlantUML：<a href="https://plantuml.com/zh/">https://plantuml.com/zh/</a></li><li>时间戳：<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></li><li>cron表达式生成器：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li><li>json：<a href="https://www.bejson.com/jsoneditoronline/">https://www.bejson.com/jsoneditoronline/</a></li><li>思维导图、流程图：<a href="https://www.processon.com/">https://www.processon.com/</a></li><li>jwt解密：<a href="https://jwt.io/">https://jwt.io/</a></li><li>代码分享：<a href="https://paste.ubuntu.com/">https://paste.ubuntu.com/</a></li></ul><h2 id="ATOM"><a href="#ATOM" class="headerlink" title="ATOM"></a>ATOM</h2><ul><li>DocBlocker                          自动代码补全，注释</li><li>atom-material-ui                    美化</li><li>language-markdown                   markdown语法高亮插件</li><li>markdown-preview-plus 或者<br>markdown-preview-enhanced           语法高亮，双向实时预览</li><li>markdown-table-editor               markdown表格插件</li><li>regex-railroad-diagram              正则表达式插件</li><li>simplified-chinese-menu             菜单汉化语言包</li></ul><h2 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h2><ul><li>JSON Viewer插件<br>  地址：<a href="https://github.com/tulios/json-viewer">https://github.com/tulios/json-viewer</a></li></ul><h2 id="渗透工具"><a href="#渗透工具" class="headerlink" title="渗透工具"></a>渗透工具</h2><ul><li>Nmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装命令：</span><br><span class="line">sudo apt-get install nmap</span><br></pre></td></tr></table></figure><ul><li>Zenmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装命令：</span><br><span class="line">sudo apt-get install -y zenmap</span><br></pre></td></tr></table></figure><ul><li>Sqlmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安装git:</span><br><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line">然后使用git安装sqlmap:</span><br><span class="line">sudo git clone git:&#x2F;&#x2F;github.com&#x2F;sqlmapproject&#x2F;sqlmap.git</span><br><span class="line"></span><br><span class="line">修改环境变量：</span><br><span class="line">sudo vi &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">export sqlmap&#x3D;&#39;python **&#x2F;sqlmap&#x2F;sqlmap.py&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：本文主要总结了自己开发所用的各种工具。&quot;&gt;&lt;a href=&quot;#摘要：本文主要总结了自己开发所用的各种工具。&quot; class=&quot;headerlink&quot; title=&quot;摘要：本文主要总结了自己开发所用的各种工具。&quot;&gt;&lt;/a&gt;摘要：本文主要总结了自己开发所用的各种工具。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot;&gt;&lt;a href=&quot;#前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot; class=&quot;headerlink&quot; title=&quot;前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot;&gt;&lt;/a&gt;前言：主要是汇总了一下，自己在开发过程中的各种工具。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    <category term="Tool" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/Tool/"/>
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 数据库相关知识点总结</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-16T14:51:14.000Z</published>
    <updated>2021-12-13T16:13:46.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：对于-Mysql-常见的知识点总结。"><a href="#摘要：对于-Mysql-常见的知识点总结。" class="headerlink" title="摘要：对于 Mysql 常见的知识点总结。"></a>摘要：对于 Mysql 常见的知识点总结。</h1><hr><h1 id="前言：对于-Mysql-常见的知识点的总结。"><a href="#前言：对于-Mysql-常见的知识点的总结。" class="headerlink" title="前言：对于 Mysql 常见的知识点的总结。"></a>前言：对于 Mysql 常见的知识点的总结。</h1><hr><h2 id="Mysql-知识点脑图"><a href="#Mysql-知识点脑图" class="headerlink" title="Mysql 知识点脑图"></a>Mysql 知识点脑图</h2><p><img src="/img/image/blog/20210516/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE.png" alt="Mysql 知识点脑图"></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：对于-Mysql-常见的知识点总结。&quot;&gt;&lt;a href=&quot;#摘要：对于-Mysql-常见的知识点总结。&quot; class=&quot;headerlink&quot; title=&quot;摘要：对于 Mysql 常见的知识点总结。&quot;&gt;&lt;/a&gt;摘要：对于 Mysql 常见的知识点总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于-Mysql-常见的知识点的总结。&quot;&gt;&lt;a href=&quot;#前言：对于-Mysql-常见的知识点的总结。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于 Mysql 常见的知识点的总结。&quot;&gt;&lt;/a&gt;前言：对于 Mysql 常见的知识点的总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Mysql-知识点脑图&quot;&gt;&lt;a href=&quot;#Mysql-知识点脑图&quot; class=&quot;headerlink&quot; title=&quot;Mysql 知识点脑图&quot;&gt;&lt;/a&gt;Mysql 知识点脑图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/image/blog/20210516/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE.png&quot; alt=&quot;Mysql 知识点脑图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Mysql/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://www.blog.ajie39.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之Hashmap</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/Java%E9%9D%A2%E8%AF%95%E4%B9%8BHashmap/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/Java%E9%9D%A2%E8%AF%95%E4%B9%8BHashmap/</id>
    <published>2021-05-16T10:46:10.000Z</published>
    <updated>2021-12-13T16:26:35.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：Hashmap面试内容总结"><a href="#摘要：Hashmap面试内容总结" class="headerlink" title="摘要：Hashmap面试内容总结"></a>摘要：Hashmap面试内容总结</h1><hr><h1 id="前言：Hashmap面试内容总结，为面试做准备。"><a href="#前言：Hashmap面试内容总结，为面试做准备。" class="headerlink" title="前言：Hashmap面试内容总结，为面试做准备。"></a>前言：Hashmap面试内容总结，为面试做准备。</h1><hr><span id="more"></span><h2 id="1、为什么用HashMap？"><a href="#1、为什么用HashMap？" class="headerlink" title="1、为什么用HashMap？"></a>1、为什么用HashMap？</h2><ul><li>HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射</li><li>HashMap 采用了数组和链表的数据结构，查询和修改方便，继承了数组的线性查找和链表的寻址修改</li><li>HashMap 是非 synchronized，所以 HashMap 很快</li><li>HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）</li><li>HashMap 存储着Entry(hash, key, value, next)对象</li></ul><h2 id="2、HashMap-的工作原理是什么？"><a href="#2、HashMap-的工作原理是什么？" class="headerlink" title="2、HashMap 的工作原理是什么？"></a>2、HashMap 的工作原理是什么？</h2><p>HashMap 通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p><p><img src="/img/image/blog/12/1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以下是 HashMap 初始化</span><br><span class="line">简化的模拟数据结构：</span><br><span class="line"></span><br><span class="line">Node[] table = <span class="keyword">new</span> Node[<span class="number">16</span>]; <span class="comment">// 散列桶初始化，table</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    hash; <span class="comment">//hash值</span></span><br><span class="line">    key; <span class="comment">//键</span></span><br><span class="line">    value; <span class="comment">//值</span></span><br><span class="line">    node next; <span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是具体的 put 过程（JDK1.8）</p><ol><li>对 Key 求 Hash 值，然后再计算下标</li><li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）</li><li>如果碰撞了，以链表的方式链接到后面</li><li>如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li><li>如果节点已经存在就替换旧值</li><li>如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）</li></ol><p>以下是具体 get 过程</p><p>考虑特殊情况：如果两个键的 hashcode 相同，你如何获取值对象？</p><p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p><p><img src="/img/image/blog/12/2.png"></p><h2 id="3、有什么方法可以减少碰撞？"><a href="#3、有什么方法可以减少碰撞？" class="headerlink" title="3、有什么方法可以减少碰撞？"></a>3、有什么方法可以减少碰撞？</h2><p><strong>碰撞：所谓“碰撞”就上面所述是多个元素计算得出相同的hashCode，在put时出现冲突。</strong></p><p>处理方法:<br>　　Java中HashMap是利用“拉链法”处理HashCode的碰撞问题。在调用HashMap的put方法或get方法时，都会首先调用hashcode方法，去查找相关的key，当有冲突时，再调用equals方法。</p><p>hashMap 通过put和get方法存取对象。当我们将键值对传递给put方法时，他调用键对象的hashCode()方法来计算hashCode，然后找到bucket（哈希桶）位置来存储对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当碰撞发生了，对象将会存储在链表的下一个节点中。hashMap在每个链表节点存储键值对对象。当两个不同的键却有相同的hashCode时，他们会存储在同一个bucket位置的链表中。键对象的equals()来找到键值对。</p><p><strong>HashMap基本结构概念图：</strong></p><p><img src="/img/image/blog/12/3.png"></p><p>到目前为止，我们了解了两件事：</p><ul><li>1、HashMap通过键的hashCode来快速的存取元素。</li><li>2、当不同的对象发生碰撞时，HashMap通过单链表来解决，将新元素加入链表表头，通过next指向原有的元素。单链表在Java中的实现就是对象的引用(复合)。</li></ul><h2 id="4、为什么-String、Integer-这样的-wrapper-类适合作为键？"><a href="#4、为什么-String、Integer-这样的-wrapper-类适合作为键？" class="headerlink" title="4、为什么 String、Integer 这样的 wrapper 类适合作为键？"></a>4、为什么 String、Integer 这样的 wrapper 类适合作为键？</h2><p>因为 String 是 final，而且已经重写了 equals() 和 hashCode() 方法了。不可变性是必要的，因为为了要计算 hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的 hashcode 的话，那么就不能从 HashMap 中找到你想要的对象。</p><h2 id="5、HashMap-中-hash-函数怎么是实现的"><a href="#5、HashMap-中-hash-函数怎么是实现的" class="headerlink" title="5、HashMap 中 hash 函数怎么是实现的?"></a>5、HashMap 中 hash 函数怎么是实现的?</h2><p>我们可以看到，在 hashmap 中要找到某个元素，需要根据 key 的 hash 值来求得对应数组中的位置。如何计算这个位置就是 hash 算法。</p><p>前面说过，hashmap 的数据结构是数组和链表的结合，所以我们当然希望这个 hashmap 里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个。那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以，我们首先想到的就是把 hashcode 对数组长度取模运算。这样一来，元素的分布相对来说是比较均匀的。</p><p>但是“模”运算的消耗还是比较大的，能不能找一种更快速、消耗更小的方式？我们来看看 JDK1.8 源码是怎么做的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    h = key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">    <span class="keyword">return</span> (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/image/blog/12/4.png"></p><p>简单来说就是：</p><ul><li>1、高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和6 bit做了一个异或）</li><li>2、(n·1) &amp; hash = -&gt; 得到下标</li></ul><h2 id="6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？"><a href="#6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？"></a>6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷：</p><p>二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成层次很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋、右旋、变色这些操作来保持平衡。引入红黑树就是为了查找数据快，解决链表查询深度的问题。我们知道红黑树属于平衡二叉树，为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少。所以当长度大于8的时候，会使用红黑树；如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h2 id="7、说说你对红黑树的见解？"><a href="#7、说说你对红黑树的见解？" class="headerlink" title="7、说说你对红黑树的见解？"></a>7、说说你对红黑树的见解？</h2><p><img src="/img/image/blog/12/5.png"></p><ol><li>每个节点非红即黑</li><li>根节点总是黑色的</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li><li>每个叶子节点都是黑色的空节点（NIL节点）</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ol><h2 id="8、解决-hash-碰撞还有那些办法？"><a href="#8、解决-hash-碰撞还有那些办法？" class="headerlink" title="8、解决 hash 碰撞还有那些办法？"></a>8、解决 hash 碰撞还有那些办法？</h2><p><strong>1.开放地址法</strong></p><p>开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。</p><p>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。</p><p>如果di取值可能为伪随机数列。称伪随机探测再散列。</p><p><strong>2.再哈希法</strong></p><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止。</p><p><strong>3.链地址法（拉链法）</strong></p><p>将所有关键字为同义词的记录存储在同一线性链表中。如下：</p><p><img src="/img/image/blog/12/6.png"></p><p>因此这种方法，可以近似的认为是筒子里面套筒子。</p><p><strong>优点：</strong></p><ol><li>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li><li>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</li><li>开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</li><li>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li></ol><p><strong>缺点：</strong></p><ul><li>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</li></ul><h2 id="9、如果-HashMap-的大小超过了负载因子（load-factor）定义的容量怎么办？"><a href="#9、如果-HashMap-的大小超过了负载因子（load-factor）定义的容量怎么办？" class="headerlink" title="9、如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？"></a>9、如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？</h2><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</span><br><span class="line"></span><br><span class="line">大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</span><br></pre></td></tr></table></figure><p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="/img/image/blog/12/7.png"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/img/image/blog/12/8.png"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p><img src="/img/image/blog/12/9.png"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><h2 id="10、重新调整-HashMap-大小存在什么问题吗？"><a href="#10、重新调整-HashMap-大小存在什么问题吗？" class="headerlink" title="10、重新调整 HashMap 大小存在什么问题吗？"></a>10、重新调整 HashMap 大小存在什么问题吗？</h2><p>重新调整 HashMap 大小的时候，确实存在条件竞争。</p><p>因为如果两个线程都发现 HashMap 需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来。因为移动到新的 bucket 位置的时候，HashMap 并不会将元素放在链表的尾部，而是放在头部。这是为了避免尾部遍历（tail traversing）。如果条件竞争发生了，那么就死循环了。<strong>多线程的环境下不使用 HashMap。</strong></p><p>为什么多线程会导致死循环，它是怎么发生的？<br>HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。这时候， HashMap 需要扩展它的长度，也就是进行Resize。</p><ol><li>扩容：创建一个新的 Entry 空数组，长度是原数组的2倍</li><li>rehash：遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组</li></ol><p>详细文章参考: <a href="https://www.cnblogs.com/zhuoqingsen/p/8577646.html">HashMap扩容全过程</a></p><h2 id="11、HashTable"><a href="#11、HashTable" class="headerlink" title="11、HashTable"></a>11、HashTable</h2><ol><li>数组 + 链表方式存储</li><li>默认容量：11（质数为宜）</li><li>put操作：首先进行索引计算 （key.hashCode() &amp; 0x7FFFFFFF）% table.length；若在链表中找到了，则替换旧值，若未找到则继续；当总元素个数超过 容量 * 加载因子 时，扩容为原来 2 倍并重新散列；将新元素加到链表头部</li><li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全</li></ol><h2 id="12、HashMap-与-HashTable-区别"><a href="#12、HashMap-与-HashTable-区别" class="headerlink" title="12、HashMap 与 HashTable 区别"></a>12、HashMap 与 HashTable 区别</h2><ol><li>默认容量不同，扩容不同</li><li>线程安全性：HashTable 安全</li><li>效率不同：HashTable 要慢，因为加锁</li></ol><h2 id="13、可以使用-CocurrentHashMap-来代替-Hashtable-吗？"><a href="#13、可以使用-CocurrentHashMap-来代替-Hashtable-吗？" class="headerlink" title="13、可以使用 CocurrentHashMap 来代替 Hashtable 吗？"></a>13、可以使用 CocurrentHashMap 来代替 Hashtable 吗？</h2><ol><li>我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁</li><li>ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性</li><li>它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map</li></ol><h2 id="14、CocurrentHashMap（JDK-1-7）"><a href="#14、CocurrentHashMap（JDK-1-7）" class="headerlink" title="14、CocurrentHashMap（JDK 1.7）"></a>14、CocurrentHashMap（JDK 1.7）</h2><ol><li>CocurrentHashMap 是由 Segment 数组和 HashEntry 数组和链表组成</li><li>Segment 是基于重入锁（ReentrantLock）：一个数据段竞争锁。每个 HashEntry 一个链表结构的元素，利用 Hash 算法得到索引确定归属的数据段，也就是对应到在修改时需要竞争获取的锁。ConcurrentHashMap 支持 CurrencyLevel（Segment 数组数量）的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment</li><li>核心数据如 value，以及链表都是 volatile 修饰的，保证了获取时的可见性</li><li>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put 操作如下：<ul><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li><li>遍历该 HashEntry，如果不为空则判断传入的  key 和当前遍历的 key 是否相等，相等则覆盖旧的 value</li><li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li><li>最后会解除在 1 中所获取当前 Segment 的锁。</li></ul></li><li>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理<ul><li>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。</li><li>尝试自旋获取锁，如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。最后解除当前 Segment 的锁</li></ul></li></ol><h2 id="15、CocurrentHashMap（JDK-1-8）"><a href="#15、CocurrentHashMap（JDK-1-8）" class="headerlink" title="15、CocurrentHashMap（JDK 1.8）"></a>15、CocurrentHashMap（JDK 1.8）</h2><p>CocurrentHashMap 抛弃了原有的 Segment 分段锁，采用了 CAS + synchronized 来保证并发安全性。其中的 val next 都用了 volatile 修饰，保证了可见性。</p><p><strong>最大特点是引入了 CAS</strong></p><p>  借助 Unsafe 来实现 native code。CAS有3个操作数，内存值 V、旧的预期值 A、要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值V修改为 B，否则什么都不做。Unsafe 借助 CPU 指令 cmpxchg 来实现。</p><p><strong>CAS 使用实例</strong></p><p>对 sizeCtl 的控制都是用 CAS 来实现的：</p><ul><li>-1 代表 table 正在初始化</li><li>N 表示有 -N-1 个线程正在进行扩容操作</li><li>如果 table 未初始化，表示table需要初始化的大小</li><li>如果 table 初始化完成，表示table的容量，默认是table大小的0.75倍，用这个公式算 0.75（n – (n &gt;&gt;&gt; 2)）</li></ul><p><strong>CAS 会出现的问题：ABA</strong></p><p>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。</p><p><strong>put 过程</strong></p><ul><li>根据 key 计算出 hashcode</li><li>判断是否需要进行初始化</li><li>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容</li><li>如果都不满足，则利用 synchronized 锁写入数据</li><li>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树</li></ul><p><strong>get 过程</strong></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值</li><li>如果是红黑树那就按照树的方式获取值</li><li>就不满足那就按照链表的方式遍历获取值</li></ul><h2 id="16、ConcurrentHashMap-在-Java-8-中存在一个-bug-会进入死循环"><a href="#16、ConcurrentHashMap-在-Java-8-中存在一个-bug-会进入死循环" class="headerlink" title="16、ConcurrentHashMap 在 Java 8 中存在一个 bug 会进入死循环"></a>16、ConcurrentHashMap 在 Java 8 中存在一个 bug 会进入死循环</h2><p>原因是递归创建 ConcurrentHashMap 对象，但是在 JDK 1.9 已经修复了。场景重现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; cache =<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        ConcurrentHashMapDemo ch =    <span class="keyword">new</span> ConcurrentHashMapDemo();</span><br><span class="line">        System.out.println(ch.fibonaacci(<span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonaacci</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>||i ==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cache.computeIfAbsent(i,(key) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fibonaacci : &quot;</span>+key);</span><br><span class="line">            <span class="keyword">return</span> fibonaacci(key -<span class="number">1</span>)+fibonaacci(key - <span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：Hashmap面试内容总结&quot;&gt;&lt;a href=&quot;#摘要：Hashmap面试内容总结&quot; class=&quot;headerlink&quot; title=&quot;摘要：Hashmap面试内容总结&quot;&gt;&lt;/a&gt;摘要：Hashmap面试内容总结&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：Hashmap面试内容总结，为面试做准备。&quot;&gt;&lt;a href=&quot;#前言：Hashmap面试内容总结，为面试做准备。&quot; class=&quot;headerlink&quot; title=&quot;前言：Hashmap面试内容总结，为面试做准备。&quot;&gt;&lt;/a&gt;前言：Hashmap面试内容总结，为面试做准备。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法与数据结构" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数据结构" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础复习</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-16T07:34:26.000Z</published>
    <updated>2021-12-13T16:24:36.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章是对数据库基础的总结和归纳。"><a href="#摘要：这篇文章是对数据库基础的总结和归纳。" class="headerlink" title="摘要：这篇文章是对数据库基础的总结和归纳。"></a>摘要：这篇文章是对数据库基础的总结和归纳。</h1><hr><h1 id="前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。"><a href="#前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。" class="headerlink" title="前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。"></a>前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。</h1><hr><span id="more"></span><p><strong>1.常用的数据库有哪些？redis用过吗?</strong></p><ul><li>常用的数据库<ul><li>MySQL</li><li>SQLServer</li><li>Redis</li><li>oracle</li></ul></li><li>Redis是一个速度非常快的非关系型数据库，他可以存储键(key)与5种不同类型的值（value）之间的映射，可以将存储在内存中的键值对数据持久化到硬盘中。</li><li>与Memcached相比<ul><li>两者都可用于存储键值映射，彼此性能也相差无几</li><li>Redis能够自动以两种不同的方式将数据写入硬盘</li><li>Redis除了能存储普通的字符串键之外，还可以存储其他4种数据结构，memcached只能存储字符串键</li><li>Redis既能用作主数据库，由可以作为其他存储系统的辅助数据库</li></ul></li></ul><p><strong>2数据库索引的优缺点以及什么时候数据库索引失效</strong></p><ul><li><p>索引的特点</p><ul><li>可以加快数据库的检索速度</li><li>降低数据库插入、修改、删除等维护的速度</li><li>只能创建在表上，不能创建到视图上</li><li>既可以直接创建又可以间接创建</li><li>可以在优化隐藏中使用索引</li><li>使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引</li></ul></li><li><p>索引的优点</p><ul><li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li><li>大大加快数据的检索速度，这是创建索引的最主要的原因</li><li>加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能</li></ul></li><li><p>索引的缺点</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度</li></ul></li><li><p>索引分类</p><ul><li>直接创建索引和间接创建索引</li><li>普通索引和唯一性索引</li><li>单个索引和复合索引</li><li>聚簇索引和非聚簇索引</li></ul></li><li><p>索引失效</p><ul><li>如果条件中有or，即使其中有条件带索引也不会使用(这就是问什么尽量少使用or的原因)</li><li>对于多列索引，不是使用的第一部分，则不会使用索引</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中使用引号引起来，否则不会使用索引</li></ul></li><li><p>如果mysql估计使用全表扫秒比使用索引快，则不适用索引。</p></li><li><p>各引擎支持索引<br><img src="/img/image/blog/6/sql.png" alt="sql"></p></li></ul><p><strong>3.事务隔离级别</strong></p><ul><li>串行化(Serializable)：所有事务一个接着一个的执行，这样可以避免幻读(phantom read),对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需回滚该事务。</li><li>可重复读(Repeated Read)：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取不一致的情况。但是没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为强恶意事务没有范围锁</li><li>读已提交(Read Committed)：被读取的数据可以被其他事务修改，这样可能导致不可重复读。也就是说，事务读取的时候获取读锁，但是在读完之后立即释放(不需要等事务结束)，而写锁则是事务提交之后才释放，释放读锁之后，就可能被其他事务修改数据。改等级也是SQL Server默认的隔离等级</li><li>读未提交(Read Uncommitted)：最低的隔离等级，允许其他事务看到没有提交的数据，会导致脏读</li><li>总结<ul><li>四个级别逐渐增强，每个级别解决一个问题，每个级别解决一个问题，事务级别遇到，性能越差，大多数环境(Read committed 就可以用了)<br><img src="/img/image/blog/6/sql1.png" alt="sql1"></li></ul></li></ul><p><strong>4.数据库中的范式有哪些？</strong></p><ul><li>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。</li><li>范式的包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式…</li><li>范式</li><li>1NF ：符合1NF的关系中的每个属性都不可再分</li><li>2NF：属性完全依赖于主键 [消除部分子函数依赖]</li><li>3NF：属性不依赖于其它非主属性[消除传递依赖]</li><li>BCNF：在1NF基础上，任何非主属性不能对主键子集依赖[在3NF基础上消除对主码子集的依赖]</li><li>4NF：要求把同一表内的多对多关系删除。</li><li>5NF：从最终结构重新建立原始结构。</li></ul><p><strong>5数据库中的索引的结构？什么情况下适合建索引?</strong></p><ul><li><p>数据库中的索引结构<br>因为在使用二叉树的时候，由于二叉树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下。因此采用多叉树结构。B树的各种操作能使B树能保持较低的高度。</p></li><li><p>B 树又叫平衡多路查找树，一棵 m 阶的 B 树的特性如下</p></li><li><p>树中每个结点最多含有 m 个孩子（m&gt;=2）；</p></li><li><p>除根结点和叶子结点外，其他每个结点至少有[ceil(m / 2)]个孩子（其中 ceil(x)是一个取上限的函数）；</p></li><li><p>根结点至少有 2 个孩子（除非 B 树只包含一个结点：根结点）；</p></li><li><p>所有叶子结点都出现在同一层， 叶子结点不包含任何关键字信息 (可以看做是外部结点或查询失败的结点，指向这些结点的指针都为 null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存<br>在，也有元素。类似红黑树中，每一个 NULL 指针即当做叶子结点，只是没画出来而已）。</p></li><li><p>每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>a) Ki (i=1…n)为关键字，且关键字按顺序升序排序 K(i-1)&lt; Ki。<br>b) Pi 为指向子树根的结点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。<br>c) 关键字的个数 n 必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。比如有 j 个孩子的非叶结点恰好有 j-1 个关<br>键码。<br><img src="/img/image/blog/6/sql2.png" alt="sql2"></p></li><li><p>B+树<br><img src="/img/image/blog/6/sql3.png" alt="sql3"></p></li><li><p>在什么情况下适合建立索引</p><ul><li>为经常出现在关键字order by、group by、distinct后面的字段，建立索引。</li><li>在union等集合操作的结果集字段上，建立索引。其建立索引的目的同上。</li><li>为经常用作查询选择的字段，建立索引。</li><li>在经常用作表连接的属性上，建立索引。</li><li>考虑使用索引覆盖。对数据很少被更新的表，如果用户经常只查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描。</li></ul></li></ul><p><strong>6.Redis的存储结构，或者说如何工作的，与mysql的区别？有哪些数据类型？</strong></p><ul><li>Redis的数据结构<ul><li>STRING：可以是字符串、整数或者浮点数</li><li>LIST：一个链表，链表上的每个节点都包含了一个字符串</li><li>SET：包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二、各不相同的</li><li>HAST：包含键值对的无序散列表</li><li>ZSET：字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</li></ul></li></ul><p><strong>7.数据库中的分页查询语句怎么写？<a href="http://qimo601.iteye.com/blog/1634748">http://qimo601.iteye.com/blog/1634748</a></strong></p><ul><li>Mysql的limit用法<ul><li>SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</li><li>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</li></ul></li><li>最基本的分页方式：SELECT … FROM … WHERE … ORDER BY … LIMIT …</li><li>子查询的分页方式：</li></ul><p><strong>8.数据库ACID</strong></p><ul><li>原子性(Atomicity)：保证事务中的所有操作全部执行或全部不执行</li><li>一致性(Consistency)：保证数据库始终保持数据的一致性——事务操作之前和之后都是一致的</li><li>隔离性(Isolation)：多个事务并发执行的话，结果应该与多个事务串行执行效果是一样的</li><li>持久性(Durability)：事务操作完成之后，对数据库的影响是持久的，即使数据库因故障而受到破坏，数据库也能够恢复(日志)</li></ul><p><strong>9.脏读、不可重复读和幻读</strong></p><ul><li>脏读：事务T1更新了一行记录的内容，但是并没有提交所做的修改。事务T2读取更新后的行，然后T1执行了回滚操作，取消了刚才所做的修改。现在T2读取的行就无效了（一个事务读取了另一个事务未提交的数据）</li><li>不可重复读：事务T1读取了一行记录，紧接着T2修改了T1刚才读取的那一行记录，然后T1又再次读取这行记录，发现与刚才读取的结果不同。</li><li>幻读：事务T1读取一条指定的Where子句所返回的结果集，然后T2事务新插入一行记录，这行记录恰好可以满足T1所使用的查询条件。然后T1再次对表进行检索，但又看到了T2插入的数据。</li></ul><p><strong>10.MyISAM和InnoDB引擎的区别</strong></p><ul><li><p>主要区别：</p><ul><li>MyISAM是非事务安全型的，而InnoDB是事务安全型的。</li><li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</li><li>MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li><li>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</li><li>MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li><li>InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li></ul></li><li><p>应用场景：</p><ul><li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</li><li>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章是对数据库基础的总结和归纳。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章是对数据库基础的总结和归纳。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章是对数据库基础的总结和归纳。&quot;&gt;&lt;/a&gt;摘要：这篇文章是对数据库基础的总结和归纳。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot;&gt;&lt;a href=&quot;#前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot; class=&quot;headerlink&quot; title=&quot;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot;&gt;&lt;/a&gt;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="数据库" scheme="https://www.blog.ajie39.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="数据库" scheme="https://www.blog.ajie39.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis 是单线程的？？？？你别唬我，我可不是厦（吓）大的</title>
    <link href="https://www.blog.ajie39.top/2021/05/09/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84/"/>
    <id>https://www.blog.ajie39.top/2021/05/09/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84/</id>
    <published>2021-05-09T12:53:14.000Z</published>
    <updated>2021-05-09T12:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。"><a href="#摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。" class="headerlink" title="摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。"></a>摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。</h1><hr><h1 id="前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。"><a href="#前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。" class="headerlink" title="前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。"></a>前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。</h1><hr><span id="more"></span><h2 id="一、Redis-是否真的是单线程？"><a href="#一、Redis-是否真的是单线程？" class="headerlink" title="一、Redis 是否真的是单线程？"></a>一、Redis 是否真的是单线程？</h2><p>​        <code>Redis 服务器</code>使用<code>单线程单进程</code>的方式来处理命令请求， 并与多个客户端进行网络通信。Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。所以说 Redis 不是所有模块都是单线程的。</p><p>​         Redis 服务器是典型的一对多服务器程序： 一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求， 并向客户端返回命令回复。</p><p>​    Redis 服务器状态结构的 clients 属性是一个链表。这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历 clients 链表来完成。</p><ul><li>Redis v4.0（引入多线程处理异步任务）</li><li>Redis v6.0（正式在网络模型中实现 I/O 多线程）</li></ul><h2 id="二、Redis-单线程模型"><a href="#二、Redis-单线程模型" class="headerlink" title="二、Redis 单线程模型"></a>二、Redis 单线程模型</h2><p>Redis作为一个成熟的分布式缓存框架，它由很多个模块组成，如网络请求模块、索引模块、存储模块、高可用集群支撑模块、数据操作模块等。</p><p>我们所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。</p><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所以每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题。</p><h2 id="三、Redis-客户端到服务端请求过程"><a href="#三、Redis-客户端到服务端请求过程" class="headerlink" title="三、Redis 客户端到服务端请求过程"></a>三、Redis 客户端到服务端请求过程</h2><ol><li>客户端到服务端建立网络连接</li><li>客户端发生读写事件并向服务器端发送请求数据</li><li>服务端进行数据处理</li><li>服务端数据返回</li></ol><h3 id="1、客户端到服务端建立网络连接"><a href="#1、客户端到服务端建立网络连接" class="headerlink" title="1、客户端到服务端建立网络连接"></a>1、客户端到服务端建立网络连接</h3><p>首先，客户端和服务端是 socket 通信方式，socket 服务端监听可同时接受多个客户端请求，这点很重要，如果不理解可先记住。注意这里可以理解为本质上与 redis 无关，这里仅仅做网络连接，或者可以理解为，为 redis 服务端提供网络交互api。</p><p>假设建立网络连接需要15秒（实际上比这个时间小非常多）。</p><h3 id="2、客户端发生读写事件并向服务端发送请求数据"><a href="#2、客户端发生读写事件并向服务端发送请求数据" class="headerlink" title="2、客户端发生读写事件并向服务端发送请求数据"></a>2、客户端发生读写事件并向服务端发送请求数据</h3><p>首先确定一点，redis的客户端与服务端通信是基于TCP连接，第一阶段仅仅是建立了客户端到服务端的网络连接，然后才是发生第二阶段的读写事件。</p><p>完成了上一个阶段的网络连接，redis客户端开始真正向服务端发起读写事件，假设是set（写）事件，此时redis客户端开始向建立的网络流中送数据，服务端可以理解为给每一个网络连接创建一个线程同时接收客户端的请求数据。<br>假设从客户端发数据，到服务端接收完数据需要5秒。</p><h3 id="3、Redis-服务器进行数据处理"><a href="#3、Redis-服务器进行数据处理" class="headerlink" title="3、Redis 服务器进行数据处理"></a>3、Redis 服务器进行数据处理</h3><p>服务端完成了第二阶段的数据接收，接下来开始依据接收到的数据做逻辑处理，然后得到处理后的数据。数据处理可以理解为一次方法调用，带参调用方法，最终得到方法返回值。不要想复杂，重在理解流程。假设redis服务端处理数据需要0.1秒</p><h3 id="4、服务器数据返回"><a href="#4、服务器数据返回" class="headerlink" title="4、服务器数据返回"></a>4、服务器数据返回</h3><p>这一阶段很简单，当reids服务端数据处理完后 就会立即返回处理后的数据，没什么特别需要强调的。假设服务端把处理后的数据回送给客户端需要5秒。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>第一阶段说过，redis 是以 socket 方式通信，socket服务端可同时接受多个客户端请求连接，也就是说，redis服务同时面对多个redis客户端连接请求，而redis服务本身是单线程运行。</p><p>假设，现在有A,B,C,D,E五个客户端同时发起redis请求，A优先稍微一点点第一个到达，然后是B，C，D，E依次到达，此时redis服务端开始处理A请求，建立连接需要15秒，获取请求数据需要5秒，然后处理数据需要0.1秒，回送数据给客户端需要5秒，总共大概需要25.1秒。也就是说，下一个B请求需要等待25.1秒，这里注意，也许这五个几乎同时请求，由于socket可以同时处理多个请求，所以建立网络连接阶段时间差可忽略<code>(也就是说少了15秒)</code>，但是在第二阶段，服务端需要什么事都不干，坐等5秒中，对于CPU和客户端来说是无法忍受的。所以说单线程效率非常，非常低，但是正是因为这些类似问题，Redis单线程本质上并不是如此运行。接下来讨论redis真正的单线程运行方式。</p><h2 id="Redis-单线程运行方式简单理解"><a href="#Redis-单线程运行方式简单理解" class="headerlink" title="Redis 单线程运行方式简单理解"></a>Redis 单线程运行方式简单理解</h2><p>客户端与服务端建立连接交由 socket，可以同时建立多个连接（这里应该是多线程/多进程），建立的连接redis是知道的（不了解的，这里可以去看一下socket编程），然后 redis 会基于这些建立的连接去探测哪个连接已经接收完了客户端的请求数据（注意：不是探测哪个连接建立好了，<code>而是探测哪个接收完了请求数据</code>），而且这里的探测动作就是单线程的开始，一旦探测到则基于接收到的数据开始数据处理阶段，然后返回数据，再继续探测下一个已经接收完请求数据的网络连接。注意，从探测到数据处理再到数据返回，全程单线程。</p><p>从探测到接受完请求数据的网络连接到最终的数据返回，服务器只需要5.1秒，这个时间是我放大N倍后的数据，实际时间远远小于这个，最终的返回数据虽然牵扯到网络，但是网络连接已经建立，这个速度也是非常非常快的，只是比数据处理阶段慢那么一点点。因此单线程方式在效率上其实并不需要担心。</p><h2 id="单线程事件循环"><a href="#单线程事件循环" class="headerlink" title="单线程事件循环"></a>单线程事件循环</h2><h2 id="四、为什么-Redis-网络操作模块和数据存储模块最初并没有使用多线程呢"><a href="#四、为什么-Redis-网络操作模块和数据存储模块最初并没有使用多线程呢" class="headerlink" title="四、为什么 Redis 网络操作模块和数据存储模块最初并没有使用多线程呢?"></a>四、为什么 Redis 网络操作模块和数据存储模块最初并没有使用多线程呢?</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.51cto.com/art/202103/650049.htm">Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a></li><li><a href="https://www.cnblogs.com/myseries/p/11733861.html">Redis 单线程的理解</a></li><li><a href="https://zhuanlan.zhihu.com/p/140927022">Redis 网络通信模块源码分析（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/352557644">Redis 多线程网络模型全面揭秘</a></li><li><a href="https://zhuanlan.zhihu.com/p/345327284">Redis 的通讯协议及事件处理机制</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。&quot;&gt;&lt;a href=&quot;#摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。&quot; class=&quot;headerlink&quot; title=&quot;摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。&quot;&gt;&lt;/a&gt;摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。&quot;&gt;&lt;a href=&quot;#前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。&quot; class=&quot;headerlink&quot; title=&quot;前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。&quot;&gt;&lt;/a&gt;前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（拓展篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:54:00.000Z</published>
    <updated>2021-05-05T08:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（基础篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（进阶篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？<br>2、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>3、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？<br>4、Redis 常见性能问题和解决方案？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（进阶篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（进阶篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:53:50.000Z</published>
    <updated>2021-05-05T08:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（基础篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（拓展篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、说说 Redis 哈希槽的概念？<br>2、Redis 的同步机制了解么？<br>3、是否使用过 Redis 集群，集群的原理是什么？<br>4、Redis 集群方案什么情况下会导致整个集群不可<br>5、Redis 集群的主从复制模型是怎样的？<br>6、Redis 集群会有写操作丢失吗？为什么？<br>7、Redis 集群之间是如何复制的？<br>8、Redis 集群最大节点个数是多少？<br>9、Redis 集群如何选择数据库？<br>10、如何实现集群中的 session 共享存储？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（拓展篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁原理分析与应用</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-05-05T07:54:50.000Z</published>
    <updated>2022-01-17T15:59:28.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是介绍分布式锁相关的内容。"><a href="#摘要：这篇文章主要是介绍分布式锁相关的内容。" class="headerlink" title="摘要：这篇文章主要是介绍分布式锁相关的内容。"></a>摘要：这篇文章主要是介绍分布式锁相关的内容。</h1><hr><h1 id="前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"><a href="#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。" class="headerlink" title="前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"></a>前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。</h1><hr><span id="more"></span><h2 id="分布式锁的使用场景"><a href="#分布式锁的使用场景" class="headerlink" title="分布式锁的使用场景"></a>分布式锁的使用场景</h2><ul><li><p>效率性:使用分布式锁可以避免不同节点重复相同的工作。</p></li><li><p>正确性:分布式锁可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</p></li></ul><h2 id="分布式锁的几种特性"><a href="#分布式锁的几种特性" class="headerlink" title="分布式锁的几种特性"></a>分布式锁的几种特性</h2><ul><li><p>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</p></li><li><p>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</p></li><li><p>锁超时:和本地锁一样支持锁超时，防止死锁。</p></li><li><p>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</p></li><li><p>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</p></li><li><p>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。</p></li></ul><h2 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h2><p>分布式锁有以下几个方式:</p><ul><li>MySql</li><li>Zk</li><li>Redis</li><li>一些自研的分布式锁(Chubby)</li></ul><h3 id="一、基于-Mysql-实现分布式锁"><a href="#一、基于-Mysql-实现分布式锁" class="headerlink" title="一、基于 Mysql 实现分布式锁"></a>一、基于 Mysql 实现分布式锁</h3><p>1、首先，我们需要创建一个锁表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &#96;resource_lock&#96; (</span><br><span class="line">    &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;resource_name&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;资源名称&#39;,</span><br><span class="line">    &#39;node_info&#39; varchar(128) DEFAULT &#39;0&#39; COMMENT &#39;节点信息&#39;,</span><br><span class="line">    &#39;count&#39; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT  &#39;锁的次数，统计可重入锁&#39;,</span><br><span class="line">    &#39;desc&#39; varchar(128) DEFAULT NULL COMMENT &#39;额外的描述信息&#39;,</span><br><span class="line">    &#96;create_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">    &#96;update_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,</span><br><span class="line">    PRIMARY KEY (&#39;id&#39;),</span><br><span class="line">    UNIQUE KEY &#39;un_resource_name&#39; (&#39;resource_name&#39;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、lock</p><p>先进行查询，如果有值，那么需要比较 node_info 是否一致，这里的 node_info 可以用机器 IP 和线程名字来表示，如果一致那么就加可重入锁 count 的值，如果不一致那么就返回 false 。如果没有值那么直接插入一条数据。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加事务，原子性</span><br><span class="line">@Transaction</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断节点信息是否一致</span><br><span class="line">        if (currentNodeInfo &#x3D;&#x3D; resultNodeInfo) &#123;</span><br><span class="line">            &#x2F;&#x2F; 保住锁的可重入性</span><br><span class="line">            update resource_lock set count &#x3D; count + 1 where resource_name &#x3D; &#39;xxx&#39;;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 插入新数据</span><br><span class="line">        insert into resourceLock;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、tryLock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean tryLock(long timeOut) &#123;</span><br><span class="line">    long stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    long endTimeOut &#x3D; stTime + timeOut;</span><br><span class="line"></span><br><span class="line">    while (endTimeOut &gt; stTime) &#123;</span><br><span class="line">        if (mysqlLock.lock()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 休眠3s后重试</span><br><span class="line">        LockSupport.parkNanos(1000 * 1000 * 1000 * 1);</span><br><span class="line">        stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、unlock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Transaction</span><br><span class="line">public boolean unlock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 查询是否有数据</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; count为1那么可以删除，如果大于1那么需要减去1。</span><br><span class="line">        if (count &gt; 1) &#123;</span><br><span class="line">            update count &#x3D; count - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、定时清理因为机器宕机导致的锁未被释放的问题</p><p>启动一个定时任务，当这个锁远超过任务的执行时间，没有被释放我们就可以认定是节点挂了然后将其直接释放。</p><h3 id="二、基于单Redis节点的分布式锁"><a href="#二、基于单Redis节点的分布式锁" class="headerlink" title="二、基于单Redis节点的分布式锁"></a>二、基于单Redis节点的分布式锁</h3><p>首先，Redis客户端为了获取锁，向Redis节点发送如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SET resource_name my_random_value NX PX 30000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。</p><p>注意，在上面的SET命令中：</p><ul><li>my_random_value是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。</li><li>NX表示只有当resource_name对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</li><li>PX 30000表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。</li></ul><p>最后，当客户端完成了对共享资源的操作之后，执行下面的Redis Lua脚本来释放锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">     return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line"> else</span><br><span class="line">     return 0</span><br><span class="line"> end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段Lua脚本在执行的时候要把前面的my_random_value作为 ARGV[1] 的值传进去，把 resource_name 作为 KEYS[1] 的值传进去。</p><p>至此，基于单Redis节点的分布式锁的算法就描述完了。</p><h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><h5 id="第一点：过期时间"><a href="#第一点：过期时间" class="headerlink" title="第一点：过期时间"></a>第一点：过期时间</h5><p>首先第一个问题，这个锁必须要设置一个过期时间。<br>否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了，而且把这个过期时间称为锁的有效时间(lock validity time)。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p><h5 id="第二点：获取锁"><a href="#第二点：获取锁" class="headerlink" title="第二点：获取锁"></a>第二点：获取锁</h5><p>第二个问题，第一步获取锁的操作，网上不少文章把它实现成了两个Redis命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SETNX resource_name my_random_value</span><br><span class="line">EXPIRE resource_name 30</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然这两个命令和前面算法描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。</p><h5 id="第三点：my-random-value"><a href="#第三点：my-random-value" class="headerlink" title="第三点：my_random_value"></a>第三点：my_random_value</h5><p>第三个问题，设置一个随机字符串 my_random_value 是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。</p><p>假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1在某个操作上阻塞了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</li><li>之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。</li></ul><h5 id="第四点：Lua脚本"><a href="#第四点：Lua脚本" class="headerlink" title="第四点：Lua脚本"></a>第四点：Lua脚本</h5><p>第四个问题，释放锁的操作必须使用Lua脚本来实现。释放锁其实包含三步操作：获取、判断和删除，用Lua脚本来实现能保证这三步的原子性。</p><p>否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面第三个问题类似的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1访问共享资源。</li><li>客户端1为了释放锁，先执行’GET’操作获取随机字符串的值。</li><li>客户端1判断随机字符串的值，与预期的值相等。</li><li>客户端1由于某个原因阻塞住了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</li></ul><p>实际上，在上述第三个问题和第四个问题的分析中，如果不是客户端阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。</p><p>这四个问题，只要实现分布式锁的时候加以注意，就都能够被正确处理。</p><p>但除此之外，还有一个问题，是由 failover（故障转移） 引起的，却是基于单Redis节点的分布式锁无法解决的。正是这个问题催生了Redlock的出现。</p><h5 id="多个Redis节点的情况下会产生的问题"><a href="#多个Redis节点的情况下会产生的问题" class="headerlink" title="多个Redis节点的情况下会产生的问题"></a>多个Redis节点的情况下会产生的问题</h5><p>这个问题是这样的。假如Redis节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。</p><p>例如下面的执行序列：</p><ul><li>客户端1从Master获取了锁。</li><li>Master宕机了，存储锁的key还没有来得及同步到Slave上。</li><li>Slave升级为Master。</li><li>客户端2从新的Master获取到了对应同一个资源的锁。</li></ul><p>于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。</p><h4 id="三、分布式锁-Redlock"><a href="#三、分布式锁-Redlock" class="headerlink" title="三、分布式锁 Redlock"></a>三、分布式锁 Redlock</h4><p>前面介绍的基于单Redis节点的分布式锁在failover的时候会产生解决不了的安全性问题，因此antirez提出了新的分布式锁的算法Redlock，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p><p>运行Redlock算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p><p>1、获取当前时间（毫秒数）。</p><p>2、按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</p><p>3、计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p><p>4、如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p><p>5、如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p><p>上面描述的只是获取锁的过程，而释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p><p>由于N个Redis节点中的大多数能正常工作就能保证Redlock正常工作，因此理论上它的可用性更高。我们前面讨论的单Redis节点的分布式锁在failover的时候锁失效的问题，在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟Redis对数据的持久化程度有关。</p><h5 id="节点崩溃可能导致的问题"><a href="#节点崩溃可能导致的问题" class="headerlink" title="节点崩溃可能导致的问题"></a>节点崩溃可能导致的问题</h5><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><p>1、客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</p><p>2、节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</p><p>3、节点C重启后，客户端2锁住了C, D, E，获取锁成功。</p><p>4、这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p>在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez又提出了延迟重启(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><h5 id="客户端应该向所有Redis节点发起释放锁的操作？"><a href="#客户端应该向所有Redis节点发起释放锁的操作？" class="headerlink" title="客户端应该向所有Redis节点发起释放锁的操作？"></a>客户端应该向所有Redis节点发起释放锁的操作？</h5><p>在最后释放锁的时候，antirez在算法描述中特别强调，客户端应该向所有Redis节点发起释放锁的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？</p><p>设想这样一种情况，客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p><h3 id="四、基于zk实现分布式锁"><a href="#四、基于zk实现分布式锁" class="headerlink" title="四、基于zk实现分布式锁"></a>四、基于zk实现分布式锁</h3><p>ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。Zk的数据节点和文件目录类似，所以我们可以用此特性实现分布式锁。</p><p>基本实现步骤如下：</p><p>1、客户端尝试创建一个znode节点，比如/lock。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode已存在），获取锁失败。</p><p>2、持有锁的客户端访问共享资源完成后，将znode删掉，这样其它客户端接下来就能来获取锁了。</p><p>注意：<br>  这里的znode应该被创建成ephemeral的（临时节点）。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除。这保证了锁一定会被释放。</p><h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><p>看起来这个锁相当完美，没有Redlock过期时间的问题，而且能在需要的时候让锁自动释放。但其实也存在这其中也存在问题。</p><p>ZooKeeper是怎么检测出某个客户端已经崩溃了呢？实际上，每个客户端都与ZooKeeper的某台服务器维护着一个Session，这个Session依赖定期的心跳(heartbeat)来维持。如果ZooKeeper长时间收不到客户端的心跳（这个时间称为Sesion的过期时间），那么它就认为Session过期了，通过这个Session所创建的所有的ephemeral类型的znode节点都会被自动删除。</p><p>假如按照下面的顺序执行：</p><p>1、客户端1创建了znode节点/lock，获得了锁。</p><p>2、客户端1进入了长时间的GC pause。</p><p>3、客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。</p><p>4、客户端2创建了znode节点/lock，从而获得了锁。</p><p>5、客户端1从GC pause中恢复过来，它仍然认为自己持有锁。</p><p>由上面的执行顺序，可以发现最后客户端1和客户端2都认为自己持有了锁，冲突了。所以说，用ZooKeeper实现的分布式锁也不一定就是安全的，该有的问题它还是有。</p><h4 id="zk的watch机制"><a href="#zk的watch机制" class="headerlink" title="zk的watch机制"></a>zk的watch机制</h4><p>ZooKeeper有个很特殊的机制–watch机制。这个机制可以这样来使用，比如当客户端试图创建 /lock 节点的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6844903688088059912">https://juejin.cn/post/6844903688088059912</a></li><li>Redlock的算法：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></li><li><a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></li><li>linux的同步IO操作函数: sync、fsync与fdatasync：<a href="https://my.oschina.net/u/1377774/blog/529847">https://my.oschina.net/u/1377774/blog/529847</a></li><li><a href="https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w">https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是介绍分布式锁相关的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是介绍分布式锁相关的内容。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;a href=&quot;#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;/a&gt;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://www.blog.ajie39.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式锁" scheme="https://www.blog.ajie39.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>YAML的常用语法</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/YAML%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/YAML%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2021-05-05T04:26:56.000Z</published>
    <updated>2021-05-05T04:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：主要介绍YAML的常用语法"><a href="#摘要：主要介绍YAML的常用语法" class="headerlink" title="摘要：主要介绍YAML的常用语法"></a>摘要：主要介绍YAML的常用语法</h1><hr><h1 id="前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。"><a href="#前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。" class="headerlink" title="前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。"></a>前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。</h1><hr><span id="more"></span><h1 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h1><h2 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h2><p><strong>诞生</strong></p><p>  YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822。Clark Evans在2001年5月在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。</p><p><strong>命名</strong></p><p>  YAML是<code>&quot;YAML Ain&#39;t a Markup Languag&quot;</code>（YAML不是一种置标语言）的递归缩写。在开发的这种语言时，YAML的意思其实是：Yet Another Markup Language（仍是一种置标语言）。</p><p><strong>功能</strong></p><p>  YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表，标量等资料形态、。它使用空白符号缩排和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种设定档、倾印除错内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。尽管它比较适合用来表达阶层式（hierarchical model）的数据结构，不过也有精致的语法可以表示关联性（relational model）的资料。由于YAML使用空白字符和分行来分隔资料，使得它他特别适合用grep、Python、Perl、Ruby操作。其让人最容易上手的特色是巧妙避开各种封闭符号，如：引号、各种括号等，这些符号在嵌套结构中会变得复杂而难以辨认。</p><p><strong>它的基本语法规则如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 大小写敏感。</span><br><span class="line">- 使用缩进表示层级关系。</span><br><span class="line">- 缩进时不允许使用Tab键，只允许使用空格。</span><br><span class="line">- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可。</span><br></pre></td></tr></table></figure><p><code># 表示注释，从这个字符一直到行尾，都会被解析器忽略。</code></p><p><strong>YAML 支持的数据结构有三种：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</span><br><span class="line">- 数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</span><br><span class="line">- 纯量（scalars）：单个的、不可再分的值</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的一组键值对，使用冒号结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal: pets</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal: &#39;pets&#39; &#125;</span><br></pre></td></tr></table></figure><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash: &#123; name: Steve, foo: bar &#125;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; hash: &#123; name: &#39;Steve&#39;, foo: &#39;bar&#39; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一组连词线开头的行，构成一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Cat</span><br><span class="line">- Dog</span><br><span class="line">- Goldfish</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#39;Cat&#39;, &#39;Dog&#39;, &#39;Goldfish&#39; ]</span><br></pre></td></tr></table></figure><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line"> - Cat</span><br><span class="line"> - Dog</span><br><span class="line"> - Goldfish</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ &#39;Cat&#39;, &#39;Dog&#39;, &#39;Goldfish&#39; ] ]</span><br></pre></td></tr></table></figure><p>数组也可以采用行内表示法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal: [Cat, Dog]</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal: [ &#39;Cat&#39;, &#39;Dog&#39; ] &#125;</span><br></pre></td></tr></table></figure><h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><p>对象和数组可以结合使用，形成复合结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">languages:</span><br><span class="line"> - Ruby</span><br><span class="line"> - Perl</span><br><span class="line"> - Python</span><br><span class="line">websites:</span><br><span class="line"> YAML: yaml.org</span><br><span class="line"> Ruby: ruby-lang.org</span><br><span class="line"> Python: python.org</span><br><span class="line"> Perl: use.perl.org</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; languages: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39; ],</span><br><span class="line">  websites:</span><br><span class="line">   &#123; YAML: &#39;yaml.org&#39;,</span><br><span class="line">     Ruby: &#39;ruby-lang.org&#39;,</span><br><span class="line">     Python: &#39;python.org&#39;,</span><br><span class="line">     Perl: &#39;use.perl.org&#39; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h3><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串</span><br><span class="line">布尔值</span><br><span class="line">整数</span><br><span class="line">浮点数</span><br><span class="line">Null</span><br><span class="line">时间</span><br><span class="line">日期</span><br></pre></td></tr></table></figure><p>数值直接以字面量的形式表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number: 12.30</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; number: 12.30 &#125;</span><br></pre></td></tr></table></figure><p>布尔值用true和false表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isSet: true</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; isSet: true &#125;</span><br></pre></td></tr></table></figure><p>null用~表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent: ~</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; parent: null &#125;</span><br></pre></td></tr></table></figure><p>时间采用 ISO8601 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iso8601: 2001-12-14t21:59:43.10-05:00</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; iso8601: new Date(&#39;2001-12-14t21:59:43.10-05:00&#39;) &#125;</span><br></pre></td></tr></table></figure><p>日期采用复合 iso8601 格式的年、月、日表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date: 1976-07-31</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; date: new Date(&#39;1976-07-31&#39;) &#125;</span><br></pre></td></tr></table></figure><p>YAML 允许使用两个感叹号，强制转换数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e: !!str 123</span><br><span class="line">f: !!str true</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; e: &#39;123&#39;, f: &#39;true&#39; &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是最常见，也是最复杂的一种数据类型。</p><p>字符串默认不使用引号表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: 这是一行字符串</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;这是一行字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>如果字符串之中包含空格或特殊字符，需要放在引号之中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: &#39;内容： 字符串&#39;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;内容: 字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>单引号和双引号都可以使用，双引号不会对特殊字符转义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1: &#39;内容\n字符串&#39;</span><br><span class="line">s2: &quot;内容\n字符串&quot;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; s1: &#39;内容\\n字符串&#39;, s2: &#39;内容\n字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>单引号之中如果还有单引号，必须连续使用两个单引号转义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: &#39;labor&#39;&#39;s day&#39;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;labor\&#39;s day&#39; &#125;</span><br></pre></td></tr></table></figure><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str: 这是一段</span><br><span class="line">  多行</span><br><span class="line">  字符串</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;这是一段 多行 字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this: |</span><br><span class="line">  Foo</span><br><span class="line">  Bar</span><br><span class="line">that: &gt;</span><br><span class="line">  Foo</span><br><span class="line">  Bar</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; this: &#39;Foo\nBar\n&#39;, that: &#39;Foo Bar\n&#39; &#125;</span><br></pre></td></tr></table></figure><p>+表示保留文字块末尾的换行，-表示删除字符串末尾的换行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1: |</span><br><span class="line">  Foo</span><br><span class="line"></span><br><span class="line">s2: |+</span><br><span class="line">  Foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s3: |-</span><br><span class="line">  Foo</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; s1: &#39;Foo\n&#39;, s2: &#39;Foo\n\n\n&#39;, s3: &#39;Foo&#39; &#125;</span><br></pre></td></tr></table></figure><p>字符串之中可以插入 HTML 标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message: |</span><br><span class="line"></span><br><span class="line">  &lt;p style&#x3D;&quot;color: red&quot;&gt;</span><br><span class="line">    段落</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; message: &#39;\n&lt;p style&#x3D;&quot;color: red&quot;&gt;\n  段落\n&lt;&#x2F;p&gt;\n&#39; &#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaults: &amp;defaults</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure><p>等同于下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaults:</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br></pre></td></tr></table></figure><p><code>&amp;</code>用来建立锚点（defaults），<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点。</p><p>下面是另一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- &amp;showell Steve</span><br><span class="line">- Clark</span><br><span class="line">- Brian</span><br><span class="line">- Oren</span><br><span class="line">- *showell</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#39;Steve&#39;, &#39;Clark&#39;, &#39;Brian&#39;, &#39;Oren&#39;, &#39;Steve&#39; ]</span><br></pre></td></tr></table></figure><h3 id="函数和正则表达式的转换"><a href="#函数和正则表达式的转换" class="headerlink" title="函数和正则表达式的转换"></a>函数和正则表达式的转换</h3><p>这是<a href="https://github.com/nodeca/js-yaml">JS-YAML</a>库特有的功能，可以把函数和正则表达式转为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># example.yml</span><br><span class="line">fn: function () &#123; return 1 &#125;</span><br><span class="line">reg: &#x2F;test&#x2F;</span><br></pre></td></tr></table></figure><p>解析上面的 yml 文件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var yaml &#x3D; require(&#39;js-yaml&#39;);</span><br><span class="line">var fs   &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  var doc &#x3D; yaml.load(</span><br><span class="line">    fs.readFileSync(&#39;.&#x2F;example.yml&#39;, &#39;utf8&#39;)</span><br><span class="line">  );</span><br><span class="line">  console.log(doc);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 JavaScript 对象还原到 yaml 文件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var yaml &#x3D; require(&#39;js-yaml&#39;);</span><br><span class="line">var fs   &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  fn: function () &#123; return 1 &#125;,</span><br><span class="line">  reg: &#x2F;test&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    &#39;.&#x2F;example.yml&#39;,</span><br><span class="line">    yaml.dump(obj),</span><br><span class="line">    &#39;utf8&#39;</span><br><span class="line">  );</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：主要介绍YAML的常用语法&quot;&gt;&lt;a href=&quot;#摘要：主要介绍YAML的常用语法&quot; class=&quot;headerlink&quot; title=&quot;摘要：主要介绍YAML的常用语法&quot;&gt;&lt;/a&gt;摘要：主要介绍YAML的常用语法&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot;&gt;&lt;a href=&quot;#前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot; class=&quot;headerlink&quot; title=&quot;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot;&gt;&lt;/a&gt;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    <category term="Blog" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/Blog/"/>
    
    
    <category term="YAML" scheme="https://www.blog.ajie39.top/tags/YAML/"/>
    
  </entry>
  
</feed>
