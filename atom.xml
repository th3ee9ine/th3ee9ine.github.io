<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教练，我想学技术!</title>
  
  <subtitle>开局一双手，升级全靠苟，拼一拼，搏一搏，单车变摩托。</subtitle>
  <link href="https://www.blog.ajie39.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.ajie39.top/"/>
  <updated>2021-05-16T14:51:13.132Z</updated>
  <id>https://www.blog.ajie39.top/</id>
  
  <author>
    <name>th3ee9ine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql 数据库相关知识点总结</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-16T07:44:58.392Z</published>
    <updated>2021-05-16T14:51:13.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：对于-Mysql-常见的知识点总结。"><a href="#摘要：对于-Mysql-常见的知识点总结。" class="headerlink" title="摘要：对于 Mysql 常见的知识点总结。"></a>摘要：对于 Mysql 常见的知识点总结。</h1><hr><h1 id="前言：对于-Mysql-常见的知识点的总结。"><a href="#前言：对于-Mysql-常见的知识点的总结。" class="headerlink" title="前言：对于 Mysql 常见的知识点的总结。"></a>前言：对于 Mysql 常见的知识点的总结。</h1><hr><h2 id="Mysql-知识点脑图"><a href="#Mysql-知识点脑图" class="headerlink" title="Mysql 知识点脑图"></a>Mysql 知识点脑图</h2><p><img src="/blog/20210516/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE.png" alt="Mysql 知识点脑图"></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：对于-Mysql-常见的知识点总结。&quot;&gt;&lt;a href=&quot;#摘要：对于-Mysql-常见的知识点总结。&quot; class=&quot;headerlink&quot; title=&quot;摘要：对于 Mysql 常见的知识点总结。&quot;&gt;&lt;/a&gt;摘要：对于 Mysql 常见的知识点总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于-Mysql-常见的知识点的总结。&quot;&gt;&lt;a href=&quot;#前言：对于-Mysql-常见的知识点的总结。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于 Mysql 常见的知识点的总结。&quot;&gt;&lt;/a&gt;前言：对于 Mysql 常见的知识点的总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Mysql-知识点脑图&quot;&gt;&lt;a href=&quot;#Mysql-知识点脑图&quot; class=&quot;headerlink&quot; title=&quot;Mysql 知识点脑图&quot;&gt;&lt;/a&gt;Mysql 知识点脑图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/blog/20210516/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE.png&quot; alt=&quot;Mysql 知识点脑图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Mysql/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://www.blog.ajie39.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis 是单线程的？？？？你别唬我，我可不是厦（吓）大的</title>
    <link href="https://www.blog.ajie39.top/2021/05/08/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84/"/>
    <id>https://www.blog.ajie39.top/2021/05/08/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84/</id>
    <published>2021-05-08T06:54:53.707Z</published>
    <updated>2021-05-09T12:53:12.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。"><a href="#摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。" class="headerlink" title="摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。"></a>摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。</h1><hr><h1 id="前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。"><a href="#前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。" class="headerlink" title="前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。"></a>前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。</h1><hr><span id="more"></span><h2 id="一、Redis-是否真的是单线程？"><a href="#一、Redis-是否真的是单线程？" class="headerlink" title="一、Redis 是否真的是单线程？"></a>一、Redis 是否真的是单线程？</h2><p>​        <code>Redis 服务器</code>使用<code>单线程单进程</code>的方式来处理命令请求， 并与多个客户端进行网络通信。Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。所以说 Redis 不是所有模块都是单线程的。</p><p>​         Redis 服务器是典型的一对多服务器程序： 一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求， 并向客户端返回命令回复。</p><p>​    Redis 服务器状态结构的 clients 属性是一个链表。这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历 clients 链表来完成。</p><ul><li>Redis v4.0（引入多线程处理异步任务）</li><li>Redis v6.0（正式在网络模型中实现 I/O 多线程）</li></ul><h2 id="二、Redis-单线程模型"><a href="#二、Redis-单线程模型" class="headerlink" title="二、Redis 单线程模型"></a>二、Redis 单线程模型</h2><p>Redis作为一个成熟的分布式缓存框架，它由很多个模块组成，如网络请求模块、索引模块、存储模块、高可用集群支撑模块、数据操作模块等。</p><p>我们所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。</p><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所以每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题。</p><h2 id="三、Redis-客户端到服务端请求过程"><a href="#三、Redis-客户端到服务端请求过程" class="headerlink" title="三、Redis 客户端到服务端请求过程"></a>三、Redis 客户端到服务端请求过程</h2><ol><li>客户端到服务端建立网络连接</li><li>客户端发生读写事件并向服务器端发送请求数据</li><li>服务端进行数据处理</li><li>服务端数据返回</li></ol><h3 id="1、客户端到服务端建立网络连接"><a href="#1、客户端到服务端建立网络连接" class="headerlink" title="1、客户端到服务端建立网络连接"></a>1、客户端到服务端建立网络连接</h3><p>首先，客户端和服务端是 socket 通信方式，socket 服务端监听可同时接受多个客户端请求，这点很重要，如果不理解可先记住。注意这里可以理解为本质上与 redis 无关，这里仅仅做网络连接，或者可以理解为，为 redis 服务端提供网络交互api。</p><p>假设建立网络连接需要15秒（实际上比这个时间小非常多）。</p><h3 id="2、客户端发生读写事件并向服务端发送请求数据"><a href="#2、客户端发生读写事件并向服务端发送请求数据" class="headerlink" title="2、客户端发生读写事件并向服务端发送请求数据"></a>2、客户端发生读写事件并向服务端发送请求数据</h3><p>首先确定一点，redis的客户端与服务端通信是基于TCP连接，第一阶段仅仅是建立了客户端到服务端的网络连接，然后才是发生第二阶段的读写事件。</p><p>完成了上一个阶段的网络连接，redis客户端开始真正向服务端发起读写事件，假设是set（写）事件，此时redis客户端开始向建立的网络流中送数据，服务端可以理解为给每一个网络连接创建一个线程同时接收客户端的请求数据。<br>假设从客户端发数据，到服务端接收完数据需要5秒。</p><h3 id="3、Redis-服务器进行数据处理"><a href="#3、Redis-服务器进行数据处理" class="headerlink" title="3、Redis 服务器进行数据处理"></a>3、Redis 服务器进行数据处理</h3><p>服务端完成了第二阶段的数据接收，接下来开始依据接收到的数据做逻辑处理，然后得到处理后的数据。数据处理可以理解为一次方法调用，带参调用方法，最终得到方法返回值。不要想复杂，重在理解流程。假设redis服务端处理数据需要0.1秒</p><h3 id="4、服务器数据返回"><a href="#4、服务器数据返回" class="headerlink" title="4、服务器数据返回"></a>4、服务器数据返回</h3><p>这一阶段很简单，当reids服务端数据处理完后 就会立即返回处理后的数据，没什么特别需要强调的。假设服务端把处理后的数据回送给客户端需要5秒。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>第一阶段说过，redis 是以 socket 方式通信，socket服务端可同时接受多个客户端请求连接，也就是说，redis服务同时面对多个redis客户端连接请求，而redis服务本身是单线程运行。</p><p>假设，现在有A,B,C,D,E五个客户端同时发起redis请求，A优先稍微一点点第一个到达，然后是B，C，D，E依次到达，此时redis服务端开始处理A请求，建立连接需要15秒，获取请求数据需要5秒，然后处理数据需要0.1秒，回送数据给客户端需要5秒，总共大概需要25.1秒。也就是说，下一个B请求需要等待25.1秒，这里注意，也许这五个几乎同时请求，由于socket可以同时处理多个请求，所以建立网络连接阶段时间差可忽略<code>(也就是说少了15秒)</code>，但是在第二阶段，服务端需要什么事都不干，坐等5秒中，对于CPU和客户端来说是无法忍受的。所以说单线程效率非常，非常低，但是正是因为这些类似问题，Redis单线程本质上并不是如此运行。接下来讨论redis真正的单线程运行方式。</p><h2 id="Redis-单线程运行方式简单理解"><a href="#Redis-单线程运行方式简单理解" class="headerlink" title="Redis 单线程运行方式简单理解"></a>Redis 单线程运行方式简单理解</h2><p>客户端与服务端建立连接交由 socket，可以同时建立多个连接（这里应该是多线程/多进程），建立的连接redis是知道的（不了解的，这里可以去看一下socket编程），然后 redis 会基于这些建立的连接去探测哪个连接已经接收完了客户端的请求数据（注意：不是探测哪个连接建立好了，<code>而是探测哪个接收完了请求数据</code>），而且这里的探测动作就是单线程的开始，一旦探测到则基于接收到的数据开始数据处理阶段，然后返回数据，再继续探测下一个已经接收完请求数据的网络连接。注意，从探测到数据处理再到数据返回，全程单线程。</p><p>从探测到接受完请求数据的网络连接到最终的数据返回，服务器只需要5.1秒，这个时间是我放大N倍后的数据，实际时间远远小于这个，最终的返回数据虽然牵扯到网络，但是网络连接已经建立，这个速度也是非常非常快的，只是比数据处理阶段慢那么一点点。因此单线程方式在效率上其实并不需要担心。</p><h2 id="单线程事件循环"><a href="#单线程事件循环" class="headerlink" title="单线程事件循环"></a>单线程事件循环</h2><h2 id="四、为什么-Redis-网络操作模块和数据存储模块最初并没有使用多线程呢"><a href="#四、为什么-Redis-网络操作模块和数据存储模块最初并没有使用多线程呢" class="headerlink" title="四、为什么 Redis 网络操作模块和数据存储模块最初并没有使用多线程呢?"></a>四、为什么 Redis 网络操作模块和数据存储模块最初并没有使用多线程呢?</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.51cto.com/art/202103/650049.htm">Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a></li><li><a href="https://www.cnblogs.com/myseries/p/11733861.html">Redis 单线程的理解</a></li><li><a href="https://zhuanlan.zhihu.com/p/140927022">Redis 网络通信模块源码分析（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/352557644">Redis 多线程网络模型全面揭秘</a></li><li><a href="https://zhuanlan.zhihu.com/p/345327284">Redis 的通讯协议及事件处理机制</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。&quot;&gt;&lt;a href=&quot;#摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。&quot; class=&quot;headerlink&quot; title=&quot;摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。&quot;&gt;&lt;/a&gt;摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。&quot;&gt;&lt;a href=&quot;#前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。&quot; class=&quot;headerlink&quot; title=&quot;前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。&quot;&gt;&lt;/a&gt;前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（拓展篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:16:46.258Z</published>
    <updated>2021-05-05T08:53:58.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（基础篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（进阶篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？<br>2、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>3、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？<br>4、Redis 常见性能问题和解决方案？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（进阶篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（进阶篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:16:46.257Z</published>
    <updated>2021-05-05T08:53:49.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（基础篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（拓展篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、说说 Redis 哈希槽的概念？<br>2、Redis 的同步机制了解么？<br>3、是否使用过 Redis 集群，集群的原理是什么？<br>4、Redis 集群方案什么情况下会导致整个集群不可<br>5、Redis 集群的主从复制模型是怎样的？<br>6、Redis 集群会有写操作丢失吗？为什么？<br>7、Redis 集群之间是如何复制的？<br>8、Redis 集群最大节点个数是多少？<br>9、Redis 集群如何选择数据库？<br>10、如何实现集群中的 session 共享存储？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（拓展篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（基础篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T07:39:46.014Z</published>
    <updated>2021-06-19T18:55:31.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（拓展篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（进阶篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、Redis 是什么?<br>2、Redis 的数据类型？<br>3、Redis 是单进程单线程的？<br>4、Redis 的持久化机制有哪些？各自的优缺点？<br>5、Redis 常见性能问题和解决方案：<br>6、Redis 过期键的删除策略？<br>7、Redis 的回收策略（淘汰策略）?<br>8、为什么 Redis 需要把所有数据放到内存中？<br>9、Redis 支持的 Java 客户端都有哪些？<br>10、Jedis 与 Redisson 对比有什么优缺点？<br>12、Pipeline 有什么好处，为什么要用 pipeline？<br>13、怎么理解 Redis 事务？<br>16、Redis 事务相关的命令有哪几个？<br>17、Redis key 的过期时间和永久有效分别怎么设置？<br>18、Redis 如何做内存优化？<br>20、Redis 回收进程如何工作的？<br>21、都有哪些办法可以降低 Redis 的内存使用情况呢？<br>22、Redis 的内存用完了会发生什么？<br>24、查看 Redis 使用情况及状态信息用什么命令？<br>25、怎么测试 Redis 的连通性？<br>28、修改配置不重启 Redis 会实时生效吗？<br>29、使用过 Redis 分布式锁么，它是什么回事？<br>30、使用过 Redis 做异步队列么，你是怎么用的？<br>31、Redis 最适合的场景？</p><h2 id="1、Redis-是什么？"><a href="#1、Redis-是什么？" class="headerlink" title="1、Redis 是什么？"></a>1、Redis 是什么？</h2><p>Redis 是一个 <code>远程内存数据库</code>，它不仅性能强劲，而且还具有 <code>复制特性</code> 以及 <code>为解决问题而生</code> 的独一无二的数据模型。Redis提供了 <code>5种不同类型的数据结构</code>，它可以存储键 (key) 与 5种不同类型的值 (value) 之间的映射(mapping)；可以将存储在内存的键值对数据待久化到硬盘，可以 <code>使用复制特性来扩展读性能</code>，还可以使用 <code>客户端分片来扩展写性能</code>，各式各样的问题都可以很自然地映射到这些数据结构上：Redis的数据结构致力千帮助用户解决问题，而不会像其他数据库那样，要求用户扭曲问题来适应数据库。除此之外，通过 <code>复制</code>、 <code>持久化(persistence)</code> 和 <code>客户端分片(client-side sharding)</code> 等特性，用户可以很方便地将 Redis 扩展成一个能够包含数百GB数据、 每秒处理上百万次请求的系统。</p><h2 id="2、Redis-的数据类型？"><a href="#2、Redis-的数据类型？" class="headerlink" title="2、Redis 的数据类型？"></a>2、Redis 的数据类型？</h2><p>Redis 数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：</p><ul><li>数据库 <code>键</code> 总是一个 <code>字符串对象（string object）</code>；</li><li>Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为 <code>String</code> (字符串)、 <code>List</code> （列表）、<code>Set</code>（集合）、<code>Hash</code>（散列）、<code>Zset</code>（有序集合）。</li></ul><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>String（字符串）</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作。</td></tr><tr><td>List（列表）</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素。</td></tr><tr><td>Set（集合）</td><td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td><td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素。</td></tr><tr><td>Hash（散列）</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对。</td></tr><tr><td>Zset（有序集合）</td><td>字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围或者成员来获取元素。</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1) 简单动态字符串"></a>1) 简单动态字符串</h4><p>​        Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称C<br>字符串），而是自己构建了一种名为 <code>简单动态字符串（simple dynamic string，SDS）</code>的抽象<br>类型，并将 SDS 用作 Redis 的<code>默认字符串</code>表示。</p><p>​        当 Redis 需要的不仅仅是一个字符串字面量，而是一个可以<code>被修改的字符串值</code>时，Redis<br>就会使用 SDS 来表示字符串值，比如在 Redis 的数据库里面，包含字符串值的键值对在底<br>层都是由 SDS 实现的。除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区（buffer）：AOF 模块中的 AOF 缓冲区，以及客户端状态中的输入缓冲区，都是由 SDS 实现的。</p><h4 id="2-SDS-的定义"><a href="#2-SDS-的定义" class="headerlink" title="2) SDS 的定义"></a>2) SDS 的定义</h4><p>SDS 的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">// 记录buf 数组中已使用字节的数量</span></span><br><span class="line"><span class="comment">// 等于SDS 所保存字符串的长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 记录buf 数组中未使用字节的数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图展示了一个 SDS 示例：</p><p><img src="/blog/20210505/SDS%E7%A4%BA%E4%BE%8B.png" alt="SDS示例"></p><ul><li>free 属性的值为0，表示这个 SDS 没有分配任何未使用空间。</li><li>len 属性的值为5，表示这个 SDS 保存了一个五字节长的字符串。</li><li>buf 属性是一个 <code>char 类型的数组</code>，数组的前五个字节分别保存了 ‘R’、’e’、’d’、’i’、’s’ 五个字符，而最后一个字节则保存了空字符 ‘\0’。</li></ul><p>SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的1 字节空间不计算在SDS 的 len 属性里面，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由SDS 函数自动完成的，所以这个空字符对于 SDS 的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分C 字符串函数库里面的函数。</p><h4 id="3-C-字符串和-SDS-之间的区别"><a href="#3-C-字符串和-SDS-之间的区别" class="headerlink" title="3) C 字符串和 SDS 之间的区别"></a>3) C 字符串和 SDS 之间的区别</h4><table><thead><tr><th align="center">C 字符串</th><th align="center">SDS</th></tr></thead><tbody><tr><td align="center">获取字符串长度的复杂度为O(N)</td><td align="center">获取字符串长度的复杂度为O(1)</td></tr><tr><td align="center">API 是不安全的，可能会造成缓冲区溢出</td><td align="center">API 是安全的，不会造成缓冲区溢出</td></tr><tr><td align="center">修改字符串长度N 次<code>必然</code>需要执行N 次内存重分配</td><td align="center">修改字符串长度N 次<code>最多</code>需要执行N 次内存重分配</td></tr><tr><td align="center">只能保存文本数据</td><td align="center">可以保存文本或者二进制数据</td></tr><tr><td align="center">可以使用所有&lt;string.h&gt; 库中的函数</td><td align="center">可以使用一部分&lt;string.h&gt; 库中的函数</td></tr></tbody></table><h4 id="4-C-字符串和-SDS-之间的区别"><a href="#4-C-字符串和-SDS-之间的区别" class="headerlink" title="4) C 字符串和 SDS 之间的区别"></a>4) C 字符串和 SDS 之间的区别</h4><p>比起C 字符串，SDS 具有以下优点：</p><ul><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出（空间预分配）。</li><li>减少修改字符串长度时所需的内存重分配次数（惰性空间释放）。</li><li>二进制安全。</li><li>兼容部分C 字符串函数。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>在 Redis 5.0 版本引入了一个新的数据类型–Streams(流信息)。它支持消费者组，借鉴 Kafka 设计的支持多播的可持久化消息队列(支持 group，不支持 partition)。</li><li>其他的数据类型的具体内容，这里就不在进行过多的展开了，后面会补上相关文章。</li><li>各个数据类型的存储最大存储大小：<ul><li>String：最大可以存储512M。</li><li>List：元素个数最多为 2^32-1 个，即 4294967295 个。</li><li>Set：元素个数最多为 2^32-1 个，即 4294967295 个。</li><li>Hash：键值对个数最多为 2^32-1 个，即 4294967295 个。</li><li>Zset：同 Sets。</li></ul></li></ul><h2 id="3、Redis-是单进程单线程的？"><a href="#3、Redis-是单进程单线程的？" class="headerlink" title="3、Redis 是单进程单线程的？"></a>3、Redis 是单进程单线程的？</h2><p>​        <code>Redis 服务器</code>使用<code>单线程单进程</code>的方式来处理命令请求， 并与多个客户端进行网络通信。Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><p>​        Redis 服务器是典型的一对多服务器程序： 一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求， 而服务器则接收并处理客户端发送的命令请求， 并向客户端返回命令回复。</p><p>​        对于每个与服务器进行连接的客户端， 服务器都为这些客户端建立了相应的 redis.h/ redisClient 结构（客户端状态），这个结构保存了客户端当前的状态信息． 以及执行相关功能时需要用到的数据结构， 其中包括：</p><ul><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值 (flag)。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制(soft limit) 的时间。</li></ul><p>​    Redis 服务器状态结构的 clients 属性是一个链表。这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历 clients 链表来完成。</p><p>关于 Redis 单线程的相关问题，因为内容较多，全部写到该篇文章中不太合适，所以这里重新写了一篇文章来进行总结 ：</p><p><a href="https://www.blog.ajie39.top/2021/05/08/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84">Redis 是单线程的？？？？你别唬我，我可不是厦（吓）大的</a></p><h2 id="4、Redis-的持久化机制有哪些？各自的优缺点？"><a href="#4、Redis-的持久化机制有哪些？各自的优缺点？" class="headerlink" title="4、Redis 的持久化机制有哪些？各自的优缺点？"></a>4、Redis 的持久化机制有哪些？各自的优缺点？</h2><p>​        Redis 是一个内存数据库，数据都存储在内存中，这也是 Redis 非常快的原因之一。虽然速度提上来了，但是如果数据一直放在内存中，是非常容易丢失的。比如服务器关闭或宕机了，内存中的数据就丢失了。为了解决这一问题，Redis 提供了持久化机制。一种是 RDB 持久化（<strong>原理是将Redis 在内存中的数据库记录定时dump到磁盘上</strong>），另一种是 AOF (append only file) 持久化，（<strong>原理是将 Redis 的操作日志以追加的方式写入文件</strong>）。两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。</p><pre><code>    #### 1）RDB（默认）</code></pre><p>RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照 (point-in-time snapshot)。</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><strong>RDB存在哪些优势？</strong></p><ol><li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松地将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样可以极大地避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ol><p><strong>RDB的劣势？</strong></p><ol><li>如果你想保证数据的高可用性，即最大限度地避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据将丢失。</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至1秒钟。</li></ol><h4 id="2）AOF"><a href="#2）AOF" class="headerlink" title="2）AOF"></a>2）AOF</h4><p>AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。</p><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF进行重写<strong>，</strong>重写后的新 AOF 文件包含了恢复当前数据集所需的<strong>最小命令集合</strong>。</p><p>AOF 持久化以日志的形式记录服务器所处理的每一个写、删操作（注意查询操作不会被记录）。以文本的方式记录，可以打开文件看到详细的操作记录。</p><p><strong>AOF的优势？</strong></p><ol><li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3种同步策略，及每秒同步，每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率非常高。所差的是一旦系统出现宕机现象，那么这一秒种之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无序多言，大家都能正确的理解它。</li><li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题</li><li>如果日志文件过大，Redis可以自动启动rewrite机制。即Reids以append模式不断地键修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更高的保证数据安全性。</li><li>AOF包含一个格式清晰，易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ol><p><strong>AOF的劣势？</strong></p><ol><li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件.RDB在恢复大数据集时速度比AOF的恢复速度快。</li><li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的。同步禁用策略的效率和RDB一样高效。</li></ol><p><strong>二者选择的标准</strong>：就是看系统是愿意牺牲一些性能，换取更高的缓存一致性(AOF)，还是愿意写操作频繁的时候，不启动备份来换取更高的性能。待手动运行save的时候，再做备份(RDB)。RDB 这个就更有些最终一致性的意思了</p><h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><h5 id="RDB持久化配置"><a href="#RDB持久化配置" class="headerlink" title="RDB持久化配置"></a><strong>RDB持久化配置</strong></h5><p>Redis 会将数据集的快照 dump 到 dump.rdb 文件中。此外，我们也可以通过配置文件来修改Redis 服务器 dump 快照的频率，在打开 redis.conf 文件之后，我们搜索 save 可以看到下面的配置信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save　　900　　1 #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照</span><br><span class="line"></span><br><span class="line">save　　300　　10 #在300秒(5分钟)之后，如果至少有10个key发生变化，则dunp内存快照</span><br><span class="line"></span><br><span class="line">save　　60　　 10000　　#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照</span><br></pre></td></tr></table></figure><h5 id="AOF持久化配置"><a href="#AOF持久化配置" class="headerlink" title="AOF持久化配置"></a><strong>AOF持久化配置</strong></h5><p>在 Redis 的配置文件中存在三种同步方式，它们分别是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendsync always #每次有数据修改发生时都会写入AOF文件</span><br><span class="line"></span><br><span class="line">appendsync everysec #每秒同步一次，该策略为AOF的缺省策略</span><br><span class="line"></span><br><span class="line">appendsync no #从不同步。高效但是数据不会被持久化</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（拓展篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（进阶篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁原理分析与应用</title>
    <link href="https://www.blog.ajie39.top/2021/04/30/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://www.blog.ajie39.top/2021/04/30/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-04-30T13:53:06.943Z</published>
    <updated>2021-05-05T07:54:48.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是介绍分布式锁相关的内容。"><a href="#摘要：这篇文章主要是介绍分布式锁相关的内容。" class="headerlink" title="摘要：这篇文章主要是介绍分布式锁相关的内容。"></a>摘要：这篇文章主要是介绍分布式锁相关的内容。</h1><hr><h1 id="前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"><a href="#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。" class="headerlink" title="前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"></a>前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。</h1><hr><span id="more"></span><h2 id="分布式锁的使用场景"><a href="#分布式锁的使用场景" class="headerlink" title="分布式锁的使用场景"></a>分布式锁的使用场景</h2><ul><li><p>效率性:使用分布式锁可以避免不同节点重复相同的工作。</p></li><li><p>正确性:分布式锁可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</p></li></ul><h2 id="分布式锁的几种特性"><a href="#分布式锁的几种特性" class="headerlink" title="分布式锁的几种特性"></a>分布式锁的几种特性</h2><ul><li><p>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</p></li><li><p>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</p></li><li><p>锁超时:和本地锁一样支持锁超时，防止死锁。</p></li><li><p>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</p></li><li><p>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</p></li><li><p>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。</p></li></ul><h2 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h2><p>分布式锁有以下几个方式:</p><ul><li>MySql</li><li>Zk</li><li>Redis</li><li>一些自研的分布式锁(Chubby)</li></ul><h3 id="一、基于-Mysql-实现分布式锁"><a href="#一、基于-Mysql-实现分布式锁" class="headerlink" title="一、基于 Mysql 实现分布式锁"></a>一、基于 Mysql 实现分布式锁</h3><p>1、首先，我们需要创建一个锁表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &#96;resource_lock&#96; (</span><br><span class="line">    &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;resource_name&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;资源名称&#39;,</span><br><span class="line">    &#39;node_info&#39; varchar(128) DEFAULT &#39;0&#39; COMMENT &#39;节点信息&#39;,</span><br><span class="line">    &#39;count&#39; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT  &#39;锁的次数，统计可重入锁&#39;,</span><br><span class="line">    &#39;desc&#39; varchar(128) DEFAULT NULL COMMENT &#39;额外的描述信息&#39;,</span><br><span class="line">    &#96;create_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">    &#96;update_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,</span><br><span class="line">    PRIMARY KEY (&#39;id&#39;),</span><br><span class="line">    UNIQUE KEY &#39;un_resource_name&#39; (&#39;resource_name&#39;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、lock</p><p>先进行查询，如果有值，那么需要比较 node_info 是否一致，这里的 node_info 可以用机器 IP 和线程名字来表示，如果一致那么就加可重入锁 count 的值，如果不一致那么就返回 false 。如果没有值那么直接插入一条数据。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加事务，原子性</span><br><span class="line">@Transaction</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断节点信息是否一致</span><br><span class="line">        if (currentNodeInfo &#x3D;&#x3D; resultNodeInfo) &#123;</span><br><span class="line">            &#x2F;&#x2F; 保住锁的可重入性</span><br><span class="line">            update resource_lock set count &#x3D; count + 1 where resource_name &#x3D; &#39;xxx&#39;;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 插入新数据</span><br><span class="line">        insert into resourceLock;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、tryLock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean tryLock(long timeOut) &#123;</span><br><span class="line">    long stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    long endTimeOut &#x3D; stTime + timeOut;</span><br><span class="line"></span><br><span class="line">    while (endTimeOut &gt; stTime) &#123;</span><br><span class="line">        if (mysqlLock.lock()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 休眠3s后重试</span><br><span class="line">        LockSupport.parkNanos(1000 * 1000 * 1000 * 1);</span><br><span class="line">        stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、unlock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Transaction</span><br><span class="line">public boolean unlock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 查询是否有数据</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; count为1那么可以删除，如果大于1那么需要减去1。</span><br><span class="line">        if (count &gt; 1) &#123;</span><br><span class="line">            update count &#x3D; count - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、定时清理因为机器宕机导致的锁未被释放的问题</p><p>启动一个定时任务，当这个锁远超过任务的执行时间，没有被释放我们就可以认定是节点挂了然后将其直接释放。</p><h3 id="二、基于单Redis节点的分布式锁"><a href="#二、基于单Redis节点的分布式锁" class="headerlink" title="二、基于单Redis节点的分布式锁"></a>二、基于单Redis节点的分布式锁</h3><p>首先，Redis客户端为了获取锁，向Redis节点发送如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SET resource_name my_random_value NX PX 30000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。</p><p>注意，在上面的SET命令中：</p><ul><li>my_random_value是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。</li><li>NX表示只有当resource_name对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</li><li>PX 30000表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。</li></ul><p>最后，当客户端完成了对共享资源的操作之后，执行下面的Redis Lua脚本来释放锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">     return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line"> else</span><br><span class="line">     return 0</span><br><span class="line"> end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段Lua脚本在执行的时候要把前面的my_random_value作为 ARGV[1] 的值传进去，把 resource_name 作为 KEYS[1] 的值传进去。</p><p>至此，基于单Redis节点的分布式锁的算法就描述完了。</p><h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><h5 id="第一点：过期时间"><a href="#第一点：过期时间" class="headerlink" title="第一点：过期时间"></a>第一点：过期时间</h5><p>首先第一个问题，这个锁必须要设置一个过期时间。<br>否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了，而且把这个过期时间称为锁的有效时间(lock validity time)。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p><h5 id="第二点：获取锁"><a href="#第二点：获取锁" class="headerlink" title="第二点：获取锁"></a>第二点：获取锁</h5><p>第二个问题，第一步获取锁的操作，网上不少文章把它实现成了两个Redis命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SETNX resource_name my_random_value</span><br><span class="line">EXPIRE resource_name 30</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然这两个命令和前面算法描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。</p><h5 id="第三点：my-random-value"><a href="#第三点：my-random-value" class="headerlink" title="第三点：my_random_value"></a>第三点：my_random_value</h5><p>第三个问题，设置一个随机字符串 my_random_value 是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。</p><p>假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1在某个操作上阻塞了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</li><li>之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。</li></ul><h5 id="第四点：Lua脚本"><a href="#第四点：Lua脚本" class="headerlink" title="第四点：Lua脚本"></a>第四点：Lua脚本</h5><p>第四个问题，释放锁的操作必须使用Lua脚本来实现。释放锁其实包含三步操作：获取、判断和删除，用Lua脚本来实现能保证这三步的原子性。</p><p>否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面第三个问题类似的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1访问共享资源。</li><li>客户端1为了释放锁，先执行’GET’操作获取随机字符串的值。</li><li>客户端1判断随机字符串的值，与预期的值相等。</li><li>客户端1由于某个原因阻塞住了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</li></ul><p>实际上，在上述第三个问题和第四个问题的分析中，如果不是客户端阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。</p><p>这四个问题，只要实现分布式锁的时候加以注意，就都能够被正确处理。</p><p>但除此之外，还有一个问题，是由 failover（故障转移） 引起的，却是基于单Redis节点的分布式锁无法解决的。正是这个问题催生了Redlock的出现。</p><h5 id="多个Redis节点的情况下会产生的问题"><a href="#多个Redis节点的情况下会产生的问题" class="headerlink" title="多个Redis节点的情况下会产生的问题"></a>多个Redis节点的情况下会产生的问题</h5><p>这个问题是这样的。假如Redis节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。</p><p>例如下面的执行序列：</p><ul><li>客户端1从Master获取了锁。</li><li>Master宕机了，存储锁的key还没有来得及同步到Slave上。</li><li>Slave升级为Master。</li><li>客户端2从新的Master获取到了对应同一个资源的锁。</li></ul><p>于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。</p><h4 id="三、分布式锁-Redlock"><a href="#三、分布式锁-Redlock" class="headerlink" title="三、分布式锁 Redlock"></a>三、分布式锁 Redlock</h4><p>前面介绍的基于单Redis节点的分布式锁在failover的时候会产生解决不了的安全性问题，因此antirez提出了新的分布式锁的算法Redlock，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p><p>运行Redlock算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p><p>1、获取当前时间（毫秒数）。</p><p>2、按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</p><p>3、计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p><p>4、如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p><p>5、如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p><p>上面描述的只是获取锁的过程，而释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p><p>由于N个Redis节点中的大多数能正常工作就能保证Redlock正常工作，因此理论上它的可用性更高。我们前面讨论的单Redis节点的分布式锁在failover的时候锁失效的问题，在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟Redis对数据的持久化程度有关。</p><h5 id="节点崩溃可能导致的问题"><a href="#节点崩溃可能导致的问题" class="headerlink" title="节点崩溃可能导致的问题"></a>节点崩溃可能导致的问题</h5><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><p>1、客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</p><p>2、节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</p><p>3、节点C重启后，客户端2锁住了C, D, E，获取锁成功。</p><p>4、这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p>在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez又提出了延迟重启(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><h5 id="客户端应该向所有Redis节点发起释放锁的操作？"><a href="#客户端应该向所有Redis节点发起释放锁的操作？" class="headerlink" title="客户端应该向所有Redis节点发起释放锁的操作？"></a>客户端应该向所有Redis节点发起释放锁的操作？</h5><p>在最后释放锁的时候，antirez在算法描述中特别强调，客户端应该向所有Redis节点发起释放锁的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？</p><p>设想这样一种情况，客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p><h3 id="四、基于zk实现分布式锁"><a href="#四、基于zk实现分布式锁" class="headerlink" title="四、基于zk实现分布式锁"></a>四、基于zk实现分布式锁</h3><p>ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。Zk的数据节点和文件目录类似，所以我们可以用此特性实现分布式锁。</p><p>基本实现步骤如下：</p><p>1、客户端尝试创建一个znode节点，比如/lock。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode已存在），获取锁失败。</p><p>2、持有锁的客户端访问共享资源完成后，将znode删掉，这样其它客户端接下来就能来获取锁了。</p><p>注意：<br>  这里的znode应该被创建成ephemeral的（临时节点）。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除。这保证了锁一定会被释放。</p><h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><p>看起来这个锁相当完美，没有Redlock过期时间的问题，而且能在需要的时候让锁自动释放。但其实也存在这其中也存在问题。</p><p>ZooKeeper是怎么检测出某个客户端已经崩溃了呢？实际上，每个客户端都与ZooKeeper的某台服务器维护着一个Session，这个Session依赖定期的心跳(heartbeat)来维持。如果ZooKeeper长时间收不到客户端的心跳（这个时间称为Sesion的过期时间），那么它就认为Session过期了，通过这个Session所创建的所有的ephemeral类型的znode节点都会被自动删除。</p><p>假如按照下面的顺序执行：</p><p>1、客户端1创建了znode节点/lock，获得了锁。</p><p>2、客户端1进入了长时间的GC pause。</p><p>3、客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。</p><p>4、客户端2创建了znode节点/lock，从而获得了锁。</p><p>5、客户端1从GC pause中恢复过来，它仍然认为自己持有锁。</p><p>由上面的执行顺序，可以发现最后客户端1和客户端2都认为自己持有了锁，冲突了。所以说，用ZooKeeper实现的分布式锁也不一定就是安全的，该有的问题它还是有。</p><h4 id="zk的watch机制"><a href="#zk的watch机制" class="headerlink" title="zk的watch机制"></a>zk的watch机制</h4><p>ZooKeeper有个很特殊的机制–watch机制。这个机制可以这样来使用，比如当客户端试图创建 /lock 节点的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6844903688088059912">https://juejin.cn/post/6844903688088059912</a></li><li>Redlock的算法：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></li><li><a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></li><li>linux的同步IO操作函数: sync、fsync与fdatasync：<a href="https://my.oschina.net/u/1377774/blog/529847">https://my.oschina.net/u/1377774/blog/529847</a></li><li><a href="https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w">https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是介绍分布式锁相关的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是介绍分布式锁相关的内容。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;a href=&quot;#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;/a&gt;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://www.blog.ajie39.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
    <category term="分布式锁" scheme="https://www.blog.ajie39.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>乌班图安装Tools等教程</title>
    <link href="https://www.blog.ajie39.top/2020/10/25/%E4%B9%8C%E7%8F%AD%E5%9B%BE%E5%AE%89%E8%A3%85Tools%E7%AD%89%E6%95%99%E7%A8%8B/"/>
    <id>https://www.blog.ajie39.top/2020/10/25/%E4%B9%8C%E7%8F%AD%E5%9B%BE%E5%AE%89%E8%A3%85Tools%E7%AD%89%E6%95%99%E7%A8%8B/</id>
    <published>2020-10-25T15:21:38.757Z</published>
    <updated>2020-10-25T15:21:34.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：主要总结了一下乌班图安装一些Tool的步骤。"><a href="#摘要：主要总结了一下乌班图安装一些Tool的步骤。" class="headerlink" title="摘要：主要总结了一下乌班图安装一些Tool的步骤。"></a>摘要：主要总结了一下乌班图安装一些Tool的步骤。</h1><hr><h1 id="前言：乌班图安装一些开发Tool的步骤。"><a href="#前言：乌班图安装一些开发Tool的步骤。" class="headerlink" title="前言：乌班图安装一些开发Tool的步骤。"></a>前言：乌班图安装一些开发Tool的步骤。</h1><hr><h2 id="一、乌班图安装-mysql-5-7"><a href="#一、乌班图安装-mysql-5-7" class="headerlink" title="一、乌班图安装 mysql-5.7"></a>一、乌班图安装 mysql-5.7</h2><h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>执行以下命令即可完成安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update  <span class="comment">#更新软件源</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install mysql-server  <span class="comment">#安装mysql</span></span></span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install libmysqlclient-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、更改密码"><a href="#2、更改密码" class="headerlink" title="2、更改密码"></a>2、更改密码</h3><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入完命令直接回车即可，确认密码也直接回车</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第一种方法-用SET-PASSWORD命令"><a href="#第一种方法-用SET-PASSWORD命令" class="headerlink" title="第一种方法, 用SET PASSWORD命令"></a>第一种方法, 用SET PASSWORD命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：mysql&gt; set password for 用户名@localhost = password(&#x27;新密码&#x27;);</span><br><span class="line"></span><br><span class="line">例子：mysql&gt; set password for root@localhost = password(&#x27;123&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第一种方法-用mysqladmin"><a href="#第一种方法-用mysqladmin" class="headerlink" title="第一种方法, 用mysqladmin"></a>第一种方法, 用mysqladmin</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">格式：mysqladmin -u用户名 -p旧密码 password 新密码</span><br><span class="line"></span><br><span class="line">例子：mysqladmin -uroot -p123456 password 123</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第三种方法，用UPDATE直接编辑user表"><a href="#第三种方法，用UPDATE直接编辑user表" class="headerlink" title="第三种方法，用UPDATE直接编辑user表"></a>第三种方法，用UPDATE直接编辑user表</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先登录MySQL。</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use mysql;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> password=password(<span class="string">&#x27;123&#x27;</span>) <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span> and host=<span class="string">&#x27;localhost&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新MySQL的系统权限相关表，否则会出现拒绝访问。</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> quit­</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第四种方法，忘记root密码"><a href="#第四种方法，忘记root密码" class="headerlink" title="第四种方法，忘记root密码"></a>第四种方法，忘记root密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、编辑mysqld.cnf文件</span></span><br><span class="line"></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、在文件中的skip-external-locking一行的下面添加一行：</span></span><br><span class="line"></span><br><span class="line">skip-grant-tables</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、重启MySQL服务</span></span><br><span class="line"></span><br><span class="line">sudo service mysql restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、终端输入mysql进入MySQL，输入USE mysql切换至mysql数据库</span></span><br><span class="line"></span><br><span class="line">mysql</span><br><span class="line"></span><br><span class="line">USE mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、把root用户的密码修改为000000</span></span><br><span class="line"></span><br><span class="line">UPDATE mysql.user SET authentication_string=password(&#x27;000000&#x27;) WHERE User=&#x27;root&#x27; AND Host =&#x27;localhost&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、修改字段plugin</span></span><br><span class="line"></span><br><span class="line">UPDATE user SET plugin=&quot;mysql_native_password&quot;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7、刷新MySQL的系统权限相关表，否则会出现拒绝访问。</span></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8、退出</span></span><br><span class="line"></span><br><span class="line">quit;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9、注释掉/etc/mysql/mysql.conf.d/mysqld.cnf文件中添加的一行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、更改编码方式"><a href="#3、更改编码方式" class="headerlink" title="3、更改编码方式"></a>3、更改编码方式</h3><p>(1)编辑配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2)在[mysqld]下添加一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">character_set_server = utf8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3)重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">service mysql restart</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、关闭防火墙"><a href="#4、关闭防火墙" class="headerlink" title="4、关闭防火墙"></a>4、关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">systemctl start firewalld # 开启防火墙</span><br><span class="line">systemctl stop firewalld  # 关闭防火墙</span><br><span class="line">systemctl status firewalld  #检查防火墙状态</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5、远程连接设置"><a href="#5、远程连接设置" class="headerlink" title="5、远程连接设置"></a>5、远程连接设置</h3><p>(1)注释掉bind-address = 127.0.0.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(2)执行授权命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录mysql</span></span><br><span class="line">mysql -uroot -p123456</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权</span></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新权限</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3)重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo service mysql restart</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、乌班图安装-redis"><a href="#二、乌班图安装-redis" class="headerlink" title="二、乌班图安装 redis"></a>二、乌班图安装 redis</h2><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><p>在 Ubuntu 系统安装 Redi 可以使用以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get install redis-server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 Redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/redis-server start</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 redis 是否启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改redis的配置文件</span></span><br><span class="line">cd /etc/redis  (首先查询redis文件夹下所有的文件，去这个文件夹去找一个叫redis.conf的配置文件)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用vi打开这个redis.conf的配置文件，将redis.conf配置文件中的<span class="built_in">bind</span> 127.0.0.1注释掉（改成<span class="comment">#bind 127.0.0.1）保存</span></span></span><br><span class="line">vi /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启redis服务</span></span><br><span class="line">sudo /etc/init.d/redis-server restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置Redis密码</span></span><br><span class="line">sudo vi /etc/redis/redis.conf   （找到# requirepass foobared 这一行，将前面的#号删除，然后将foobared改成你要设置的密码）</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启Redis服务</span></span><br><span class="line">sudo /etc/init.d/redis-server restart</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询密码</span></span><br><span class="line">redis 127.0.0.1:6379&gt; config get requirepass</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 密码验证：</span></span><br><span class="line">redis 127.0.0.1:6379&gt; auth test123</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登陆有密码的Redis</span></span><br><span class="line">redis-cli -p 6379 -a test123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是用apt-get或者yum install安装的redis，可以直接通过下面的命令停止/启动/重启redis</span></span><br><span class="line">/etc/init.d/redis-server stop</span><br><span class="line">/etc/init.d/redis-server start</span><br><span class="line">/etc/init.d/redis-server restart</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要：主要总结了一下乌班图安装一些Tool的步骤。&quot;&gt;&lt;a href=&quot;#摘要：主要总结了一下乌班图安装一些Tool的步骤。&quot; class=&quot;headerlink&quot; title=&quot;摘要：主要总结了一下乌班图安装一些Tool的步骤。&quot;&gt;&lt;/a&gt;摘要：主要总结了一下乌</summary>
      
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    <category term="Tool" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/Tool/"/>
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>面试基础题之《面向对象》</title>
    <link href="https://www.blog.ajie39.top/2020/08/16/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B/"/>
    <id>https://www.blog.ajie39.top/2020/08/16/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B/</id>
    <published>2020-08-16T09:46:55.312Z</published>
    <updated>2021-05-05T04:24:11.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。"><a href="#摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。" class="headerlink" title="摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。"></a>摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。</h1><hr><h1 id="前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。"><a href="#前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。" class="headerlink" title="前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。"></a>前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。</h1><hr><span id="more"></span><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>在了解抽象类之前，先来了解一下抽象方法。抽象方法是一种特殊的方法：它只有声明，而没有具体的实现。抽象方法的声明格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>抽象方法必须使用abstract关键字进行修饰。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类含有抽象方法，则称这个类为抽象类，抽象类必须在类前用abstract关键字修饰。因为抽象类中无具体实现的方法，所以不能用抽象类创建对象。</p><p>在《JAVA编程思想》一书中，将抽象类定义为 <strong>“包含抽象方法的类”</strong> ，但是如果一个类不包含抽象方法，只是用abstract修饰的话也是抽象类。也就是说抽象类不一定必须含有抽象方法。例如下面的两个类，都是抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">        System.out.println(st);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String st)</span> </span>&#123;</span><br><span class="line">        System.out.println(st);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><p>包含抽象方法的类称为抽象类(但是抽象类不一定要拥有抽象方法)，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意，抽象类和普通类的主要有三点区别：</p><ol><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li><li>抽象类不能用来创建对象；</li><li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口中可以含有变量和方法。</p><ul><li><p>接口中的变量会被隐式地指定为 public static final 变量（并且只能是 public static final变量，用 private 修饰会报编译错误）。</p></li><li><p>方法会被隐式地指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、 final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现（Java8以后，接口中可以提供方法的默认实现），也就是说，接口中的方法必须都是抽象方法。</p></li></ul><p>从这里可以隐约看出接口和抽象类的区别，接口是一种极度抽象的类型，它比抽象类更加”抽象”，并且一般情况下不在接口中定义变量。在 Java 中，定一个接口如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p>1、语法层面上的区别</p><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><p>2、设计层面上的区别</p><p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。也就是说接口中的方法，必须是这一类事物共有的特征，不能拥有属于自己的个性特征。但是抽象类拥有这一类事物共有的特征，并且还拥有自己特有的属性、方法。举个例子：动物共有的特征：交流、进食。但是每种动物又有用自己的特征，比如鸟会飞、鱼会游泳、壁虎会爬。所以如果以动物维度进行接口设计的话，则这里只能吧交流、进食等所有动物都 <strong>共有</strong> 的特征设计成接口中的方法，如果是某一类动物特有的特征，则只能设计成 <strong>更小的接口</strong> 或者 <strong>抽象方法</strong>;</p><h2 id="面向对象的四大特性：抽象、封装、继承、多态"><a href="#面向对象的四大特性：抽象、封装、继承、多态" class="headerlink" title="面向对象的四大特性：抽象、封装、继承、多态"></a>面向对象的四大特性：抽象、封装、继承、多态</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>通常认为封装是把<strong>数据</strong>和<strong>操作数据的方法</strong>绑定起来，对数据的访问<strong>只能通过已定义的接口</strong>。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是<strong>隐藏一切可隐藏的东西</strong>，只向外界<strong>提供最简单的编程接口</strong>。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是<strong>从已有类得到继承信息创建新类的过程</strong>。提供继承信息的类被称为 <strong>父类（超类、基类）</strong>；得到继承信息的类被称为 <strong>子类（派生类）</strong>。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（桥梁模式）。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态性是指允许<strong>不同类型的对象对同一消息作出不同的响应</strong>。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为<strong>编译时的多态性</strong>和<strong>运行时的多态性</strong>。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。 <strong>方法重载（overload）</strong> 实现的是 <strong>编译时的多态性</strong>（也称为前绑定），而 <strong>方法重写（override）</strong> 实现的是 <strong>运行时的多态性</strong>（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p><ol><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）。</li><li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li></ol><p>总结：</p><ol><li><p>在同一个方法中，这种由于参数类型不同而导致执行效果各异的现象就是多态。</p></li><li><p>Java实现多态有三个必要条件：继承、重写、向上转型。</p><ul><li><strong>继承</strong>：在多态中必须存在有继承关系的子类和父类。</li><li><strong>重写</strong>：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li><strong>向上转型</strong>：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul></li><li><p>指向子类的父类引用由于向上转型了，<strong>它只能访问父类中拥有的方法和属性</strong>，而对于<strong>子类中存在而父类中不存在的方法，该引用是不能使用的</strong>，尽管是重载该方法。<strong>若子类重写了父类中的某些方法</strong>，在调用该些方法的时候，<strong>必定是使用子类中定义的这些方法（动态连接、动态调用）</strong>。</p></li><li><p>instanceof可以判断一个对象是否为某个类（或接口）的实例或者子类实例。<br>语法格式：对象（或者对象引用变量） instanceof 类（或接口）</p></li><li><p>JAVA运行过程：编译，类的加载，类的执行。</p></li><li><p>多态机制遵循的原则概括为：当超类对象引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：<strong>this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</strong></p></li><li><p>只有方法具有多态性，变量不具有多态性。</p></li></ol><p><strong>以上概念，可以参考下面的代码，进行理解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(D obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;A and D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;A and A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">110</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;B and B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;B and A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Temp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a1 = <span class="keyword">new</span> A();</span><br><span class="line">        A a2 = <span class="keyword">new</span> B();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        D d = <span class="keyword">new</span> D();</span><br><span class="line">        System.out.println(<span class="string">&quot;1--&quot;</span> + a1.show(b));</span><br><span class="line">        System.out.println(<span class="string">&quot;2--&quot;</span> + a1.show(c));</span><br><span class="line">        System.out.println(<span class="string">&quot;3--&quot;</span> + a1.show(d));</span><br><span class="line">        System.out.println(<span class="string">&quot;4--&quot;</span> + a2.show(b) + <span class="string">&quot; &quot;</span> + a2.s);</span><br><span class="line">        System.out.println(<span class="string">&quot;5--&quot;</span> + a2.show(c));</span><br><span class="line">        System.out.println(<span class="string">&quot;6--&quot;</span> + a2.show(d));</span><br><span class="line">        System.out.println(<span class="string">&quot;7--&quot;</span> + b.show(b));</span><br><span class="line">        System.out.println(<span class="string">&quot;8--&quot;</span> + b.show(c));</span><br><span class="line">        System.out.println(<span class="string">&quot;9--&quot;</span> + b.show(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">1</span>--A and A</span><br><span class="line"><span class="number">2</span>--A and A</span><br><span class="line"><span class="number">3</span>--A and D</span><br><span class="line"><span class="number">4</span>--B and A <span class="number">10</span></span><br><span class="line"><span class="number">5</span>--B and A</span><br><span class="line"><span class="number">6</span>--A and D</span><br><span class="line"><span class="number">7</span>--B and B</span><br><span class="line"><span class="number">8</span>--B and B</span><br><span class="line"><span class="number">9</span>--A and D</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="问题时刻"><a href="#问题时刻" class="headerlink" title="问题时刻"></a>问题时刻</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Father father = <span class="keyword">new</span> Son();</span><br><span class="line">        father.show(map);</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.show(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Map map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father执行......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(HashMap map)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son执行......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请给出上面代码的运行结果，并思考上面代码存在的问题。</p><p>答：<br>运行结果为：<br>Father执行……<br>Son执行……</p><p>存在的问题：Son类实际上是重载了show方法，而不是重写。Son类没有遵循里氏替换原则。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。&quot;&gt;&lt;a href=&quot;#摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。&quot; class=&quot;headerlink&quot; title=&quot;摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。&quot;&gt;&lt;/a&gt;摘要：该篇文章主要是总结了一下面试过程中关于接口、抽象类、面向对象的四大特性的知识点。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。&quot;&gt;&lt;a href=&quot;#前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。&quot; class=&quot;headerlink&quot; title=&quot;前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。&quot;&gt;&lt;/a&gt;前言：接口、抽象类、面向对象的四大特性在面试的过程中属于基础中的基础，是属于入门级别的题目，这些内容如果回答不上，基本上你的面试就会直接GG。建议熟练掌握，特别是一些容易混淆的概念。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面试题目总结</title>
    <link href="https://www.blog.ajie39.top/2020/08/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2020/08/15/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-15T06:54:53.062Z</published>
    <updated>2021-05-05T04:24:19.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。"><a href="#摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。" class="headerlink" title="摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。"></a>摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。</h1><hr><h1 id="前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。"><a href="#前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。" class="headerlink" title="前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。"></a>前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。</h1><hr><span id="more"></span><h2 id="一、基础问题"><a href="#一、基础问题" class="headerlink" title="一、基础问题"></a>一、基础问题</h2><ol><li><p>volatile相关:<br><a href="https://www.blog.ajie.xin/2020/08/15/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8Avolatile%E3%80%8B/">面试基础题之《Volatile》</a></p></li><li><p>接口和抽象类的区别<br><a href="https://www.blog.ajie.xin/2020/08/16/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B">面试基础题之《面向对象》</a></p></li><li><p>面向对象四大特性：继承、封装、多态、抽象<br><a href="https://www.blog.ajie.xin/2020/08/16/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%8B">面试基础题之《面向对象》</a></p></li><li><p>HashMap的数据结构、查询时间复杂度、是否线程安全</p></li><li><p>数组和链表的差异，优缺点，使用场景</p></li><li><p>请给出你记忆的基本的数据结构有哪些？他们分别有什么特征？对应Java里面的哪些类？</p></li><li><p>线程池 ThreadPoolExecutor 类构造函数的参数有哪些，分别代表什么意思</p></li><li><p>针对候选人说Mysql熟悉的，询问候选人Mysql 聚簇索引的概念</p></li><li><p>针对候选人说Mysql熟悉的，询问候选人建表时，建索引有哪些原则或优化技巧</p></li><li><p>如何解决慢查询</p></li><li><p>说出几种设计模式，并针对其中一种做详细解释，包括使用场景，实现方法，好处</p></li><li><p>针对候选人说Redis熟悉的，询问候选人redis有哪些数据结构，每种数据结构有哪些使用场景</p></li><li><p>针对用Redis做过分布式锁的，询问候选人Redis可以做分布式锁的原因，怎样做分布式锁，有哪些步骤，需要注意什么</p></li></ol><h2 id="二、进阶问题"><a href="#二、进阶问题" class="headerlink" title="二、进阶问题"></a>二、进阶问题</h2><ol><li>ConcurrentHashMap 线程安全的实现原理</li><li>如何判断一个类的内部实现是线程安全的，有哪些原则？怎样将一个类改造后变成线程安全的类？</li><li>数组和链表在存储海量数据时，各有什么问题？</li><li>CAS的原理，作用，什么是乐观锁，悲观锁？Java中哪些类使用到了CAS</li><li>volatile的底层原理(能答出内存栅栏即可)，产生内存可见性问题的原因(cpu cache和主存)</li><li>jdk1.8新增哪些新功能？函数式编程的优缺点？</li><li>为什么jdk8在接口里增加defalut实现，目的是为了什么？</li><li>HashMap在jdk8中用到了红黑树，作用是什么？为什么不是别的树而是红黑树？红黑树还在哪个类中被用到了？</li><li>线程池ThreadPoolExecutor在超过核心线程数时，是先放进队列里还是先扩充线程到最大线程数？有哪些拒绝策略可以使用？如果要自定义线程池创建的线程名要怎么做?</li><li>Jvm中有哪些垃圾回收器？或有哪些垃圾回收算法？如何识别一个对象是可被回收的？</li><li>如何排查频繁GC的问题？如何排查OOM？</li><li>针对候选人说Redis熟悉的，询问候选人redis的io模型或单线程为何也可以保持较快并发。并进一步询问操作系统支持的5种io模型(阻塞，非阻塞，多路复用，信号驱动，异步io)。询问java中，nio使用的是哪一种</li><li>针对候选人说Redis熟悉的，询问候选人redis如何做持久化，如果答上rdb和aof两种模式，询问两种模式的优缺点，使用场景</li><li>如何理解微服务？微服务架构解决什么问题？如何划分微服务？</li><li>如果要设计一个RPC框架，需要考虑哪些问题？</li><li>熔断和限流的概念？他们之间有什么区别？如何做限流？什么是令牌桶？如何做熔断？什么是线程隔离？</li><li>Redis做缓存，缓存的更新策略有哪些？什么是缓存雪崩？什么是缓存穿透？如何解决？</li><li>Redis如何做分布式集群？什么是一致性哈希算法？redis cluster使用的是什么算法？</li><li>注册中心zk等，和redis有什么区别？为什么它们可以用来做注册中心？原理是什么？</li><li>zk是否可以做分布式锁？原理是什么？它和redis做分布式锁有什么优缺点？</li><li>zk还可以做什么？</li><li>Java中的类加载模型是什么？为什么要有双亲委派模型？有哪些类加载器？</li><li>如何保证分布式的数据一致性？什么是分布式事务？两段式提交有什么缺点？什么是最终一致性？BASE原则？CAP理论？</li><li>如果候选人有秒杀场景基础，或高并发经验，询问候选人如何设计一个健壮的秒杀系统？</li><li>询问候选人Https的原理，为什么Https相比Http是安全的，过程是怎样的？</li><li>Java中Collections.sort或List.sort，即默认提供的排序，底层的排序算法是什么？(timsort，一种归并排序)</li><li>请列举所有你知道的排序算法，以及他们的时间复杂度？快速排序的缺点是什么？</li></ol><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><ol><li>Java是编译型语言还是解释型语言？还是两者都有？谈谈你的看法</li><li>如果候选人还写过别的语言，询问候选人你觉得Java和其他语言有什么区别？有什么优缺点？主要观察候选人对编程语言的思考</li><li>如果候选人提起zk的一致性算法，进一步询问分布式一致性领域的两军问题，拜占庭将军问题，prxos算法和raft算法，观察候选人是否理解透彻</li><li>针对一个代码老旧但是又非常核心的系统，如何做重构？谈谈你的想法？</li><li>你是如何学习新的知识的？比如如果现在让你学习Guice，你会怎么做？</li></ol><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><ol><li>作为JDK的作者，实现Java中Integer.valueOf(String s)这个函数<br>（本题考查编程功底，主干代码需要对char转int也就是ascii码有所认知和了解，经过提示还不能写出主干代码的，基本上都是野路子非科班出身，编程功底会非常差，可能会连二进制转十进制都不会算(此时可以考察候选人是否会算2进制转10进制)。<br>本题边界条件非常多，一上来就对String做null处理的加分，知道处理负数的加分，知道处理int最大值的加分，能一上来就写对完全版的给高分，不知道int最大值是多少的扣印象分）</li><li>实现一个线程死锁的代码，两个线程相互等待对方<br>（本题考察候选人多线程编程功底，有些人连怎么new一个线程出来都不知道，这道题就会写不出，如果对线程死锁理解不透彻，也会写出有问题的代码而不能真的产生死锁）</li><li>如果观察到候选人数据结构和算法能力较差，为了进一步确认这一点，会让候选人写出冒泡排序的实现，并给出一个数列来演算冒泡排序。并会询问，冒泡排序内层循环一轮之后，效果是什么(实际就是冒一个泡)？</li><li>偶尔会出到的考题：用两个栈实现一个队列、判断一个链表是否为循环链表、二叉树的中序遍历（递归写法和非递归写法）</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。&quot;&gt;&lt;a href=&quot;#摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。&quot;&gt;&lt;/a&gt;摘要：这是一个悲伤的故事，因为太菜、频繁出现低级错误而惨遭leader嫌弃，为了不被T出团队，便将公司的面试题总结了一遍，（今天也是元气满满的一天）。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。&quot;&gt;&lt;a href=&quot;#前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。&quot; class=&quot;headerlink&quot; title=&quot;前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。&quot;&gt;&lt;/a&gt;前言：题目主要包括四个部分：基础问题、进阶问题、扩展问题、编程题。基础问题：是必须数量掌握题目，如果答不上来，在面试的过程中会惨遭扣分，基本面试无望，一般出现在一面中，和少数的二面中。进阶问题：一般是了解面试者对于改技术的了解深度，答的越多，评分越高，一般出现在二面和三面中。扩展问题：一般属于开发性的题目，不要出现致命性的低级错误即可，一般出现在三面和四面中。编程题：这里主要是为了考验面试者的编码能力，和一些算法功底，我们公司现在的编程题目较为简单，主要是为了考验编码能力，涉及算法部分较少，一般出现在笔试中。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面试基础题之《volatile》</title>
    <link href="https://www.blog.ajie39.top/2020/08/15/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8Avolatile%E3%80%8B/"/>
    <id>https://www.blog.ajie39.top/2020/08/15/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E9%A2%98%E4%B9%8B%E3%80%8Avolatile%E3%80%8B/</id>
    <published>2020-08-15T06:17:48.561Z</published>
    <updated>2021-05-05T04:24:15.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。"><a href="#摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。" class="headerlink" title="摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。"></a>摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。</h1><hr><h1 id="前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。"><a href="#前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。" class="headerlink" title="前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。"></a>前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。</h1><hr><span id="more"></span><h2 id="volatile关键字基本介绍"><a href="#volatile关键字基本介绍" class="headerlink" title="volatile关键字基本介绍"></a>volatile关键字基本介绍</h2><p>volatile可以看成是synchronized的一种轻量级的实现，但volatile并不能完全代替synchronized，volatile有synchronized可见性的特性，但没有synchronized原子性的特性。可见性即用volatile关键字修饰的成员变量表明该变量不存在工作线程的副本，线程每次直接都从主内存中读取，每次读取的都是最新的值，这也就保证了变量对其他线程的可见性。另外，使用volatile还能确保变量不能被重排序，保证了有序性。</p><ul><li><p>当一个变量定义为volatile之后，它将具备两种特性：</p><ul><li>保证此变量对所有线程的<strong>可见性</strong></li><li>禁止指令重排序优化</li></ul></li><li><p>volatile与synchronized的区别：</p><ul><li>1、volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</li><li>2、volatile保证数据的可见性，但是不保证原子性; 而synchronized是一种排他(互斥)的机制，既保证可见性，又保证原子性。</li><li>3、volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>4、volatile可以看做是轻量版的synchronized，volatile不保证原子性，但是如果是对一个共享变量进行多个线程的赋值，而没有其他的操作，那么就可以用volatile来代替synchronized，因为赋值本身是有原子性的，而volatile又保证了可见性，所以就可以保证线程安全了。</li></ul></li></ul><h2 id="保证此变量对所有线程的可见性："><a href="#保证此变量对所有线程的可见性：" class="headerlink" title="保证此变量对所有线程的可见性："></a>保证此变量对所有线程的<strong>可见性</strong>：</h2><p>当一条线程修改了这个变量的值，新值对于其他线程可以说是可以立即得知的。Java内存模型规定了所有的变量都存储在主内存，每条线程还有自己的工作内存，线程的工作内存保存了该线程使用到的变量在主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读取主内存中的变量。</p><p>知识拓展：<strong>内存可见性</strong>：</p><ul><li>概念：JVM内存模型：<strong>主内存</strong> 和 线程独立的 <strong>工作内存</strong>。Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存（比如CPU的寄存器），线程只能访问自己的工作内存，不可以访问其它线程的工作内存。工作内存中保存了主内存共享变量的副本，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。</li><li>如何保证多个线程操作主内存的数据完整性是一个难题，Java内存模型也规定了工作内存与主内存之间交互的协议，定义了8种原子操作：<ul><li>(1) lock:将主内存中的变量锁定，为一个线程所独占。</li><li>(2) unclock:将lock加的锁定解除，此时其它的线程可以有机会访问此变量。</li><li>(3) read:将主内存中的变量值读到工作内存当中。</li><li>(4) load:将read读取的值保存到工作内存中的变量副本中。</li><li>(5) use:将值传递给线程的代码执行引擎。</li><li>(6) assign:将执行引擎处理返回的值重新赋值给变量副本。</li><li>(7) store:将变量副本的值存储到主内存中。</li><li>(8) write:将store存储的值写入到主内存的共享变量当中。</li></ul></li></ul><p>  通过上面Java内存模型的概述，我们会注意到这么一个问题，每个线程在获取锁之后会在自己的工作内存来操作共享变量，操作完成之后将工作内存中的副本回写到主内存，并且在其它线程从主内存将变量同步回自己的工作内存之前，共享变量的改变对其是不可见的。即其他线程的本地内存中的变量已经是过时的，并不是更新后的值。volatile保证可见性的原理是在每次访问变量时都会进行一次刷新，因此每次访问都是主内存中最新的版本。所以volatile关键字的作用之一就是保证变量修改的实时可见性。</p><p>  即，volatile的特殊规则就是：</p><ul><li>read、load、use动作必须连续出现。</li><li>assign、store、write动作必须连续出现。</li></ul><p>  所以，使用volatile变量能够保证:</p><ul><li>每次读取前必须先从主内存刷新最新的值。</li><li>每次写入后必须立即同步回主内存当中。</li></ul><p>  也就是说，volatile关键字修饰的变量看到的是自己的最新值。线程1中对变量v的最新修改，对线程2是可见的。</p><h2 id="禁止指令重排序优化："><a href="#禁止指令重排序优化：" class="headerlink" title="禁止指令重排序优化："></a>禁止指令重排序优化：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean isOK &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;假设以下代码在线程A执行</span><br><span class="line">A.init();</span><br><span class="line">isOK&#x3D;true;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;假设以下代码在线程B执行</span><br><span class="line">while(!isOK)&#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line">B.init();</span><br></pre></td></tr></table></figure><p>A线程在初始化的时候，B线程处于睡眠状态，等待A线程完成初始化的时候才能够进行自己的初始化。这里的先后关系依赖于isOK这个变量。如果没有volatile修饰isOK这个变量，那么isOK的赋值就可能出现在A.init()之前（指令重排序,Java虚拟机的一种优化措施），此时A没有初始化，而B的初始化就破坏了它们之前形成的那种依赖关系，可能就会出错。</p><p>知识拓展：<strong>指令重排序</strong>：</p><ul><li>概念：指令重排序是JVM为了优化指令，提高程序运行效率，在不影响 <strong>单线程程序</strong> 执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序带来问题。</li></ul><p>  不同的指令间可能存在数据依赖。比如下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int l &#x3D; 3; &#x2F;&#x2F; (1)</span><br><span class="line">int w &#x3D; 4; &#x2F;&#x2F; (2)</span><br><span class="line">int s &#x3D; l * w; &#x2F;&#x2F; (3)</span><br></pre></td></tr></table></figure><p>面积的计算依赖于l与w两个变量的赋值指令。而l与w无依赖关系。</p><p>重排序会遵守两个规则：</p><ul><li><strong>as-if-serial规则</strong>：as-if-serial规则是指不管如何重排序（编译器与处理器为了提高并行度），（单线程）程序的结果不能被改变。这是编译器、Runtime、处理器必须遵守的语义。</li><li><strong>happens-before规则</strong>：<ul><li>概念：前一个操作的结果可以被后续的操作获取。讲直白点就是前面一个操作把变量a赋值为1，那后面一个操作肯定能知道a已经变成了1。</li><li>happens-before（先行发生）规则如下：<ul><li>程序顺序规则：一个线程中的每个操作，happens-before于线程中的任意后续操作。</li><li>监视器锁规则：一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li>传递性：如果（A）happens-before（B），且（B）happens-before（C），那么（A）happens-before（C）。</li><li>线程start()规则：主线程A启动线程B，线程B中可以看到主线程启动B之前的操作。也就是start() happens-before 线程B中的操作。</li><li>线程join()规则：主线程A等待子线程B完成，当子线程B执行完毕后，主线程A可以看到线程B的所有操作。也就是说，子线程B中的任意操作，happens-before join()的返回。</li><li>中断规则：一个线程调用另一个线程的interrupt，happens-before于被中断的线程发现中断。</li><li>终结规则：一个对象的构造函数的结束，happens-before于这个对象finalizer的开始。</li></ul></li></ul></li></ul><p>虽然，（1）-happensbefore -&gt;（2）,（2）-happens before-&gt;（3），但是计算顺序(1)(2)(3)与(2)(1)(3)对于l、w、area变量的结果并无区别。编译器、Runtime在优化时可以根据情况重排序（1）与（2），而丝毫不影响程序的结果。</p><ul><li>volatile使用场景：<ul><li>如果正确使用volatile的话，必须依赖下以下种条件：<ul><li>1、对变量的写操作不依赖当前变量的值。</li><li>2、该变量没有包含在其他变量的不变式中。</li></ul></li></ul></li></ul><p>也可以这样理解，就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（i++）看上去类似一个单独操作，实际上它是一个由（读取－修改－写入）操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 i 的值在操作期间保持不变，而 volatile 变量无法实现这点。</p><ul><li>在以下两种情况下都必须使用volatile：<ul><li>1、状态的改变。</li><li>2、读多写少的情况。</li></ul></li></ul><p>具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 场景一：状态改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查（DCL）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sun</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Sun sunInstance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Sun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sun <span class="title">getSunInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sunInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Sun.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sunInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">          sunInstance = <span class="keyword">new</span> Sun();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sunInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景二：读多写少</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作，没有synchronized，提高性能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写操作，必须synchronized。因为x++不是原子操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="问题来了volatile是如何防止指令重排序优化的呢？"><a href="#问题来了volatile是如何防止指令重排序优化的呢？" class="headerlink" title="问题来了volatile是如何防止指令重排序优化的呢？"></a>问题来了volatile是如何防止指令重排序优化的呢？</h2><p>答：</p><p>volatile关键字通过 <strong>“内存屏障”</strong> 的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。大多数的处理器都支持内存屏障的指令。</p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>知识拓展：<strong>内存屏障</strong>：</p><p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。<br>    内存屏障可以被分为以下几种类型：<br>    - LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<br>    - StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<br>    - LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<br>    - StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。&quot;&gt;&lt;a href=&quot;#摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。&quot; class=&quot;headerlink&quot; title=&quot;摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。&quot;&gt;&lt;/a&gt;摘要：该篇文章主要是总结了一下面试过程中关于volatile关键字的知识点。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。&quot;&gt;&lt;a href=&quot;#前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。&quot; class=&quot;headerlink&quot; title=&quot;前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。&quot;&gt;&lt;/a&gt;前言：volatile相关的知识点，在面试过程中，属于基础问题，是必须要掌握的知识点，如果回答不上来会严重扣分的哦。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>如何保证类线程安全</title>
    <link href="https://www.blog.ajie39.top/2020/06/21/%E4%BF%9D%E8%AF%81%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>https://www.blog.ajie39.top/2020/06/21/%E4%BF%9D%E8%AF%81%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2020-06-20T17:02:22.886Z</published>
    <updated>2021-05-05T04:23:43.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：主要总结了一下如何保证类线程安全。"><a href="#摘要：主要总结了一下如何保证类线程安全。" class="headerlink" title="摘要：主要总结了一下如何保证类线程安全。"></a>摘要：主要总结了一下如何保证类线程安全。</h1><hr><h1 id="前言：总结了一下如何保证类线程安全。"><a href="#前言：总结了一下如何保证类线程安全。" class="headerlink" title="前言：总结了一下如何保证类线程安全。"></a>前言：总结了一下如何保证类线程安全。</h1><hr><span id="more"></span><h2 id="保证类线程安全的措施"><a href="#保证类线程安全的措施" class="headerlink" title="保证类线程安全的措施"></a>保证类线程安全的措施</h2><ul><li>不共享线程间的变量；</li><li>设置属性变量为不可变变量；</li><li>每个共享的可变变量都使用一个确定的锁保护。</li></ul><h2 id="保证线程安全的思路"><a href="#保证线程安全的思路" class="headerlink" title="保证线程安全的思路"></a>保证线程安全的思路</h2><h3 id="1-通过架构设计"><a href="#1-通过架构设计" class="headerlink" title="1. 通过架构设计"></a>1. 通过架构设计</h3><p>通过上层的架构设计和业务分析来避免并发场景。比如需要用多线程或分布式集群统计一堆用户的相关统计值，由于用户的统计值是共享数据，因此需要保证线程安全。</p><p>从业务上分析出用户之间的数据并不共享，因此可以设计一个规则来保证一个用户的计算工作和数据访问只被一个线程或一台机器完成，这样从设计上避免了接下来可能的并发问题。</p><h3 id="2-保证类无状态"><a href="#2-保证类无状态" class="headerlink" title="2. 保证类无状态"></a>2. 保证类无状态</h3><p>有状态会限制横向扩展能力，也可能产生并发问题。如果类是无状态的，那它永远是线程安全的。因此在设计阶段尽可能用无状态的类来满足业务需求。</p><h3 id="3-区别原子操作和复合操作"><a href="#3-区别原子操作和复合操作" class="headerlink" title="3. 区别原子操作和复合操作"></a>3. 区别原子操作和复合操作</h3><p>常见的复合操作包括check-then-act, i++等。虽然check-then-act从表面上看很简单，但却普遍存在与我们日常的开发中，特别是在数据库存取这一块。比如我们需要在数据库里存一个客户的统计值，当统计值不存在时初始化，当存在时就去更新。如果不把这组逻辑设计为原子性的就很有可能产生出两条这个客户的统计值。</p><p>在单机环境下处理这个问题还算容易，通过锁或者同步来把这组复合操作变为原子操作，但在分布式环境下就不适用了。一般情况下是通过在数据库端做文章，比如通过唯一性索引或者悲观锁来保障其数据一致性。当然任何方案都是有代价的，这就需要具体情况下来权衡。</p><h3 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h3><p>使用锁应注意：</p><ul><li>每个共享变量必须由一个确定的锁保护。</li><li>使用锁会有性能损失。</li><li>锁不能解决在分布式环境共享变量的并发问题。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：主要总结了一下如何保证类线程安全。&quot;&gt;&lt;a href=&quot;#摘要：主要总结了一下如何保证类线程安全。&quot; class=&quot;headerlink&quot; title=&quot;摘要：主要总结了一下如何保证类线程安全。&quot;&gt;&lt;/a&gt;摘要：主要总结了一下如何保证类线程安全。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：总结了一下如何保证类线程安全。&quot;&gt;&lt;a href=&quot;#前言：总结了一下如何保证类线程安全。&quot; class=&quot;headerlink&quot; title=&quot;前言：总结了一下如何保证类线程安全。&quot;&gt;&lt;/a&gt;前言：总结了一下如何保证类线程安全。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java依赖注入详解</title>
    <link href="https://www.blog.ajie39.top/2020/06/13/Java%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.blog.ajie39.top/2020/06/13/Java%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-06-13T07:05:22.573Z</published>
    <updated>2021-05-05T04:26:12.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。"><a href="#摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。" class="headerlink" title="摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。"></a>摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。</h1><hr><h1 id="前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。"><a href="#前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。" class="headerlink" title="前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。"></a>前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。</h1><hr><span id="more"></span><h2 id="依赖注入的方法"><a href="#依赖注入的方法" class="headerlink" title="依赖注入的方法"></a>依赖注入的方法</h2><p>注：下面例子主要以spring为例。</p><h3 id="1、setter注入"><a href="#1、setter注入" class="headerlink" title="1、setter注入"></a>1、setter注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFooService</span><span class="params">(FooService fooService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fooService = fooService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这种注入方式是在Spring3.x刚推出的时候，推荐使用的注入方式。</p><h3 id="2、field注入"><a href="#2、field注入" class="headerlink" title="2、field注入"></a>2、field注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Foo&gt; <span class="title">listFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fooService.list();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种注入方式非常简单，只要加入要注入的字段，附上@Autowired，即可完成。</p><h3 id="3、构造器注入"><a href="#3、构造器注入" class="headerlink" title="3、构造器注入"></a>3、构造器注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FooService fooService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooController</span><span class="params">(FooService fooService)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fooService = fooService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这种注入方式是在Spring4.x版本中推荐使用的注入方式。</p><p>使用构造器注入的优点：</p><ol><li>能够保证注入的组件不可变。</li><li>确保需要的依赖不为空。</li><li>构造器注入的依赖总是能够保证完全初始化的状态。</li></ol><h2 id="为什么推荐使用构造器注入？"><a href="#为什么推荐使用构造器注入？" class="headerlink" title="为什么推荐使用构造器注入？"></a>为什么推荐使用构造器注入？</h2><ol><li><p>field注入<br>优点：注入简单。简洁明了。<br>缺点：循环依赖、重名依赖、依赖为空。</p></li><li><p>构造器注入<br>优点：初始化、不可变性、数据检查、依赖不为空。<br>缺点：循环依赖、注入的一多就非常的臃肿。</p></li><li><p>setter注入<br>优点：通过调用，可以让代码控制类依赖的顺序，解决循环依赖。<br>缺点：注入的一多就非常的臃肿、依赖可变性，不够安全。</p></li></ol><p>构造器注入和field注入的循环依赖的报错提示也有点不同，前者编译时就报错，后者使用时报错。</p><p>所以说为什么使用构造器注入呢，主要是因为：</p><ol><li>保证依赖不可变（final关键字）。</li><li>保证依赖不为空（省去了我们对其检查）。</li><li>保证返回客户端（调用）的代码的时候是完全初始化的状态。</li><li>如果产生了循环依赖的问题，可以在编译是就知道，这样可以及时解决（尽量把错误在编译时就发现才是最好的开发习惯！机器的可信度远高于人类！）。</li></ol><p>来自spring官方的解释：</p><p>We usually advise people to use constructor injection for all mandatory collaborators and setter injection for all other properties. Again, constructor injection ensures all mandatory properties have been satisfied, and it is simply not possible to instantiate an object in an invalid state (not having passed its collaborators). In other words, when using constructor injection you do not have to use a dedicated mechanism to ensure required properties are set (other than normal Java mechanisms).</p><p>具体详情可以参考一下这篇文章：<a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/</a></p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><h3 id="1、什么是循环依赖？"><a href="#1、什么是循环依赖？" class="headerlink" title="1、什么是循环依赖？"></a>1、什么是循环依赖？</h3><p>循环依赖其实就是循环引用，也就是两个或者两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。如下图：</p><p><img src="/blog/24/1.png" alt="循环依赖图"></p><p>注意，这里不是函数的循环调用，是对象的相互依赖关系。循环调用其实就是一个死循环，除非有终结条件。</p><p>循环依赖场景有：</p><ol><li>构造器的循环依赖。</li><li>field属性的循环依赖。</li></ol><p>其中，构造器的循环依赖问题无法通过框架自动去解决，但是它会在编译时就报错，我们可以人为的解决它。在解决属性循环依赖时，Spring通过将实例化后的对象提前暴露给Spring容器中的singletonFactories，解决了循环依赖的问题。</p><h3 id="2、Spring怎么解决循环依赖"><a href="#2、Spring怎么解决循环依赖" class="headerlink" title="2、Spring怎么解决循环依赖"></a>2、Spring怎么解决循环依赖</h3><p>Spring的循环依赖的理论依据基于Java的引用传递，当获得对象的引用时，对象的属性是可以延后设置的（但是构造器必须是在获取引用之前）。</p><p>Spring的单例对象的初始化主要分为三步：</p><p><img src="/blog/24/2.png" alt="单例对象的初始化三步骤"></p><ol><li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象。</li><li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充。</li><li>initializeBean：初始化，调用spring xml中的init 方法。</li></ol><p>从上面单例bean的初始化可以知道：循环依赖主要发生在第一、二步，也就是构造器循环依赖和field循环依赖。那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>三级缓存分别指：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三级缓存主要指：</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ol><li>singletonFactories：单例对象工厂的cache。</li><li>earlySingletonObjects：提前暴光的单例对象的Cache。</li><li>singletonObjects：单例对象的cache。</li></ol><ul><li>在创建bean的时候，首先想到的是从cache中获取这个单例的bean，这个缓存就是singletonObjects。</li><li>如果获取不到，并且对象正在创建中，就再从二级缓存earlySingletonObjects中获取。</li><li>如果还是获取不到且允许singletonFactories通过getObject()获取，就从三级缓存singletonFactory.getObject()获取，如果获取到了则从singletonFactories中移除，并放入earlySingletonObjects中。其实也就是从三级缓存移动到了二级缓存。</li></ul><p>从上面三级缓存的分析中，我们可以知道，Spring解决循环依赖的诀窍就在于singletonFactories这个三级cache。这个cache的类型是ObjectFactory。这里就是解决循环依赖的关键，发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来(调用了构造器)。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p><p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况：</p><p>A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存 earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p><p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！因为加入singletonFactories三级缓存的前提是执行了构造器，所以构造器的循环依赖没法解决。</p><p><img src="/blog/24/3.png" alt="DEBUG流程图"></p><h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://www.zhihu.com/question/27053548">https://www.zhihu.com/question/27053548</a></p><p><a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/</a></p><p><a href="https://www.cnblogs.com/zzq6032010/p/11406405.html">https://www.cnblogs.com/zzq6032010/p/11406405.html</a></p><p><a href="https://blog.csdn.net/qq_33808244/article/details/102453052">https://blog.csdn.net/qq_33808244/article/details/102453052</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是总结了一下Java依赖注入的相关知识点。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。&quot;&gt;&lt;a href=&quot;#前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C-，Java，C-等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection-Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。&quot; class=&quot;headerlink&quot; title=&quot;前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。&quot;&gt;&lt;/a&gt;前言：依赖注入是用来做对象管理的，为啥要管理呢？面向对象本质上是要多个不同职责相互对立的Object互相通过发消息来进行交互的。但是这个思想落地时，因为性能的原因，Object之间并不像网络那样真的发消息，而是互相调用对方的方法（C++，Java，C#等都是这么做的）。如果想调用某个Object的方法，就得拿到那个Object的引用。那么怎么拿到Object的引用呢？new一个不就可以了嘛。但现实当中比这个更复杂。比如一个系统需要一个“paymentService”的对象做支付，也许整个系统只需要一个paymentService的实例，所以必须得判断那个要用的Object有没有，没有才创建。但有时，对于一些Object可能每次都需要一个新的实例。两种策略之间，也许是某种“池化Object“的特定的逻辑，比如连接池只能有100个Connection Object。每个对象要初始化，获取一些资源，也可能某些时候释放一些资源。这些都是对Object生命周期管理的逻辑。如果没有注入机制，那么这些逻辑会散播到整个系统每一个角落，带来巨大的维护问题。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>flagr入门</title>
    <link href="https://www.blog.ajie39.top/2020/05/05/Flagr%E5%85%A5%E9%97%A8/"/>
    <id>https://www.blog.ajie39.top/2020/05/05/Flagr%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-05T08:38:55.675Z</published>
    <updated>2021-05-05T04:24:45.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要介绍一个A-B测试的中间件–flagr"><a href="#摘要：这篇文章主要介绍一个A-B测试的中间件–flagr" class="headerlink" title="摘要：这篇文章主要介绍一个A/B测试的中间件–flagr"></a>摘要：这篇文章主要介绍一个A/B测试的中间件–flagr</h1><hr><h1 id="前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。-它提供功能标记，实验（A-B测试）和动态配置。-它具有用于标志管理和标志评估的清晰的REST-API。"><a href="#前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。-它提供功能标记，实验（A-B测试）和动态配置。-它具有用于标志管理和标志评估的清晰的REST-API。" class="headerlink" title="前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。 它提供功能标记，实验（A / B测试）和动态配置。 它具有用于标志管理和标志评估的清晰的REST API。"></a>前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。 它提供功能标记，实验（A / B测试）和动态配置。 它具有用于标志管理和标志评估的清晰的REST API。</h1><hr><span id="more"></span><h2 id="flagr是什么？"><a href="#flagr是什么？" class="headerlink" title="flagr是什么？"></a>flagr是什么？</h2><p>在介绍flagr之前，我们先要明白什么是A/B测试，什么是灰度测试，这样可以让我们更好的理解flagr。</p><h3 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h3><p>A/B测试指的是系统测试通过并发布后，同一个软件功能不同的用户会看到不同的实现方式，收集每个用户的反馈。本质上是上线后的测试，收集用户的反馈。即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</p><h3 id="灰度测试"><a href="#灰度测试" class="headerlink" title="灰度测试"></a>灰度测试</h3><p>灰度发布，又名金丝雀发布，或者灰度测试，是指在黑与白之间能够平滑过渡的一种发布方式。在其上可以进行A/B测试。</p><p>灰度发布是对某一产品的发布逐步扩大使用群体范围，也叫灰度放量。系统集成测试通过后，将测试版本发布到线上环境，替换部分的线上服务器代码进行预测试。当灰度测试结束后，线上版本实现会统一。本质上是上线前的测试，收集用户的反馈。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</p><p>灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。</p><h4 id="灰度测试的意义"><a href="#灰度测试的意义" class="headerlink" title="灰度测试的意义"></a>灰度测试的意义</h4><p>灰度测试能及早获得用户的意见反馈，完善产品功能，提升产品质量，让用户参与产品测试，加强与用户互动，降低产品升级所影响的用户范围。</p><h4 id="灰度发布步骤"><a href="#灰度发布步骤" class="headerlink" title="灰度发布步骤"></a>灰度发布步骤</h4><ol><li>定义目标。</li><li>选定策略：包括用户规模、发布频率、功能覆盖度、回滚策略、运营策略、新旧系统部署策略等。</li><li>筛选用户：包括用户特征、用户数量、用户常用功能、用户范围等。</li><li>部署系统：部署新系统、部署用户行为分析系统（web analytics）、设定分流规则、运营数据分析、分流规则微调。</li><li>发布总结：用户行为分析报告、用户问卷调查、社会化媒体意见收集、形成产品功能改进列表。</li><li>产品完善。</li><li>新一轮灰度发布或完整发布。</li></ol><h3 id="flagr是什么？可以用来做什么？"><a href="#flagr是什么？可以用来做什么？" class="headerlink" title="flagr是什么？可以用来做什么？"></a>flagr是什么？可以用来做什么？</h3><p>Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。它提供功能标记，A/B测试和动态配置。它具有用于标志管理和标志评估的清晰的REST API。</p><p>我们可以利用flagr进行A/B测试和灰度发布，通过它完善产品。</p><h3 id="flagr中的一些专业术语解释"><a href="#flagr中的一些专业术语解释" class="headerlink" title="flagr中的一些专业术语解释"></a>flagr中的一些专业术语解释</h3><ul><li>Flag. It can be a feature flag, an experiment, or a configuration.（它可以是功能标记，实验或配置。）</li><li>Variant represents the possible variation of a flag. For example, control/treatment, green/yellow/red, etc.（变体表示标志的可能变体。 例如，控制/处理，绿色/黄色/红色等。）</li><li>Variant Attachment represents the dynamic configuration of a variant. For example, if you have a variant for the green button, you can dynamically control what’s the hex color of green you want to use (e.g. {“hex_color”: “#42b983”}).（变体附件表示变体的动态配置。 例如，如果您有绿色按钮的变体，则可以动态控制要使用的绿色的十六进制颜色（例如{“ hex_color”：“＃42b983”}）。）</li><li>Segment represents the segmentation, i.e. the set of audience we want to target. Segment is the smallest unit of a component we can analyze in Flagr Metrics.（细分表示分区，即我们要定位的受众群体。 细分是我们可以在Flagr指标中分析的组件的最小单位。）</li><li>Constraint represents rules that we can use to define the audience of the segment. In other words, the audience in the segment is defined by a set of constraints. Specifically, in Flagr, the constraints are connected with AND in a segment.（约束表示可以用来定义细分受众群的规则。 换句话说，细分受众群是由一组约束定义的。 具体而言，在Flagr中，约束与细分中的AND连接。）</li><li>Distribution represents the distribution of variants in a segment.（分布表示细分中变体的分布。）</li><li>Entity represents the context of what we are going to assign the variant on. Usually, Flagr expects the context coming with the entity, so that one can define constraints based on the context of the entity.（实体表示我们要为其分配变量的上下文。 通常，Flagr期望上下文随实体一起提供，以便人们可以基于实体的上下文定义约束。）</li><li>Rollout and deterministic random logic. The goal here is to ensure deterministic and persistent evaluation result for entities. Steps to evaluating a flag given an entity context:（推出和确定性随机逻辑。 此处的目的是确保对实体的确定性和持久性评估结果。 在给定实体上下文的情况下评估标志的步骤：）<ul><li>Take the unique ID from the entity, hash it using a hash function that has a uniform distribution (e.g. CRC32, MD5).（从实体中获取唯一ID，然后使用具有均匀分布的哈希函数（例如CRC32，MD5）对其进行哈希处理。）</li><li>Take the hash value (base 10) and mod 1000. 1000 is the total number of buckets used in Flagr.（取哈希值（以10为底）和mod1000。1000是Flagr中使用的存储桶总数。）</li><li>Consider the distribution. For example, 50/50 split for control and treatment means 0-499 for control and 500-999 for treatment.（考虑分布。 例如，控制和治疗的50/50分割意味着控制的0-499和治疗的500-999。）</li><li>Consider the rollout percentage. For example, 10% rollout means only the first 10% of the control buckets (again, use the previous step example, 0-49 out of 0-499 will be rolled out to control experience).（考虑部署百分比。 例如，推出10％表示仅控制桶的前10％（同样，使用上一个步骤示例，将推出0-499中的0-49以控制体验）。）</li></ul></li></ul><h2 id="flagr提供的http接口"><a href="#flagr提供的http接口" class="headerlink" title="flagr提供的http接口"></a>flagr提供的http接口</h2><p>几个专业术语的解释：<br>Flag：标志<br>Segment：<br>官方英文解释：Segment defines the audience of the flag, it’s the user segmentation.<br>中文翻译：分割区定义了标志的受众群体，即对用户细分。<br>Constraint：<br>官方英文解释：Constraint is the unit of defining a small subset of users.<br>中文翻译：约束是定义一小部分用户的单位。<br>Distribution：<br>官方英文解释：Distribution is the percent distribution of variants within that segment.<br>中文翻译：分布是该细分中变体的百分比分布。<br>Variant：<br>官方英文解释：Variants are the possible outcomes of flag evaluation.<br>中文翻译：变体是标志评估的可能结果。<br>Evaluation：<br>官方英文解释：Evaluation is the process of evaluating a flag given the entity context.<br>中文翻译：评估是在给定实体上下文的情况下评估标志的过程<br>Health：<br>官方英文解释：Check if Flagr is healthy.<br>中文翻译：检查Flagr是否健康。</p><table><thead><tr><th>Class</th><th>Method</th><th>HTTP</th><th>request</th><th>Description</th></tr></thead><tbody><tr><td>Jsflagr.ConstraintApi</td><td>createConstraint</td><td>POST</td><td>/flags/{flagID}/segments/{segmentID}/constraints</td><td>创建约束</td></tr><tr><td>Jsflagr.ConstraintApi</td><td>deleteConstraint</td><td>DELETE</td><td>/flags/{flagID}/segments/{segmentID}/constraints/{constraintID}</td><td>删除约束</td></tr><tr><td>Jsflagr.ConstraintApi</td><td>findConstraints</td><td>GET</td><td>/flags/{flagID}/segments/{segmentID}/constraints</td><td>查找约束</td></tr><tr><td>Jsflagr.ConstraintApi</td><td>putConstraint</td><td>PUT</td><td>/flags/{flagID}/segments/{segmentID}/constraints/{constraintID}</td><td>更新约束</td></tr><tr><td>Jsflagr.DistributionApi</td><td>findDistributions</td><td>GET</td><td>/flags/{flagID}/segments/{segmentID}/distributions</td><td>查找分布</td></tr><tr><td>Jsflagr.DistributionApi</td><td>putDistributions</td><td>PUT</td><td>/flags/{flagID}/segments/{segmentID}/distributions</td><td>更新分布</td></tr><tr><td>Jsflagr.EvaluationApi</td><td>postEvaluation</td><td>POST</td><td>/evaluation</td><td>更新某个评估</td></tr><tr><td>Jsflagr.EvaluationApi</td><td>postEvaluationBatch</td><td>POST</td><td>/evaluation/batch</td><td>批量更新评估</td></tr><tr><td>Jsflagr.ExportApi</td><td>getExportSQLite</td><td>GET</td><td>/export/sqlite</td><td>导出数据库转储的sqlite3格式，该格式是从主数据库转换而来的。</td></tr><tr><td>Jsflagr.FlagApi</td><td>createFlag</td><td>POST</td><td>/flags</td><td>创建标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>deleteFlag</td><td>DELETE</td><td>/flags/{flagID}</td><td>删除标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>findFlags</td><td>GET</td><td>/flags</td><td>查找所有的标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>getFlag</td><td>GET</td><td>/flags/{flagID}</td><td>查找某个标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>getFlagEntityTypes</td><td>GET</td><td>/flags/entity_types</td><td>获取标志实体的类型</td></tr><tr><td>Jsflagr.FlagApi</td><td>getFlagSnapshots</td><td>GET</td><td>/flags/{flagID}/snapshots</td><td>获取标志快照</td></tr><tr><td>Jsflagr.FlagApi</td><td>putFlag</td><td>PUT</td><td>/flags/{flagID}</td><td>更新标志</td></tr><tr><td>Jsflagr.FlagApi</td><td>setFlagEnabled</td><td>PUT</td><td>/flags/{flagID}/enabled</td><td>启用标志</td></tr><tr><td>Jsflagr.HealthApi</td><td>getHealth</td><td>GET</td><td>/health</td><td>获取健康指标</td></tr><tr><td>Jsflagr.SegmentApi</td><td>createSegment</td><td>POST</td><td>/flags/{flagID}/segments</td><td>创建分割区</td></tr><tr><td>Jsflagr.SegmentApi</td><td>deleteSegment</td><td>DELETE</td><td>/flags/{flagID}/segments/{segmentID}</td><td>删除分割区</td></tr><tr><td>Jsflagr.SegmentApi</td><td>findSegments</td><td>GET</td><td>/flags/{flagID}/segments</td><td>查找标志下的所有分割区</td></tr><tr><td>Jsflagr.SegmentApi</td><td>putSegment</td><td>PUT</td><td>/flags/{flagID}/segments/{segmentID}</td><td>更新某个分割区</td></tr><tr><td>Jsflagr.SegmentApi</td><td>putSegmentsReorder</td><td>PUT</td><td>/flags/{flagID}/segments/reorder</td><td>重新分配分割区</td></tr><tr><td>Jsflagr.VariantApi</td><td>createVariant</td><td>POST</td><td>/flags/{flagID}/variants</td><td>创建变体</td></tr><tr><td>Jsflagr.VariantApi</td><td>deleteVariant</td><td>DELETE</td><td>/flags/{flagID}/variants/{variantID}</td><td>删除变体</td></tr><tr><td>Jsflagr.VariantApi</td><td>findVariants</td><td>GET</td><td>/flags/{flagID}/variants</td><td>查找标志下的变体</td></tr><tr><td>Jsflagr.VariantApi</td><td>putVariant</td><td>PUT</td><td>/flags/{flagID}/variants/{variantID}</td><td>更新变体</td></tr></tbody></table><p>具体的api文档可以参考以下地址：<br><a href="https://checkr.github.io/flagr/api_docs/">https://checkr.github.io/flagr/api_docs/</a></p><h2 id="flagr实例"><a href="#flagr实例" class="headerlink" title="flagr实例"></a>flagr实例</h2><p>假设我们想向美国用户推出一个新按钮，而我们不知道哪种颜色效果最好。 绿色/蓝色/粉红色是标志的三种变体。</p><p><img src="/blog/23/1.png" alt="按钮1"></p><p><img src="/blog/23/2.png" alt="按钮2"></p><p>我们可能希望将标志公开给一小部分用户，例如加利福尼亚的用户。 因此，加利福尼亚的用户属于细分区。</p><p><img src="/blog/23/3.png" alt="细分区图1"></p><p>后来，我们了解到CA的用户喜欢绿色的按钮，NY的人们喜欢粉红色的按钮，DC的人们喜欢蓝色的按钮。因此，我们将分为三个部分，每个部分均由约束定义：州 ==？。该细分区也可以由多个约束定义。 例如，州== NY AND 年龄 &gt;= 21</p><p><img src="/blog/23/4.png" alt="细分区图2"></p><p><img src="/blog/23/5.png" alt="细分区图3"></p><p>要对此标志进行A / B测试，我们可以尝试使用50％ / 50％（分布）的绿色 / 蓝色，并仅对CA细分区域中20％（点击率）的用户进行测试。 稍后，我们可以将推广百分比设置为100％，以便CA中的每个用户都能以50％的机会获得绿色或蓝色。 当然，如果要向100％的用户推广到100％绿色，只需将分发设置为100％ / 0％的绿色 / 蓝色和100％的推广百分比。</p><p><img src="/blog/23/6.png" alt="A/B测试图1"></p><p><img src="/blog/23/7.png" alt="A/B测试图1"></p><h2 id="flagr的结构"><a href="#flagr的结构" class="headerlink" title="flagr的结构"></a>flagr的结构</h2><p>flagr中包含三个组件，标志评估器，标志管理器和flagr指标。</p><ul><li>flagr评估器：评估传入的请求。</li><li>flagr管理器：flagr管理器是 CRUD 的出入口。flagr的所有变化都在这里发生。</li><li>flagr指标. Flagr指标是收集评估结果的数据管道。 目前Flagr仅支持Kafka作为管道。</li></ul><p><img src="/blog/23/8.png" alt="flagr架构图"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要介绍一个A-B测试的中间件–flagr&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要介绍一个A-B测试的中间件–flagr&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要介绍一个A/B测试的中间件–flagr&quot;&gt;&lt;/a&gt;摘要：这篇文章主要介绍一个A/B测试的中间件–flagr&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。-它提供功能标记，实验（A-B测试）和动态配置。-它具有用于标志管理和标志评估的清晰的REST-API。&quot;&gt;&lt;a href=&quot;#前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。-它提供功能标记，实验（A-B测试）和动态配置。-它具有用于标志管理和标志评估的清晰的REST-API。&quot; class=&quot;headerlink&quot; title=&quot;前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。 它提供功能标记，实验（A / B测试）和动态配置。 它具有用于标志管理和标志评估的清晰的REST API。&quot;&gt;&lt;/a&gt;前言：Flagr是一个开源Go服务，可为正确的实体提供正确的体验并监视其影响。 它提供功能标记，实验（A / B测试）和动态配置。 它具有用于标志管理和标志评估的清晰的REST API。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://www.blog.ajie39.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="https://www.blog.ajie39.top/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="A/B测试" scheme="https://www.blog.ajie39.top/tags/A-B%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>专业术语汇总</title>
    <link href="https://www.blog.ajie39.top/2020/03/28/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/"/>
    <id>https://www.blog.ajie39.top/2020/03/28/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E6%B1%87%E6%80%BB/</id>
    <published>2020-03-28T07:33:31.728Z</published>
    <updated>2020-05-31T08:22:51.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是对开发过程中遇到的一些专业术语进行整理"><a href="#摘要：这篇文章主要是对开发过程中遇到的一些专业术语进行整理" class="headerlink" title="摘要：这篇文章主要是对开发过程中遇到的一些专业术语进行整理"></a>摘要：这篇文章主要是对开发过程中遇到的一些专业术语进行整理</h1><hr><h1 id="前言：这个篇文章主要是对开发过程中遇到的一些专业术语进行整理，其中包含各个领域的术语和一些开发术语。"><a href="#前言：这个篇文章主要是对开发过程中遇到的一些专业术语进行整理，其中包含各个领域的术语和一些开发术语。" class="headerlink" title="前言：这个篇文章主要是对开发过程中遇到的一些专业术语进行整理，其中包含各个领域的术语和一些开发术语。"></a>前言：这个篇文章主要是对开发过程中遇到的一些专业术语进行整理，其中包含各个领域的术语和一些开发术语。</h1><hr><h2 id="Git-团队协作中常用术语"><a href="#Git-团队协作中常用术语" class="headerlink" title="Git 团队协作中常用术语"></a>Git 团队协作中常用术语</h2><table><thead><tr><th>术语</th><th>英文全拼</th><th>解释</th></tr></thead><tbody><tr><td>WIP</td><td>Work in progress, do not merge yet.</td><td>开发中</td></tr><tr><td>LGTM</td><td>Looks good to me.</td><td>Riview 完别人的 PR ，没有问题</td></tr><tr><td>PTAL</td><td>Please take a look.</td><td>帮我看下，一般都是请别人 review 自己的 PR</td></tr><tr><td>CC</td><td>Carbon copy</td><td>一般代表抄送别人的意思</td></tr><tr><td>RFC</td><td>request for comments.</td><td>我觉得这个想法很好, 我们来一起讨论下</td></tr><tr><td>IIRC</td><td>if I recall correctly.</td><td>如果我没记错</td></tr><tr><td>ACK</td><td>acknowledgement</td><td>我确认了或者我接受了,我承认了</td></tr><tr><td>NACK/NAK</td><td>negative acknowledgement.</td><td>我不同意</td></tr></tbody></table><h2 id="软件测试中的术语"><a href="#软件测试中的术语" class="headerlink" title="软件测试中的术语"></a>软件测试中的术语</h2><p>在软件测试中：</p><ul><li>UT：单元测试</li><li>IT：集成测试</li><li>ST：系统测试</li><li>UAT：用户接受测试</li></ul><p>一、UT(单元测试，Unit Test):</p><p>单元测试任务包括：</p><p>1、模块接口测试；</p><p>2、模块局部数据结构测试；</p><p>3、模块边界条件测试；</p><p>4、模块中所有独立执行通路测试；</p><p>5、模块的各条错误处理通路测试。；</p><p>二、IT（集成测试，Integration Test）：</p><p>也称系统集成测试（System Integration Test）或结合测试，集成测试阶段是以黑盒法为主，在自底向上集成的早期，白盒法测试占一定的比例，随着集成测试的不断深入，这种比例在测试过程中将越来越少，渐渐地，黑盒法测试占据主导地位。</p><p>三、ST（系统测试，System Test）：</p><p>从技术角度看，系统测试是整个测试阶段的最后一步，所有的开发和测试在这一点上集中表现为生成一个具有一定功能的软件系统。该阶段主要对系统的准确性及完整性等方面进行测试。</p><p>主要进行：</p><p>功能确认测试、运行测试、强度测试、恢复测试、安全性测试等。系统测试的测试人员由测试组成员（或质量保证人员）或测试组成员与用户共同测试。在整个系统开发完成，即将交付用户使用前进行。在这一阶段，完全采用黑盒法对整个系统进行测试。</p><p>四、UAT(验收测试，User Acceptance Test):验收测试是向未来的用户表明系统能够像预定要求那样工作。</p><p>经集成测试后，已经按照设计把所有的模块组装成一个完整的软件系统，接口错误也已经基本排除了，接着就应该进一步验证软件的有效性，这就是验收测试的任务，即软件的功能和性能如同用户所合理期待的那样。</p><h2 id="供应链中的术语"><a href="#供应链中的术语" class="headerlink" title="供应链中的术语"></a>供应链中的术语</h2><table><thead><tr><th>领域</th><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>整体</td><td>ERP</td><td>Enterprise Resource Planning 企业资源计划</td></tr><tr><td></td><td>WMS</td><td>Warehouse Management System 仓储管理系统</td></tr><tr><td></td><td>WCS</td><td>Warehouse Control System  仓储控制系统</td></tr><tr><td></td><td>PLM</td><td>Product Life-Cycle Management 产品生命周期管理</td></tr><tr><td></td><td>SCM</td><td>Supply Chain Management 供应链管理</td></tr><tr><td></td><td>CRM</td><td>Customer Relationship Management 客户关系管理</td></tr><tr><td></td><td>EIP</td><td>Enterprise Information Portal 企业信息门户</td></tr><tr><td></td><td>BI</td><td>Business Intelligence 商业智能</td></tr><tr><td></td><td>OA</td><td>Office Automation 办公自动化</td></tr><tr><td></td><td>KM</td><td>Knowledge Management 知识管理</td></tr><tr><td></td><td>EDI</td><td>Electronic Data Interchange 电子数据交换</td></tr><tr><td>商品域</td><td></td><td></td></tr><tr><td></td><td>SPU</td><td>Standard Product Unit 标准化产品单元</td></tr><tr><td></td><td>SKU</td><td>Stock Keeping Unit 最小存货单位</td></tr><tr><td></td><td>主档</td><td></td></tr><tr><td></td><td>类目</td><td></td></tr><tr><td></td><td>条码</td><td></td></tr><tr><td></td><td>PLU码</td><td></td></tr><tr><td></td><td>规格</td><td></td></tr><tr><td>仓储域</td><td>入库（Inbound）</td><td>Inbound process 入库操作/入库流程</td></tr><tr><td></td><td>预约（appointment scheduling）</td><td></td></tr><tr><td></td><td>收货（check in）</td><td></td></tr><tr><td></td><td>质检（quality control）</td><td></td></tr><tr><td></td><td>上架（putaway）</td><td></td></tr><tr><td></td><td>退货（retums）</td><td></td></tr><tr><td></td><td>定位（Locating）</td><td></td></tr><tr><td></td><td>出库（outbound）</td><td>outbound process 出库操作/出库流程</td></tr><tr><td></td><td>分拣（picking）</td><td>也叫“拣货”，pick list 分拣单</td></tr><tr><td></td><td>复核</td><td></td></tr><tr><td></td><td>打包（packing）</td><td></td></tr><tr><td></td><td>发运（shipping）</td><td>shipping order 运货单</td></tr><tr><td></td><td>盘点（count）</td><td>循环盘点：cycle count，盘盈，盘亏</td></tr><tr><td></td><td>制单（printing）</td><td></td></tr><tr><td></td><td>报损/报溢</td><td></td></tr><tr><td></td><td>标签（Label）</td><td></td></tr><tr><td></td><td>库区</td><td></td></tr><tr><td></td><td>存货区</td><td></td></tr><tr><td></td><td>暂存区</td><td></td></tr><tr><td></td><td>集货区</td><td></td></tr><tr><td></td><td>分拣区（picking face）</td><td></td></tr><tr><td></td><td>月台（dock）</td><td></td></tr><tr><td></td><td>通道</td><td></td></tr><tr><td></td><td>货架</td><td></td></tr><tr><td></td><td>货位</td><td></td></tr><tr><td></td><td>地堆</td><td></td></tr><tr><td></td><td>容器</td><td></td></tr><tr><td></td><td>LPN</td><td>License Plate Number 注册容器编码</td></tr><tr><td>物流域</td><td>直通</td><td></td></tr><tr><td></td><td>直送</td><td></td></tr><tr><td></td><td>配送</td><td>也叫“内配”</td></tr><tr><td></td><td>调拨</td><td></td></tr><tr><td></td><td>批发</td><td></td></tr><tr><td>库存域</td><td>库存</td><td></td></tr><tr><td></td><td>库存同步</td><td></td></tr><tr><td></td><td>销售库存</td><td></td></tr><tr><td></td><td>实物库存</td><td></td></tr><tr><td></td><td>安全库存</td><td></td></tr><tr><td>商户域</td><td>商户</td><td></td></tr><tr><td></td><td>销售商</td><td>内部也有人称为“机构”</td></tr><tr><td></td><td>服务商</td><td></td></tr><tr><td></td><td>供应商</td><td></td></tr><tr><td></td><td>门店</td><td></td></tr><tr><td></td><td>营业部</td><td></td></tr><tr><td></td><td>自提点</td><td></td></tr><tr><td></td><td>店组</td><td></td></tr><tr><td>履约域</td><td>集波</td><td></td></tr><tr><td></td><td>寻源</td><td></td></tr><tr><td>财务部</td><td>移动平均成本</td><td></td></tr><tr><td></td><td>批次成本</td><td></td></tr><tr><td></td><td>进项税</td><td></td></tr><tr><td></td><td>销项税</td><td></td></tr><tr><td></td><td>发票（invoice）</td><td></td></tr><tr><td>采购域</td><td>补货（replenishment）</td><td></td></tr><tr><td>技术域</td><td>租户</td><td></td></tr></tbody></table><h2 id="回复过程会用到的一些英语0"><a href="#回复过程会用到的一些英语0" class="headerlink" title="回复过程会用到的一些英语0"></a>回复过程会用到的一些英语0</h2><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>got it（明白了，懂了）</td><td>注意：“I get it”的时候更加突出是明白之前不明白的事情，但是“I got it”则是纯粹的表示我知道了，无论是之前就知道还是现在明白。</td></tr><tr><td>copy that</td><td>收到</td></tr><tr><td>done</td><td>完成</td></tr></tbody></table><h2 id="AI方面"><a href="#AI方面" class="headerlink" title="AI方面"></a>AI方面</h2><table><thead><tr><th>术语</th><th>含义</th><th>功能</th></tr></thead><tbody><tr><td>dialogue-manager</td><td>会话引擎</td><td>响应agent路由过来的用户咨询问题，调用后端相关服务收集对话背景信息，按照一定策略计算回复内容，并通过agent发送回客户端。</td></tr><tr><td>nlu-server</td><td>意图判断</td><td>响应dialogue调用的用户咨询问题，判断对应的意图</td></tr><tr><td>attention-server</td><td>槽识别</td><td>响应dialogue调用的用户咨询问题，根据意图识别对应的槽(slot)</td></tr><tr><td>agent</td><td>用来路由系统与客户端之间的请求。</td><td>向客户端发送reply，需要保证DialogueReply的session_id是可路由的，即session_id由store_id, assistant_id, user_id构成。如果assistant不在线，则reply被丢弃掉。</td></tr><tr><td>activity</td><td>用来存储以及归档服务的结构化log或数据。相关数据会存储在kafka中，以及归档在hdfs之上</td><td>用来存储以及归档服务的结构化log或数据。相关数据会存储在kafka中，以及归档在hdfs之上。</td></tr><tr><td>context-service</td><td>用来存储dialogue的对话处理逻辑的上下文相关的服务</td><td>GetContext：根据某个key获得上下文- SetContext：根据某个key存储上下文</td></tr><tr><td>insight-server</td><td>AI pipeline中的preprocess 模块</td><td>Preprocessor: query filter、中文繁转简、全角转半角、英文大写转小写；中文分词、词性标注，命名实体：人名、地名、URL、表情、快递、数字及normalize、时间及normalize、邮编、电话、邮箱、主播。</td></tr><tr><td>nlg-service</td><td>AI pipeline中的LAT模块</td><td>识别LAT，目前主要处理咨询尺码后面跟一句的情况</td></tr><tr><td>kbqa-server</td><td>AI 系统中，基于knowledge base进行QA的service</td><td>在知识库中进行查询推理，并进行回复。</td></tr><tr><td>FAQ-server</td><td>AI 系统中，frequently asked question 回复</td><td>目前主要对转人工、重置等，进行回复。</td></tr><tr><td>Sentimenter-server</td><td>AI 系统中，对用户的query进行情感分析分类</td><td>对用户query进行情感分析分类，对一些骂人的话或者很难听的话会判断成negative</td></tr><tr><td>shop-item-center</td><td>店铺信息的获得</td><td></td></tr><tr><td>mockingjay</td><td>mock data 的管理、修改、刷新</td><td>管理e2e 相关的mock data</td></tr><tr><td>Turnstile</td><td>1. 商家身份验证 2. 将配置推送到各个服务 3.直接提供api查询服务</td><td></td></tr><tr><td>Ya</td><td>1. 询单挽回 2. 付款后推荐 3. 质量问题挽回 4. 催付款 5. 催好评 等event触发的主动发送话术</td><td></td></tr><tr><td>collector-gateway</td><td>日志收集系统的一部分，用于收集从外网传送回来的日志，主要为机器人客户端准备 （目前机器人尚未启用日志回传功能，故未实际使用）</td><td></td></tr><tr><td>kibana</td><td>日志展示系统，连接后端ES，提供前端访问功能，用于内部人员查看系统及服务日志.</td><td></td></tr><tr><td>webrouter</td><td>Lain 集群中所有 web 服务的总入口.</td><td></td></tr><tr><td>load-test</td><td>只部署在stg环境，可以通过beary chat触发，按照指定qps向指定服务发起压力测试，并最终返回P95等信息。</td><td></td></tr><tr><td>notebook</td><td>只部署在stg环境，基于jupiter notebook实现的交互式访问stg环境所有grpc service的portal。</td><td></td></tr></tbody></table><h2 id="安全方面"><a href="#安全方面" class="headerlink" title="安全方面"></a>安全方面</h2><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>RCE</td><td></td></tr><tr><td>poc</td><td></td></tr><tr><td>exp</td><td></td></tr><tr><td>getshell</td><td></td></tr><tr><td>反弹shell</td><td></td></tr><tr><td>fuzz</td><td></td></tr><tr><td>gadget</td><td></td></tr><tr><td>dns劫持</td><td></td></tr><tr><td>链路劫持</td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="未完待续。。。。。。不定期添加"><a href="#未完待续。。。。。。不定期添加" class="headerlink" title="未完待续。。。。。。不定期添加"></a>未完待续。。。。。。不定期添加</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是对开发过程中遇到的一些专业术语进行整理&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是对开发过程中遇到的一些专业术语进行整理&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是对开发过程中遇到的一些专业术语进行整理&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>ORM之他暂时可能只是个弟弟——Jooq</title>
    <link href="https://www.blog.ajie39.top/2020/03/28/ORM%E4%B9%8B%E4%BB%96%E6%9A%82%E6%97%B6%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E4%B8%AA%E5%BC%9F%E5%BC%9F%E2%80%94%E2%80%94Jooq/"/>
    <id>https://www.blog.ajie39.top/2020/03/28/ORM%E4%B9%8B%E4%BB%96%E6%9A%82%E6%97%B6%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E4%B8%AA%E5%BC%9F%E5%BC%9F%E2%80%94%E2%80%94Jooq/</id>
    <published>2020-03-28T07:32:00.031Z</published>
    <updated>2021-05-05T04:26:33.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是对之前一段时间学习Jooq的总结。"><a href="#摘要：这篇文章主要是对之前一段时间学习Jooq的总结。" class="headerlink" title="摘要：这篇文章主要是对之前一段时间学习Jooq的总结。"></a>摘要：这篇文章主要是对之前一段时间学习Jooq的总结。</h1><hr><h1 id="前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。"><a href="#前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。" class="headerlink" title="前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。"></a>前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。</h1><hr><span id="more"></span><h2 id="Jooq简介"><a href="#Jooq简介" class="headerlink" title="Jooq简介"></a>Jooq简介</h2><p>JOOQ 是基于Java访问关系型数据库的工具包，轻量，简单，并且足够灵活，可以轻松的使用Java面向对象语法来实现各种复杂的sql。不管是Hibernate或者Mybatis，都能简单的使用实体映射来访问数据库，但有时候这些“高级”的对象关系映射，没有直接使用原生sql来的灵活和简单，而且对于一些如：joins,union, nested selects等复杂的操作支持的不友好。JOOQ 既吸取了传统ORM操作数据的简单性和安全性，又保留了原生sql的灵活性，它更像是介于ORM和JDBC的中间层。</p><p>相比其它ORM，JOOQ更注重于对<a href="http://stackoverflow.com/a/4208156/851099">数据库模型的建模</a>。它拥有以下特点：</p><ul><li>面向SQL</li><li>构建类型安全的SQL</li><li>强大的代码生成工具</li><li>方便的乐观锁等高级特性</li></ul><p>详细的可以看看<a href="http://www.jooq.org/doc/3.8/manual-single-page/#preface">Jooq官网介绍</a>。</p><p>如果说它有什么缺点，那就是它对一些商用数据库，如Oracle、SQL Server是收费的。</p><h2 id="快速上手Jooq"><a href="#快速上手Jooq" class="headerlink" title="快速上手Jooq"></a>快速上手Jooq</h2><p>接下来，让我们通过官网的<a href="http://www.jooq.org/doc/3.8/manual-single-page/#jooq-in-7-steps">《JOOQ7步走》</a>中的例子快速上手JOOQ吧。</p><h3 id="第一步-下载JOOQ"><a href="#第一步-下载JOOQ" class="headerlink" title="第一步 下载JOOQ"></a>第一步 下载JOOQ</h3><p>首先需要在JOOQ的<a href="http://www.jooq.org/download">下载页面</a>下载它。如果使用的是开源版本，可以直接通过Maven等工具下载。</p><h3 id="第二步-创建数据库"><a href="#第二步-创建数据库" class="headerlink" title="第二步 创建数据库"></a>第二步 创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &#96;test&#96;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;student&#96; (</span><br><span class="line">  &#96;id&#96; int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;stu_id&#96; int(20) NOT NULL,</span><br><span class="line">  &#96;stu_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;age&#96; int(8) DEFAULT NULL,</span><br><span class="line">  &#96;class_id&#96; int(10) NOT NULL,</span><br><span class="line">  &#96;class_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;result&#96; int(8) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="第三步-生成代码"><a href="#第三步-生成代码" class="headerlink" title="第三步 生成代码"></a>第三步 生成代码</h3><p>JOOQ生成代码方式有多种，可以按照<a href="http://www.jooq.org/doc/3.8/manual-single-page/#jooq-in-7-steps-step3">官网的方法</a>生成代码。然后就可以在自己的代码中使用这些生成的代码了。</p><p>或者参考下面配置，修改你的pom.xml，然后在Terminal运行：mvn jooq-codegen:generate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;!-- 数据库信息 --&gt;</span><br><span class="line">    &lt;db.url&gt;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&lt;&#x2F;db.url&gt;</span><br><span class="line">    &lt;!-- 你的数据库用户名 --&gt;</span><br><span class="line">    &lt;db.username&gt;root&lt;&#x2F;db.username&gt;</span><br><span class="line">    &lt;!-- 你的数据库密码 --&gt;</span><br><span class="line">    &lt;db.password&gt;&#123;*********&#125;&lt;&#x2F;db.password&gt;</span><br><span class="line">    &lt;jooq.version&gt;3.13.1&lt;&#x2F;jooq.version&gt;</span><br><span class="line">    &lt;!-- 你的packageName --&gt;</span><br><span class="line">    &lt;jooq.packageName&gt;&#123;*********&#125;&lt;&#x2F;jooq.packageName&gt;</span><br><span class="line">    &lt;!-- 你的directory --&gt;</span><br><span class="line">    &lt;jooq.directory&gt;&#123;*********&#125;&lt;&#x2F;jooq.directory&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">&lt;!-- jOOQ代码生成插件 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.jooq&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;jooq-codegen-maven&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.11.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;jooq-codegen&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;generate&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;&#x2F;phase&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;skip&gt;false&lt;&#x2F;skip&gt;</span><br><span class="line">                    &lt;jdbc&gt;</span><br><span class="line">                        &lt;driver&gt;com.mysql.jdbc.Driver&lt;&#x2F;driver&gt;</span><br><span class="line">                        &lt;url&gt;$&#123;db.url&#125;&lt;&#x2F;url&gt;</span><br><span class="line">                        &lt;user&gt;$&#123;db.username&#125;&lt;&#x2F;user&gt;</span><br><span class="line">                        &lt;password&gt;$&#123;db.password&#125;&lt;&#x2F;password&gt;</span><br><span class="line">                    &lt;&#x2F;jdbc&gt;</span><br><span class="line">                    &lt;generator&gt;</span><br><span class="line">                        &lt;name&gt;org.jooq.codegen.JavaGenerator&lt;&#x2F;name&gt;</span><br><span class="line">                        &lt;database&gt;</span><br><span class="line">                            &lt;name&gt;org.jooq.meta.mysql.MySQLDatabase&lt;&#x2F;name&gt;</span><br><span class="line">                            &lt;includes&gt;.*&lt;&#x2F;includes&gt;</span><br><span class="line">                            &lt;excludes&gt;&lt;&#x2F;excludes&gt;</span><br><span class="line">                            &lt;inputSchema&gt;test&lt;&#x2F;inputSchema&gt;</span><br><span class="line">                        &lt;&#x2F;database&gt;</span><br><span class="line">                        &lt;generate&gt;</span><br><span class="line">                            &lt;javaTimeTypes&gt;true&lt;&#x2F;javaTimeTypes&gt;</span><br><span class="line">                        &lt;&#x2F;generate&gt;</span><br><span class="line">                        &lt;target&gt;</span><br><span class="line">                            &lt;!-- The destination package of your generated classes (within the</span><br><span class="line">                                destination directory) --&gt;</span><br><span class="line">                            &lt;packageName&gt;$&#123;jooq.packageName&#125;&lt;&#x2F;packageName&gt;</span><br><span class="line">                            &lt;!-- The destination directory of your generated classes --&gt;</span><br><span class="line">                            &lt;directory&gt;$&#123;jooq.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;&#x2F;target&gt;</span><br><span class="line">                        &lt;generate&gt;</span><br><span class="line">                            &lt;!-- 生成pojo --&gt;</span><br><span class="line">                            &lt;pojos&gt;true&lt;&#x2F;pojos&gt;</span><br><span class="line">                            &lt;!-- 生成dao --&gt;</span><br><span class="line">                            &lt;daos&gt;true&lt;&#x2F;daos&gt;</span><br><span class="line">                        &lt;&#x2F;generate&gt;</span><br><span class="line">                    &lt;&#x2F;generator&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">      &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><h3 id="第四、五、六步-完成增删改操作"><a href="#第四、五、六步-完成增删改操作" class="headerlink" title="第四、五、六步 完成增删改操作"></a>第四、五、六步 完成增删改操作</h3><p>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import org.jooq.DSLContext;</span><br><span class="line">import org.jooq.Record;</span><br><span class="line">import org.jooq.Result;</span><br><span class="line">import org.jooq.SQLDialect;</span><br><span class="line">import org.jooq.impl.DSL;</span><br><span class="line">import top.ajie.jooqDemo.entity.tables.Student;</span><br><span class="line">import top.ajie.jooqDemo.entity.tables.records.StudentRecord;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line">import static top.ajie.jooqDemo.entity.Tables.STUDENT;</span><br><span class="line"></span><br><span class="line">public class JooqCRUD &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String userName &#x3D; &quot;root&quot;;</span><br><span class="line">        String password &#x3D; &quot;&quot;;</span><br><span class="line">        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&quot;;</span><br><span class="line">        &#x2F;&#x2F; Connection is the only JDBC resource that we need</span><br><span class="line">        &#x2F;&#x2F; PreparedStatement and ResultSet are handled by jOOQ, internally</span><br><span class="line">        try (Connection conn &#x3D; DriverManager.getConnection(url, userName, password)) &#123;</span><br><span class="line">            DSLContext dslContext &#x3D; DSL.using(conn, SQLDialect.MYSQL);</span><br><span class="line">            &#x2F;&#x2F; 查询数据</span><br><span class="line">            query(dslContext);</span><br><span class="line">            &#x2F;&#x2F; 添加数据</span><br><span class="line">            StudentRecord stu &#x3D; dslContext.newRecord(STUDENT);</span><br><span class="line">            stu.setStuId(123456);</span><br><span class="line">            stu.setStuName(&quot;张三&quot;);</span><br><span class="line">            stu.setClassId(20200306);</span><br><span class="line">            stu.setClassName(&quot;三年六班&quot;);</span><br><span class="line">            stu.setAge(9);</span><br><span class="line">            stu.setResult(100);</span><br><span class="line">            stu.store();</span><br><span class="line">            &#x2F;&#x2F; 查询数据</span><br><span class="line">            query(dslContext);</span><br><span class="line">            &#x2F;&#x2F; 修改数据</span><br><span class="line">            int sumUp &#x3D; dslContext</span><br><span class="line">                    .update(Student.STUDENT)</span><br><span class="line">                    .set(Student.STUDENT.STU_NAME, &quot;李四&quot;)</span><br><span class="line">                    .where(Student.STUDENT.STU_NAME.eq(&quot;张三&quot;)</span><br><span class="line">                            .and(Student.STUDENT.RESULT.eq(100))</span><br><span class="line">                    )</span><br><span class="line">                    .execute();</span><br><span class="line">            System.out.println(sumUp);</span><br><span class="line">            &#x2F;&#x2F; 查询数据</span><br><span class="line">            query(dslContext);</span><br><span class="line">            &#x2F;&#x2F; 删除数据</span><br><span class="line">            int sumDelete &#x3D; dslContext</span><br><span class="line">                    .delete(Student.STUDENT)</span><br><span class="line">                    .where(Student.STUDENT.STU_NAME.eq(&quot;李四&quot;)</span><br><span class="line">                            .and(Student.STUDENT.RESULT.eq(100))</span><br><span class="line">                    )</span><br><span class="line">                    .execute();</span><br><span class="line">            System.out.println(sumDelete);</span><br><span class="line">            &#x2F;&#x2F; 查询数据</span><br><span class="line">            query(dslContext);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; For the sake of this tutorial, let&#39;s keep exception handling simple</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void query(DSLContext dslContext) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查询数据</span><br><span class="line">        Result&lt;Record&gt; stuResult &#x3D; dslContext.select().from(STUDENT).fetch();</span><br><span class="line">        for (Record r : stuResult) &#123;</span><br><span class="line">            String stuName &#x3D; r.getValue(STUDENT.STU_NAME);</span><br><span class="line">            String className &#x3D; r.getValue(STUDENT.CLASS_NAME);</span><br><span class="line">            Integer result &#x3D; r.getValue(STUDENT.RESULT);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;stuName: &quot; + stuName + &quot; className: &quot; + className + &quot; result: &quot; + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="探索-：略"><a href="#探索-：略" class="headerlink" title="探索 ：略"></a>探索 ：略</h3><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="1、生成POJO"><a href="#1、生成POJO" class="headerlink" title="1、生成POJO"></a>1、生成POJO</h3><p>首先在生成配置中添加生成POJO的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generate&gt;</span><br><span class="line">  &lt;pojos&gt;true&lt;&#x2F;pojos&gt;</span><br><span class="line">&lt;&#x2F;generate&gt;</span><br></pre></td></tr></table></figure><p>重新运行生成工具，一个 student 类就生成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Generated;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&#123; &quot;all&quot;, &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public class Student implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; -1386674258;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private Integer stuId;</span><br><span class="line">    private String  stuName;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Integer classId;</span><br><span class="line">    private String  className;</span><br><span class="line">    private Integer result;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Student(Student value) &#123;</span><br><span class="line">        this.id &#x3D; value.id;</span><br><span class="line">        this.stuId &#x3D; value.stuId;</span><br><span class="line">        this.stuName &#x3D; value.stuName;</span><br><span class="line">        this.age &#x3D; value.age;</span><br><span class="line">        this.classId &#x3D; value.classId;</span><br><span class="line">        this.className &#x3D; value.className;</span><br><span class="line">        this.result &#x3D; value.result;</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用JOOQ的API方便的将查询结果和POJO相互转化了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Record to POJO</span><br><span class="line">List&lt;Student&gt; list &#x3D; dslContext.selectFrom(STUDENT).fetch().into(Student.class);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; POJO to Record</span><br><span class="line">Student a &#x3D; dslContext.selectFrom(STUDENT).fetch().get(0).into(Student.class);</span><br><span class="line">StudentRecord author &#x3D; dslContext.newRecord(STUDENT);</span><br><span class="line">author.from(a);</span><br><span class="line">System.out.println(author);</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li><code>from</code>方法提供了多个重载，可以从<code>Map</code>或<code>Array</code>获取数据</li><li><code>from</code>方法从<code>Object</code>获取数据使用了反射的方式，因此效率会比较低。【后面会有解决办法】</li></ul><h3 id="2、生成接口"><a href="#2、生成接口" class="headerlink" title="2、生成接口"></a>2、生成接口</h3><p>Java提倡面向接口编程，JOOQ也提供了生成接口的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generate&gt;</span><br><span class="line">  &lt;interfaces&gt;true&lt;&#x2F;interfaces&gt;</span><br><span class="line">&lt;&#x2F;generate&gt;</span><br></pre></td></tr></table></figure><p>生成的接口是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Generated;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This class is generated by jOOQ.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Generated(</span><br><span class="line">    value &#x3D; &#123;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.jooq.org&quot;,</span><br><span class="line">        &quot;jOOQ version:3.11.11&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    comments &#x3D; &quot;This class is generated by jOOQ&quot;</span><br><span class="line">)</span><br><span class="line">@SuppressWarnings(&#123; &quot;all&quot;, &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">public interface IStudent extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Setter for &lt;code&gt;test.student.id&lt;&#x2F;code&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setId(Integer value);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Getter for &lt;code&gt;test.student.id&lt;&#x2F;code&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Integer getId();</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Copy data into another generated Record&#x2F;POJO implementing the common interface IStudent</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;E extends top.ajie.jooqDemo.entity.tables.interfaces.IStudent&gt; E into(E into);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果选择生成“接口”，则生成的Record和POJO都将继承该接口。<br>而之前提到的from方法也将会增加一个IStudent的重载，并使用其中的Getters, Setters，从而具有更好的性能。</p><p>如果只生成接口，而不生成Record或POJO，则JOOQ会使用proxy动态代理对象的方法来达到相同的效果。</p><h3 id="3、生成Annotation"><a href="#3、生成Annotation" class="headerlink" title="3、生成Annotation"></a>3、生成Annotation</h3><p>JOOQ可以选择生成JPA和JSR-303的注解，从而能够更好的和JPA框架配合，并提供更加强大的校验能力：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jpaAnnotations&gt;true&lt;&#x2F;jpaAnnotations&gt;</span><br><span class="line">&lt;validationAnnotations&gt;true&lt;&#x2F;validationAnnotations&gt;</span><br></pre></td></tr></table></figure><p>选择之后，以<code>IStudent</code>为例，生成的代码将变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Generated;</span><br><span class="line">import javax.persistence.Column;</span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.GeneratedValue;</span><br><span class="line">import javax.persistence.GenerationType;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line">import javax.persistence.Index;</span><br><span class="line">import javax.persistence.Table;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraints.Size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This class is generated by jOOQ.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Generated(</span><br><span class="line">    value &#x3D; &#123;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.jooq.org&quot;,</span><br><span class="line">        &quot;jOOQ version:3.11.11&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    comments &#x3D; &quot;This class is generated by jOOQ&quot;</span><br><span class="line">)</span><br><span class="line">@SuppressWarnings(&#123; &quot;all&quot;, &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">@Entity</span><br><span class="line">@Table(name &#x3D; &quot;student&quot;, schema &#x3D; &quot;test&quot;, indexes &#x3D; &#123;</span><br><span class="line">    @Index(name &#x3D; &quot;PRIMARY&quot;, unique &#x3D; true, columnList &#x3D; &quot;id ASC&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">public interface IStudent extends Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Setter for &lt;code&gt;test.student.id&lt;&#x2F;code&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setId(Integer value);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Getter for &lt;code&gt;test.student.id&lt;&#x2F;code&gt;.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)</span><br><span class="line">    @Column(name &#x3D; &quot;id&quot;, unique &#x3D; true, nullable &#x3D; false, precision &#x3D; 10)</span><br><span class="line">    public Integer getId();</span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Copy data into another generated Record&#x2F;POJO implementing the common interface IStudent</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;E extends top.ajie.jooqDemo.entity.tables.interfaces.IStudent&gt; E into(E into);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、Builder模式"><a href="#4、Builder模式" class="headerlink" title="4、Builder模式"></a>4、Builder模式</h3><p>到了这一步，也许你已经在问自己，为什么没有早点认识JOOQ了，能省不少事呢。不过你知道吗，JOOQ还可以做得更多——它能生成具有Builder模式的Bean：</p><p>添加以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;generate&gt;</span><br><span class="line">  &lt;fluentSetters&gt;true&lt;&#x2F;fluentSetters&gt;</span><br><span class="line">&lt;&#x2F;generate&gt;</span><br></pre></td></tr></table></figure><p>配置fluentSetters为true时，Setter将返回自身：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Student setId(Integer id) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的代码将可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IStudent student &#x3D; dslContext.newRecord(STUDENT);</span><br><span class="line">student.setId(1).setStuId(123456).setStuName(&quot;老六&quot;);</span><br></pre></td></tr></table></figure><p>这样代码字段设置和之前相比简洁了很多。</p><h3 id="5、DAO和spring"><a href="#5、DAO和spring" class="headerlink" title="5、DAO和spring"></a>5、DAO和spring</h3><p>如果你是DAO模式和Spring的忠实粉丝，还可以增加以下两个配置，无缝对接Spring的集成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;daos&gt;true&lt;&#x2F;daos&gt;</span><br><span class="line">&lt;springAnnotations&gt;true&lt;&#x2F;springAnnotations&gt;</span><br></pre></td></tr></table></figure><p>生成的代码类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Generated;</span><br><span class="line"></span><br><span class="line">import org.jooq.Configuration;</span><br><span class="line">import org.jooq.impl.DAOImpl;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">import top.ajie.jooqDemo.entity.tables.Student;</span><br><span class="line">import top.ajie.jooqDemo.entity.tables.records.StudentRecord;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This class is generated by jOOQ.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Generated(</span><br><span class="line">    value &#x3D; &#123;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;www.jooq.org&quot;,</span><br><span class="line">        &quot;jOOQ version:3.11.11&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    comments &#x3D; &quot;This class is generated by jOOQ&quot;</span><br><span class="line">)</span><br><span class="line">@SuppressWarnings(&#123; &quot;all&quot;, &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="line">@Repository</span><br><span class="line">public class StudentDao extends DAOImpl&lt;StudentRecord, top.ajie.jooqDemo.entity.tables.pojos.Student, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create a new StudentDao without any configuration</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public StudentDao() &#123;</span><br><span class="line">        super(Student.STUDENT, top.ajie.jooqDemo.entity.tables.pojos.Student.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Create a new StudentDao with an attached configuration</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Autowired</span><br><span class="line">    public StudentDao(Configuration configuration) &#123;</span><br><span class="line">        super(Student.STUDENT, top.ajie.jooqDemo.entity.tables.pojos.Student.class, configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Fetch records that have &lt;code&gt;result IN (values)&lt;&#x2F;code&gt;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public List&lt;top.ajie.jooqDemo.entity.tables.pojos.Student&gt; fetchByResult(Integer... values) &#123;</span><br><span class="line">        return fetch(Student.STUDENT.RESULT, values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、无符号数字类型"><a href="#6、无符号数字类型" class="headerlink" title="6、无符号数字类型"></a>6、无符号数字类型</h3><p>SQL支持无符号数字，但是java没有内建无符号数字的类型，为此JOOQ的作者提供了JOOU来处理无符号数。</p><p>例如对上面的age字段，类型可以设置成UInteger，可以使用age.intValue()获取对应的int数值。尽管UInteger更加准确，但是如果你觉得增加一个intValue()的调用会比较繁琐。可以通过下面这个配置使POJO直接使用int作为字段类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;database&gt;</span><br><span class="line">  &lt;unsignedTypes&gt;false&lt;&#x2F;unsignedTypes&gt;</span><br><span class="line">&lt;&#x2F;database&gt;</span><br></pre></td></tr></table></figure><h3 id="7、乐观锁支持"><a href="#7、乐观锁支持" class="headerlink" title="7、乐观锁支持"></a>7、乐观锁支持</h3><p>一个修改的常见场景是：用户读取了记录，作了修改之后再保存入数据库。如果这个时间里，有人修改了数据库的同一个字段，则上一个人的修改就被覆盖了。</p><p>乐观锁就是再出现这种情况时，通过抛出异常或其他方式，来提醒用户改动不安全，需要刷新并重新修改记录。</p><p>jOOQ允许您使用乐观锁定执行CRUD操作。您可以通过激活相关的<a href="https://www.jooq.org/doc/3.8/manual/sql-building/dsl-context/custom-settings/">executeWithOptimisticLocking</a>设置立即利用此功能。如果不进一步了解基础数据语义，这将对store()和delete()方法产生以下影响：</p><ul><li>INSERT语句不受此Setting标志的影响。</li><li>在UPDATE或DELETE语句之前，jOOQ将运行SELECT .. FOR UPDATE语句，悲观地锁定记录以用于后续的UPDATE(DELETE)。</li><li>使用先前的SELECT提取的数据将与存储或删除的记录中的数据进行比较。</li><li>一个org.jooq.exception.DataChangedException如果记录已经在平均时间被修改，则被抛出。</li><li>如果同时未修改记录，则记录成功UPDATE(DELETE)。</li></ul><p>JOOQ提供了一个配置能方便地实现乐观锁，而不需要修改业务代码【详见<a href="http://www.jooq.org/doc/3.8/manual/sql-execution/crud-with-updatablerecords/optimistic-locking/">文档</a>】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Properly configure the DSLContext</span><br><span class="line">DSLContext optimistic &#x3D; DSLContext.using(connection, SQLDialect.MYSQL,</span><br><span class="line">  new Settings().withExecuteWithOptimisticLocking(true));</span><br></pre></td></tr></table></figure><p>JOOQ的乐观锁模式虽然对业务逻辑代码没有侵入性，但是需要数据表提供<code>numeric VERSION</code>或<code>TIMESTAMP</code>字段，比如下表的<code>last_modified_time</code>字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;student&#96; (</span><br><span class="line">  &#96;id&#96; int(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;stu_id&#96; int(20) NOT NULL,</span><br><span class="line">  &#96;stu_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;age&#96; int(8) DEFAULT NULL,</span><br><span class="line">  &#96;class_id&#96; int(10) NOT NULL,</span><br><span class="line">  &#96;class_name&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;result&#96; int(8) DEFAULT NULL,</span><br><span class="line">  &#96;time&#96; timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP(0),</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4;</span><br></pre></td></tr></table></figure><p>然后在代码生成中添加下面的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;database&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;!-- 支持正则，多个字段可以使用&#96;|&#96;分隔 --&gt;</span><br><span class="line">  &lt;recordTimestampFields&gt;last_modified_time&lt;&#x2F;recordTimestampFields&gt;</span><br><span class="line">&lt;&#x2F;database&gt;</span><br></pre></td></tr></table></figure><p>最后生成的<code>Table</code>类中将增加一个<code>getRecordTimestamp</code>方法供乐观锁使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TableField&lt;StudentRecord, Timestamp&gt; getRecordTimestamp() &#123;</span><br><span class="line">    return TIME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用集成"><a href="#应用集成" class="headerlink" title="应用集成"></a>应用集成</h2><h3 id="JOOQ与hikaricp集成管理数据源"><a href="#JOOQ与hikaricp集成管理数据源" class="headerlink" title="JOOQ与hikaricp集成管理数据源"></a>JOOQ与hikaricp集成管理数据源</h3><p>JOOQ唯一的外部依赖就是一个JDBC连接或JDBC资源池<code>DataSource</code>。JOOQ只会使用这个连接构建<code>PreparedStatement</code>和执行SQL，并不会管理这个连接的生命周期。这样做的好处是模块功能划分做的很彻底，数据源的事情由专门的数据源库来管理<code>DataSource</code>是一个独立的模块，我们可以灵活地配置它。</p><p>应用开发需要引入一个第三方的<code>DatatSource</code>数据源来管理数据库连接；这里介绍一下<a href="https://github.com/brettwooldridge/HikariCP">hikaricp</a>的集成方式：</p><p>Hikari提供了<a href="https://github.com/brettwooldridge/HikariCP#initialization">多种方式</a>创建数据源，例如可以程序直接创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HikariConfig config &#x3D; new HikariConfig();</span><br><span class="line">config.setJdbcUrl(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;);</span><br><span class="line">config.setUsername(&quot;root&quot;);</span><br><span class="line">config.setPassword(&quot;123456&quot;);</span><br><span class="line">config.addDataSourceProperty(&quot;cachePrepStmts&quot;, &quot;true&quot;);</span><br><span class="line">config.addDataSourceProperty(&quot;prepStmtCacheSize&quot;, &quot;350&quot;);</span><br><span class="line">config.addDataSourceProperty(&quot;prepStmtCacheSqlLimit&quot;, &quot;2048&quot;);</span><br><span class="line"></span><br><span class="line">HikariDataSource ds &#x3D; new HikariDataSource(config);</span><br><span class="line">DSLContext create &#x3D; DSL.using(ds, SQLDialect.MYSQL);</span><br></pre></td></tr></table></figure><h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>ExecuteListener 可以看作是一个JOOQ执行的观察者，它可以监控SQL执行的整个生命周期。并且可以通过执行上下文，做一些个性化的操作。下面SlowQueryListener类的作用就是收集sql执行过程的慢查询日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class SlowQueryListener extends DefaultExecuteListener &#123;</span><br><span class="line">  private Logger logger &#x3D; LoggerFactory.getLogger(SlowQueryListener.class);</span><br><span class="line">  StopWatch watch;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void executeStart(ExecuteContext ctx) &#123;</span><br><span class="line">    super.executeStart(ctx);</span><br><span class="line">    watch &#x3D; new StopWatch();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void executeEnd(ExecuteContext ctx) &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">      super.executeEnd(ctx);</span><br><span class="line">      if (watch.split() &gt; 1_000_000_000L) &#123;&#x2F;&#x2F;记录执行时间超过1s的操作</span><br><span class="line">        ExecuteType type &#x3D; ctx.type();</span><br><span class="line">        StringBuffer sqlBuffer &#x3D; new StringBuffer();</span><br><span class="line">        if(type &#x3D;&#x3D; ExecuteType.BATCH) &#123;</span><br><span class="line">          for(Query query:ctx.batchQueries()) &#123;</span><br><span class="line">            sqlBuffer.append(query.toString()).append(&quot;\n&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">          sqlBuffer.append(ctx.query() &#x3D;&#x3D; null ? &quot;blank query &quot;:ctx.query().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        watch.splitInfo(String.format(&quot;Slow SQL query meta executed : [ %s ]&quot;,</span><br><span class="line">                                      sqlBuffer.toString() ));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;catch (Exception e) &#123;</span><br><span class="line">      logger.error(&quot; SlowQueryListener has occur,fix bug  &quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在初始化 DSLContext 的时候把SlowQueryListener配置进去，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dslContext.configuration()</span><br><span class="line">                .set(DefaultExecuteListenerProvider.providers(slowQueryListener));</span><br></pre></td></tr></table></figure><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p>数据库分库是生产环境中经常使用的方式，例如我们提供了一个新的<code>class</code>的库，复用了<code>student</code>表。如果我们要查询<code>class</code>库，还需要重新生成<code>class</code>的代码，那就太麻烦了。JOOQ提供了运行时替换库名的能力，使得在生产环境中使用多个分库变得很轻松。还以<code>student</code>的查询为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DSLContext dsl &#x3D; DSL.using(conn, SQLDialect.MYSQL);</span><br><span class="line">List&lt;Student&gt; list &#x3D; dslContext.selectFrom(STUDENT).fetch();</span><br></pre></td></tr></table></figure><p>对应的默认查询语句是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;id&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;stu_id&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;stu_name&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;age&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;class_id&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;class_name&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;result&#96;,</span><br><span class="line">&#96;test&#96;.&#96;student&#96;.&#96;time&#96;</span><br><span class="line">from &#96;test&#96;.&#96;student&#96;</span><br></pre></td></tr></table></figure><p>如果我们配置了动态替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Settings settings &#x3D;</span><br><span class="line">        new Settings().withRenderMapping(new RenderMapping().withSchemata(</span><br><span class="line">                new MappedSchema().withInput(&quot;test&quot;).withOutput(&quot;class&quot;)));</span><br><span class="line">DSLContext dsl &#x3D; DSL.using(dataSource, SQLDialect.MYSQL, settings);</span><br><span class="line">List&lt;Student&gt; list &#x3D; dsl.selectFrom(STUDENT).fetch();</span><br></pre></td></tr></table></figure><p>则生成的语句就变为<code>class</code>下的SQL了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;id&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;stu_id&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;stu_name&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;age&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;class_id&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;class_name&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;result&#96;,</span><br><span class="line">&#96;class&#96;.&#96;student&#96;.&#96;time&#96;</span><br><span class="line">from &#96;class&#96;.&#96;student&#96;</span><br></pre></td></tr></table></figure><p>JOOQ还支持多个Schema的动态替换，以及表名的动态替换，详见<a href="http://www.jooq.org/doc/latest/manual/sql-building/dsl-context/runtime-schema-mapping/">Runtime schema mapping</a></p><h3 id="复用数据库实例"><a href="#复用数据库实例" class="headerlink" title="复用数据库实例"></a>复用数据库实例</h3><p>因为JOOQ的SQL是带有Schema名称的，所以对同一个IP实例中的不同数据库，JOOQ可以方便的支持查询。</p><p>这在当多个数据库共用一个数据库实例的时候，很有用，可以复用数据源配置，从而不需要为每一个库创建一个连接池，减少数据库连接资源的占用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataSource &#x3D; ImmutableMap.&lt;String, HikariDataSource&gt;builder()</span><br><span class="line">        .put(&quot;DATABASE1&quot;, datasources1)</span><br><span class="line">        .put(&quot;DATABASE2&quot;, datasources1).build();</span><br></pre></td></tr></table></figure><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul><li><p>Spring： <a href="http://www.jooq.org/doc/3.8/manual-single-page/#jooq-with-spring">http://www.jooq.org/doc/3.8/manual-single-page/#jooq-with-spring</a></p></li><li><p>JOOQ：<a href="https://github.com/jOOQ/jOOQ/tree/master/jOOQ-examples/jOOQ-spring-guice-example">https://github.com/jOOQ/jOOQ/tree/master/jOOQ-examples/jOOQ-spring-guice-example</a></p></li></ul><h3 id="其他常用操作：Batch、Curser、Transaction"><a href="#其他常用操作：Batch、Curser、Transaction" class="headerlink" title="其他常用操作：Batch、Curser、Transaction"></a>其他常用操作：Batch、Curser、Transaction</h3><ul><li>Batch： <a href="http://www.jooq.org/doc/3.8/manual/sql-execution/batch-execution/">http://www.jooq.org/doc/3.8/manual/sql-execution/batch-execution/</a></li><li>游标 Curser： <a href="http://www.jooq.org/doc/3.8/manual/sql-execution/fetching/lazy-fetching/">http://www.jooq.org/doc/3.8/manual/sql-execution/fetching/lazy-fetching/</a></li><li>事务： <a href="http://www.jooq.org/doc/3.8/manual-single-page/#transaction-management">http://www.jooq.org/doc/3.8/manual-single-page/#transaction-management</a></li></ul><h3 id="其它运行时配置"><a href="#其它运行时配置" class="headerlink" title="其它运行时配置"></a>其它运行时配置</h3><p>JOOQ将一些不常用的配置，放在Settings对象类管理，例如</p><ul><li>是否使用乐观锁</li><li>是否打印JOOQ的SQL日志</li></ul><p>具体可以参考<a href="http://www.jooq.org/doc/3.8/manual/sql-building/dsl-context/custom-settings/">JOOQ文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是对之前一段时间学习Jooq的总结。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是对之前一段时间学习Jooq的总结。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是对之前一段时间学习Jooq的总结。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是对之前一段时间学习Jooq的总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。&quot;&gt;&lt;a href=&quot;#前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。&quot; class=&quot;headerlink&quot; title=&quot;前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。&quot;&gt;&lt;/a&gt;前言：相比较Hibernate、Mybatis等大家早已熟知的ORM框架来说，JOOQ只能算是一个弟弟。但它之所以能够脱颖而出，是因为它找到了正确的设计思想。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="ORM" scheme="https://www.blog.ajie39.top/categories/ORM/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="ORM" scheme="https://www.blog.ajie39.top/tags/ORM/"/>
    
    <category term="Jooq" scheme="https://www.blog.ajie39.top/tags/Jooq/"/>
    
  </entry>
  
  <entry>
    <title>Google Java编程风格规范（中文）</title>
    <link href="https://www.blog.ajie39.top/2020/02/14/Google%20Java%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2020/02/14/Google%20Java%20%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89/</id>
    <published>2020-02-14T00:09:15.341Z</published>
    <updated>2021-05-05T04:24:53.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这份文档是Google-Java编程风格规范的完整定义。"><a href="#摘要：这份文档是Google-Java编程风格规范的完整定义。" class="headerlink" title="摘要：这份文档是Google Java编程风格规范的完整定义。"></a>摘要：这份文档是Google Java编程风格规范的完整定义。</h1><hr><h1 id="前言：这份文档是Google-Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。"><a href="#前言：这份文档是Google-Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。" class="headerlink" title="前言：这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。"></a>前言：这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</h1><p>原文《Google Java Style》：<a href="https://google.github.io/styleguide/javaguide.html">https://google.github.io/styleguide/javaguide.html</a></p><p>January 20, 2014<br>作者：Hawstein<br>出处：<a href="http://hawstein.com/2014/01/20/google-java-style/">http://hawstein.com/2014/01/20/google-java-style/</a><br>声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0，转载请注明作者及出处。</p><hr><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>在本文档中，除非另有说明：</p><ol><li>术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface)。</li><li>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。</li></ol><p>其他的术语说明会偶尔在后面的文档出现。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式为UTF-8。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h4><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ol><li>所有其它字符串中的空白字符都要进行转义。</li><li>制表符不用于缩进。</li></ol><h4 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h4><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, &quot;, &#39;及\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p><h4 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h4><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p><p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String unitAbbrev &#x3D; &quot;μs&quot;;                                 | 赞，即使没有注释也非常清晰</span><br><span class="line">String unitAbbrev &#x3D; &quot;\u03bcs&quot;; &#x2F;&#x2F; &quot;μs&quot;                    | 允许，但没有理由要这样做</span><br><span class="line">String unitAbbrev &#x3D; &quot;\u03bcs&quot;; &#x2F;&#x2F; Greek letter mu, &quot;s&quot;    | 允许，但这样做显得笨拙还容易出错</span><br><span class="line">String unitAbbrev &#x3D; &quot;\u03bcs&quot;;                            | 很糟，读者根本看不出这是什么</span><br><span class="line">return &#39;\ufeff&#39; + content; &#x2F;&#x2F; byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释</span><br></pre></td></tr></table></figure><p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p><h2 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h2><p>一个源文件包含(按顺序地)：</p><ol><li>许可证或版权信息(如有需要)</li><li>package语句</li><li>import语句</li><li>一个顶级类(只有一个)</li></ol><p>以上每个部分之间用一个空行隔开。</p><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h3><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h3><h4 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h4><p>即，不要出现类似这样的import语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h4><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p><ol><li>所有的静态导入独立成组</li><li>com.google imports(仅当这个源文件是在com.google包下)</li><li>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun</li><li>java imports</li><li>javax imports</li></ol><p>组内不空行，按字典序排列。</p><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p><p>例外：package-info.java，该文件中可没有package-info类。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h4 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h4><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h4><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">return new MyClass() &#123;</span><br><span class="line">  @Override public void method() &#123;</span><br><span class="line">    if (condition()) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        something();</span><br><span class="line">      &#125; catch (ProblemException e) &#123;</span><br><span class="line">        recover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在4.8.1节给出了enum类的一些例外。</p><h4 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h4><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void doNothing() &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h3><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每个语句后要换行。</p><h3 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h3><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p><p>例外：</p><ol><li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li><li>package和import语句(见3.2节和3.3节)。</li><li>注释中那些可能被剪切并粘贴到shell中的命令行。</li></ol><h3 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h3><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p><p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p><h4 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h4><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p><ol><li>如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（&lt;T extends Foo &amp; Bar&gt;)，catch块中的管道符号(catch (FooException | BarException e)</li><li>如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。</li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(,)与其前面的内容留在同一行。</li></ol><h4 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>在4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用一个空行：</p><ol><li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul><li>例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li></ul></li><li>在函数体内，语句的逻辑分组间使用空行。</li><li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li><li>要满足本文档中其他节的空行要求(比如3.3节：import语句)</li></ol><p>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</p><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p><ol><li>分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。</li><li>分隔任何保留字与其前面的右大括号(})(如else, catch)。</li><li>在任何左大括号前({)，两个例外：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. @SomeAnnotation(&#123;a, b&#125;)(不使用空格)。</span><br><span class="line"></span><br><span class="line">2. String[][] x &#x3D; foo;(大括号间没有空格，见下面的Note)。</span><br></pre></td></tr></table></figure><p>  4.在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 类型界限中的&amp;(&lt;T extends Foo &amp; Bar&gt;)。</span><br><span class="line"></span><br><span class="line">2. catch块中的管道符号(catch (FooException | BarException e)。</span><br><span class="line"></span><br><span class="line">3. foreach语句中的分号。</span><br></pre></td></tr></table></figure><ol start="5"><li>在, : ;及右括号())后。</li><li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li><li>类型和变量之间：List list。</li><li>数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。</li></ol><p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><p>术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p><p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p><p>以下示例先展示未对齐的代码，然后是对齐的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private int x; &#x2F;&#x2F; this is fine</span><br><span class="line">private Color color; &#x2F;&#x2F; this too</span><br><span class="line"></span><br><span class="line">private int   x;      &#x2F;&#x2F; permitted, but future edits</span><br><span class="line">private Color color;  &#x2F;&#x2F; may leave it unaligned</span><br></pre></td></tr></table></figure><p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p><h3 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h3><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p><h3 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h3><h4 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h4><p>枚举常量间用逗号隔开，换行可选。</p><p>没有方法和文档的枚举类可写成数组初始化的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h5><p>不要使用组合声明，比如int a, b;。</p><h5 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new int[] &#123;</span><br><span class="line">  0, 1, 2, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[] &#123;</span><br><span class="line">  0,</span><br><span class="line">  1,</span><br><span class="line">  2,</span><br><span class="line">  3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[] &#123;</span><br><span class="line">  0, 1,</span><br><span class="line">  2, 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new int[]&#123;0, 1, 2, 3&#125;</span><br></pre></td></tr></table></figure><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：String[] args， 而非String args[]。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p>术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p><p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p><h5 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h5><p>在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch (input) &#123;</span><br><span class="line">  case 1:</span><br><span class="line">  case 2:</span><br><span class="line">    prepareOneOrTwo();</span><br><span class="line">    &#x2F;&#x2F; fall through</span><br><span class="line">  case 3:</span><br><span class="line">    handleOneTwoOrThree();</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h5><p>每个switch语句都包含一个default语句组，即使它什么代码也不包含。</p><h4 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h4><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public String getNameIfPresent() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Override public int hashCode() &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Partial @Mock DataLoader loader;</span><br></pre></td></tr></table></figure><p>参数和局部变量注解没有特定规则。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">块注释与其周围的代码在同一缩进级别。它们可以是&#x2F;* ... *&#x2F;风格，也可以是&#x2F;&#x2F; ...风格。对于多行的&#x2F;* ... *&#x2F;注释，后续行必须从*开始， 并且与前一行的*对齐。以下示例注释都是OK的。</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * This is</span><br><span class="line"> * okay.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* Or you can</span><br><span class="line"> * even do this. *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; And so</span><br></pre></td></tr></table></figure><p>注释不要封闭在由星号或其它字符绘制的框架里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 &#x2F;* ... *&#x2F;。</span><br></pre></td></tr></table></figure><h4 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h4><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public protected private abstract static final transient volatile synchronized native strictfp</span><br></pre></td></tr></table></figure><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以UpperCamelCase风格编写。</p><p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以lowerCamelCase风格编写。</p><p>方法名通常是动词或动词短语。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test&lt;MethodUnderTest&gt;_&lt;state&gt;，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p><p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Constants</span><br><span class="line">static final int NUMBER &#x3D; 5;</span><br><span class="line">static final ImmutableList&lt;String&gt; NAMES &#x3D; ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);</span><br><span class="line">static final Joiner COMMA_JOINER &#x3D; Joiner.on(&#39;,&#39;);  &#x2F;&#x2F; because Joiner is immutable</span><br><span class="line">static final SomeMutableType[] EMPTY_ARRAY &#x3D; &#123;&#125;;</span><br><span class="line">enum SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Not constants</span><br><span class="line">static String nonFinal &#x3D; &quot;non-final&quot;;</span><br><span class="line">final String nonStatic &#x3D; &quot;non-static&quot;;</span><br><span class="line">static final Set&lt;String&gt; mutableCollection &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">static final ImmutableSet&lt;SomeMutableType&gt; mutableElements &#x3D; ImmutableSet.of(mutable);</span><br><span class="line">static final Logger logger &#x3D; Logger.getLogger(MyClass.getName());</span><br><span class="line">static final String[] nonEmptyArray &#x3D; &#123;&quot;these&quot;, &quot;can&quot;, &quot;change&quot;&#125;;</span><br></pre></td></tr></table></figure><p>这些名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以lowerCamelCase风格编写。</p><p>这些名字通常是名词或名词短语。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以lowerCamelCase风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p><p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p><p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p>驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ol><li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Prose form                Correct               Incorrect</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest</span><br><span class="line">&quot;new customer ID&quot;         newCustomerId         newCustomerID</span><br><span class="line">&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch</span><br><span class="line">&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS</span><br><span class="line">&quot;YouTube importer&quot;        YouTubeImporter</span><br><span class="line">                          YoutubeImporter*</span><br></pre></td></tr></table></figure><p>加星号处表示可以，但不推荐。</p><p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。</p><h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><h3 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 /@Override：能用则用"></a>6.1 /@Override：能用则用</h3><p>只要是合法的，就把@Override注解给用上。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)</p><p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  int i &#x3D; Integer.parseInt(response);</span><br><span class="line">  return handleNumericResponse(i);</span><br><span class="line">&#125; catch (NumberFormatException ok) &#123;</span><br><span class="line">  &#x2F;&#x2F; it&#39;s not numeric; that&#39;s fine, just continue</span><br><span class="line">&#125;</span><br><span class="line">return handleTextResponse(response);</span><br></pre></td></tr></table></figure><p>例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  emptyStack.pop();</span><br><span class="line">  fail();</span><br><span class="line">&#125; catch (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h3><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo &#x3D; ...;</span><br><span class="line">Foo.aStaticMethod(); &#x2F;&#x2F; good</span><br><span class="line">aFoo.aStaticMethod(); &#x2F;&#x2F; bad</span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); &#x2F;&#x2F; very bad</span><br></pre></td></tr></table></figure><h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h3><p>极少会去重写Object.finalize。</p><p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解 Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。</p><h2 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p>Javadoc块的基本格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Multiple lines of Javadoc text are written here,</span><br><span class="line"> * wrapped normally...</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int method(String p1) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>或者是以下单行形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** An especially short bit of Javadoc. *&#x2F;</span><br></pre></td></tr></table></figure><p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签&lt;p&gt;，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的Javadoc标记按以下顺序出现：@param, @return, @throws,<br>@deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p><h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a…或This method returns…开头, 它也不会是一个完整的祈使句，如Save the record…。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tip：一个常见的错误是把简单的Javadoc写成&#x2F;** @return the customer ID *&#x2F;，这是不正确的。它应该写成&#x2F;** Returns the customer ID. *&#x2F;。</span><br></pre></td></tr></table></figure><h3 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h3><p>至少在每个public类及它的每个 public 和 protected 成员处使用 Javadoc，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 getCanonicalName ， 就不应该忽视文档说明，因为读者很可能不知道词语 canonical name 指的是什么。</p><h4 id="7-3-2-例外：重写"><a href="#7-3-2-例外：重写" class="headerlink" title="7.3.2 例外：重写"></a>7.3.2 例外：重写</h4><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这份文档是Google-Java编程风格规范的完整定义。&quot;&gt;&lt;a href=&quot;#摘要：这份文档是Google-Java编程风格规范的完整定义。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这份文档是Google Java编程风格规范的完整定义。&quot;&gt;&lt;/a&gt;摘要：这份文档是Google Java编程风格规范的完整定义。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：这份文档是Google-Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。&quot;&gt;&lt;a href=&quot;#前言：这份文档是Google-Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。&quot; class=&quot;headerlink&quot; title=&quot;前言：这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。&quot;&gt;&lt;/a&gt;前言：这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则，我们才认为它符合Google的Java编程风格。与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。&lt;/h1&gt;&lt;p&gt;原文《Google Java Style》：&lt;a href=&quot;https://google.github.io/styleguide/javaguide.html&quot;&gt;https://google.github.io/styleguide/javaguide.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;January 20, 2014&lt;br&gt;作者：Hawstein&lt;br&gt;出处：&lt;a href=&quot;http://hawstein.com/2014/01/20/google-java-style/&quot;&gt;http://hawstein.com/2014/01/20/google-java-style/&lt;/a&gt;&lt;br&gt;声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0，转载请注明作者及出处。&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="编程规范" scheme="https://www.blog.ajie39.top/categories/Java/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>架构图</title>
    <link href="https://www.blog.ajie39.top/2020/01/05/%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
    <id>https://www.blog.ajie39.top/2020/01/05/%E6%9E%B6%E6%9E%84%E5%9B%BE/</id>
    <published>2020-01-05T14:35:18.623Z</published>
    <updated>2021-05-01T13:09:43.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：架构图汇总。"><a href="#摘要：架构图汇总。" class="headerlink" title="摘要：架构图汇总。"></a>摘要：架构图汇总。</h1><hr><h1 id="前言：架构图汇总。"><a href="#前言：架构图汇总。" class="headerlink" title="前言：架构图汇总。"></a>前言：架构图汇总。</h1><hr><p><img src="/blog/22/1.png" alt="NLP总体架构图"></p><p><img src="/blog/22/2.png" alt="大数据总体架构图"></p><p><img src="/blog/22/3.png" alt="知识图谱总体架构图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要：架构图汇总。&quot;&gt;&lt;a href=&quot;#摘要：架构图汇总。&quot; class=&quot;headerlink&quot; title=&quot;摘要：架构图汇总。&quot;&gt;&lt;/a&gt;摘要：架构图汇总。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：架构图汇总。&quot;&gt;&lt;a href=&quot;#前言：架构图汇总。&quot; </summary>
      
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    <category term="架构图" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/%E6%9E%B6%E6%9E%84%E5%9B%BE/"/>
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习lambda表达式</title>
    <link href="https://www.blog.ajie39.top/2019/12/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://www.blog.ajie39.top/2019/12/03/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-12-03T11:18:52.686Z</published>
    <updated>2021-05-05T04:23:53.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。"><a href="#摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。" class="headerlink" title="摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。"></a>摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。</h1><hr><h1 id="前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。"><a href="#前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。" class="headerlink" title="前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。"></a>前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。</h1><hr><span id="more"></span><h2 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h2><p>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口。lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。Lambda表达式还增强了集合库。</p><p>Java Lambda表达式的一个重要用法是简化某些匿名内部类（Anonymous Classes）的写法。实际上Lambda表达式并不仅仅是匿名内部类的语法糖，JVM内部是通过invokedynamic指令来实现Lambda表达式的。</p><h2 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h2><p>Lambda 表达式在 Java 语言中引入了一个新的语法元素和操作符。这个操作符为 “-&gt;”，该操作符被称 为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分：</p><ul><li>左侧： 指定了 Lambda 表达式需要的所有参数</li><li>右侧： 指定了 Lambda 体，即 Lambda 表达式要执行的功能。</li></ul><ol><li><p>语法格式一：无参，无返回值，Lambda 体只需一条语句。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      示例：</span><br><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello Lambda!&quot;);</span><br></pre></td></tr></table></figure></li><li><p>语法格式二：Lambda 需要一个参数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">  Consumer&lt;String&gt; con &#x3D; （x） -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure></li><li><p>语法格式三：Lambda 只需要一个参数时，参数的小括号可以省略。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      示例：</span><br><span class="line">Consumer&lt;String&gt; con &#x3D; x -&gt; System.out.println(x);</span><br></pre></td></tr></table></figure></li><li><p>语法格式四：Lambda 需要两个参数，并且有返回值。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">   Comparator&lt;Integer&gt; com &#x3D; (x, y) -&gt; &#123;</span><br><span class="line">      System.out.println(&quot;函数式接口&quot;);</span><br><span class="line">      return Integer.compare(x, y);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li><li><p>语法格式五：当 Lambda 体只有一条语句时，return 与大括号可以省略。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">  Comparator&lt;Integer&gt; com &#x3D; (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure></li><li><p>Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">  Comparator&lt;Integer&gt; com &#x3D; (Integer x,Integer y) -&gt; &#123;  &#x2F;&#x2F;Integer 类型可以省略</span><br><span class="line">     System.out.println(&quot;函数式接口&quot;);</span><br><span class="line">     return Integer.compare(x, y);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  BinaryOperator&lt;Long&gt; add &#x3D; (Long x, Long y) -&gt; x + y;&#x2F;&#x2F; 4</span><br><span class="line"></span><br><span class="line">  BinaryOperator&lt;Long&gt; addImplicit &#x3D; (x, y) -&gt; x + y;&#x2F;&#x2F; 5 类型推断</span><br></pre></td></tr></table></figure></li></ol><p>类型推断：Lambda 表达式中的参数类型都是由编译器推断 得出的。 Lambda 表达式中无需指定类型，程序依然可 以编译，这是因为 javac 根据程序的上下文，在后台 推断出了参数的类型。 Lambda 表达式的类型依赖于上 下文环境，是由编译器推断出来的。这就是所谓的 “类型推断”</p><h2 id="使用Lambda表达式的要求"><a href="#使用Lambda表达式的要求" class="headerlink" title="使用Lambda表达式的要求"></a>使用Lambda表达式的要求</h2><p>也许你已经想到了，能够使用Lambda的依据是必须有相应的 <strong>函数接口</strong>。</p><p>函数接口，是指内部只有一个抽象方法的接口。这一点跟Java是强类型语言吻合，也就是说你并不能在代码的任何地方任性的写Lambda表达式。实际上Lambda的类型就是对应函数接口的类型。Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名。</p><h2 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h2><p>自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义函数接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface ConsumerInterface&lt;T&gt;&#123;</span><br><span class="line">void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override标注会检查是否重载了函数一样。有了上述接口定义，就可以写出类似如下的代码：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConsumerInterface&lt;String&gt; consumer &#x3D; str -&gt; System.out.println(str);</span><br><span class="line">consumer.accept(&quot;我是自定义函数式接口&quot;);</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">详细例子参考：</span><br><span class="line">  import java.util.Arrays;</span><br><span class="line">  import java.util.List;</span><br><span class="line"></span><br><span class="line">  public class Test &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          TestStream&lt;String&gt; stream &#x3D; new TestStream&lt;String&gt;();</span><br><span class="line">          List list &#x3D; Arrays.asList(&quot;11&quot;, &quot;22&quot;, &quot;33&quot;);</span><br><span class="line">          stream.setList(list);</span><br><span class="line">          stream.myForEach(str -&gt; System.out.println(str));&#x2F;&#x2F; 使用自定义函数接口书写Lambda表达式</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @FunctionalInterface</span><br><span class="line">  interface ConsumerInterface&lt;T&gt;&#123;</span><br><span class="line">      void accept(T t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class TestStream&lt;T&gt;&#123;</span><br><span class="line">      private List&lt;T&gt; list;</span><br><span class="line">      public void myForEach(ConsumerInterface&lt;T&gt; consumer)&#123;&#x2F;&#x2F; 1</span><br><span class="line">          for(T t : list)&#123;</span><br><span class="line">              consumer.accept(t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void setList(List&lt;T&gt; list) &#123;</span><br><span class="line">          this.list &#x3D; list;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Java-内置四大核心函数式接口"><a href="#Java-内置四大核心函数式接口" class="headerlink" title="Java 内置四大核心函数式接口"></a>Java 内置四大核心函数式接口</h2><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>Consumer&lt;T&gt;  消费型接口</td><td>T</td><td>void</td><td>对类型为T的对象应用操作，包含方法：void accept(T t);</td></tr><tr><td>Supplier&lt;T&gt;  供给型接口</td><td>无</td><td>T</td><td>返回类型为T的对象，包含方法：T get();</td></tr><tr><td>Function&lt;T, R&gt;  函数型接口</td><td>T</td><td>R</td><td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t);</td></tr><tr><td>Predicate&lt;T&gt;  断定型接口</td><td>T</td><td>boolean</td><td>确定类型为T的对象是否满足某约束，并返回boolean值。包含方法boolean test(T t);</td></tr></tbody></table><h3 id="Consumer-lt-T-gt-消费型接口"><a href="#Consumer-lt-T-gt-消费型接口" class="headerlink" title="Consumer&lt;T&gt;  消费型接口"></a>Consumer&lt;T&gt;  消费型接口</h3><p>  void accept(T t);</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    hello(&quot;张三&quot;, (m) -&gt; System.out.println(&quot;你好：&quot; + m));</span><br><span class="line">&#125;</span><br><span class="line">public void hello(String st, Consumer&lt;String&gt; con)&#123;</span><br><span class="line">    con.accept(st);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Supplier-lt-T-gt-供给型接口"><a href="#Supplier-lt-T-gt-供给型接口" class="headerlink" title="Supplier&lt;T&gt; 供给型接口"></a>Supplier&lt;T&gt; 供给型接口</h3><p>  T get();</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Supplier&lt;T&gt; 供给型接口 :</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    List list &#x3D; Arrays.asList(121, 1231, 455, 56, 67,78);</span><br><span class="line">    List&lt;Integer&gt; numList &#x3D; getNumList(1, () -&gt; (int)(Math.random() * 100));</span><br><span class="line">    for (Integer num : numList) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;需求：产生指定个数的整数，并放入集合中</span><br><span class="line">public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123;</span><br><span class="line">    List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">        Integer n &#x3D; sup.get();</span><br><span class="line">        list.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function-lt-T-R-gt-函数型接口"><a href="#Function-lt-T-R-gt-函数型接口" class="headerlink" title="Function&lt;T, R&gt; 函数型接口"></a>Function&lt;T, R&gt; 函数型接口</h3><p>  R apply(T t);</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Function&lt;T, R&gt; 函数型接口：</span><br><span class="line">@Test</span><br><span class="line">public void test3()&#123;</span><br><span class="line">    String newStr &#x3D; strHandler(&quot;\t\t\t 这是一个函数型接口 &quot;, (str) -&gt; str.trim());</span><br><span class="line">    System.out.println(newStr);</span><br><span class="line">    String subStr &#x3D; strHandler(&quot;这是一个函数型接口&quot;, (str) -&gt; str.substring(4, 7));</span><br><span class="line">    System.out.println(subStr);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;需求：用于处理字符串</span><br><span class="line">public String strHandler(String str, Function&lt;String, String&gt; fun)&#123;</span><br><span class="line">    return fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate-lt-T-gt-断定型接口"><a href="#Predicate-lt-T-gt-断定型接口" class="headerlink" title="Predicate&lt;T&gt; 断定型接口"></a>Predicate&lt;T&gt; 断定型接口</h3><p>  boolean test(T t);</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Predicate&lt;T&gt; 断言型接口：</span><br><span class="line">@Test</span><br><span class="line">public void test4()&#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;Hello&quot;, &quot;Java8&quot;, &quot;Lambda&quot;, &quot;www&quot;, &quot;ok&quot;);</span><br><span class="line">    List&lt;String&gt; strList &#x3D; filterStr(list, (s) -&gt; s.length() &gt; 3);</span><br><span class="line">    for (String str : strList) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;需求：将满足条件的字符串，放入集合中</span><br><span class="line">public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        if(pre.test(str))&#123;</span><br><span class="line">            strList.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return strList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h3><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>BiFunction&lt;T, U, R&gt;</td><td>T,U</td><td>R</td><td>对类型为 T，U 参数应用操作，返回 R 类型的结果。包含方法为R apply(T t, U u);</td></tr><tr><td>UnaryOperator&lt;T&gt; (Function子接口)</td><td>T</td><td>T</td><td>对类型为 T 的对象进行一元运算，并返回 T 类型的结果。包含方法为 T apply(T t);</td></tr><tr><td>BinaryOperator&lt;T&gt;  (BiFunction子接口)</td><td>T,T</td><td>T</td><td>对类型为T的对象进行二元运算，并返回 T 类型的结果。包含方法为 T apply(T t1, T t2);</td></tr><tr><td>BiConsumer&lt;T, U&gt;</td><td>T,U</td><td>void</td><td>对类型为T，U参数应用操作。包含方法为 void accept(T t, U u)</td></tr><tr><td>ToIntFunction&lt;T&gt; <br> ToLongFunction&lt;T&gt; <br> ToDoubleFunction&lt;T&gt; <br></td><td>T</td><td>int <br> long <br> double</td><td>分别计算int、long、double值的函数</td></tr><tr><td>IntFunction&lt;R&gt; <br> LongFunction&lt;R&gt; <br> DoubleFunction&lt;R&gt; <br></td><td>int <br> long <br> double</td><td>R</td><td>参数分别为int、long、double类型的函数</td></tr></tbody></table><h2 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h2><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>当要传递给Lambda体内的操作，已经有实现的方法了，就可以使用方法引用了！</p><p>方法引用使用的前提条件是什么呢？</p><ul><li>方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表相同（完全一致）。</li><li>方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值相同（完全一致）。</li></ul><p>方法引用一般有三种格式：</p><ul><li>实例对象名::实例方法名</li><li>类名::静态方法名</li><li>类名::实例方法名</li></ul><p>注意：</p><ul><li>2和3的区别：若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： 类名::实例方法名。</li></ul><p>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。</p><h4 id="1、对象-实例方法"><a href="#1、对象-实例方法" class="headerlink" title="1、对象::实例方法"></a>1、对象::实例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1()&#123;</span><br><span class="line">    PrintStream ps &#x3D; System.out;</span><br><span class="line">    Consumer&lt;String&gt; con &#x3D; (str) -&gt; ps.println(str);</span><br><span class="line">    con.accept(&quot;Hello World！&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;--------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">    Consumer&lt;String&gt; con2 &#x3D; ps::println;</span><br><span class="line">    con2.accept(&quot;Hello Java8！&quot;);</span><br><span class="line"></span><br><span class="line">    Consumer&lt;String&gt; con3 &#x3D; System.out::println;</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    Employee emp &#x3D; new Employee(1, &quot;张三&quot;, 18, 5112.99);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;String&gt; sup &#x3D; () -&gt; emp.getName();</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">    Employee emp1 &#x3D; new Employee(2, &quot;李四&quot;, 18, 5112.99);</span><br><span class="line">    Supplier&lt;String&gt; sup2 &#x3D; emp1::getName;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、类-静态方法"><a href="#2、类-静态方法" class="headerlink" title="2、类::静态方法"></a>2、类::静态方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test3()&#123;</span><br><span class="line">    BiFunction&lt;Double, Double, Double&gt; fun &#x3D; (x, y) -&gt; Math.max(x, y);</span><br><span class="line">    System.out.println(fun.apply(1.5, 22.2));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;--------------------------------------------------&quot;);</span><br><span class="line">    BiFunction&lt;Double, Double, Double&gt; fun2 &#x3D; Math::max;</span><br><span class="line">    System.out.println(fun2.apply(1.2, 1.5));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test4()&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com &#x3D; (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">    System.out.println(com.compare(3,9));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-------------------------------------&quot;);</span><br><span class="line">    Comparator&lt;Integer&gt; com2 &#x3D; Integer::compare;</span><br><span class="line">    System.out.println(com2.compare(3,9));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、类-实例方法"><a href="#3、类-实例方法" class="headerlink" title="3、类::实例方法"></a>3、类::实例方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test5()&#123;</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp &#x3D; (x, y) -&gt; x.equals(y);</span><br><span class="line">    System.out.println(bp.test(&quot;abcde&quot;, &quot;abcde&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp2 &#x3D; String::equals;</span><br><span class="line">    System.out.println(bp2.test(&quot;abc&quot;, &quot;abc&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    Function&lt;Employee, String&gt; fun &#x3D; (e) -&gt; e.show();</span><br><span class="line">    System.out.println(fun.apply(new Employee()));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    Function&lt;Employee, String&gt; fun2 &#x3D; Employee::show;</span><br><span class="line">    System.out.println(fun2.apply(new Employee()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器使用的前提是什么？</p><ul><li>构造器参数列表要与接口中抽象方法的参数列表一致！</li></ul><p>语法格式：</p><ul><li>类名 :: new</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Employee类中必须有一个 Employee(String name, int age) 的构造器</span><br><span class="line">BiConsumer&lt;String, Integer&gt; biConsumer &#x3D; Employee :: new;</span><br><span class="line">biConsumer.accept(&quot;王五&quot;, 19);</span><br></pre></td></tr></table></figure><h4 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h4><p>数组引用和构造引用基本相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test10()&#123;</span><br><span class="line">    &#x2F;&#x2F;传统Lambda实现</span><br><span class="line">    Function&lt;Integer,int[]&gt; function &#x3D; (i) -&gt; new int[i];</span><br><span class="line">    int[] apply &#x3D; function.apply(10);</span><br><span class="line">    System.out.println(apply.length); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;数组类型引用实现</span><br><span class="line">    function &#x3D; int[] ::new;</span><br><span class="line">    apply &#x3D; function.apply(100);</span><br><span class="line">    System.out.println(apply.length); &#x2F;&#x2F; 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collections中的常用函数接口"><a href="#Collections中的常用函数接口" class="headerlink" title="Collections中的常用函数接口"></a>Collections中的常用函数接口</h2><p>Java8新增了java.util.funcion包，里面包含常用的函数接口，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。</p><p>Java集合框架的接口继承结构:</p><p><img src="/blog/21/1.png" alt="Java集合框架的接口继承结构"></p><p>上图中绿色标注的接口类，表示在Java8中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。</p><table><thead><tr><th>接口名</th><th>Java8新加入的方法</th></tr></thead><tbody><tr><td>Collection</td><td>removeIf() spliterator() stream() parallelStream() forEach()</td></tr><tr><td>List</td><td>replaceAll() sort()</td></tr><tr><td>Map</td><td>getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td></tr></tbody></table><p>这些新加入的方法大部分要用到java.util.function包下的接口，这意味着这些方法大部分都跟Lambda表达式相关。</p><h3 id="Collection中的新方法"><a href="#Collection中的新方法" class="headerlink" title="Collection中的新方法"></a>Collection中的新方法</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法的签名为void forEach(Consumer&lt;? super E&gt; action)，作用是对容器中的每个元素执行action指定的动作，其中Consumer是个函数接口，里面只有一个待实现方法void accept(T t)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.forEach(new Consumer&lt;Integer&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer)&#123;</span><br><span class="line">        if(integer % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.forEach((s) -&gt; &#123;</span><br><span class="line">    if (s % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h4><p>该方法签名为boolean removeIf(Predicate&lt;? super E&gt; filter)，作用是删除容器中所有满足filter指定条件的元素，其中Predicate是一个函数接口，里面只有一个待实现方法boolean test(T t)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.removeIf(new Predicate&lt;Integer&gt;()&#123; &#x2F;&#x2F; 删除长度大于3的元素</span><br><span class="line">    @Override</span><br><span class="line">    public boolean test(Integer sum)&#123;</span><br><span class="line">        return sum % 3 &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.removeIf(s -&gt; s % 3 &#x3D;&#x3D; 0);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为void replaceAll(UnaryOperator&lt;E&gt; operator)，作用是对每个元素执行operator指定的操作，并用操作结果来替换原来的元素。其中UnaryOperator是一个函数接口，里面只有一个待实现函数T apply(T t)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.replaceAll(new UnaryOperator&lt;Integer&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Integer apply(Integer sum)&#123;</span><br><span class="line">        if(sum % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return ++sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return --sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(3, 6, 9, 10));</span><br><span class="line">list.replaceAll(sum -&gt; &#123;</span><br><span class="line">    if (sum % 3 &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return ++sum;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return --sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>该方法定义在List接口中，方法签名为void sort(Comparator&lt;? super E&gt; c)，该方法根据c指定的比较规则对容器元素进行排序。Comparator接口我们并不陌生，其中有一个方法int compare(T o1, T o2)需要实现，显然该接口是个函数接口。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(6, 10, 9, 3));</span><br><span class="line">Collections.sort(list, new Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Integer sum1, Integer sum2)&#123;</span><br><span class="line">        return sum1 - sum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(6, 10, 9, 3));</span><br><span class="line">System.out.println(list);</span><br><span class="line">list.sort((sum1, sum2) -&gt; sum1 - sum2);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="spliterator"><a href="#spliterator" class="headerlink" title="spliterator()"></a>spliterator()</h4><p>方法签名为Spliterator&lt;E&gt; spliterator()，该方法返回容器的可拆分迭代器。从名字来看该方法跟iterator()方法有点像，我们知道Iterator是用来迭代容器的，Spliterator也有类似作用，但二者有如下不同：</p><p>Spliterator既可以像Iterator那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。<br>Spliterator是可拆分的，一个Spliterator可以通过调用Spliterator<T> trySplit()方法来尝试分成两个。一个是this，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。<br>可通过（多次）调用Spliterator.trySplit()方法来分解负载，以便多线程处理。</p><h4 id="stream-和parallelStream"><a href="#stream-和parallelStream" class="headerlink" title="stream()和parallelStream()"></a>stream()和parallelStream()</h4><p>stream()和parallelStream()分别返回该容器的Stream视图表示，不同之处在于parallelStream()返回并行的Stream。Stream是Java函数式编程的核心类，具体内容后面单独介绍。</p><h3 id="Map中的新方法"><a href="#Map中的新方法" class="headerlink" title="Map中的新方法"></a>Map中的新方法</h3><h4 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法签名为void forEach(BiConsumer&lt;? super K,? super V&gt; action)，作用是对Map中的每个映射执行action指定的操作，其中BiConsumer是一个函数接口，里面有一个待实现方法void accept(T t, U u)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">map.forEach(new BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer key, String value)&#123;</span><br><span class="line">        System.out.println(key + &quot;&#x3D;&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><h4 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault()"></a>getOrDefault()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为V getOrDefault(Object key, V defaultValue)，作用是按照给定的key查询Map中对应的value，如果没有找到则返回defaultValue。使用该方法可以省去查询指定键值是否存在的麻烦。</p><p>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">&#x2F;&#x2F; Java7以及之前做法</span><br><span class="line">if(map.containsKey(4))&#123;</span><br><span class="line">    System.out.println(map.get(4));</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    System.out.println(&quot;NoValue&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Java8使用Map.getOrDefault()</span><br><span class="line">System.out.println(map.getOrDefault(4, &quot;NoValue&quot;));</span><br></pre></td></tr></table></figure><h4 id="putIfAbsent"><a href="#putIfAbsent" class="headerlink" title="putIfAbsent()"></a>putIfAbsent()</h4><p>该方法跟Lambda表达式没关系，但是很有用。方法签名为V putIfAbsent(K key, V value)，作用是只有在不存在key值的映射或映射值为null时，才将value指定的值放入到Map中，否则不对Map做更改．该方法将条件判断和赋值合二为一，使用起来更加方便。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>我们都知道Map中有一个remove(Object key)方法，来根据指定key值删除Map中的映射关系；Java8新增了remove(Object key, Object value)方法，只有在当前Map中key正好映射到value时才删除该映射，否则什么也不做。</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>在Java7及以前，要想替换Map中的映射关系可通过put(K key, V value)方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在Map中加入了两个replace()方法，分别如下：</p><ul><li>replace(K key, V value)，只有在当前Map中key的映射存在时才用value去替换原来的值，否则什么也不做。</li><li>replace(K key, V oldValue, V newValue)，只有在当前Map中key的映射存在且等于oldValue时才用newValue去替换原来的值，否则什么也不做。</li></ul><h4 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)，作用是对Map中的每个映射执行function指定的操作，并用function的执行结果替换原来的value，其中BiFunction是一个函数接口，里面有一个待实现方法R apply(T t, U u)。</p><p>匿名内部类实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">map.replaceAll(new BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String apply(Integer k, String v)&#123;</span><br><span class="line">        if (v.equals(&quot;我&quot;))&#123;</span><br><span class="line">            v &#x3D; &quot;你&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><p>lambda表达式实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line">map.replaceAll((k, v) -&gt; &#123;</span><br><span class="line">    if (v.equals(&quot;我&quot;))&#123;</span><br><span class="line">        v &#x3D; &quot;你&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return v.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>该方法签名为merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)。</p><p>作用是：</p><ul><li>如果Map中key对应的映射不存在或者为null，则将value（不能是null）关联到key上；</li><li>否则执行remappingFunction，如果执行结果非null则用该结果跟key关联，否则在Map中删除key的映射。</li></ul><p>  参数中BiFunction函数接口前面已经介绍过，里面有一个待实现方法R apply(T t, U u)。</p><p>merge()方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line"></span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br><span class="line">map.merge(1, &quot;和你&quot;, (v1, v2) -&gt; v1+v2);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><h4 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h4><p>该方法签名为compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)，作用是把remappingFunction的计算结果关联到key上，如果计算结果为null，则在Map中删除key的映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">map.put(1, &quot;我&quot;);</span><br><span class="line">map.put(2, &quot;拒绝&quot;);</span><br><span class="line">map.put(3, &quot;996&quot;);</span><br><span class="line"></span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br><span class="line">map.compute(1, (k,v) -&gt; v &#x3D;&#x3D; null ? &quot;值为空&quot; : v.concat(&quot;和你&quot;));</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + &quot;&#x3D;&quot; + value));</span><br></pre></td></tr></table></figure><h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h4><p>该方法签名为V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)，作用是：只有在当前Map中不存在key值的映射或映射值为null时，才调用mappingFunction，并在mappingFunction执行结果非null时，将结果跟key关联。</p><p>Function是一个函数接口，里面有一个待实现方法R apply(T t)。</p><p>computeIfAbsent()常用来对Map的某个key值建立初始化映射．比如我们要实现一个多值映射，Map的定义可能是Map&lt;K,Set&lt;V&gt;&gt;，要向Map中放入新值，可通过如下代码实现：</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// Java7及以前的实现方式</span></span><br><span class="line"><span class="keyword">if</span>(map.containsKey(<span class="number">1</span>))&#123;</span><br><span class="line">    map.get(<span class="number">1</span>).add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Set&lt;String&gt; valueSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    valueSet.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, valueSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8的实现方式</span></span><br><span class="line">map.computeIfAbsent(<span class="number">1</span>, v -&gt; <span class="keyword">new</span> HashSet&lt;String&gt;()).add(<span class="string">&quot;345&quot;</span>);</span><br><span class="line">map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;=&quot;</span> + value));</span><br></pre></td></tr></table></figure><p>使用computeIfAbsent()将条件判断和添加操作合二为一，使代码更加简洁。</p><h4 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h4><p>该方法签名为V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)，作用跟computeIfAbsent()相反。即只有在当前Map中存在key值的映射且非null时，才调用remappingFunction，如果remappingFunction执行结果为null，则删除key的映射，否则使用该结果替换key原来的映射。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>对于Java 7来说stream完全是个陌生东西，stream并不是某种数据结构，它只是数据源的一种视图。这里的数据源可以是一个数组，Java容器或I/O channel等。</p><p>常见的stream接口继承关系如图：</p><p><img src="/blog/21/2.png" alt="Java集合框架的接口继承结构"></p><p>图中4种stream接口继承自BaseStream，其中IntStream, LongStream, DoubleStream对应三种基本类型（int, long, double，注意不是包装类型），Stream对应所有剩余类型的stream视图。</p><p>为不同数据类型设置不同stream接口，可以:</p><ol><li>提高性能</li><li>增加特定接口函数。</li></ol><p>为什么不把IntStream等设计成Stream的子接口？</p><p>答案是这些方法的名字虽然相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，因为Java不允许只有返回类型不同的方法重载。</p><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p><ul><li>无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li><li>为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li><li>惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li>可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><p>对stream的操作分为为两类，中间操作(intermediate operations)和结束操作(terminal operations)，二者特点是：</p><ul><li>中间操作总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li><li>结束操作会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li></ul><p>下表汇总了Stream接口的部分常见方法：</p><table><thead><tr><th>操作类型</th><th>接口方法</th></tr></thead><tbody><tr><td>中间操作</td><td>concat() distinct() filter() flatMap() limit() map() peek() skip() sorted() parallel() sequential() unordered()</td></tr><tr><td>结束操作</td><td>allMatch() anyMatch() collect() count() findAny() findFirst() forEach() forEachOrdered() max() min() noneMatch() reduce() toArray()</td></tr></tbody></table><p>区分中间操作和结束操作最简单的方法，就是看方法的返回值，返回值为stream的大都是中间操作，否则是结束操作。</p><h3 id="stream方法使用"><a href="#stream方法使用" class="headerlink" title="stream方法使用"></a>stream方法使用</h3><p>stream跟函数接口关系非常紧密，没有函数接口stream就无法工作。</p><p>函数接口是指内部只有一个抽象方法的接口。通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字。</p><h4 id="forEach-2"><a href="#forEach-2" class="headerlink" title="forEach()"></a>forEach()</h4><p>方法签名为void forEach(Consumer&lt;? super E&gt; action)，作用是对容器中的每个元素执行action指定的动作，也就是对元素进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>由于forEach()是结束方法，上述代码会立即执行，输出所有字符串。</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>函数原型为Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)，作用是返回一个只包含满足predicate条件元素的Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保留长度大于等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stream.filter(str -&gt; str.length() &gt;= <span class="number">3</span>).forEach(str -&gt; System.out.println(str));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码将输出为长度大于等于3的字符串love和Java。注意，由于filter()是个中间操作，如果只调用filter()不会有实际计算，因此也不会输出任何信息。</p><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h4><p>函数原型为Stream&lt;T&gt; distinct()，作用是返回一个去除重复元素之后的Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素去重</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;you&quot;</span>);</span><br><span class="line">stream.distinct().forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p>上述代码会输出去掉一个you之后的其余字符串。</p><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h4><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为Stream&lt;T&gt;　sorted()和Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length() - str2.length()).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>函数原型为&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)，作用是返回一个对当前所有元素执行执行mapper之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换成大写</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;i&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase()).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h4><p>函数原型为&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)，作用是对每个元素执行mapper指定的操作，并用所有mapper返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲flatMap()的作用就相当于把原stream中的所有元素都”摊平”之后组成的Stream，转换前后元素的个数和类型都可能会改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将两个集合中大于等于2的数重新组成Stream，然后输出</span><br><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream &#x3D; Stream.of(Arrays.asList(1,2), Arrays.asList(3, 4, 5));</span><br><span class="line">stream.flatMap(list -&gt; list.stream().filter(integer -&gt; integer &gt;&#x3D; 2)).forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><h3 id="流的规约操作"><a href="#流的规约操作" class="headerlink" title="流的规约操作"></a>流的规约操作</h3><p>规约操作（reduction operation）又被称作折叠操作（fold），是通过某个连接动作将所有元素汇总成一个汇总结果的过程。元素求和、求最大值或最小值、求出元素总个数、将所有元素转换成一个列表或集合，都属于规约操作。Stream类库有两个通用的规约操作reduce()和collect()，也有一些为简化书写而设计的专用规约操作，比如sum()、max()、min()、count()等。</p><p>最大或最小值这类规约操作很好理解（至少方法语义上是这样），我们着重介绍reduce()和collect()，这是比较有魔法的地方。</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>reduce操作可以实现从一组元素中生成一个值，sum()、max()、min()、count()等都是reduce操作，将他们单独设为函数只是因为常用。reduce()的方法定义有三种重写形式：</p><ul><li>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</li><li>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</li><li>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</li></ul><p>虽然函数定义越来越长，但语义不曾改变，多的参数只是为了指明初始值（参数identity），或者是指定并行执行时多个部分结果的合并方式（参数combiner）。reduce()最常用的场景就是从一堆值中生成一个值。</p><p>具体实践：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 找出最长的单词</span><br><span class="line">Stream&lt;String&gt; stream1 &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">Optional&lt;String&gt; longest &#x3D; stream1.reduce((s1, s2) -&gt; s1.length() &gt;&#x3D; s2.length() ? s1 : s2);</span><br><span class="line">&#x2F;&#x2F; Optional&lt;String&gt; longest &#x3D; stream.max((s1, s2) -&gt; s1.length() - s2.length());</span><br><span class="line">System.out.println(longest.get());</span><br><span class="line"></span><br><span class="line">上述代码会选出最长的单词love，其中Optional是（一个）值的容器，使用它可以避免null值的麻烦。当然可以使用Stream.max(Comparator&lt;? super T&gt; comparator)方法来达到同等效果，但reduce()自有其存在的理由。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 求单词长度之和</span><br><span class="line">&#x2F;&#x2F; (参数1)初始值</span><br><span class="line">&#x2F;&#x2F; (参数2)累加器</span><br><span class="line">&#x2F;&#x2F; (参数3)部分和拼接器，并行执行时才会用到</span><br><span class="line">Stream&lt;String&gt; stream2 &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">Integer lengthSum &#x3D; stream2.reduce(0, (sum, str) -&gt; sum + str.length(), (a, b) -&gt; a + b);</span><br><span class="line">&#x2F;&#x2F; int lengthSum &#x3D; stream.mapToInt(str -&gt; str.length()).sum();</span><br><span class="line">System.out.println(lengthSum);</span><br><span class="line"></span><br><span class="line">参数2处：</span><br><span class="line">  1. 字符串映射成长度。</span><br><span class="line">  2. 并和当前累加和相加。</span><br><span class="line"></span><br><span class="line">  这显然是两步操作，使用reduce()函数将这两步合二为一，更有助于提升性能。如果想要使用map()和sum()组合来达到上述目的，也是可以的。</span><br><span class="line"></span><br><span class="line">  reduce()擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h4><p>如果你发现某个功能在Stream接口中没找到，十有八九可以通过collect()方法实现。collect()是Stream接口方法中最灵活的一个，学会它才算真正入门Java函数式编程。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">&#x2F;&#x2F; 转换成list集合</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());</span><br><span class="line">&#x2F;&#x2F; 转换成set集合</span><br><span class="line">&#x2F;&#x2F; Set&lt;String&gt; set &#x3D; stream.collect(Collectors.toSet());</span><br><span class="line">&#x2F;&#x2F; 转换成map集合</span><br><span class="line">&#x2F;&#x2F; Map&lt;String, Integer&gt; map &#x3D; stream.collect(Collectors.toMap(Function.identity(), String::length));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码分别列举了如何将Stream转换成List、Set和Map。虽然代码语义很明确，可是我们仍然会有几个疑问：</p><ul><li>Function.identity()是干什么的？</li><li>String::length是什么意思？</li><li>Collectors是个什么东西？</li></ul><h4 id="接口的静态方法和默认方法"><a href="#接口的静态方法和默认方法" class="headerlink" title="接口的静态方法和默认方法"></a>接口的静态方法和默认方法</h4><p>Function是一个接口，那么Function.identity()是什么意思呢？这要从两方面解释：</p><ul><li>Java 8允许在接口中加入具体方法。接口中的具体方法有两种，default方法和static方法，identity()就是Function接口的一个静态方法。</li><li>Function.identity()返回一个输出跟输入一样的Lambda表达式对象，等价于形如t -&gt; t形式的Lambda表达式。</li></ul><p>上面的解释是不是让你疑问更多？不要问我为什么接口中可以有具体方法，也不要告诉我你觉得t -&gt; t比identity()方法更直观。我会告诉你接口中的default方法是一个无奈之举，在Java 7及之前要想在定义好的接口中加入新的抽象方法是很困难甚至不可能的，因为所有实现了该接口的类都要重新实现。试想在Collection接口中加入一个stream()抽象方法会怎样？default方法就是用来解决这个尴尬问题的，直接在接口中实现新加入的方法。既然已经引入了default方法，为何不再加入static方法来避免专门的工具类呢！</p><h4 id="方法引用-1"><a href="#方法引用-1" class="headerlink" title="方法引用"></a>方法引用</h4><p>诸如String::length的语法形式叫做方法引用（method references），这种语法用来替代某些特定形式Lambda表达式。如果Lambda表达式的全部内容就是调用一个已有的方法，那么可以用方法引用来替代Lambda表达式。方法引用可以细分为四类：</p><table><thead><tr><th>方法引用类别</th><th>举例</th></tr></thead><tbody><tr><td>引用静态方法</td><td>Integer::sum</td></tr><tr><td>引用某个对象的方法</td><td>list::add</td></tr><tr><td>引用某个类的方法</td><td>String::length</td></tr><tr><td>引用构造方法</td><td>HashMap::new</td></tr></tbody></table><h4 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h4><p>收集器（Collector）是为Stream.collect()方法量身打造的工具接口（类）。考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？我们至少需要两样东西：</p><ul><li>目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。</li><li>新元素如何添加到容器中？是List.add()还是Map.put()。</li><li>如果并行的进行规约，还需要告诉collect()，多个部分结果如何合并成一个。</li></ul><p>结合以上分析，collect()方法定义为 &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R,? super T&gt; accumulator, BiConsumer&lt;R,R&gt; combiner)，三个参数依次对应上述三条分析。</p><p>不过每次调用collect()都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装,所以collect()的另一定义为 &lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt; collector)。</p><p>Collectors工具类可通过静态方法生成各种常用的Collector。举例来说，如果要将Stream规约成List可以通过如下两种方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　将Stream规约成List</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;Collector&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);<span class="comment">// 方式1</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; list = stream.collect(Collectors.toList());// 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>通常情况下我们不需要手动指定collect()的三个参数，而是调用collect(Collector&lt;? super T,A,R&gt; collector)方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了collect()的行为。</p><h4 id="使用collect-生成Collection"><a href="#使用collect-生成Collection" class="headerlink" title="使用collect()生成Collection"></a>使用collect()生成Collection</h4><p>有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)方法完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用toCollection()指定规约容器的类型</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;);</span><br><span class="line">ArrayList&lt;String&gt; arrayList &#x3D; stream.collect(Collectors.toCollection(ArrayList::new));</span><br><span class="line">System.out.println(arrayList);</span><br><span class="line">&#x2F;&#x2F; HashSet&lt;String&gt; hashSet &#x3D; stream.collect(Collectors.toCollection(HashSet::new));</span><br><span class="line">&#x2F;&#x2F; System.out.println(hashSet);</span><br></pre></td></tr></table></figure><h4 id="使用collect-生成Map"><a href="#使用collect-生成Map" class="headerlink" title="使用collect()生成Map"></a>使用collect()生成Map</h4><p>通常在三种情况下collect()的结果会是Map：</p><ul><li>使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。</li><li>使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。</li><li>使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。</li></ul><p>情况1：使用toMap()生成的收集器，这种情况是最直接的，前面例子中已提到，这是和Collectors.toCollection()并列的方法。如下代码将字符列表转换成由&lt;String，字符串长度&gt;组成的Map。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用toMap()统计字符长度</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());&#x2F;&#x2F; 方式2</span><br><span class="line">Map&lt;String, Integer&gt; strLength &#x3D; list.stream().collect(Collectors.toMap(Function.identity(), str -&gt; str.length()));</span><br><span class="line">System.out.println(strLength);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。下列代码展示将字符列表分成长度大于2或不大于2的两部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对字符串列表进行分组</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());&#x2F;&#x2F; 方式2</span><br><span class="line">Map&lt;Boolean, List&lt;String&gt;&gt; listMap &#x3D; list.stream().collect(Collectors.partitioningBy(str -&gt; str.length() &gt; 2));</span><br><span class="line">System.out.println(listMap);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。下列代码展示将字符列表按照字符长度进行分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照长度对字符串列表进行分组</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;, &quot;you&quot;, &quot;Java&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(Collectors.toList());&#x2F;&#x2F; 方式2</span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; listMap &#x3D; list.stream().collect(Collectors.groupingBy(String::length));</span><br><span class="line">System.out.println(listMap);</span><br></pre></td></tr></table></figure><p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如：</p><ol><li>先将员工按照部门分组。</li><li>然后统计每个部门员工的人数。</li></ol><p>Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。<br>这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对字符串列表进行分组，并统计每组元素的个数</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;, &quot;you&quot;, &quot;Java&quot;);</span><br><span class="line">List&lt;String&gt; list &#x3D; stream.collect(toList());&#x2F;&#x2F; 方式2</span><br><span class="line">Map&lt;Integer, Long&gt; listMap &#x3D; list.stream().collect(groupingBy(String::length, Collectors.counting()));</span><br><span class="line">System.out.println(listMap);</span><br></pre></td></tr></table></figure><p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器，这绝不是为了炫技而增加的把戏，而是实际场景需要。考虑将员工按照部门分组的场景，如果我们想得到每个员工的名字（字符串），而不是一个个Employee对象，可通过如下方式做到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照部门对员工分布组，并只保留员工的名字</span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept &#x3D; employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,&#x2F;&#x2F; 下游收集器</span><br><span class="line">                                Collectors.toList())));&#x2F;&#x2F; 更下游的收集器</span><br></pre></td></tr></table></figure><h4 id="使用collect-做字符串join"><a href="#使用collect-做字符串join" class="headerlink" title="使用collect()做字符串join"></a>使用collect()做字符串join</h4><p>字符串拼接时使用Collectors.joining()生成的收集器，从此告别for循环。Collectors.joining()方法有三种重写形式，分别对应三种不同的拼接方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用Collectors.joining()拼接字符串</span><br><span class="line">Stream&lt;String&gt; stream &#x3D; Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;Collector&quot;);</span><br><span class="line">&#x2F;&#x2F; String joined &#x3D; stream.collect(Collectors.joining());&#x2F;&#x2F; &quot;IloveCollector&quot;</span><br><span class="line">&#x2F;&#x2F; String joined &#x3D; stream.collect(Collectors.joining(&quot;,&quot;));&#x2F;&#x2F; &quot;I,love,Collector&quot;</span><br><span class="line">String joined &#x3D; stream.collect(Collectors.joining(&quot;,&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;));&#x2F;&#x2F; &quot;&#123;I,love,Collector&#125;</span><br><span class="line">System.out.println(joined);</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>Stream操作分类</th><th></th><th></th></tr></thead><tbody><tr><td>操作</td><td>状态</td><td></td></tr><tr><td>中间操作(Intermediate operations)</td><td>无状态(Stateless)</td><td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td></tr><tr><td></td><td>有状态(Stateful)</td><td>distinct() sorted() sorted() limit() skip()</td></tr><tr><td>结束操作(Terminal operations)</td><td>非短路操作</td><td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td></tr><tr><td></td><td>短路操作(short-circuiting)</td><td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td></tr></tbody></table><p>参考文章：</p><ul><li><a href="https://objcoding.com/2019/03/04/lambda/#lambda-and-anonymous-classesi">https://objcoding.com/2019/03/04/lambda/#lambda-and-anonymous-classesi</a>  关于Java Lambda表达式看这一篇就够了</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。&quot;&gt;&lt;a href=&quot;#摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。&quot; class=&quot;headerlink&quot; title=&quot;摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。&quot;&gt;&lt;/a&gt;摘要：重新把Lambda表达式过了一遍，新写的这篇总结更简单易懂。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。&quot;&gt;&lt;a href=&quot;#前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。&quot; class=&quot;headerlink&quot; title=&quot;前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。&quot;&gt;&lt;/a&gt;前言：Lambda表达式是Java8的一个新特性，但是我之前并没有运用的很熟练，并且在某次面试的时候，还因为这个原因，丢人了，所以特意重新总结了一下，这篇更简单易懂。之前文章跳转（建议这篇文章看完，之前的那篇）。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="基础" scheme="https://www.blog.ajie39.top/categories/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HBase学习笔记</title>
    <link href="https://www.blog.ajie39.top/2019/12/02/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.blog.ajie39.top/2019/12/02/HBase%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2019-12-02T09:30:36.490Z</published>
    <updated>2021-05-05T04:25:35.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：HBase基础。"><a href="#摘要：HBase基础。" class="headerlink" title="摘要：HBase基础。"></a>摘要：HBase基础。</h1><hr><h1 id="前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。"><a href="#前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。" class="headerlink" title="前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。"></a>前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。</h1><hr><span id="more"></span><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><h3 id="HBase是什么？"><a href="#HBase是什么？" class="headerlink" title="HBase是什么？"></a>HBase是什么？</h3><p>HBase是Apache Hadoop中的一个子项目，Hbase依托于Hadoop的HDFS作为最基本存储基础单元，通过使用hadoop的DFS工具就可以看到这些这些数据 存储文件夹的结构,还可以通过Map/Reduce的框架(算法)对HBase进行操作，如下图所示：</p><p><img src="/blog/19/3.png" alt="HBase"></p><p>HBASE是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBASE技术可在廉价PC Server上搭建起大规模结构化存储集群。</p><p>HBASE的目标是存储并处理大型的数据，更具体来说是仅需使用普通的硬件配置，就能够处理由成千上万的行和列所组成的大型数据。</p><p>HBASE是Google Bigtable的开源实现，但是也有很多不同之处。比如：Google Bigtable使用GFS作为其文件存储系统，HBASE利用Hadoop HDFS作为其文件存储系统；Google运行MAPREDUCE来处理Bigtable中的海量数据，HBASE同样利用Hadoop MapReduce来处理HBASE中的海量数据；Google Bigtable利用Chubby作为协同服务，HBASE利用Zookeeper作为协同服务。</p><h3 id="Hbase与传统数据库的对比"><a href="#Hbase与传统数据库的对比" class="headerlink" title="Hbase与传统数据库的对比"></a>Hbase与传统数据库的对比</h3><ul><li><p>传统数据库遇到的问题：</p><ol><li>数据量很大的时候无法存储。</li><li>没有很好的备份机制。</li><li>数据达到一定数量开始缓慢，很大的话基本无法支撑。</li></ol></li><li><p>HBASE优势：</p><ol><li>线性扩展，随着数据量增多可以通过节点扩展进行支撑。</li><li>数据存储在hdfs上，备份机制健全。</li><li>通过zookeeper协调查找数据，访问速度快。</li></ol></li></ul><h3 id="HBase集群中的角色"><a href="#HBase集群中的角色" class="headerlink" title="HBase集群中的角色"></a>HBase集群中的角色</h3><ul><li>一个或者多个主节点，Hmaster。</li><li>多个从节点，HregionServer。</li><li>HBase依赖项，zookeeper。</li></ul><p> HBase数据模型<br><img src="/blog/19/4.png" alt="HBase数据模型1"></p><p><img src="/blog/19/5.png" alt="HBase数据模型2"></p><h3 id="HBase的存储机制"><a href="#HBase的存储机制" class="headerlink" title="HBase的存储机制"></a>HBase的存储机制</h3><p>HBase是一个面向列的数据库，在表中它由行排序。表模式定义只能列族，也就是键值对。一个表有多个列族以及每一个列族可以有任意数量的列。后续列的值连续存储在磁盘上。表中的每个单元格值都具有时间戳。总之，在一个HBase：</p><ul><li>表是行的集合。</li><li>行是列族的集合。</li><li>列族是列的集合。</li><li>列是键值对的集合。</li></ul><p>这里的列式存储或者说面向列，其实说的是列族存储，HBase是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。</p><h4 id="Row-Key-行键"><a href="#Row-Key-行键" class="headerlink" title="Row Key 行键"></a>Row Key 行键</h4><p>与nosql数据库一样，row key是用来表示唯一一行记录的主键，HBase的数据时按照RowKey的字典顺序进行全局排序的，所有的查询都只能依赖于这一个排序维度。访问HBASE table中的行，只有三种方式：</p><ol><li>通过单个row key访问。</li><li>通过row key的range（正则）。</li><li>全表扫描。</li></ol><p>Row key行键（Row key）可以是任意字符串(最大长度是64KB，实际应用中长度一般为10-1000bytes)，在HBASE内部，row key保存为字节数组。存储时，数据按照Row key的字典序(byte order)排序存储。设计key时，要充分排序存储这个特性，将经常一起读取的行存储放到一起(位置相关性)。</p><h4 id="Columns-Family-列族"><a href="#Columns-Family-列族" class="headerlink" title="Columns Family 列族"></a>Columns Family 列族</h4><p>列族：HBASE表中的每个列，都归属于某个列族。列族是表的schema的一部分(而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如courses：history，courses：math 都属于courses这个列族。</p><h4 id="Cell-列"><a href="#Cell-列" class="headerlink" title="Cell 列"></a>Cell 列</h4><p>由{row key，columnFamily，version} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存储。</p><p>关键字：无类型、字节码</p><h4 id="Time-Stamp-时间戳"><a href="#Time-Stamp-时间戳" class="headerlink" title="Time Stamp 时间戳"></a>Time Stamp 时间戳</h4><p>HBASE中通过rowkey和columns确定的为一个存储单元称为cell。每个cell都保存着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是64位整型。时间戳可以由HBASE(在数据写入时自动)赋值，此时时间戳是精确到毫秒的当前系统时间。时间戳也可以由客户显示赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。每个cell中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。</p><p>为了避免数据存在过多版本造成的管理(包括存储和索引)负担，HBASE提供了两种数据版本回收方式。一是保存数据的最后n个版本，而是保存最近一段时间内的版本(比如最近7天)。用户可以针对每个列族进行设置。</p><h3 id="HBase原理"><a href="#HBase原理" class="headerlink" title="HBase原理"></a>HBase原理</h3><h4 id="HBase系统架构体系图"><a href="#HBase系统架构体系图" class="headerlink" title="HBase系统架构体系图"></a>HBase系统架构体系图</h4><p><img src="/blog/19/6.png" alt="HBase系统架构体系图"></p><h4 id="组成部件说明"><a href="#组成部件说明" class="headerlink" title="组成部件说明"></a>组成部件说明</h4><p>Client：</p><p>使用HBase RPC机制与HMaster和HRegionServer进行通信<br>Client与HMaster进行管理类操作<br>Client与HRegionServer进行数据读写类操作</p><p>Zookeeper：</p><p>Zookeeper Quorum存储-ROOT-表地址、HMaster地址<br>HRegionServer把自己以Ephedral方式注册到Zookeeper中，HMaster随时感知各个HRegionServer的健康状况<br>Zookeeper避免HMaster单点问题</p><p>Zookeeper的主要作用：客户端首先联系ZooKeeper子集群（quorum）（一个由ZooKeeper节点组成的单独集群）查找行健。上述过程是通过ZooKeeper获取含有-ROOT-的region服务器名（主机名）来完成的。通过含有-ROOT-的region服务器可以查询到含有.META.表中对应的region服务器名，其中包含请求的行健信息。这两处的主要内容都被缓存下来了，并且都只查询一次。最终，通过查询.META服务器来获取客户端查询的行健数据所在region的服务器名。一旦知道了数据的实际位置，即region的位置，HBase会缓存这次查询的信息，同时直接联系管理实际数据的HRegionServer。所以，之后客户端可以通过缓存信息很好地定位所需的数据位置，而不用再次查找.META.表。</p><p>HMaster：</p><p>HMaster没有单点问题，HBase可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master在运行<br>主要负责Table和Region的管理工作：</p><ol><li>管理用户对表的增删改查操作</li><li>管理HRegionServer的负载均衡，调整Region分布</li><li>Region Split后，负责新Region的分布</li><li>在HRegionServer停机后，负责失效HRegionServer上Region迁移</li></ol><p>HRegionServer：</p><p>HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统中读写</p><p><img src="/blog/19/7.png" alt="HBase系统架构体系图"></p><p>HRegionServer管理一系列HRegion对象；<br>每个HRegion对应Table中一个Region，HRegion由多个HStore组成；<br>每个HStore对应Table中一个Column Family的存储；<br>Column Family就是一个集中的存储单元，故将具有相同IO特性的Column放在一个Column Family会更高效。</p><p>可以看到，client访问hbase上的数据并不需要master参与（寻址访问zookeeper和region server，数据读写访问region server），master仅仅维护table和region的元数据信息（table的元数据信息保存在zookeeper上），负载很低。HRegionServer存取一个子表时，会创建一个HRegion对象，然后对表的每个列族创建一个Store实例，每个Store都会有一个MemStore和0个或多个StoreFile与之对应，每个StoreFile都会对应一个HFile，HFile就是实际的存储文件。因此，一个HRegion（表）有多少个列族就有多少个Store。一个HRegionServer会有多个HRegion和一个HLog。</p><p>HRegion：</p><p>table在行的方向上分隔为多个Region。Region是HBase中分布式存储和负载均衡的最小单元，即不同的region可以分别在不同的Region Server上，但同一个Region是不会拆分到多个server上。</p><p>Region按大小分隔，每个表一般是只有一个region。随着数据不断插入表，region不断增大，当region的某个列族达到一个阀值（默认256M）时就会分成两个新的region。</p><p>每个region由以下信息标识：</p><p>&lt;表名，startRowKey，创建时间&gt;<br>由目录表(-ROOT-和.META.)记录该region的endRowKey<br>HRegion定位：Region被分配给哪个RegionServer是完全动态的，所以需要机制来定位Region具体在哪个region server。</p><p>HBase使用三层结构来定位region：</p><p>通过zookeeper里的文件/hbase/rs得到-ROOT-表的位置。-ROOT-表只有一个region。<br>通过-ROOT-表查找.META.表的第一个表中相应的region的位置。其实-ROOT-表是.META.表的第一个region；.META.表中的每一个region在-ROOT-表中都是一行记录。<br>通过.META.表找到所要的用户表region的位置。用户表中的每个region在.META表中都是一行记录。<br>注意：</p><p> -ROOT-表永远不会被分隔为多个region，保证了最多需要三次跳转，就能定位到任意的region。client会将查询的位置信息缓存起来，缓存不会主动失效，因此如果client上的缓存全部失效，则需要进行6次网络来回，才能定位到正确的region，其中三次用来发现缓存失效，另外三次用来获取位置信息。</p><p>table和region的关系</p><p>table默认最初只有一个region，随着记录数的不断增加而变大，起初的region会逐渐分裂成多个region，一个region有【startKey, endKey】表示，不同的region会被master分配给相应的regionserver管理。</p><p>region是hbase分布式存储和负载均衡的最小单元，不同的region分不到不同的regionServer。</p><p>注意：region虽然是分布式存储的最小单元，但并不是存储的最小单元。region是由一个或者多个store组成的，每个store就是一个column family。每个store又由memStore和1至多个store file 组成(memstore到一个阀值会刷新，写入到storefile，有hlog来保证数据的安全性，一个regionServer有且只有一个hlog)　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　</p><p>HStore：</p><p>HBase存储的核心。由MemStore和StoreFile组成。MemStore是Stored Memory Buffer。<br>HLog：</p><p>引入HLog原因：在分布式系统环境中，无法避免系统出错或者宕机，一旦HRegionServer意外退出，MemStore中的内存数据就会丢失，引入HLog就是防止这种情况。</p><p>工作机制：<br>每个HRegionServer中都会有一个HLog对象，HLog是一个实现Write Ahead Log的类，每次用户操作写入MemStore的同时，也会写一份数据到HLog文件，HLog文件定期会滚动出新，并删除旧的文件(已持久化到StoreFile中的数据)。当HRegionServer意外终止后，HMaster会通过Zookeeper感知，HMaster首先处理遗留的HLog文件，将不同region的log数据拆分，分别放到相应region目录下，然后再将失效的region重新分配，领取到这些region的HRegionServer在Load Region的过程中，会发现有历史HLog需要处理，因此会Replay HLog中的数据到MemStore中，然后flush到StoreFiles，完成数据恢复。</p><h2 id="搭建hbase"><a href="#搭建hbase" class="headerlink" title="搭建hbase"></a>搭建hbase</h2><p>1、配置java环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">set java environment</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_151</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_151&#x2F;jre</span><br><span class="line">CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">使修改生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">java -version</span><br><span class="line">如果出现版本信息，则安装成功</span><br></pre></td></tr></table></figure><p>2、下载Hbase，<a href="http://archive.apache.org/dist/hbase/">http://archive.apache.org/dist/hbase/</a></p><p>3、配置Hbase环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">HBASE_HOME&#x3D;&#x2F;opt&#x2F;hbase</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin:$HBASE_HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line">使修改生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">hbase version</span><br><span class="line">如果出现版本信息，则安装成功</span><br></pre></td></tr></table></figure><p>4、单价模式配置hbase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;opt&#x2F;hbase&#x2F;conf&#x2F;hbase-env.sh</span><br><span class="line"></span><br><span class="line">末尾加上</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_151</span><br><span class="line">export HBASE_MANAGES_ZK&#x3D;true</span><br><span class="line"></span><br><span class="line">配置HBASE_MANAGES_ZK为true，表示由hbase自己管理zookeeper，不需要单独的zookeeper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;conf&#x2F;hbase-site.xml</span><br><span class="line"></span><br><span class="line">在启动HBase前需要设置属性hbase.rootdir，用于指定HBase数据的存储位置，因为如果不设置的话，hbase.rootdir默认为&#x2F;tmp&#x2F;hbase-$&#123;user.name&#125;,这意味着每次重启系统都会丢失数据。此处设置为HBase安装目录下的hbase-tmp文件夹即（&#x2F;usr&#x2F;local&#x2F;hbase&#x2F;hbase-tmp）,添加配置如下：</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;file:&#x2F;&#x2F;&#x2F;opt&#x2F;hbase&#x2F;hbase-tmp&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">cd &#x2F;opt&#x2F;hbase</span><br><span class="line">bin&#x2F;start-hbase.sh</span><br><span class="line">bin&#x2F;hbase shell</span><br></pre></td></tr></table></figure><p>5、配置外置的zookeeper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www-us.apache.org&#x2F;dist&#x2F;zookeeper&#x2F;</span><br></pre></td></tr></table></figure><h3 id="JAVA实际操作"><a href="#JAVA实际操作" class="headerlink" title="JAVA实际操作"></a>JAVA实际操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> com.ypsx.miniTask.server.bean.StoresData;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.client.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.filter.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleForHbase</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Admin admin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLENAME = <span class="string">&quot;shopOrderStatisticsTest0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        configuration  = HBaseConfiguration.create();</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.quorum&quot;</span>,<span class="string">&quot;yp-ubuntu-server-1,yp-ubuntu-server-2,yp-ubuntu-server-3&quot;</span>);</span><br><span class="line">        configuration.set(<span class="string">&quot;hbase.zookeeper.port&quot;</span>,<span class="string">&quot;2181&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            connection = ConnectionFactory.createConnection(configuration);</span><br><span class="line">            admin = connection.getAdmin();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(admin != <span class="keyword">null</span>)&#123;</span><br><span class="line">                admin.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != connection)&#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建表。HBase的表中会有一个系统默认的属性作为主键，主键无需自行创建，默认为put命令操作中表名后第一个数据，因此此处无需创建id列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> myTableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colFamily 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">(String myTableName,String[] colFamily)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        TableName tableName = TableName.valueOf(myTableName);</span><br><span class="line">        <span class="keyword">if</span>(admin.tableExists(tableName))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;talbe is exists!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            HTableDescriptor hTableDescriptor = <span class="keyword">new</span> HTableDescriptor(tableName);</span><br><span class="line">            <span class="keyword">for</span>(String str:colFamily)&#123;</span><br><span class="line">                HColumnDescriptor hColumnDescriptor = <span class="keyword">new</span> HColumnDescriptor(str);</span><br><span class="line">                hTableDescriptor.addFamily(hColumnDescriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            admin.createTable(hTableDescriptor);</span><br><span class="line">            System.out.println(<span class="string">&quot;create table success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteTable</span><span class="params">(String tableName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        TableName tn = TableName.valueOf(tableName);</span><br><span class="line">        <span class="keyword">if</span> (admin.tableExists(tn)) &#123;</span><br><span class="line">            admin.disableTable(tn);</span><br><span class="line">            admin.deleteTable(tn);</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看已有表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listTables</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        HTableDescriptor hTableDescriptors[] = admin.listTables();</span><br><span class="line">        <span class="keyword">for</span>(HTableDescriptor hTableDescriptor : hTableDescriptors)&#123;</span><br><span class="line">            System.out.println(hTableDescriptor.getNameAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向某一行的某一列插入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey 行键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colFamily 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 列名（如果其列族下没有子列，此参数可为空）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertRow</span><span class="params">(String tableName,String rowKey,String colFamily,String col,String val)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Put put = <span class="keyword">new</span> Put(rowKey.getBytes());</span><br><span class="line">        put.addColumn(colFamily.getBytes(), col.getBytes(), val.getBytes());</span><br><span class="line">        table.put(put);</span><br><span class="line">        table.close();</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey 行键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colFamily 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 列名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRow</span><span class="params">(String tableName,String rowKey,String colFamily,String col)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Delete delete = <span class="keyword">new</span> Delete(rowKey.getBytes());</span><br><span class="line">        <span class="comment">//删除指定列族的所有数据</span></span><br><span class="line">        <span class="comment">//delete.addFamily(colFamily.getBytes());</span></span><br><span class="line">        <span class="comment">//删除指定列的数据</span></span><br><span class="line">        <span class="comment">//delete.addColumn(colFamily.getBytes(), col.getBytes());</span></span><br><span class="line">        table.delete(delete);</span><br><span class="line">        table.close();</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据行键rowkey查找数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rowKey 行键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> colFamily 列族名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 列名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(String tableName,String rowKey,String colFamily,String col)</span><span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        Table table = connection.getTable(TableName.valueOf(tableName));</span><br><span class="line">        Get get = <span class="keyword">new</span> Get(rowKey.getBytes());</span><br><span class="line">        get.addColumn(colFamily.getBytes(),col.getBytes());</span><br><span class="line">        Result result = table.get(get);</span><br><span class="line">        showCell(result);</span><br><span class="line">        table.close();</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从指定行scan表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shopId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;StoresData&gt; <span class="title">scanTableByRow</span><span class="params">(String cityCode, String dayTime, String shopId, String[] stArr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        HTableDescriptor hTableDescriptors[] = admin.listTables();</span><br><span class="line">        List&lt;String&gt; tableList = Lists.newArrayList();</span><br><span class="line">        <span class="comment">//获取所有表名称</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hTableDescriptors.length; i++) &#123;</span><br><span class="line">            tableList.add(hTableDescriptors[i].getNameAsString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;StoresData&gt; storesDataList = Lists.newArrayList();</span><br><span class="line">        <span class="comment">//判断需要查询的表是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (tableList.contains(TABLENAME)) &#123;</span><br><span class="line">            Table table = connection.getTable(TableName.valueOf(TABLENAME));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义scan条件</span></span><br><span class="line">            Scan scan = <span class="keyword">new</span> Scan();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//过滤rowkey，$&#123;cityCode&#125;_$&#123;dayTime&#125;_$&#123;shopId&#125;,如C320100_20190910_100002445</span></span><br><span class="line">            <span class="keyword">if</span> (shopId.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                scan.setRowPrefixFilter(Bytes.toBytes(cityCode + <span class="string">&quot;_&quot;</span> + dayTime));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                scan.setRowPrefixFilter(Bytes.toBytes(cityCode + <span class="string">&quot;_&quot;</span> + dayTime + <span class="string">&quot;_&quot;</span> + shopId));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//数据要满足全部过滤器才可以</span></span><br><span class="line">            FilterList filterList = <span class="keyword">new</span> FilterList(FilterList.Operator.MUST_PASS_ALL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//过滤器1，用于过滤dayTime</span></span><br><span class="line">            SingleColumnValueFilter filter1= <span class="keyword">new</span> SingleColumnValueFilter(Bytes.toBytes(<span class="string">&quot;statistics&quot;</span>), Bytes.toBytes(<span class="string">&quot;dayTime&quot;</span>), CompareFilter.CompareOp.EQUAL, dayTime.getBytes());</span><br><span class="line">            filter1.setFilterIfMissing(<span class="keyword">true</span>); <span class="comment">//默认为false， 没有此列的数据也会返回 ，为true则只返回name=lisi的数据</span></span><br><span class="line">            filterList.addFilter(filter1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!shopId.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//过滤器2，用于过滤shopId</span></span><br><span class="line">                SingleColumnValueFilter filter2 = <span class="keyword">new</span> SingleColumnValueFilter(Bytes.toBytes(<span class="string">&quot;statistics&quot;</span>), Bytes.toBytes(<span class="string">&quot;shopId&quot;</span>), CompareFilter.CompareOp.EQUAL, shopId.getBytes());</span><br><span class="line">                filter2.setFilterIfMissing(<span class="keyword">true</span>); <span class="comment">//默认为false， 没有此列的数据也会返回 ，为true则只返回name=lisi的数据</span></span><br><span class="line">                filterList.addFilter(filter2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            scan.setFilter(filterList);</span><br><span class="line"></span><br><span class="line">            ResultScanner scanner = table.getScanner(scan);</span><br><span class="line">            <span class="comment">// 遍历scanner</span></span><br><span class="line">            Iterator&lt;Result&gt; iterator = scanner.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                Result result = iterator.next();</span><br><span class="line">                <span class="comment">// 遍历result</span></span><br><span class="line">                CellScanner cellScanner = result.cellScanner();</span><br><span class="line">                StoresData storesData = <span class="keyword">new</span> StoresData();</span><br><span class="line">                storesData.setShopId(Integer.valueOf(shopId));</span><br><span class="line">                storesData.setMerchantName(stArr[<span class="number">0</span>]);</span><br><span class="line">                storesData.setShopOrganizationCode(stArr[<span class="number">1</span>]);</span><br><span class="line">                storesData.setCityCode(cityCode);</span><br><span class="line">                storesData.setDayTime(dayTime);</span><br><span class="line">                <span class="keyword">while</span> (cellScanner.advance()) &#123;</span><br><span class="line">                    Cell cell = cellScanner.current();</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;行键:&quot; + Bytes.toString(CellUtil.copyRow(cell)));</span></span><br><span class="line">                    <span class="comment">// System.out.println(&quot;列族:&quot; + Bytes.toString(CellUtil.cloneFamily(cell)));</span></span><br><span class="line">                    <span class="comment">// System.out.println(&quot;列名:&quot; + Bytes.toString(CellUtil.cloneQualifier(cell)));</span></span><br><span class="line">                    <span class="comment">// System.out.println(&quot;值:&quot; + Bytes.toString(CellUtil.cloneValue(cell)));</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// totalPayUserNumber  totalPayOrderNumber  totalPayPrice</span></span><br><span class="line">                    String tempName = Bytes.toString(CellUtil.cloneQualifier(cell));</span><br><span class="line">                    String tempValue = Bytes.toString(CellUtil.cloneValue(cell));</span><br><span class="line">                    <span class="keyword">if</span> (tempName.equals(<span class="string">&quot;totalPayUserNumber&quot;</span>))&#123;</span><br><span class="line">                        storesData.setTotalPayUserNumber(Long.valueOf(tempValue));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tempName.equals(<span class="string">&quot;totalPayOrderNumber&quot;</span>))&#123;</span><br><span class="line">                        storesData.setTotalPayOrderNumber(Long.valueOf(tempValue));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tempName.equals(<span class="string">&quot;totalPayPrice&quot;</span>))&#123;</span><br><span class="line">                        storesData.setTotalPayPrice(Long.valueOf(tempValue));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//为客单价赋值</span></span><br><span class="line">                <span class="keyword">if</span> (storesData.getTotalPayPrice() != <span class="number">0</span> || storesData.getTotalPayOrderNumber() != <span class="number">0</span> )&#123;</span><br><span class="line">                    BigDecimal bi1 = <span class="keyword">new</span> BigDecimal(storesData.getTotalPayPrice());</span><br><span class="line">                    BigDecimal bi2 = <span class="keyword">new</span> BigDecimal(storesData.getTotalPayOrderNumber());</span><br><span class="line">                    BigDecimal divide = bi1.divide(bi2, <span class="number">2</span>, RoundingMode.HALF_UP);</span><br><span class="line">                    storesData.setUnitPrice(divide.doubleValue());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                storesDataList.add(storesData);</span><br><span class="line">            &#125;</span><br><span class="line">            table.close();</span><br><span class="line">            <span class="keyword">return</span> storesDataList;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">return</span> storesDataList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 格式化输出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCell</span><span class="params">(Result result)</span></span>&#123;</span><br><span class="line">        Cell[] cells = result.rawCells();</span><br><span class="line">        <span class="keyword">for</span>(Cell cell:cells)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;RowName:&quot;</span>+<span class="keyword">new</span> String(CellUtil.cloneRow(cell))+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Timetamp:&quot;</span>+cell.getTimestamp()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;column Family:&quot;</span>+<span class="keyword">new</span> String(CellUtil.cloneFamily(cell))+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;row Name:&quot;</span>+<span class="keyword">new</span> String(CellUtil.cloneQualifier(cell))+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;value:&quot;</span>+<span class="keyword">new</span> String(CellUtil.cloneValue(cell))+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考文章：</p><ul><li><p>Hbase批量查询-scan介绍 <a href="https://blog.csdn.net/kangkangwanwan/article/details/89332536">https://blog.csdn.net/kangkangwanwan/article/details/89332536</a></p></li><li><p>Ubuntu下HBase安装与使用(shell+Java API) <a href="https://blog.csdn.net/flyfish111222/article/details/51893096">https://blog.csdn.net/flyfish111222/article/details/51893096</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：HBase基础。&quot;&gt;&lt;a href=&quot;#摘要：HBase基础。&quot; class=&quot;headerlink&quot; title=&quot;摘要：HBase基础。&quot;&gt;&lt;/a&gt;摘要：HBase基础。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。&quot;&gt;&lt;a href=&quot;#前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。&quot; class=&quot;headerlink&quot; title=&quot;前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。&quot;&gt;&lt;/a&gt;前言：本篇文章主要是总结了一下学习HBase的过程中遇到的一些问题和知识点。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="基础" scheme="https://www.blog.ajie39.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="HBase" scheme="https://www.blog.ajie39.top/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>git和maven常用命令</title>
    <link href="https://www.blog.ajie39.top/2019/09/25/git%E5%92%8Cmaven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.blog.ajie39.top/2019/09/25/git%E5%92%8Cmaven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-09-25T09:42:02.690Z</published>
    <updated>2020-10-25T17:15:00.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：git和maven常用命令。"><a href="#摘要：git和maven常用命令。" class="headerlink" title="摘要：git和maven常用命令。"></a>摘要：git和maven常用命令。</h1><hr><h1 id="前言：git和maven常用命令。"><a href="#前言：git和maven常用命令。" class="headerlink" title="前言：git和maven常用命令。"></a>前言：git和maven常用命令。</h1><hr><h2 id="git基本使用"><a href="#git基本使用" class="headerlink" title="git基本使用"></a>git基本使用</h2><h3 id="将新项目上传到gitlab上"><a href="#将新项目上传到gitlab上" class="headerlink" title="将新项目上传到gitlab上"></a>将新项目上传到gitlab上</h3><p>1、申请公司gitLab权限<br>2、创建一个新的gitlab项目(创建的时候，需要创建一个空的项目，不要勾选Initialize repository with a README)<br>3、将代码传到gitlab上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#123;项目文件夹的路径&#125;</span><br><span class="line">git init</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;coding.ypsx-internal.com&#x2F;&#123;gitlab地址&#125;</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h3><ul><li>git init：初始化</li><li>git clone：克隆</li><li>git add：添加</li><li>git commit：提交已经被add进来的改动</li><li>git revert：撤销提交</li><li>git rm：移除文件</li><li>git clean：从工作目录中移除没有track的文件</li><li>git mv：对文件重命名</li><li>git push：如果分支已经存在,将会更新,如果不存在,将会添加这个分支</li></ul><h3 id="克隆私有库"><a href="#克隆私有库" class="headerlink" title="克隆私有库"></a>克隆私有库</h3><p>参考地址：<a href="https://www.cnblogs.com/haojile/p/11616566.html">https://www.cnblogs.com/haojile/p/11616566.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git clone https://&lt;token&gt;@github.com/&lt;用户名&gt;/&lt;仓库名&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line">git clone https://11b82b0a18fde70bb92288cf0b0b79b76f302d1e@github.com/&lt;用户名&gt;/张三</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="maven基本使用"><a href="#maven基本使用" class="headerlink" title="maven基本使用"></a>maven基本使用</h2><h3 id="maven常用命令"><a href="#maven常用命令" class="headerlink" title="maven常用命令"></a>maven常用命令</h3><ol><li><p>创建Maven的普通Java项目：<br>mvn archetype:create<br>   -DgroupId=packageName<br>   -DartifactId=projectName</p></li><li><p>创建Maven的Web项目：<br>mvn archetype:create<br>   -DgroupId=packageName<br>   -DartifactId=webappName<br>   -DarchetypeArtifactId=maven-archetype-webapp</p></li><li><p>反向生成 maven 项目的骨架：<br>mvn archetype:generate</p></li><li><p>编译源代码：<br>mvn compile</p></li><li><p>编译测试代码：<br>mvn test-compile</p></li><li><p>运行测试:<br>mvn test</p></li><li><p>产生site：<br>mvn site</p></li><li><p>打包：<br>mvn package</p></li></ol><p>  mvn clean package -Dmaven.test.skip（打包，清除临时文件，并跳过单元测试）</p><ol start="9"><li><p>在本地Repository中安装jar：<br>mvn install<br>例：installing D:\xxx\xx.jar to D:\xx\xxxx</p></li><li><p>清除产生的项目：<br>mvn clean</p></li><li><p>生成eclipse项目：<br>mvn eclipse:eclipse</p></li><li><p>生成idea项目：<br>mvn idea:idea</p></li><li><p>组合使用goal命令，如只打包不测试：<br>mvn -Dtest package</p></li><li><p>编译测试的内容：<br>mvn test-compile</p></li><li><p>只打jar包:<br>mvn jar:jar</p></li><li><p>只测试而不编译，也不测试编译：<br>mvn test -skipping compile -skipping test-compile<br>( -skipping 的灵活运用，当然也可以用于其他组合命令)</p></li><li><p>清除eclipse的一些系统设置:<br>mvn eclipse:clean</p></li></ol><p>18.查看当前项目已被解析的依赖：<br>  mvn dependency:list</p><p>19.上传到私服：<br>  mvn deploy</p><ol start="20"><li><p>强制检查更新，由于快照版本的更新策略(一天更新几次、隔段时间更新一次)存在，如果想强制更新就会用到此命令:<br>mvn clean install-U</p></li><li><p>源码打包：<br>mvn source:jar<br>或<br>mvn source:jar-no-fork</p></li></ol><p>参考文章：<br>Maven常用命令 <a href="https://www.cnblogs.com/wkrbky/p/6352188.html">https://www.cnblogs.com/wkrbky/p/6352188.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要：git和maven常用命令。&quot;&gt;&lt;a href=&quot;#摘要：git和maven常用命令。&quot; class=&quot;headerlink&quot; title=&quot;摘要：git和maven常用命令。&quot;&gt;&lt;/a&gt;摘要：git和maven常用命令。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="基础" scheme="https://www.blog.ajie39.top/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/tags/git/"/>
    
    <category term="maven" scheme="https://www.blog.ajie39.top/tags/maven/"/>
    
  </entry>
  
</feed>
