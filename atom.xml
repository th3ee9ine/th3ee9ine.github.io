<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>教练，我想学技术!</title>
  
  <subtitle>开局一双手，升级全靠苟，拼一拼，搏一搏，单车变摩托。</subtitle>
  <link href="https://www.blog.ajie39.top/atom.xml" rel="self"/>
  
  <link href="https://www.blog.ajie39.top/"/>
  <updated>2022-03-06T10:13:32.833Z</updated>
  <id>https://www.blog.ajie39.top/</id>
  
  <author>
    <name>th3ee9ine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 入门相关总结</title>
    <link href="https://www.blog.ajie39.top/2022/03/06/go%E5%85%A5%E9%97%A8/"/>
    <id>https://www.blog.ajie39.top/2022/03/06/go%E5%85%A5%E9%97%A8/</id>
    <published>2022-03-06T06:50:08.425Z</published>
    <updated>2022-03-06T10:13:32.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：golang入门相关内容，参考：Go入门指南，主要总结和-java有区别的内容，没有区别的则不进行总结"><a href="#摘要：golang入门相关内容，参考：Go入门指南，主要总结和-java有区别的内容，没有区别的则不进行总结" class="headerlink" title="摘要：golang入门相关内容，参考：Go入门指南，主要总结和 java有区别的内容，没有区别的则不进行总结"></a>摘要：golang入门相关内容，参考：<a href="https://learnku.com/docs/the-way-to-go">Go入门指南</a>，主要总结和 java有区别的内容，没有区别的则不进行总结</h1><hr><span id="more"></span><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1、包相关"><a href="#1、包相关" class="headerlink" title="1、包相关"></a>1、包相关</h3><p>①第一种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">import &quot;os&quot;</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;; import &quot;os&quot;</span><br></pre></td></tr></table></figure><p>②第二种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">import (&quot;fmt&quot;; &quot;os&quot;)</span><br></pre></td></tr></table></figure><h3 id="2、基本类型"><a href="#2、基本类型" class="headerlink" title="2、基本类型"></a>2、基本类型</h3><ul><li>布尔类型：bool</li><li>整数：int、int8、int16、int32、int64</li><li>无符号整数：uint、uint8、uint16、uint32、uint64</li><li>字节：byte(和 uint8 等价)</li><li>Unicode：rune(和 int32 等价)</li><li>整数指针：uintptr(存储 uint32、uint64 的指针)</li><li>浮点数：float32、float64</li><li>复数：complex64、complex128</li><li>字符串类型：string</li><li>值类型：array(数组)、struct(结构化变量)</li><li>引用类型：slice(动态数组)、map、channel(管道)</li><li>接口：interface</li><li>函数：function</li></ul><h3 id="3、函数相关"><a href="#3、函数相关" class="headerlink" title="3、函数相关"></a>3、函数相关</h3><p>函数执行顺序：init —》main</p><p>测试代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;demo&#x2F;com.th3ee9ine&#x2F;servic&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">&#x2F;&#x2F; 先执行</span><br><span class="line">fmt.Println(&quot;初始化.....&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">  主函数</span><br><span class="line">*&#x2F;</span><br><span class="line">func main() &#123;</span><br><span class="line">&#x2F;&#x2F; 后执行</span><br><span class="line">fmt.Println(&quot;主函数......&quot;)</span><br><span class="line">fmt.Println(&quot;加法&quot;)</span><br><span class="line">fmt.Println(servic.Add(1, 2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、类型转换"><a href="#4、类型转换" class="headerlink" title="4、类型转换"></a>4、类型转换</h3><p>在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valueOfTypeB &#x3D; typeB(valueOfTypeA)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 5.0</span><br><span class="line">var b &#x3D; int(a)</span><br></pre></td></tr></table></figure><h3 id="5、Go-程序的一般结构"><a href="#5、Go-程序的一般结构" class="headerlink" title="5、Go 程序的一般结构"></a>5、Go 程序的一般结构</h3><p>一般结构如下：</p><ul><li>在完成包的 import 之后，开始对常量、变量和类型的定义或声明。</li><li>如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。</li><li>如果当前包是 main 包，则定义 main 函数。</li><li>然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const c &#x3D; &quot;C&quot;</span><br><span class="line"></span><br><span class="line">var v int &#x3D; 5</span><br><span class="line"></span><br><span class="line">type T struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func init() &#123; &#x2F;&#x2F; initialization of package</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var a int</span><br><span class="line">   Func1()</span><br><span class="line">   &#x2F;&#x2F; ...</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t T) Method1() &#123;</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Func1() &#123; &#x2F;&#x2F; exported function Func1</span><br><span class="line">   &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、常量、变量"><a href="#6、常量、变量" class="headerlink" title="6、常量、变量"></a>6、常量、变量</h3><h4 id="①常量"><a href="#①常量" class="headerlink" title="①常量"></a>①常量</h4><p>常量使用关键字 const 定义，用于存储不会改变的数据。</p><p>存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const identifier [type] &#x3D; value</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">const PI &#x3D; 3.14159</span><br><span class="line">const NAME string &#x3D; &quot;张三&quot;</span><br><span class="line">const beef, two, c &#x3D; &quot;eat&quot;, 2, &quot;veg&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>②常量枚举</p><p>例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    Unknown &#x3D; 0</span><br><span class="line">    Female &#x3D; 1</span><br><span class="line">    Male &#x3D; 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota 可以被用作枚举值，第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1，例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b &#x3D; iota</span><br><span class="line">    c &#x3D; iota</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">    a &#x3D; iota</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="②变量"><a href="#②变量" class="headerlink" title="②变量"></a>②变量</h4><p>声明变量的一般形式是使用 var 关键字，例子如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var identifier type</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">var a int &#x3D; 15</span><br><span class="line">var i &#x3D; 5</span><br><span class="line">var b bool &#x3D; false</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">    a &#x3D; 15</span><br><span class="line">    b &#x3D; false</span><br><span class="line">    city string</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">简短形式，使用 :&#x3D; 赋值操作符，例如：</span><br><span class="line"></span><br><span class="line">a, b, c :&#x3D; 5, 7, &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。</span><br><span class="line"></span><br><span class="line">同个变量不可以多次使用 :&#x3D; 赋值操作符。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、运算符"><a href="#7、运算符" class="headerlink" title="7、运算符"></a>7、运算符</h3><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优先级     运算符</span><br><span class="line"> 7      ^ !</span><br><span class="line"> 6      * &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^</span><br><span class="line"> 5      + - | ^</span><br><span class="line"> 4      &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt;&#x3D; &gt;</span><br><span class="line"> 3      &lt;-</span><br><span class="line"> 2      &amp;&amp;</span><br><span class="line"> 1      ||</span><br></pre></td></tr></table></figure><h3 id="8、字符串"><a href="#8、字符串" class="headerlink" title="8、字符串"></a>8、字符串</h3><p>字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组。</p><p>Go 支持以下 2 种形式的字面值：</p><p>解释字符串：</p><p>该类字符串使用双引号括起来，其中的相关的转义字符将被替换，这些转义字符包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\n：换行符</span><br><span class="line">\r：回车符</span><br><span class="line">\t：tab 键</span><br><span class="line">\u 或 \U：Unicode 字符</span><br><span class="line">\\：反斜杠自身</span><br></pre></td></tr></table></figure><p>非解释字符串：</p><p>该类字符串使用反引号括起来，支持换行，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;This is a raw string \n&#96; 中的 &#96;\n\&#96; 会被原样输出。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：golang入门相关内容，参考：Go入门指南，主要总结和-java有区别的内容，没有区别的则不进行总结&quot;&gt;&lt;a href=&quot;#摘要：golang入门相关内容，参考：Go入门指南，主要总结和-java有区别的内容，没有区别的则不进行总结&quot; class=&quot;headerlink&quot; title=&quot;摘要：golang入门相关内容，参考：Go入门指南，主要总结和 java有区别的内容，没有区别的则不进行总结&quot;&gt;&lt;/a&gt;摘要：golang入门相关内容，参考：&lt;a href=&quot;https://learnku.com/docs/the-way-to-go&quot;&gt;Go入门指南&lt;/a&gt;，主要总结和 java有区别的内容，没有区别的则不进行总结&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="golang" scheme="https://www.blog.ajie39.top/categories/golang/"/>
    
    
    <category term="golang" scheme="https://www.blog.ajie39.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>git--Fork代码更新与同步</title>
    <link href="https://www.blog.ajie39.top/2022/02/02/git----Fork%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <id>https://www.blog.ajie39.top/2022/02/02/git----Fork%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%90%8C%E6%AD%A5/</id>
    <published>2022-02-02T13:20:12.729Z</published>
    <updated>2022-02-02T13:39:28.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：记录使用git–Fork代码更新与同步"><a href="#摘要：记录使用git–Fork代码更新与同步" class="headerlink" title="摘要：记录使用git–Fork代码更新与同步"></a>摘要：记录使用git–Fork代码更新与同步</h1><hr><span id="more"></span><h2 id="一、clone-fork的代码"><a href="#一、clone-fork的代码" class="headerlink" title="一、clone fork的代码"></a>一、clone fork的代码</h2><p>git clone xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git clone <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#46;&#112;&#x70;&#100;&#97;&#105;&#99;&#x6f;&#x72;&#x70;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#x69;&#x74;&#46;&#112;&#x70;&#100;&#97;&#105;&#99;&#x6f;&#x72;&#x70;&#x2e;&#x63;&#x6f;&#109;</a>:cs-global/phl/cschannel.git</p><h2 id="二、把主仓库加入-remote"><a href="#二、把主仓库加入-remote" class="headerlink" title="二、把主仓库加入 remote"></a>二、把主仓库加入 remote</h2><p>未加入前：</p><p>执行 git remote 则只会有一个仓库</p><p><img src="/img/image/blog/20220202/remote1.png" alt="remote1"></p><p>执行命令，加入主仓库</p><p>git remote add xxxxxname（自定义名字） xxxxxxxxxxxx（主仓库地址）</p><p>例如：</p><p>git remote add main <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#x2e;&#112;&#x70;&#x64;&#97;&#105;&#99;&#111;&#x72;&#x70;&#x2e;&#99;&#x6f;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#x2e;&#112;&#x70;&#x64;&#97;&#105;&#99;&#111;&#x72;&#x70;&#x2e;&#99;&#x6f;&#109;</a>:cs-global/cschannel.git</p><p>再次执行 git remote 命令，则会出现两个选项</p><p><img src="/img/image/blog/20220202/remote2.png" alt="remote2"></p><h2 id="三、同步主仓库分支至本地"><a href="#三、同步主仓库分支至本地" class="headerlink" title="三、同步主仓库分支至本地"></a>三、同步主仓库分支至本地</h2><p>命令：</p><p>git fetch xxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git fetch main</p><h2 id="四、同步主分支代码"><a href="#四、同步主分支代码" class="headerlink" title="四、同步主分支代码"></a>四、同步主分支代码</h2><p>基于 origin/master 分支创建一个临时分支</p><p>例如：</p><p>git branch origin/temp</p><p>然后将 main 分支的代码合并到 origin/temp</p><p>例如：</p><p>git merge main/master<br>解决冲突后，提交代码即可</p><p>注意：</p><p>如果出现如下报错，则需要强制合并</p><p>refusing to merge unrelated histories</p><p>强制合并命令：</p><p>git merge xxxxxxxxxxxxxxxxxxxxxx –allow-unrelated-histories</p><p>例如：</p><p>git merge main/master –allow-unrelated-histories</p><h2 id="五、移除远程分支"><a href="#五、移除远程分支" class="headerlink" title="五、移除远程分支"></a>五、移除远程分支</h2><p>git remote remove xxxxxxxxxxxxxxxxxxx</p><p>例如：</p><p>git remote remove main</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：记录使用git–Fork代码更新与同步&quot;&gt;&lt;a href=&quot;#摘要：记录使用git–Fork代码更新与同步&quot; class=&quot;headerlink&quot; title=&quot;摘要：记录使用git–Fork代码更新与同步&quot;&gt;&lt;/a&gt;摘要：记录使用git–Fork代码更新与同步&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/categories/git/"/>
    
    
    <category term="git" scheme="https://www.blog.ajie39.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>重写TreeMap的比较器(Comparator)引发的问题（源码分析）</title>
    <link href="https://www.blog.ajie39.top/2022/01/16/%E9%87%8D%E5%86%99TreeMap%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8(Comparator)%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98(%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/"/>
    <id>https://www.blog.ajie39.top/2022/01/16/%E9%87%8D%E5%86%99TreeMap%E7%9A%84%E6%AF%94%E8%BE%83%E5%99%A8(Comparator)%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98(%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/</id>
    <published>2022-01-16T06:58:04.646Z</published>
    <updated>2022-01-17T12:49:26.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。"><a href="#摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。" class="headerlink" title="摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。"></a>摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。</h1><hr><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>1、给一个无序的map，按照value的值进行排序，value值越小，排在越前面。<br>2、key和value都不为null<br>3、value可能相同<br>4、返回结果为一个相同的有序map</p><p>代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，key=商品id，value=商品剩余库存</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1L</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2L</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="number">3L</span>, <span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里，大家可以先想想，如果是你会怎么解决？</p><span id="more"></span><h2 id="我的解决思路"><a href="#我的解决思路" class="headerlink" title="我的解决思路"></a>我的解决思路</h2><p>1、使用TreeMap，因为TreeMap可以对元素进行排序<br>2、重写TreeMap的比较器</p><p>代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 承接上面的代码</span></span><br><span class="line"><span class="comment">// 按照 value 排序</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap1 = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Long o1, Long o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、如果v1等于v2，则值为0</span></span><br><span class="line">        <span class="comment">// 2、如果v1小于v2，则值为-1</span></span><br><span class="line">        <span class="comment">// 3、如果v1等于v2，则值为1</span></span><br><span class="line">        Integer value1 = map.get(o1);</span><br><span class="line">        Integer value2 = map.get(o2);</span><br><span class="line">        <span class="keyword">return</span> value1.compareTo(value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap1.putAll(map);</span><br><span class="line">System.out.println(treeMap1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>what？为什么我们添加了3个元素，结果少了一个呢？</p><p><img src="/img/image/blog/20220116/%E7%96%91%E9%97%AE.jpg" alt="疑问"></p><h2 id="TreeMap-putAll源码分析"><a href="#TreeMap-putAll源码分析" class="headerlink" title="TreeMap putAll源码分析"></a>TreeMap putAll源码分析</h2><p>让我们来看看 putAll 的具体过程</p><h3 id="1、分析-TreeMap-putAll"><a href="#1、分析-TreeMap-putAll" class="headerlink" title="1、分析 TreeMap.putAll"></a>1、分析 TreeMap.putAll</h3><p>源码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、获取待添加的map的大小</span></span><br><span class="line">    <span class="keyword">int</span> mapSize = map.size();</span><br><span class="line">    <span class="comment">// 二、当前的size大小等于0 且 待添加的map的大小不等于0 且 待添加的map是SortedMap的实现类，则执行以下逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (size==<span class="number">0</span> &amp;&amp; mapSize!=<span class="number">0</span> &amp;&amp; map <span class="keyword">instanceof</span> SortedMap) &#123;</span><br><span class="line">        <span class="comment">// 1、获取待添加的map的比较器</span></span><br><span class="line">        Comparator&lt;?&gt; c = ((SortedMap&lt;?,?&gt;)map).comparator();</span><br><span class="line">        <span class="comment">// 2、如果两个比较器相同，则执行以下逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (c == comparator || (c != <span class="keyword">null</span> &amp;&amp; c.equals(comparator))) &#123;</span><br><span class="line">            <span class="comment">// 3、修改次数+1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4、基于排序数据的线性时间树构建算法，进行build</span></span><br><span class="line">                buildFromSorted(mapSize, map.entrySet().iterator(),</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三、如果不符合上面的条件，则执行父类的 putAll 方法</span></span><br><span class="line">    <span class="keyword">super</span>.putAll(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面源码，不难看出，我们的数据符合 流程二，但是不符合 流程二-2，所以我们会执行父类的 putAll 方法，即流程三。</p><h3 id="2、分析-AbstractMap-putAll"><a href="#2、分析-AbstractMap-putAll" class="headerlink" title="2、分析 AbstractMap.putAll"></a>2、分析 AbstractMap.putAll</h3><p>TreeMap 继承 AbstractMap，所以 super.putAll(map)，执行的 putAll 为 AbstractMap 的 putAll 方法，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 m map，将它所有的值，使用put方法，全部添加到当前的map中</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码简单，就是一个遍历添加元素的。</p><p>但是有一个问题，这里的 put 方法执行的是谁的 put 方法呢？</p><ul><li>1、AbstractMap.put</li><li>2、TreeMap.put</li></ul><p>这里大家可以先思考1分钟，然后再继续往下看。</p><p>答案是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行的是 TreeMap.put</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回答错误 or 不知道真实原因的小伙伴，可以去网上搜搜答案，这里是一个很重要的基础知识点哦。</p><h3 id="3、分析-TreeMap-put"><a href="#3、分析-TreeMap-put" class="headerlink" title="3、分析 TreeMap.put"></a>3、分析 TreeMap.put</h3><p>源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、获取根节点</span></span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">// 二、判断跟节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 类型检查 and null 检查</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">// 创建根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> TreeMap.Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 修改次数加1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 三、如果比较器不为空，则执行一下逻辑，即自定义比较器执行逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 1、将t节点赋值给parent</span></span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">// 2、比较t节点的key是否与待添加的key相等</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="comment">// 3、如果返回值小于0，则将左子树赋值给t节点，即后续遍历左子树</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="comment">// 4、如果返回值大于0，则将右子树赋值给t节点，即后续遍历右子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 5、如果返回值为0，则覆盖原来的值</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 四、如果比较器为空，则执行以下逻辑，即默认执行逻辑</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这部分逻辑，先忽略</span></span><br><span class="line">    &#125;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; e = <span class="keyword">new</span> TreeMap.Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们结合上面的源码和我们自定义的排序器，就可以发现以下问题：</p><p>1、我们比较的是两个 value 的大小，而 value 可能是一样的。</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A81.jpg" alt="比较器1"></p><p>这种情况下，就会覆盖原来的值，这个就是我们执行 putAll 后，元素缺失的原因了。</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A82.jpg" alt="比较器2"></p><p>好了既然问题找到了，那如何解决这个问题呢？</p><p>如果是你，你会怎么解决呢？可以花一分钟时间思考一下，再看后面的内容。</p><h3 id="4、解决-TreeMap-putAll，元素缺失的问题"><a href="#4、解决-TreeMap-putAll，元素缺失的问题" class="headerlink" title="4、解决 TreeMap.putAll，元素缺失的问题"></a>4、解决 TreeMap.putAll，元素缺失的问题</h3><p>我当时想到最直接的方案就是，在 value 相等的情况下，不返回 0，返回1 or -1，这样就可以最简单、最快捷的解决这个问题了。</p><p>修改后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里换了一种写法，是java8的特性，简化了代码（为了偷懒）</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap2 = <span class="keyword">new</span> TreeMap&lt;&gt;((key1, key2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 1、如果v1等于v2，则值为0</span></span><br><span class="line">    <span class="comment">// 2、如果v1小于v2，则值为-1</span></span><br><span class="line">    <span class="comment">// 3、如果v1等于v2，则值为1</span></span><br><span class="line">    Integer value1 = map.get(key1);</span><br><span class="line">    Integer value2 = map.get(key2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value1.compareTo(value2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">treeMap2.putAll(map);</span><br><span class="line">System.out.println(treeMap2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>=<span class="number">10</span>, <span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以发现，3个值都有了，并且是有序的，完美符合需求！好了，关机下班！</p><p><img src="/img/image/blog/20220116/%E5%85%B3%E6%9C%BA%E4%B8%8B%E7%8F%AD.webp" alt="关机下班"></p><p>然而事情并没有结束<strong>（大家可以想一下，这样写会有什么问题呢？）</strong>！</p><h2 id="新的问题出现"><a href="#新的问题出现" class="headerlink" title="新的问题出现"></a>新的问题出现</h2><p>第二天，高高兴兴的写着业务代码、调试逻辑，突然一个<strong>空指针</strong>的报错，出现了。这也太常见了吧，3分钟内解决！</p><p><img src="/img/image/blog/20220116/2000%E5%B9%B4%E4%B9%8B%E5%90%8E.jpeg" alt="2000年之后"></p><p>排查了半天，发现又回到了昨天的修改的那段逻辑了。</p><h3 id="1、TreeMap-get-获取不到值"><a href="#1、TreeMap-get-获取不到值" class="headerlink" title="1、TreeMap.get 获取不到值"></a>1、TreeMap.get 获取不到值</h3><p>简化版代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设，key=商品id，value=商品剩余库存</span></span><br><span class="line">Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1L</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2L</span>, <span class="number">20</span>);</span><br><span class="line">map.put(<span class="number">3L</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">Map&lt;Long, Integer&gt; treeMap2 = <span class="keyword">new</span> TreeMap&lt;&gt;((key1, key2) -&gt; &#123;</span><br><span class="line">    Integer value1 = map.get(key1);</span><br><span class="line">    Integer value2 = map.get(key2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = value1.compareTo(value2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">treeMap2.putAll(map);</span><br><span class="line">System.out.println(treeMap2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取商品1的剩余数量</span></span><br><span class="line">Integer quantity = treeMap2.get(<span class="number">1L</span>);</span><br><span class="line">System.out.println(quantity);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行后的结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3</span>=<span class="number">10</span>, <span class="number">1</span>=<span class="number">10</span>, <span class="number">2</span>=<span class="number">20</span>&#125;</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个结果令我百思不得其解，只能看看源码咯。</p><h3 id="2、分析-TreeMap-get"><a href="#2、分析-TreeMap-get" class="headerlink" title="2、分析 TreeMap.get"></a>2、分析 TreeMap.get</h3><p>源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据key获取节点</span></span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="comment">// 节点为空则返回null，否则返回节点的 value 值</span></span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、如果比较器不为空，则执行一下逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 1、使用自定义比较器取出key对应的节点</span></span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// 二、如果比较器为空，且key为null，则抛空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">// 三、取出key对应的节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的源码，我们可以发现，问题肯定就是出现在 getEntryUsingComparator 方法里了。</p><h3 id="2、分析-TreeMap-getEntryUsingComparator"><a href="#2、分析-TreeMap-getEntryUsingComparator" class="headerlink" title="2、分析 TreeMap.getEntryUsingComparator"></a>2、分析 TreeMap.getEntryUsingComparator</h3><p>源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一、将key转换成对应的类型</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    K k = (K) key;</span><br><span class="line">    <span class="comment">// 二、获取比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">// 三、判断比较器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、遍历map，取出key对应的节点对象</span></span><br><span class="line">        TreeMap.Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="comment">// 2、如果小于0，则将左节点的值赋值给p</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="comment">// 3、如果大于0，则将右节点的值赋值给p</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 4、如果等于0，则返回p节点</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合上面的源码，和我们之前自定义的比较器，我们不难发现问题出现在哪里：</p><p><img src="/img/image/blog/20220116/%E6%AF%94%E8%BE%83%E5%99%A83.jpg" alt="比较器3"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自定义比较器，没有返回0的情况</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题找到了，解决吧！<br>加班中，今天到此结束！<br>啊杰，在这里谢谢大家的观看，下次再见。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot;&gt;&lt;a href=&quot;#摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot; class=&quot;headerlink&quot; title=&quot;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&quot;&gt;&lt;/a&gt;摘要：最近在开发过程中，因为重写了TreeMap的比较器，而引发了一些有趣的问题。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;1、给一个无序的map，按照value的值进行排序，value值越小，排在越前面。&lt;br&gt;2、key和value都不为null&lt;br&gt;3、value可能相同&lt;br&gt;4、返回结果为一个相同的有序map&lt;/p&gt;
&lt;p&gt;代码如下所示:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 假设，key=商品id，value=商品剩余库存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Map&amp;lt;Long, Integer&amp;gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;1L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;2L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.put(&lt;span class=&quot;number&quot;&gt;3L&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;到这里，大家可以先想想，如果是你会怎么解决？&lt;/p&gt;</summary>
    
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    <category term="Map" scheme="https://www.blog.ajie39.top/tags/Map/"/>
    
    <category term="Java基础" scheme="https://www.blog.ajie39.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="源码分析" scheme="https://www.blog.ajie39.top/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Jackson序列化时间类型的数据导致的相关问题</title>
    <link href="https://www.blog.ajie39.top/2021/12/03/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://www.blog.ajie39.top/2021/12/03/Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-02T17:17:52.573Z</published>
    <updated>2022-02-04T15:03:56.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。"><a href="#前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。" class="headerlink" title="前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。"></a>前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。</h1><hr><span id="more"></span><h2 id="1、现象"><a href="#1、现象" class="headerlink" title="1、现象"></a>1、现象</h2><p>在开发国际化项目中发现，数据库取出的时间和对象拿到的时间都是一致的，但是通过 postman 调用接口展示的时候，时间和数据库的时间相差8小时。</p><h2 id="2、原因"><a href="#2、原因" class="headerlink" title="2、原因"></a>2、原因</h2><p>SpringBoot 默认使用 Jackson 为序列化工具，Jackson 在没有指定序列化和反序列化形式的情况下，会采用默认的序列化方式。</p><p>其中 date 类型的数据，默认的序列化格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ</span><br><span class="line">例如：</span><br><span class="line"> 2021-06-08T05:43:28.000+0000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中时间的默认时区为UTC+0，在传输的过程中，会以字符串的形式按照上面的格式进行序列化。而国内的时区是 UTC+8，所以最终时间会相差 8小时。</p><p>各个符号解释：</p><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>YYYY</td><td>is the decimal digits of the year 0000 to 9999 in the Gregorian calendar.</td></tr><tr><td>-</td><td>“-“ (hyphen) appears literally twice in the string.</td></tr><tr><td>MM</td><td>is the month of the year from 01 (January) to 12 (December).</td></tr><tr><td>DD</td><td>is the day of the month from 01 to 31.</td></tr><tr><td>T</td><td>“T” appears literally in the string, to indicate the beginning of the time element.</td></tr><tr><td>HH</td><td>is the number of complete hours that have passed since midnight as two decimal digits from 00 to 24.</td></tr><tr><td>:</td><td>“:” (colon) appears literally twice in the string.</td></tr><tr><td>mm</td><td>is the number of complete minutes since the start of the hour as two decimal digits from 00 to 59.</td></tr><tr><td>ss</td><td>is the number of complete seconds since the start of the minute as two decimal digits from 00 to 59.</td></tr><tr><td>.</td><td>“.” (dot) appears literally in the string.</td></tr><tr><td>sss</td><td>is the number of complete milliseconds since the start of the second as three decimal digits.</td></tr><tr><td>Z</td><td>is the time zone offset specified as “Z” (for UTC) or either “+” or “-“ followed by a time expression HH:mm</td></tr></tbody></table><h2 id="3、解决"><a href="#3、解决" class="headerlink" title="3、解决"></a>3、解决</h2><h3 id="①前端拿到这样的数据的时候，需要做如下处理："><a href="#①前端拿到这样的数据的时候，需要做如下处理：" class="headerlink" title="①前端拿到这样的数据的时候，需要做如下处理："></a>①前端拿到这样的数据的时候，需要做如下处理：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">new Date(&#39;2021-06-08T05:43:28.000+0000&#39;)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">moment(date).format(&#39;YYYY-MM-DD HH:mm:ss&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式化前后的区别：</p><p><img src="/img/image/blog/20220204/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%90%8E%E7%9A%84%E6%95%88%E6%9E%9C.png" alt="格式化后的效果"></p><h3 id="②如果使用-Fegin-Client"><a href="#②如果使用-Fegin-Client" class="headerlink" title="②如果使用 Fegin Client"></a>②如果使用 Fegin Client</h3><p>需要确认服务端的时间格式，如果没有指定格式，则使用默认格式。</p><p>具体使用：在对应字段加上 @JsonFormat 注解即可，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@JsonFormat(shape &#x3D; JsonFormat.Shape.STRING, pattern &#x3D; &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;)</span><br><span class="line">private Date inserttime;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="③SpringBoot-全局配置-JsonFormat-date的序列化方式"><a href="#③SpringBoot-全局配置-JsonFormat-date的序列化方式" class="headerlink" title="③SpringBoot 全局配置 JsonFormat date的序列化方式"></a>③SpringBoot 全局配置 JsonFormat date的序列化方式</h3><p>在 application.yml 文件加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  jackson:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ssZ</span><br><span class="line">  mvc:</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ssZ</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、其他问题"><a href="#4、其他问题" class="headerlink" title="4、其他问题"></a>4、其他问题</h2><p>①支持 Java 8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-datatype-jsr310&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在添加 JSR-310 模块后, 让 jackson 能够识别出 Java 8 的日期 &amp; 时间类型(pom.xml)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/aerchi/article/details/78717232">https://blog.csdn.net/aerchi/article/details/78717232</a></p><p><a href="https://xiaoym.gitee.io/2021/03/26/spring-boot-code-action-jackson/">https://xiaoym.gitee.io/2021/03/26/spring-boot-code-action-jackson/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。&quot;&gt;&lt;a href=&quot;#前言：在开发国际化项目的过程中，使用-Jackson-序列化时间类型的数据导致的相关问题。&quot; class=&quot;headerlink&quot; title=&quot;前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。&quot;&gt;&lt;/a&gt;前言：在开发国际化项目的过程中，使用 Jackson 序列化时间类型的数据导致的相关问题。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/categories/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="Jackson" scheme="https://www.blog.ajie39.top/tags/Jackson/"/>
    
    <category term="问题总结" scheme="https://www.blog.ajie39.top/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>算法--排序奇升偶降链表</title>
    <link href="https://www.blog.ajie39.top/2021/11/21/%E6%8E%92%E5%BA%8F%E5%A5%87%E5%8D%87%E5%81%B6%E9%99%8D%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.blog.ajie39.top/2021/11/21/%E6%8E%92%E5%BA%8F%E5%A5%87%E5%8D%87%E5%81%B6%E9%99%8D%E9%93%BE%E8%A1%A8/</id>
    <published>2021-11-21T07:36:47.986Z</published>
    <updated>2021-11-21T07:47:42.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分"><a href="#摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分" class="headerlink" title="摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分"></a>摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分</h1><hr><h1 id="前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。"><a href="#前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。" class="headerlink" title="前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。"></a>前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。</h1><p>输入: 1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;NULL</p><p>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL</p><hr><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步：根据奇偶顺序，将链表拆分成两个链表</p><p>第二步：将偶链表，翻转，变成升序链表(这部分可以优化，在第一步拆分链表时，就将链表翻转)</p><p>第三步：排序两个链表</p><p>leetcode 类似题目：</p><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">奇偶链表</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></p><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">合并两个有序链表</a></p><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ListNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;val=&quot;</span> + val +</span><br><span class="line">                <span class="string">&quot;, next=&quot;</span> + next +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1-&gt;8-&gt;3-&gt;6-&gt;5-&gt;4-&gt;7-&gt;2-&gt;NULL</span></span><br><span class="line">        ListNode listNode = <span class="keyword">new</span> ListNode(<span class="number">1</span>, <span class="keyword">new</span> ListNode(<span class="number">8</span>,</span><br><span class="line">                <span class="keyword">new</span> ListNode(<span class="number">3</span>, <span class="keyword">new</span> ListNode(<span class="number">6</span>, <span class="keyword">new</span> ListNode(<span class="number">5</span>, <span class="keyword">new</span> ListNode(<span class="number">4</span>,</span><br><span class="line">                        <span class="keyword">new</span> ListNode(<span class="number">7</span>, <span class="keyword">new</span> ListNode(<span class="number">2</span>))))))));</span><br><span class="line">        sortList(listNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">sortList</span><span class="params">(ListNode root)</span> </span>&#123;</span><br><span class="line">        ListNode rootNode = <span class="keyword">new</span> ListNode(root.val, root.next);</span><br><span class="line">        ListNode leftRoot = <span class="keyword">null</span>;</span><br><span class="line">        ListNode leftTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode rightRoot = <span class="keyword">null</span>;</span><br><span class="line">        ListNode rightTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分成两个链表</span></span><br><span class="line">        <span class="keyword">while</span> (rootNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 找出奇数链表</span></span><br><span class="line">                <span class="keyword">if</span> (leftRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    leftTemp.val = rootNode.val;</span><br><span class="line">                    leftRoot = leftTemp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    leftTemp.next = <span class="keyword">new</span> ListNode(rootNode.val);</span><br><span class="line">                    leftTemp = leftTemp.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rightRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rightTemp.val = rootNode.val;</span><br><span class="line">                    rightRoot = rightTemp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 找出偶数链表并翻转链表</span></span><br><span class="line">                    rightRoot = <span class="keyword">new</span> ListNode(rootNode.val, rightTemp);</span><br><span class="line">                    rightTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">                    rightTemp.val = rightRoot.val;</span><br><span class="line">                    rightTemp.next = rightRoot.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rootNode = rootNode.next;</span><br><span class="line">            flag = !flag;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链表排序</span></span><br><span class="line">        rootNode = <span class="keyword">null</span>;</span><br><span class="line">        ListNode rootTemp = <span class="keyword">new</span> ListNode();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> leftNum = leftRoot.val;</span><br><span class="line">               <span class="keyword">if</span> (rightRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">int</span> rightNum = rightRoot.val;</span><br><span class="line">                   <span class="keyword">if</span> (leftNum &gt; rightNum) &#123;</span><br><span class="line">                       ListNode[] listArr = getNode(rootNode, rootTemp, rightRoot);</span><br><span class="line">                       rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">                       rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">                       rightRoot = rightRoot.next;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               ListNode[] listArr = getNode(rootNode, rootTemp, leftRoot);</span><br><span class="line">               rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">               rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">               leftRoot = leftRoot.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode[] listArr = getNode(rootNode, rootTemp, rightRoot);</span><br><span class="line">                rootNode = listArr[<span class="number">0</span>];</span><br><span class="line">                rootTemp = listArr[<span class="number">1</span>];</span><br><span class="line">                rightRoot = rightRoot.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rootNode);</span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode[] getNode(ListNode rootNode, ListNode rootTemp, ListNode transferNode) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = transferNode.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rootTemp.val = num;</span><br><span class="line">            rootNode = rootTemp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rootTemp.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">            rootTemp = rootTemp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListNode[]&#123;rootNode, rootTemp&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot;&gt;&lt;a href=&quot;#摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot; class=&quot;headerlink&quot; title=&quot;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&quot;&gt;&lt;/a&gt;摘要：链表相关的面试题，涉及链表排序、链表翻转、链表拆分&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot;&gt;&lt;a href=&quot;#前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot; class=&quot;headerlink&quot; title=&quot;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&quot;&gt;&lt;/a&gt;前言：给定一个奇数位升序，偶数位降序的链表，将其重新排序。&lt;/h1&gt;&lt;p&gt;输入: 1-&amp;gt;8-&amp;gt;3-&amp;gt;6-&amp;gt;5-&amp;gt;4-&amp;gt;7-&amp;gt;2-&amp;gt;NULL&lt;/p&gt;
&lt;p&gt;输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6-&amp;gt;7-&amp;gt;8-&amp;gt;NULL&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法" scheme="https://www.blog.ajie39.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何写容易测试的代码（结尾附带单元测试神器推荐）</title>
    <link href="https://www.blog.ajie39.top/2021/10/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E5%8F%A6%E6%9C%89%E7%A5%9E%E5%99%A8%E5%88%86%E4%BA%AB%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/10/25/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E5%8F%A6%E6%9C%89%E7%A5%9E%E5%99%A8%E5%88%86%E4%BA%AB%EF%BC%89/</id>
    <published>2021-10-24T16:13:02.000Z</published>
    <updated>2021-12-13T16:24:00.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。"><a href="#摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。" class="headerlink" title="摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。"></a>摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。</h1><hr><h1 id="前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。"><a href="#前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。" class="headerlink" title="前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。"></a>前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。</h1><hr><span id="more"></span><h2 id="关于单元测试"><a href="#关于单元测试" class="headerlink" title="关于单元测试"></a>关于单元测试</h2><h3 id="一、什么是单元测试？"><a href="#一、什么是单元测试？" class="headerlink" title="一、什么是单元测试？"></a>一、什么是单元测试？</h3><p>单元测试（英语：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p><p>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是必须的，但也不坏，这牵涉到项目管理的政策决定。</p><p><strong>总结：对于程序单元（软件设计的最小单位）进行正确性检验。</strong></p><h3 id="二、关于编写单元测试的一些声音"><a href="#二、关于编写单元测试的一些声音" class="headerlink" title="二、关于编写单元测试的一些声音"></a>二、关于编写单元测试的一些声音</h3><p>不愿写单元测试的人，千篇一律——这里收集了一些网友们不愿意写单元测试的原因：</p><ul><li>开发时间太紧张了，还要写单元测试？没时间呀！！！有时间我也愿意写。</li><li>我直接进行接口测试、功能测试、集成测试、系统测试。。。不就行了，速度快，而且效率高，要写啥单元测试。</li><li>有测试工程师了，我要写啥单元测试，让测试工程师测试不就好了，分工明确。</li><li>单元测试仅仅是证明这些代码做了什么，写了没有意义呀，这些代码都是我写的，我知道它们是做什么的。</li><li>测试代码的正确性，是测试工程师的工作，如果我找出了所有问题，我的工资可以翻倍吗？</li><li>我在开发环境发布后，通过测试业务，来验证我代码的正确性就好了，不需要通过单元测试。</li></ul><p>总结：</p><ul><li>开发时间太紧张，写单元测试太耗费时间。</li><li>有其他测试流程做了单元测试做的事情，没必要重复劳动。</li><li>开发工程师负责开发，测试工程师负责测试。</li><li>写单元测试对于我没有收益。</li><li>我可以直接执行代码，来验证正确性，没必要通过单元测试。</li><li>代码都是我写的，我知道是做什么的，写单元测试没有意义。</li></ul><h3 id="二、单元测试的好处"><a href="#二、单元测试的好处" class="headerlink" title="二、单元测试的好处"></a>二、单元测试的好处</h3><h4 id="1、适应变更"><a href="#1、适应变更" class="headerlink" title="1、适应变更"></a>1、适应变更</h4><p>单元测试允许程序员在未来重构代码，并且确保模块依然工作正确（复合测试）。这个过程就是为所有函数和方法编写单元测试，一旦变更导致错误发生，借助于单元测试可以快速定位并修复错误。</p><p>可读性强的单元测试可以使程序员方便地检查代码片断是否依然正常工作。良好设计的单元测试案例覆盖程序单元分支和循环条件的所有路径。</p><p>在连续的单元测试环境，通过其固有的持续维护工作，单元测试可以延续用于准确反映当任何变更发生时可执行程序和代码的表现。借助于上述开发实践和单元测试的覆盖，可以分分秒秒维持准确性。</p><p>总结：</p><ul><li>代码变更后，快速的验证业务逻辑是否正确，快速定位问题。一定程度上，缓解不敢更改老旧逻辑的情况。</li></ul><h4 id="2、简化集成"><a href="#2、简化集成" class="headerlink" title="2、简化集成"></a>2、简化集成</h4><p>单元测试消除程序单元的不可靠，采用自底向上的测试路径。通过先测试程序部件再测试部件组装，使集成测试变得更加简单。</p><p>业界对于人工集成测试的必要性存在较大争议。尽管精心设计的单元测试体系看上去实现了集成测试，因为集成测试需要人为评估一些人为因素才能证实的方面，单元测试替代集成测试不可信。一些人认为在足够的自动化测试系统的条件下，人力集成测试组不再是必需的。事实上，真实的需求最终取决于开发产品的特点和使用目标。另外，人工或手动测试很大程度上依赖于组织的可用资源。</p><p>总结：</p><ul><li>在开发过程中，可以屏蔽部分外部依赖，验证程序的正确性。</li></ul><h4 id="3、文档记录"><a href="#3、文档记录" class="headerlink" title="3、文档记录"></a>3、文档记录</h4><p>单元测试提供了系统的一种文档记录。借助于查看单元测试提供的功能和单元测试中如何使用程序单元，开发人员可以直观的理解程序单元的基础API。</p><p>单元测试具体表现了程序单元成功的关键特点。这些特点可以指出正确使用和非正确使用程序单元，也能指出需要捕获的程序单元的负面表现（译注：异常和错误）。尽管很多软件开发环境不仅依赖于代码做为产品文档，在单元测试中和单元测试本身确实文档化了程序单元的上述关键特点。</p><p>另一方面，传统文档易受程序本身实现的影响，并且时效性难以保证（如设计变更、功能扩展等在不太严格时经常不能保持文档同步更新）。</p><ul><li>有助于他人或者自己（在自己遗忘的情况下）快速了解业务逻辑。</li></ul><h4 id="4、表达设计（测试驱动开发）"><a href="#4、表达设计（测试驱动开发）" class="headerlink" title="4、表达设计（测试驱动开发）"></a>4、表达设计（测试驱动开发）</h4><p>在测试驱动开发的软件实践中，单元测试可以取代正式的设计。每一个单元测试案例均可以视为一项类、方法和待观察行为等设计元素。</p><p>不同于其他基于图的设计方法，用单元测试表达设计有一项显著优点：设计文档（单元测试本身）可以用于验证程序实现符合设计。UML可能会遇到这样的问题：尽管图上一个类被命名为Customer，但开发人员可以称其为Wibble，而且系统中没有任何地方会显示出这个差异。基于单元测试设计方法，开发人员不遵循设计要求的解决方案永远不会通过测试。</p><p>当然，单元测试缺乏图的可读性，但UML图可以在自由工具（通常可从IDE扩展获取）中为大多数现代程序语言生成UML图，很难要求采购昂贵的UML设计套装软件。自由工具，类似于基于xUnit框架的工具，测试结果输出到一些可生成供人工识读的图形化工具系统中去。</p><p>总结：</p><ul><li>测试驱动开发，利用单元测试表达接口设计</li></ul><h2 id="如何写好单元测试？"><a href="#如何写好单元测试？" class="headerlink" title="如何写好单元测试？"></a>如何写好单元测试？</h2><p>虚假的标题：如何写好单元测试</p><p>真实的标题：如何写容易测试的代码</p><p>编写单元测试没有任何技巧，只有编写可测试代码的技巧。</p><p><img src="/img/image/blog/20211024/%E9%97%AE%E5%8F%B7.jpeg" alt="问号"></p><p>为什么说编写单元测试没有任何技巧呢？因为单元测试的本质就是验证你代码的正确性，代码如果写的不好、不可被单独测试，那么单元测试也无能为力。单元测试本来就是枯燥的事情，并没有任何捷径。</p><h3 id="一、为什么写容易测试的代码很重要？"><a href="#一、为什么写容易测试的代码很重要？" class="headerlink" title="一、为什么写容易测试的代码很重要？"></a>一、为什么写容易测试的代码很重要？</h3><p>渣男：我在忙，晚点聊</p><p>暖男：我正在开会，大概6.30左右结束，到时候回复你。</p><p>容易测试的代码通常意味：</p><ul><li>更容易理解：更容易理解意图，写出有效的测试case</li><li>更好维护：容易单元测试的代码一般解耦做的更好，便于后期维护</li></ul><p>于是乎，容易测试——》容易理解——》容易维护，三者形成了闭环。</p><p><img src="/img/image/blog/20211024/%E5%AE%B9%E6%98%93%E6%B5%8B%E8%AF%95.png" alt="容易测试"></p><h3 id="二、导致测试不好写的几类问题"><a href="#二、导致测试不好写的几类问题" class="headerlink" title="二、导致测试不好写的几类问题"></a>二、导致测试不好写的几类问题</h3><h4 id="1、复杂的构造函数-or-无参的构造函数"><a href="#1、复杂的构造函数-or-无参的构造函数" class="headerlink" title="1、复杂的构造函数 or 无参的构造函数"></a>1、复杂的构造函数 or 无参的构造函数</h4><p><img src="/img/image/blog/20211024/%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png" alt="复杂的构造函数"></p><h4 id="2、混合业务逻辑和构建依赖对象的逻辑"><a href="#2、混合业务逻辑和构建依赖对象的逻辑" class="headerlink" title="2、混合业务逻辑和构建依赖对象的逻辑"></a>2、混合业务逻辑和构建依赖对象的逻辑</h4><p><img src="/img/image/blog/20211024/%E6%B7%B7%E5%90%88%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%92%8C%E6%9E%84%E5%BB%BA%E4%BE%9D%E8%B5%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%80%BB%E8%BE%91.png" alt="混合业务逻辑和构建依赖对象的逻辑"></p><h4 id="3、太多、嵌套太深的条件判断语句"><a href="#3、太多、嵌套太深的条件判断语句" class="headerlink" title="3、太多、嵌套太深的条件判断语句"></a>3、太多、嵌套太深的条件判断语句</h4><p><img src="/img/image/blog/20211024/%E5%A4%AA%E5%A4%9A%E3%80%81%E5%B5%8C%E5%A5%97%E5%A4%AA%E6%B7%B1%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5.png" alt="太多、嵌套太深的条件判断语句"></p><h4 id="4、不必要的、太深的继承"><a href="#4、不必要的、太深的继承" class="headerlink" title="4、不必要的、太深的继承"></a>4、不必要的、太深的继承</h4><p><img src="/img/image/blog/20211024/%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E3%80%81%E5%A4%AA%E6%B7%B1%E7%9A%84%E7%BB%A7%E6%89%BF.png" alt="不必要的、太深的继承"></p><h4 id="5、在一个方法内混合纯计算与IO"><a href="#5、在一个方法内混合纯计算与IO" class="headerlink" title="5、在一个方法内混合纯计算与IO"></a>5、在一个方法内混合纯计算与IO</h4><p><img src="/img/image/blog/20211024/%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%86%85%E6%B7%B7%E5%90%88%E7%BA%AF%E8%AE%A1%E7%AE%97%E4%B8%8EIO.png" alt="在一个方法内混合纯计算与IO"></p><h4 id="6、不写毫无价值的单元测试"><a href="#6、不写毫无价值的单元测试" class="headerlink" title="6、不写毫无价值的单元测试"></a>6、不写毫无价值的单元测试</h4><p><img src="/img/image/blog/20211024/%E4%B8%8D%E5%86%99%E6%AF%AB%E6%97%A0%E4%BB%B7%E5%80%BC%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.jpeg" alt="不写毫无价值的单元测试"></p><h3 id="三、让测试更简单的一些建议"><a href="#三、让测试更简单的一些建议" class="headerlink" title="三、让测试更简单的一些建议"></a>三、让测试更简单的一些建议</h3><ul><li>使用依赖注入器(dependency injector), 而不是尝试手动创建 object graph</li><li>坚持单一原则：努力做到能用一句话描述一个 method 的功能</li><li>坚持最少知识原则：只使用直接依赖对象的API，不使用间接依赖对象的API(不要有 .getX().doY())</li><li>警惕使用 static 和 new 关键字</li><li>优先使用组合而不是继承</li><li>使用多态替代复杂的条件语句</li><li>尽量写无副作用的函数</li><li>用 give-when-then（准备、执行、校验） 为每个 test case 做三段式注释</li></ul><h2 id="一些-mock-技巧"><a href="#一些-mock-技巧" class="headerlink" title="一些 mock 技巧"></a>一些 mock 技巧</h2><h3 id="一、推荐使用构造器注入"><a href="#一、推荐使用构造器注入" class="headerlink" title="一、推荐使用构造器注入"></a>一、推荐使用构造器注入</h3><p>推荐阅读文章：</p><p>spring 官方文章：<a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">Setter injection versus constructor injection and the use of @Required</a></p><p>腾讯云专栏：<a href="https://cloud.tencent.com/developer/article/1126880">【Spring】浅谈spring为什么推荐使用构造器注入</a></p><p>使用构造器注入的好处，总结：</p><ul><li>保证依赖不可变（final关键字）</li><li>保证依赖不为空（省去了我们对其检查）</li><li>保证返回客户端（调用）的代码的时候是完全初始化的状态</li><li>避免了循环依赖</li><li>提升了代码的可复用性</li></ul><p>对于单元测试的好处：更容易的 mock 依赖对象</p><h3 id="二、如何mock-Value注解修饰的变量"><a href="#二、如何mock-Value注解修饰的变量" class="headerlink" title="二、如何mock @Value注解修饰的变量"></a>二、如何mock @Value注解修饰的变量</h3><p>参考文章：</p><ul><li><a href="https://my.oschina.net/u/4286379/blog/4455366">编写单测时，使用mock如何解决使用用@Value注解注入的属性</a></li><li><a href="https://stackoverflow.com/questions/23162777/how-do-i-mock-an-autowired-value-field-in-spring-with-mockito">How do I mock an autowired @Value field in Spring with Mockito?</a></li></ul><h3 id="三、如何mock静态方法"><a href="#三、如何mock静态方法" class="headerlink" title="三、如何mock静态方法"></a>三、如何mock静态方法</h3><p>参考文章：</p><ul><li><a href="https://frontbackend.com/java/how-to-mock-static-methods-with-mockito">How to mock static methods with Mockito</a></li><li><a href="https://yanbin.blog/mockito-3-4-0-mock-static-method/">Mockito 3.4.0 开始可 Mock 静态方法</a></li></ul><h3 id="四、如何校验没有返回值的方法"><a href="#四、如何校验没有返回值的方法" class="headerlink" title="四、如何校验没有返回值的方法"></a>四、如何校验没有返回值的方法</h3><p>校验关键逻辑是否都被调用。</p><p><img src="/img/image/blog/20211024/%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="如何校验没有返回值的方法"></p><h2 id="附：单元测试神器"><a href="#附：单元测试神器" class="headerlink" title="附：单元测试神器"></a>附：单元测试神器</h2><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>说起来，这是一个悲伤的故事，公司要求今年第四季度结束前，所有项目的单元测试覆盖率要达到50%。</p><p>于是乎，我开始炸毛了，新项目进度紧张吧，编写单元测试非常耗时，而且还有一堆老旧项目单元测试覆盖率基本为0%，这要慢慢写，不得补到天荒地老？？？？？</p><p>而且在编写单元测试的过程中，其实是有很大一部份内容是重复劳动，作为一名开发者，对于这种重复且量大的工作，肯定第一个想法就是可不可以通过技术手段，减少这部分工作的耗时，以及操作步骤。</p><h3 id="二、神器介绍"><a href="#二、神器介绍" class="headerlink" title="二、神器介绍"></a>二、神器介绍</h3><p><a href="https://weirddev.com/testme/">https://weirddev.com/testme/</a><br><a href="https://squaretest.com/">https://squaretest.com/</a>  付费<br><a href="http://www.evosuite.org/">http://www.evosuite.org/</a><br><a href="https://randoop.github.io/randoop/">https://randoop.github.io/randoop/</a></p><h3 id="三、神器之TestMe"><a href="#三、神器之TestMe" class="headerlink" title="三、神器之TestMe"></a>三、神器之TestMe</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>TestMe 是一款 IntelliJ 插件，用于生成单元测试样板代码。</p><p>TestMe 支持的单元测试模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Unit4 + Mockito</span><br><span class="line">Unit5 + Mockito</span><br><span class="line">TestNG + Mockito</span><br><span class="line">Groovy +Unit4 + Mockito</span><br><span class="line">Spock + Mockito</span><br><span class="line">Spock Parameterized tests+ Mockito</span><br><span class="line">Specs2(Scala) + Mockito</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h5><ul><li>在 Java、Groovy 或 Scala 中自动生成单元测试代码</li><li>为测试类的非原始字段生成模拟</li><li>支持 Mockito 作为 Mock 框架</li><li>支持 JUnit4、JUnit5、TestNG 和 Spock 框架</li><li>为每个可访问的非私有方法生成测试方法，不包括 setter/getter</li><li>为测试方法生成默认输入参数</li><li>生成测试结果断言表达式</li><li>支持的目标测试类语言： Java、Groovy、Scala。</li></ul><p>示例：<br><img src="/img/image/blog/20211024/simple-use-case.gif" alt="&quot;示例&quot;"></p><h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><h5 id="1、-从-IntelliJ-IDEA-中安装最新版本，并重启IDEA"><a href="#1、-从-IntelliJ-IDEA-中安装最新版本，并重启IDEA" class="headerlink" title="1、 从 IntelliJ IDEA 中安装最新版本，并重启IDEA"></a>1、 从 IntelliJ IDEA 中安装最新版本，并重启IDEA</h5><p>在IDEA菜单：Preferences（Ctrl+ Shift+ S） - &gt; Plugins- &gt; Browse repositories…- &gt;搜索：TestMe- &gt;Install Plugin</p><p><img src="/img/image/blog/20211024/TestMe%E6%88%AA%E5%9B%BE01.png" alt="&quot;TestMe截图01&quot;"></p><h5 id="2、生成测试代码模板"><a href="#2、生成测试代码模板" class="headerlink" title="2、生成测试代码模板"></a>2、生成测试代码模板</h5><h6 id="1）选择测试类："><a href="#1）选择测试类：" class="headerlink" title="1）选择测试类："></a>1）选择测试类：</h6><p>选择一个需要测试的类 -》 alt + Insert 跳出如下选择框</p><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%811.png" alt="&quot;生成代码1&quot;"></p><h6 id="2）选择测试工具："><a href="#2）选择测试工具：" class="headerlink" title="2）选择测试工具："></a>2）选择测试工具：</h6><p>并选择 TestMe 后跳出如下选项框</p><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%812.png" alt="&quot;生成代码2&quot;"></p><p>选择你最常用的测试工具即可，我比较常用的是 Unit4 + Mockito，所以我选择的是第一个。</p><h6 id="3）根据生成的测试模板代码修改测试用例"><a href="#3）根据生成的测试模板代码修改测试用例" class="headerlink" title="3）根据生成的测试模板代码修改测试用例"></a>3）根据生成的测试模板代码修改测试用例</h6><p><img src="/img/image/blog/20211024/%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%813.png" alt="&quot;生成代码3&quot;"></p><h5 id="ps："><a href="#ps：" class="headerlink" title="ps："></a>ps：</h5><p>默认值是为测试的方法参数自动生成的。目前，此行为不可配置。</p><p>作者解释：从某种意义上说，Groovy 测试生成器更健壮，可以使用映射构造函数（在适用时）通过内联 setter 初始化对象。Java 测试生成器尚不支持此类匹配功能，因为为测试参数初始化分配给局部变量会使测试生成模板复杂化。就我个人而言，在进行单元测试时，我总是建议使用 Groovy 而不是 Java。如果您还没有过渡到 Groovy作为您选择的测试代码语言 - 现在是开始的好时机:)</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">维基百科–单元测试</a></p><p><a href="https://testing.googleblog.com/2008/08/by-miko-hevery-so-you-decided-to.html">Writing Testable Code</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot;&gt;&lt;a href=&quot;#摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot; class=&quot;headerlink&quot; title=&quot;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&quot;&gt;&lt;/a&gt;摘要：分享一些个人在编写单元测试过程中遇到的问题，以及从写单元测试的角度出发，分析如何让我们写出”容易单元测试的代码”。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot;&gt;&lt;a href=&quot;#前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot; class=&quot;headerlink&quot; title=&quot;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&quot;&gt;&lt;/a&gt;前言：单元测试是所有测试体系里的一个部分，而非全部，不能解决所有问题。覆盖率并不是越高，就能保证系统绝对不出错。为了单元测试，而单元测试是不可取的。单元测试最主要的目的之一，是为了提高我们的代码质量。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="测试" scheme="https://www.blog.ajie39.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="https://www.blog.ajie39.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="开发基础" scheme="https://www.blog.ajie39.top/tags/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（基础篇）</title>
    <link href="https://www.blog.ajie39.top/2021/06/29/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/06/29/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</id>
    <published>2021-06-29T15:25:40.000Z</published>
    <updated>2021-12-13T16:21:40.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（拓展篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（进阶篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、Redis 是什么?<br>2、Redis 的数据类型？<br>3、Redis 是单进程单线程的？<br>4、Redis 的持久化机制有哪些？各自的优缺点？<br>5、Redis 常见性能问题和解决方案：<br>6、Redis 过期键的删除策略？<br>7、Redis 的回收策略（淘汰策略）?<br>8、为什么 Redis 需要把所有数据放到内存中？<br>9、Redis 支持的 Java 客户端都有哪些？<br>10、Jedis 与 Redisson 对比有什么优缺点？<br>12、Pipeline 有什么好处，为什么要用 pipeline？<br>13、怎么理解 Redis 事务？<br>16、Redis 事务相关的命令有哪几个？<br>17、Redis key 的过期时间和永久有效分别怎么设置？<br>18、Redis 如何做内存优化？<br>20、Redis 回收进程如何工作的？<br>21、都有哪些办法可以降低 Redis 的内存使用情况呢？<br>22、Redis 的内存用完了会发生什么？<br>24、查看 Redis 使用情况及状态信息用什么命令？<br>25、怎么测试 Redis 的连通性？<br>28、修改配置不重启 Redis 会实时生效吗？<br>29、使用过 Redis 分布式锁么，它是什么回事？<br>30、使用过 Redis 做异步队列么，你是怎么用的？<br>31、Redis 最适合的场景？</p><h2 id="1、Redis-是什么？"><a href="#1、Redis-是什么？" class="headerlink" title="1、Redis 是什么？"></a>1、Redis 是什么？</h2><p>Redis 是一个 <code>远程内存数据库</code>，它不仅性能强劲，而且还具有 <code>复制特性</code> 以及 <code>为解决问题而生</code> 的独一无二的数据模型。Redis提供了 <code>5种不同类型的数据结构</code>，它可以存储键 (key) 与 5种不同类型的值 (value) 之间的映射(mapping)；可以将存储在内存的键值对数据待久化到硬盘，可以 <code>使用复制特性来扩展读性能</code>，还可以使用 <code>客户端分片来扩展写性能</code>，各式各样的问题都可以很自然地映射到这些数据结构上：Redis的数据结构致力千帮助用户解决问题，而不会像其他数据库那样，要求用户扭曲问题来适应数据库。除此之外，通过 <code>复制</code>、 <code>持久化(persistence)</code> 和 <code>客户端分片(client-side sharding)</code> 等特性，用户可以很方便地将 Redis 扩展成一个能够包含数百GB数据、 每秒处理上百万次请求的系统。</p><h2 id="2、Redis-的数据类型？"><a href="#2、Redis-的数据类型？" class="headerlink" title="2、Redis 的数据类型？"></a>2、Redis 的数据类型？</h2><p>Redis 数据库里面的每个键值对（key-value pair）都是由对象（object）组成的，其中：</p><ul><li>数据库 <code>键</code> 总是一个 <code>字符串对象（string object）</code>；</li><li>Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为 <code>String</code> (字符串)、 <code>List</code> （列表）、<code>Set</code>（集合）、<code>Hash</code>（散列）、<code>Zset</code>（有序集合）。</li></ul><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>String（字符串）</td><td>可以是字符串、整数或者浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作。</td></tr><tr><td>List（列表）</td><td>一个链表，链表上的每个节点都包含了一个字符串</td><td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素。</td></tr><tr><td>Set（集合）</td><td>包含字符串的无序收集器，并且被包含的每个字符串都是独一无二、各不相同的</td><td>添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素。</td></tr><tr><td>Hash（散列）</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对；获取所有键值对。</td></tr><tr><td>Zset（有序集合）</td><td>字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</td><td>添加、获取、删除单个元素；根据分值范围或者成员来获取元素。</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1) 简单动态字符串"></a>1) 简单动态字符串</h4><p>​        Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称C<br>字符串），而是自己构建了一种名为 <code>简单动态字符串（simple dynamic string，SDS）</code>的抽象<br>类型，并将 SDS 用作 Redis 的<code>默认字符串</code>表示。</p><p>​        当 Redis 需要的不仅仅是一个字符串字面量，而是一个可以<code>被修改的字符串值</code>时，Redis<br>就会使用 SDS 来表示字符串值，比如在 Redis 的数据库里面，包含字符串值的键值对在底<br>层都是由 SDS 实现的。除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区（buffer）：AOF 模块中的 AOF 缓冲区，以及客户端状态中的输入缓冲区，都是由 SDS 实现的。</p><h4 id="2-SDS-的定义"><a href="#2-SDS-的定义" class="headerlink" title="2) SDS 的定义"></a>2) SDS 的定义</h4><p>SDS 的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">// 记录buf 数组中已使用字节的数量</span></span><br><span class="line"><span class="comment">// 等于SDS 所保存字符串的长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 记录buf 数组中未使用字节的数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图展示了一个 SDS 示例：</p><p><img src="/img/image/blog/20210505/SDS%E7%A4%BA%E4%BE%8B.png" alt="SDS示例"></p><ul><li>free 属性的值为0，表示这个 SDS 没有分配任何未使用空间。</li><li>len 属性的值为5，表示这个 SDS 保存了一个五字节长的字符串。</li><li>buf 属性是一个 <code>char 类型的数组</code>，数组的前五个字节分别保存了 ‘R’、’e’、’d’、’i’、’s’ 五个字符，而最后一个字节则保存了空字符 ‘\0’。</li></ul><p>SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的1 字节空间不计算在SDS 的 len 属性里面，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由SDS 函数自动完成的，所以这个空字符对于 SDS 的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分C 字符串函数库里面的函数。</p><h4 id="3-C-字符串和-SDS-之间的区别"><a href="#3-C-字符串和-SDS-之间的区别" class="headerlink" title="3) C 字符串和 SDS 之间的区别"></a>3) C 字符串和 SDS 之间的区别</h4><table><thead><tr><th align="center">C 字符串</th><th align="center">SDS</th></tr></thead><tbody><tr><td align="center">获取字符串长度的复杂度为O(N)</td><td align="center">获取字符串长度的复杂度为O(1)</td></tr><tr><td align="center">API 是不安全的，可能会造成缓冲区溢出</td><td align="center">API 是安全的，不会造成缓冲区溢出</td></tr><tr><td align="center">修改字符串长度N 次<code>必然</code>需要执行N 次内存重分配</td><td align="center">修改字符串长度N 次<code>最多</code>需要执行N 次内存重分配</td></tr><tr><td align="center">只能保存文本数据</td><td align="center">可以保存文本或者二进制数据</td></tr><tr><td align="center">可以使用所有&lt;string.h&gt; 库中的函数</td><td align="center">可以使用一部分&lt;string.h&gt; 库中的函数</td></tr></tbody></table><h4 id="4-C-字符串和-SDS-之间的区别"><a href="#4-C-字符串和-SDS-之间的区别" class="headerlink" title="4) C 字符串和 SDS 之间的区别"></a>4) C 字符串和 SDS 之间的区别</h4><p>比起C 字符串，SDS 具有以下优点：</p><ul><li>常数复杂度获取字符串长度。</li><li>杜绝缓冲区溢出（空间预分配）。</li><li>减少修改字符串长度时所需的内存重分配次数（惰性空间释放）。</li><li>二进制安全。</li><li>兼容部分C 字符串函数。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>在 Redis 5.0 版本引入了一个新的数据类型–Streams(流信息)。它支持消费者组，借鉴 Kafka 设计的支持多播的可持久化消息队列(支持 group，不支持 partition)。</li><li>其他的数据类型的具体内容，这里就不在进行过多的展开了，后面会补上相关文章。</li><li>各个数据类型的存储最大存储大小：<ul><li>String：最大可以存储512M。</li><li>List：元素个数最多为 2^32-1 个，即 4294967295 个。</li><li>Set：元素个数最多为 2^32-1 个，即 4294967295 个。</li><li>Hash：键值对个数最多为 2^32-1 个，即 4294967295 个。</li><li>Zset：同 Sets。</li></ul></li></ul><h2 id="3、Redis-是单进程单线程的？"><a href="#3、Redis-是单进程单线程的？" class="headerlink" title="3、Redis 是单进程单线程的？"></a>3、Redis 是单进程单线程的？</h2><p>​        <code>Redis 服务器</code>使用<code>单线程单进程</code>的方式来处理命令请求， 并与多个客户端进行网络通信。Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。</p><p>​        Redis 服务器是典型的一对多服务器程序： 一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求， 而服务器则接收并处理客户端发送的命令请求， 并向客户端返回命令回复。</p><p>​        对于每个与服务器进行连接的客户端， 服务器都为这些客户端建立了相应的 redis.h/ redisClient 结构（客户端状态），这个结构保存了客户端当前的状态信息． 以及执行相关功能时需要用到的数据结构， 其中包括：</p><ul><li>客户端的套接字描述符。</li><li>客户端的名字。</li><li>客户端的标志值 (flag)。</li><li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li><li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li><li>客户端的输入缓冲区和输出缓冲区。</li><li>客户端的复制状态信息，以及进行复制所需的数据结构。</li><li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li><li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li><li>客户端执行发布与订阅功能时用到的数据结构。</li><li>客户端的身份验证标志。</li><li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制(soft limit) 的时间。</li></ul><p>​    Redis 服务器状态结构的 clients 属性是一个链表。这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历 clients 链表来完成。</p><p>关于 Redis 单线程的相关问题，因为内容较多，全部写到该篇文章中不太合适，所以这里重新写了一篇文章来进行总结 ：</p><p><a href="https://www.blog.ajie39.top/2021/05/08/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84">Redis 是单线程的？？？？你别唬我，我可不是厦（吓）大的</a></p><h2 id="4、Redis-的持久化机制有哪些？各自的优缺点？"><a href="#4、Redis-的持久化机制有哪些？各自的优缺点？" class="headerlink" title="4、Redis 的持久化机制有哪些？各自的优缺点？"></a>4、Redis 的持久化机制有哪些？各自的优缺点？</h2><p>​        Redis 是一个内存数据库，数据都存储在内存中，这也是 Redis 非常快的原因之一。虽然速度提上来了，但是如果数据一直放在内存中，是非常容易丢失的。比如服务器关闭或宕机了，内存中的数据就丢失了。为了解决这一问题，Redis 提供了持久化机制。一种是 RDB 持久化（<strong>原理是将Redis 在内存中的数据库记录定时dump到磁盘上</strong>），另一种是 AOF (append only file) 持久化，（<strong>原理是将 Redis 的操作日志以追加的方式写入文件</strong>）。两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。</p><h4 id="1）RDB（默认）"><a href="#1）RDB（默认）" class="headerlink" title="1）RDB（默认）"></a>1）RDB（默认）</h4><p>RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照 (point-in-time snapshot)。</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><img src="/img/image/blog/20210505/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="RDB持久化过程"></p><p><strong>RDB存在哪些优势？</strong></p><ol><li>一旦采用该方式，那么你的整个 Redis 数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松地将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样可以极大地避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ol><p><strong>RDB的劣势？</strong></p><ol><li>如果你想保证数据的高可用性，即最大限度地避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据将丢失。</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至1秒钟。</li></ol><h4 id="2）AOF"><a href="#2）AOF" class="headerlink" title="2）AOF"></a>2）AOF</h4><p>AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存。</p><p>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF进行重写<strong>，</strong>重写后的新 AOF 文件包含了恢复当前数据集所需的<strong>最小命令集合</strong>。</p><p>AOF 持久化以日志的形式记录服务器所处理的每一个写、删操作（注意查询操作不会被记录）。以文本的方式记录，可以打开文件看到详细的操作记录。</p><p><img src="/img/image/blog/20210505/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="AOF持久化过程"></p><p><strong>AOF的优势？</strong></p><ol><li>该机制可以带来更高的数据安全性，即数据持久性。Redis 中提供了3种同步策略，及每秒同步，每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率非常高。所差的是一旦系统出现宕机现象，那么这一秒种之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，大家都能正确的理解它。</li><li>由于该机制对日志文件的写入操作采用的是 append（在被选元素的结尾插入指定内容） 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。</li><li>如果日志文件过大，Redis可以自动启动 rewrite 机制。即 Reids 以 append 模式不断地修改数据并写入到老的磁盘文件中，同时 Redis 还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行切换时可以更高的保证数据安全性。</li><li>AOF 包含一个格式清晰，易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ol><p><strong>AOF的劣势？</strong></p><ol><li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件，RDB 在恢复大数据集时速度比AOF 的恢复速度快。</li><li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB。总之，每秒同步策略的效率是比较高的。同步禁用策略的效率和 RDB 一样高效。</li></ol><p><strong>二者选择的标准</strong>：就是看系统是愿意牺牲一些性能，换取更高的缓存一致性(AOF)，还是愿意写操作频繁的时候，不启动备份来换取更高的性能。待手动运行save的时候，再做备份(RDB)。RDB 这个就更有些最终一致性的意思了。</p><h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><h5 id="RDB持久化配置"><a href="#RDB持久化配置" class="headerlink" title="RDB持久化配置"></a><strong>RDB持久化配置</strong></h5><p>Redis 会将数据集的快照 dump 到 dump.rdb 文件中。此外，我们也可以通过配置文件来修改Redis 服务器 dump 快照的频率，在打开 redis.conf 文件之后，我们搜索 save 可以看到下面的配置信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save　　900　　1 #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照</span><br><span class="line"></span><br><span class="line">save　　300　　10 #在300秒(5分钟)之后，如果至少有10个key发生变化，则dunp内存快照</span><br><span class="line"></span><br><span class="line">save　　60　　 10000　　#在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照</span><br></pre></td></tr></table></figure><h5 id="AOF持久化配置"><a href="#AOF持久化配置" class="headerlink" title="AOF持久化配置"></a><strong>AOF持久化配置</strong></h5><p>在 Redis 的配置文件中存在三种同步方式，它们分别是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendsync always #每次有数据修改发生时都会写入AOF文件</span><br><span class="line"></span><br><span class="line">appendsync everysec #每秒同步一次，该策略为AOF的缺省策略</span><br><span class="line"></span><br><span class="line">appendsync no #从不同步。高效但是数据不会被持久化</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（拓展篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（进阶篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>开发工具汇总</title>
    <link href="https://www.blog.ajie39.top/2021/06/20/%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
    <id>https://www.blog.ajie39.top/2021/06/20/%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E6%B1%87%E6%80%BB/</id>
    <published>2021-06-19T18:15:56.000Z</published>
    <updated>2021-06-19T18:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：本文主要总结了自己开发所用的各种工具。"><a href="#摘要：本文主要总结了自己开发所用的各种工具。" class="headerlink" title="摘要：本文主要总结了自己开发所用的各种工具。"></a>摘要：本文主要总结了自己开发所用的各种工具。</h1><hr><h1 id="前言：主要是汇总了一下，自己在开发过程中的各种工具。"><a href="#前言：主要是汇总了一下，自己在开发过程中的各种工具。" class="headerlink" title="前言：主要是汇总了一下，自己在开发过程中的各种工具。"></a>前言：主要是汇总了一下，自己在开发过程中的各种工具。</h1><hr><span id="more"></span><h2 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h2><ul><li>clear 刷新屏幕</li><li>tab 自动补全</li></ul><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><ul><li>打包、跳过测试<br>mvn clean package -Dmaven.test.skip</li><li>执行<br>java -jar *.jar</li><li>退出<br>ctrl + c</li></ul><h2 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h2><ul><li><p>Lombok插件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lombok官方api：https:&#x2F;&#x2F;projectlombok.org&#x2F;features&#x2F;index.html</span><br><span class="line"></span><br><span class="line">使用lombok之后，省去了许多没必要的get，set，toString，</span><br><span class="line">equals，hashCode代码，简化了代码编写，减少了代码量。</span><br><span class="line"></span><br><span class="line">另外@Data注解的作用相当于 @Getter @Setter</span><br><span class="line">@RequiredArgsConstructor @ToString @EqualsAndHashCode的合集</span><br></pre></td></tr></table></figure></li><li><p>Background Image 背景图片设置插件</p></li><li><p>Maven Helper：展示的pom文件依赖关系<br>使用参考地址：<a href="https://blog.csdn.net/u013870094/article/details/79712500">https://blog.csdn.net/u013870094/article/details/79712500</a></p></li><li><p>Alibaba Java Coding Guidelines 阿里巴巴Java编码准则插件</p></li><li><p>Translation 翻译插件</p></li><li><p>MyBatis Log Plugin 打印mybatis的sql语句</p></li><li><p>Free Mybatis plugin 生成mapper xml文件，快速从代码跳转到mapper及从mapper返回代码<br>使用参考地址：<a href="https://github.com/wuzhizhan/free-idea-mybatis">https://github.com/wuzhizhan/free-idea-mybatis</a></p></li><li><p>protobuf support proto文件插件</p></li><li><p>VisualVM Launcher 查看jvm的情况</p></li><li><p>FindBugs 检测代码中可能的bug及不规范的位置</p></li><li><p>MybatisX MybatisX 辅助 idea 快速开发插件</p></li><li><p>CodeGlance 代码编辑区缩略图插件</p></li><li><p>Kubernetes</p></li><li><p>Zoolytic  zookeeper可视化</p></li></ul><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><ul><li>中文简体语言包：Chinese (Simplified) Language Pack for Visual Studio Code</li><li>PlantUML</li><li>VS Code JavaScript(ES6) snippets：这个插件为 JavaScript、TypeScript、HTML、React 和 Vue 提供了 ES6 的语法支持。</li><li>React-Redux ES6 Snippets</li><li>jQuery Code Snippets</li><li>Path Intellisense：自动路径补全</li><li>Vetur：Vue 的语法高亮、智能感知、Emmet 等。</li><li>Debugger for Chrome</li><li>Markdown All in One</li></ul><h2 id="一些工具类网站"><a href="#一些工具类网站" class="headerlink" title="一些工具类网站"></a>一些工具类网站</h2><ul><li>PlantUML：<a href="https://plantuml.com/zh/">https://plantuml.com/zh/</a></li><li>时间戳：<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></li><li>cron表达式生成器：<a href="https://cron.qqe2.com/">https://cron.qqe2.com/</a></li><li>json：<a href="https://www.bejson.com/jsoneditoronline/">https://www.bejson.com/jsoneditoronline/</a></li><li>思维导图、流程图：<a href="https://www.processon.com/">https://www.processon.com/</a></li><li>jwt解密：<a href="https://jwt.io/">https://jwt.io/</a></li><li>代码分享：<a href="https://paste.ubuntu.com/">https://paste.ubuntu.com/</a></li></ul><h2 id="ATOM"><a href="#ATOM" class="headerlink" title="ATOM"></a>ATOM</h2><ul><li>DocBlocker                          自动代码补全，注释</li><li>atom-material-ui                    美化</li><li>language-markdown                   markdown语法高亮插件</li><li>markdown-preview-plus 或者<br>markdown-preview-enhanced           语法高亮，双向实时预览</li><li>markdown-table-editor               markdown表格插件</li><li>regex-railroad-diagram              正则表达式插件</li><li>simplified-chinese-menu             菜单汉化语言包</li></ul><h2 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h2><ul><li>JSON Viewer插件<br>  地址：<a href="https://github.com/tulios/json-viewer">https://github.com/tulios/json-viewer</a></li></ul><h2 id="渗透工具"><a href="#渗透工具" class="headerlink" title="渗透工具"></a>渗透工具</h2><ul><li>Nmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装命令：</span><br><span class="line">sudo apt-get install nmap</span><br></pre></td></tr></table></figure><ul><li>Zenmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装命令：</span><br><span class="line">sudo apt-get install -y zenmap</span><br></pre></td></tr></table></figure><ul><li>Sqlmap</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安装git:</span><br><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line">然后使用git安装sqlmap:</span><br><span class="line">sudo git clone git:&#x2F;&#x2F;github.com&#x2F;sqlmapproject&#x2F;sqlmap.git</span><br><span class="line"></span><br><span class="line">修改环境变量：</span><br><span class="line">sudo vi &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">export sqlmap&#x3D;&#39;python **&#x2F;sqlmap&#x2F;sqlmap.py&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：本文主要总结了自己开发所用的各种工具。&quot;&gt;&lt;a href=&quot;#摘要：本文主要总结了自己开发所用的各种工具。&quot; class=&quot;headerlink&quot; title=&quot;摘要：本文主要总结了自己开发所用的各种工具。&quot;&gt;&lt;/a&gt;摘要：本文主要总结了自己开发所用的各种工具。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot;&gt;&lt;a href=&quot;#前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot; class=&quot;headerlink&quot; title=&quot;前言：主要是汇总了一下，自己在开发过程中的各种工具。&quot;&gt;&lt;/a&gt;前言：主要是汇总了一下，自己在开发过程中的各种工具。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    <category term="Tool" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/Tool/"/>
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 数据库相关知识点总结</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-16T14:51:14.000Z</published>
    <updated>2021-12-13T16:13:46.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：对于-Mysql-常见的知识点总结。"><a href="#摘要：对于-Mysql-常见的知识点总结。" class="headerlink" title="摘要：对于 Mysql 常见的知识点总结。"></a>摘要：对于 Mysql 常见的知识点总结。</h1><hr><h1 id="前言：对于-Mysql-常见的知识点的总结。"><a href="#前言：对于-Mysql-常见的知识点的总结。" class="headerlink" title="前言：对于 Mysql 常见的知识点的总结。"></a>前言：对于 Mysql 常见的知识点的总结。</h1><hr><h2 id="Mysql-知识点脑图"><a href="#Mysql-知识点脑图" class="headerlink" title="Mysql 知识点脑图"></a>Mysql 知识点脑图</h2><p><img src="/img/image/blog/20210516/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE.png" alt="Mysql 知识点脑图"></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：对于-Mysql-常见的知识点总结。&quot;&gt;&lt;a href=&quot;#摘要：对于-Mysql-常见的知识点总结。&quot; class=&quot;headerlink&quot; title=&quot;摘要：对于 Mysql 常见的知识点总结。&quot;&gt;&lt;/a&gt;摘要：对于 Mysql 常见的知识点总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于-Mysql-常见的知识点的总结。&quot;&gt;&lt;a href=&quot;#前言：对于-Mysql-常见的知识点的总结。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于 Mysql 常见的知识点的总结。&quot;&gt;&lt;/a&gt;前言：对于 Mysql 常见的知识点的总结。&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Mysql-知识点脑图&quot;&gt;&lt;a href=&quot;#Mysql-知识点脑图&quot; class=&quot;headerlink&quot; title=&quot;Mysql 知识点脑图&quot;&gt;&lt;/a&gt;Mysql 知识点脑图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/image/blog/20210516/Mysql%E7%9F%A5%E8%AF%86%E7%82%B9%E8%84%91%E5%9B%BE.png&quot; alt=&quot;Mysql 知识点脑图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Mysql/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Mysql" scheme="https://www.blog.ajie39.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java面试之Hashmap</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/Java%E9%9D%A2%E8%AF%95%E4%B9%8BHashmap/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/Java%E9%9D%A2%E8%AF%95%E4%B9%8BHashmap/</id>
    <published>2021-05-16T10:46:10.000Z</published>
    <updated>2021-12-13T16:26:35.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：Hashmap面试内容总结"><a href="#摘要：Hashmap面试内容总结" class="headerlink" title="摘要：Hashmap面试内容总结"></a>摘要：Hashmap面试内容总结</h1><hr><h1 id="前言：Hashmap面试内容总结，为面试做准备。"><a href="#前言：Hashmap面试内容总结，为面试做准备。" class="headerlink" title="前言：Hashmap面试内容总结，为面试做准备。"></a>前言：Hashmap面试内容总结，为面试做准备。</h1><hr><span id="more"></span><h2 id="1、为什么用HashMap？"><a href="#1、为什么用HashMap？" class="headerlink" title="1、为什么用HashMap？"></a>1、为什么用HashMap？</h2><ul><li>HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射</li><li>HashMap 采用了数组和链表的数据结构，查询和修改方便，继承了数组的线性查找和链表的寻址修改</li><li>HashMap 是非 synchronized，所以 HashMap 很快</li><li>HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）</li><li>HashMap 存储着Entry(hash, key, value, next)对象</li></ul><h2 id="2、HashMap-的工作原理是什么？"><a href="#2、HashMap-的工作原理是什么？" class="headerlink" title="2、HashMap 的工作原理是什么？"></a>2、HashMap 的工作原理是什么？</h2><p>HashMap 通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p><p><img src="/img/image/blog/12/1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以下是 HashMap 初始化</span><br><span class="line">简化的模拟数据结构：</span><br><span class="line"></span><br><span class="line">Node[] table = <span class="keyword">new</span> Node[<span class="number">16</span>]; <span class="comment">// 散列桶初始化，table</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    hash; <span class="comment">//hash值</span></span><br><span class="line">    key; <span class="comment">//键</span></span><br><span class="line">    value; <span class="comment">//值</span></span><br><span class="line">    node next; <span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是具体的 put 过程（JDK1.8）</p><ol><li>对 Key 求 Hash 值，然后再计算下标</li><li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）</li><li>如果碰撞了，以链表的方式链接到后面</li><li>如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li><li>如果节点已经存在就替换旧值</li><li>如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）</li></ol><p>以下是具体 get 过程</p><p>考虑特殊情况：如果两个键的 hashcode 相同，你如何获取值对象？</p><p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p><p><img src="/img/image/blog/12/2.png"></p><h2 id="3、有什么方法可以减少碰撞？"><a href="#3、有什么方法可以减少碰撞？" class="headerlink" title="3、有什么方法可以减少碰撞？"></a>3、有什么方法可以减少碰撞？</h2><p><strong>碰撞：所谓“碰撞”就上面所述是多个元素计算得出相同的hashCode，在put时出现冲突。</strong></p><p>处理方法:<br>　　Java中HashMap是利用“拉链法”处理HashCode的碰撞问题。在调用HashMap的put方法或get方法时，都会首先调用hashcode方法，去查找相关的key，当有冲突时，再调用equals方法。</p><p>hashMap 通过put和get方法存取对象。当我们将键值对传递给put方法时，他调用键对象的hashCode()方法来计算hashCode，然后找到bucket（哈希桶）位置来存储对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当碰撞发生了，对象将会存储在链表的下一个节点中。hashMap在每个链表节点存储键值对对象。当两个不同的键却有相同的hashCode时，他们会存储在同一个bucket位置的链表中。键对象的equals()来找到键值对。</p><p><strong>HashMap基本结构概念图：</strong></p><p><img src="/img/image/blog/12/3.png"></p><p>到目前为止，我们了解了两件事：</p><ul><li>1、HashMap通过键的hashCode来快速的存取元素。</li><li>2、当不同的对象发生碰撞时，HashMap通过单链表来解决，将新元素加入链表表头，通过next指向原有的元素。单链表在Java中的实现就是对象的引用(复合)。</li></ul><h2 id="4、为什么-String、Integer-这样的-wrapper-类适合作为键？"><a href="#4、为什么-String、Integer-这样的-wrapper-类适合作为键？" class="headerlink" title="4、为什么 String、Integer 这样的 wrapper 类适合作为键？"></a>4、为什么 String、Integer 这样的 wrapper 类适合作为键？</h2><p>因为 String 是 final，而且已经重写了 equals() 和 hashCode() 方法了。不可变性是必要的，因为为了要计算 hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的 hashcode 的话，那么就不能从 HashMap 中找到你想要的对象。</p><h2 id="5、HashMap-中-hash-函数怎么是实现的"><a href="#5、HashMap-中-hash-函数怎么是实现的" class="headerlink" title="5、HashMap 中 hash 函数怎么是实现的?"></a>5、HashMap 中 hash 函数怎么是实现的?</h2><p>我们可以看到，在 hashmap 中要找到某个元素，需要根据 key 的 hash 值来求得对应数组中的位置。如何计算这个位置就是 hash 算法。</p><p>前面说过，hashmap 的数据结构是数组和链表的结合，所以我们当然希望这个 hashmap 里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个。那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以，我们首先想到的就是把 hashcode 对数组长度取模运算。这样一来，元素的分布相对来说是比较均匀的。</p><p>但是“模”运算的消耗还是比较大的，能不能找一种更快速、消耗更小的方式？我们来看看 JDK1.8 源码是怎么做的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    h = key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">    <span class="keyword">return</span> (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/image/blog/12/4.png"></p><p>简单来说就是：</p><ul><li>1、高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和6 bit做了一个异或）</li><li>2、(n·1) &amp; hash = -&gt; 得到下标</li></ul><h2 id="6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？"><a href="#6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？"></a>6、拉链法导致的链表过深，为什么不用二叉查找树代替而选择红黑树？为什么不一直使用红黑树？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷：</p><p>二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成层次很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋、右旋、变色这些操作来保持平衡。引入红黑树就是为了查找数据快，解决链表查询深度的问题。我们知道红黑树属于平衡二叉树，为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少。所以当长度大于8的时候，会使用红黑树；如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h2 id="7、说说你对红黑树的见解？"><a href="#7、说说你对红黑树的见解？" class="headerlink" title="7、说说你对红黑树的见解？"></a>7、说说你对红黑树的见解？</h2><p><img src="/img/image/blog/12/5.png"></p><ol><li>每个节点非红即黑</li><li>根节点总是黑色的</li><li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li><li>每个叶子节点都是黑色的空节点（NIL节点）</li><li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ol><h2 id="8、解决-hash-碰撞还有那些办法？"><a href="#8、解决-hash-碰撞还有那些办法？" class="headerlink" title="8、解决 hash 碰撞还有那些办法？"></a>8、解决 hash 碰撞还有那些办法？</h2><p><strong>1.开放地址法</strong></p><p>开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。</p><p>如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)，称二次探测再散列。</p><p>如果di取值可能为伪随机数列。称伪随机探测再散列。</p><p><strong>2.再哈希法</strong></p><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止。</p><p><strong>3.链地址法（拉链法）</strong></p><p>将所有关键字为同义词的记录存储在同一线性链表中。如下：</p><p><img src="/img/image/blog/12/6.png"></p><p>因此这种方法，可以近似的认为是筒子里面套筒子。</p><p><strong>优点：</strong></p><ol><li>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li><li>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</li><li>开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</li><li>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li></ol><p><strong>缺点：</strong></p><ul><li>指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</li></ul><h2 id="9、如果-HashMap-的大小超过了负载因子（load-factor）定义的容量怎么办？"><a href="#9、如果-HashMap-的大小超过了负载因子（load-factor）定义的容量怎么办？" class="headerlink" title="9、如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？"></a>9、如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？</h2><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</span><br><span class="line"></span><br><span class="line">大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</span><br></pre></td></tr></table></figure><p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：</p><p><img src="/img/image/blog/12/7.png"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="/img/image/blog/12/8.png"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p><img src="/img/image/blog/12/9.png"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><h2 id="10、重新调整-HashMap-大小存在什么问题吗？"><a href="#10、重新调整-HashMap-大小存在什么问题吗？" class="headerlink" title="10、重新调整 HashMap 大小存在什么问题吗？"></a>10、重新调整 HashMap 大小存在什么问题吗？</h2><p>重新调整 HashMap 大小的时候，确实存在条件竞争。</p><p>因为如果两个线程都发现 HashMap 需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来。因为移动到新的 bucket 位置的时候，HashMap 并不会将元素放在链表的尾部，而是放在头部。这是为了避免尾部遍历（tail traversing）。如果条件竞争发生了，那么就死循环了。<strong>多线程的环境下不使用 HashMap。</strong></p><p>为什么多线程会导致死循环，它是怎么发生的？<br>HashMap 的容量是有限的。当经过多次元素插入，使得 HashMap 达到一定饱和度时，Key 映射位置发生冲突的几率会逐渐提高。这时候， HashMap 需要扩展它的长度，也就是进行Resize。</p><ol><li>扩容：创建一个新的 Entry 空数组，长度是原数组的2倍</li><li>rehash：遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组</li></ol><p>详细文章参考: <a href="https://www.cnblogs.com/zhuoqingsen/p/8577646.html">HashMap扩容全过程</a></p><h2 id="11、HashTable"><a href="#11、HashTable" class="headerlink" title="11、HashTable"></a>11、HashTable</h2><ol><li>数组 + 链表方式存储</li><li>默认容量：11（质数为宜）</li><li>put操作：首先进行索引计算 （key.hashCode() &amp; 0x7FFFFFFF）% table.length；若在链表中找到了，则替换旧值，若未找到则继续；当总元素个数超过 容量 * 加载因子 时，扩容为原来 2 倍并重新散列；将新元素加到链表头部</li><li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全</li></ol><h2 id="12、HashMap-与-HashTable-区别"><a href="#12、HashMap-与-HashTable-区别" class="headerlink" title="12、HashMap 与 HashTable 区别"></a>12、HashMap 与 HashTable 区别</h2><ol><li>默认容量不同，扩容不同</li><li>线程安全性：HashTable 安全</li><li>效率不同：HashTable 要慢，因为加锁</li></ol><h2 id="13、可以使用-CocurrentHashMap-来代替-Hashtable-吗？"><a href="#13、可以使用-CocurrentHashMap-来代替-Hashtable-吗？" class="headerlink" title="13、可以使用 CocurrentHashMap 来代替 Hashtable 吗？"></a>13、可以使用 CocurrentHashMap 来代替 Hashtable 吗？</h2><ol><li>我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁</li><li>ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性</li><li>它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map</li></ol><h2 id="14、CocurrentHashMap（JDK-1-7）"><a href="#14、CocurrentHashMap（JDK-1-7）" class="headerlink" title="14、CocurrentHashMap（JDK 1.7）"></a>14、CocurrentHashMap（JDK 1.7）</h2><ol><li>CocurrentHashMap 是由 Segment 数组和 HashEntry 数组和链表组成</li><li>Segment 是基于重入锁（ReentrantLock）：一个数据段竞争锁。每个 HashEntry 一个链表结构的元素，利用 Hash 算法得到索引确定归属的数据段，也就是对应到在修改时需要竞争获取的锁。ConcurrentHashMap 支持 CurrencyLevel（Segment 数组数量）的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment</li><li>核心数据如 value，以及链表都是 volatile 修饰的，保证了获取时的可见性</li><li>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put 操作如下：<ul><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li><li>遍历该 HashEntry，如果不为空则判断传入的  key 和当前遍历的 key 是否相等，相等则覆盖旧的 value</li><li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li><li>最后会解除在 1 中所获取当前 Segment 的锁。</li></ul></li><li>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理<ul><li>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。</li><li>尝试自旋获取锁，如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。最后解除当前 Segment 的锁</li></ul></li></ol><h2 id="15、CocurrentHashMap（JDK-1-8）"><a href="#15、CocurrentHashMap（JDK-1-8）" class="headerlink" title="15、CocurrentHashMap（JDK 1.8）"></a>15、CocurrentHashMap（JDK 1.8）</h2><p>CocurrentHashMap 抛弃了原有的 Segment 分段锁，采用了 CAS + synchronized 来保证并发安全性。其中的 val next 都用了 volatile 修饰，保证了可见性。</p><p><strong>最大特点是引入了 CAS</strong></p><p>  借助 Unsafe 来实现 native code。CAS有3个操作数，内存值 V、旧的预期值 A、要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值V修改为 B，否则什么都不做。Unsafe 借助 CPU 指令 cmpxchg 来实现。</p><p><strong>CAS 使用实例</strong></p><p>对 sizeCtl 的控制都是用 CAS 来实现的：</p><ul><li>-1 代表 table 正在初始化</li><li>N 表示有 -N-1 个线程正在进行扩容操作</li><li>如果 table 未初始化，表示table需要初始化的大小</li><li>如果 table 初始化完成，表示table的容量，默认是table大小的0.75倍，用这个公式算 0.75（n – (n &gt;&gt;&gt; 2)）</li></ul><p><strong>CAS 会出现的问题：ABA</strong></p><p>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。</p><p><strong>put 过程</strong></p><ul><li>根据 key 计算出 hashcode</li><li>判断是否需要进行初始化</li><li>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容</li><li>如果都不满足，则利用 synchronized 锁写入数据</li><li>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树</li></ul><p><strong>get 过程</strong></p><ul><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值</li><li>如果是红黑树那就按照树的方式获取值</li><li>就不满足那就按照链表的方式遍历获取值</li></ul><h2 id="16、ConcurrentHashMap-在-Java-8-中存在一个-bug-会进入死循环"><a href="#16、ConcurrentHashMap-在-Java-8-中存在一个-bug-会进入死循环" class="headerlink" title="16、ConcurrentHashMap 在 Java 8 中存在一个 bug 会进入死循环"></a>16、ConcurrentHashMap 在 Java 8 中存在一个 bug 会进入死循环</h2><p>原因是递归创建 ConcurrentHashMap 对象，但是在 JDK 1.9 已经修复了。场景重现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; cache =<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        ConcurrentHashMapDemo ch =    <span class="keyword">new</span> ConcurrentHashMapDemo();</span><br><span class="line">        System.out.println(ch.fibonaacci(<span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonaacci</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>||i ==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cache.computeIfAbsent(i,(key) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;fibonaacci : &quot;</span>+key);</span><br><span class="line">            <span class="keyword">return</span> fibonaacci(key -<span class="number">1</span>)+fibonaacci(key - <span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：Hashmap面试内容总结&quot;&gt;&lt;a href=&quot;#摘要：Hashmap面试内容总结&quot; class=&quot;headerlink&quot; title=&quot;摘要：Hashmap面试内容总结&quot;&gt;&lt;/a&gt;摘要：Hashmap面试内容总结&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：Hashmap面试内容总结，为面试做准备。&quot;&gt;&lt;a href=&quot;#前言：Hashmap面试内容总结，为面试做准备。&quot; class=&quot;headerlink&quot; title=&quot;前言：Hashmap面试内容总结，为面试做准备。&quot;&gt;&lt;/a&gt;前言：Hashmap面试内容总结，为面试做准备。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="算法与数据结构" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="数据结构" scheme="https://www.blog.ajie39.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础复习</title>
    <link href="https://www.blog.ajie39.top/2021/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.blog.ajie39.top/2021/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-16T07:34:26.000Z</published>
    <updated>2021-12-13T16:24:36.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章是对数据库基础的总结和归纳。"><a href="#摘要：这篇文章是对数据库基础的总结和归纳。" class="headerlink" title="摘要：这篇文章是对数据库基础的总结和归纳。"></a>摘要：这篇文章是对数据库基础的总结和归纳。</h1><hr><h1 id="前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。"><a href="#前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。" class="headerlink" title="前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。"></a>前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。</h1><hr><span id="more"></span><p><strong>1.常用的数据库有哪些？redis用过吗?</strong></p><ul><li>常用的数据库<ul><li>MySQL</li><li>SQLServer</li><li>Redis</li><li>oracle</li></ul></li><li>Redis是一个速度非常快的非关系型数据库，他可以存储键(key)与5种不同类型的值（value）之间的映射，可以将存储在内存中的键值对数据持久化到硬盘中。</li><li>与Memcached相比<ul><li>两者都可用于存储键值映射，彼此性能也相差无几</li><li>Redis能够自动以两种不同的方式将数据写入硬盘</li><li>Redis除了能存储普通的字符串键之外，还可以存储其他4种数据结构，memcached只能存储字符串键</li><li>Redis既能用作主数据库，由可以作为其他存储系统的辅助数据库</li></ul></li></ul><p><strong>2数据库索引的优缺点以及什么时候数据库索引失效</strong></p><ul><li><p>索引的特点</p><ul><li>可以加快数据库的检索速度</li><li>降低数据库插入、修改、删除等维护的速度</li><li>只能创建在表上，不能创建到视图上</li><li>既可以直接创建又可以间接创建</li><li>可以在优化隐藏中使用索引</li><li>使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引</li></ul></li><li><p>索引的优点</p><ul><li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li><li>大大加快数据的检索速度，这是创建索引的最主要的原因</li><li>加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能</li></ul></li><li><p>索引的缺点</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度</li></ul></li><li><p>索引分类</p><ul><li>直接创建索引和间接创建索引</li><li>普通索引和唯一性索引</li><li>单个索引和复合索引</li><li>聚簇索引和非聚簇索引</li></ul></li><li><p>索引失效</p><ul><li>如果条件中有or，即使其中有条件带索引也不会使用(这就是问什么尽量少使用or的原因)</li><li>对于多列索引，不是使用的第一部分，则不会使用索引</li><li>like查询是以%开头</li><li>如果列类型是字符串，那一定要在条件中使用引号引起来，否则不会使用索引</li></ul></li><li><p>如果mysql估计使用全表扫秒比使用索引快，则不适用索引。</p></li><li><p>各引擎支持索引<br><img src="/img/image/blog/6/sql.png" alt="sql"></p></li></ul><p><strong>3.事务隔离级别</strong></p><ul><li>串行化(Serializable)：所有事务一个接着一个的执行，这样可以避免幻读(phantom read),对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需回滚该事务。</li><li>可重复读(Repeated Read)：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取不一致的情况。但是没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为强恶意事务没有范围锁</li><li>读已提交(Read Committed)：被读取的数据可以被其他事务修改，这样可能导致不可重复读。也就是说，事务读取的时候获取读锁，但是在读完之后立即释放(不需要等事务结束)，而写锁则是事务提交之后才释放，释放读锁之后，就可能被其他事务修改数据。改等级也是SQL Server默认的隔离等级</li><li>读未提交(Read Uncommitted)：最低的隔离等级，允许其他事务看到没有提交的数据，会导致脏读</li><li>总结<ul><li>四个级别逐渐增强，每个级别解决一个问题，每个级别解决一个问题，事务级别遇到，性能越差，大多数环境(Read committed 就可以用了)<br><img src="/img/image/blog/6/sql1.png" alt="sql1"></li></ul></li></ul><p><strong>4.数据库中的范式有哪些？</strong></p><ul><li>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。</li><li>范式的包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式…</li><li>范式</li><li>1NF ：符合1NF的关系中的每个属性都不可再分</li><li>2NF：属性完全依赖于主键 [消除部分子函数依赖]</li><li>3NF：属性不依赖于其它非主属性[消除传递依赖]</li><li>BCNF：在1NF基础上，任何非主属性不能对主键子集依赖[在3NF基础上消除对主码子集的依赖]</li><li>4NF：要求把同一表内的多对多关系删除。</li><li>5NF：从最终结构重新建立原始结构。</li></ul><p><strong>5数据库中的索引的结构？什么情况下适合建索引?</strong></p><ul><li><p>数据库中的索引结构<br>因为在使用二叉树的时候，由于二叉树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下。因此采用多叉树结构。B树的各种操作能使B树能保持较低的高度。</p></li><li><p>B 树又叫平衡多路查找树，一棵 m 阶的 B 树的特性如下</p></li><li><p>树中每个结点最多含有 m 个孩子（m&gt;=2）；</p></li><li><p>除根结点和叶子结点外，其他每个结点至少有[ceil(m / 2)]个孩子（其中 ceil(x)是一个取上限的函数）；</p></li><li><p>根结点至少有 2 个孩子（除非 B 树只包含一个结点：根结点）；</p></li><li><p>所有叶子结点都出现在同一层， 叶子结点不包含任何关键字信息 (可以看做是外部结点或查询失败的结点，指向这些结点的指针都为 null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存<br>在，也有元素。类似红黑树中，每一个 NULL 指针即当做叶子结点，只是没画出来而已）。</p></li><li><p>每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<br>a) Ki (i=1…n)为关键字，且关键字按顺序升序排序 K(i-1)&lt; Ki。<br>b) Pi 为指向子树根的结点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。<br>c) 关键字的个数 n 必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。比如有 j 个孩子的非叶结点恰好有 j-1 个关<br>键码。<br><img src="/img/image/blog/6/sql2.png" alt="sql2"></p></li><li><p>B+树<br><img src="/img/image/blog/6/sql3.png" alt="sql3"></p></li><li><p>在什么情况下适合建立索引</p><ul><li>为经常出现在关键字order by、group by、distinct后面的字段，建立索引。</li><li>在union等集合操作的结果集字段上，建立索引。其建立索引的目的同上。</li><li>为经常用作查询选择的字段，建立索引。</li><li>在经常用作表连接的属性上，建立索引。</li><li>考虑使用索引覆盖。对数据很少被更新的表，如果用户经常只查询其中的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描改变为索引的扫描。</li></ul></li></ul><p><strong>6.Redis的存储结构，或者说如何工作的，与mysql的区别？有哪些数据类型？</strong></p><ul><li>Redis的数据结构<ul><li>STRING：可以是字符串、整数或者浮点数</li><li>LIST：一个链表，链表上的每个节点都包含了一个字符串</li><li>SET：包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二、各不相同的</li><li>HAST：包含键值对的无序散列表</li><li>ZSET：字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定</li></ul></li></ul><p><strong>7.数据库中的分页查询语句怎么写？<a href="http://qimo601.iteye.com/blog/1634748">http://qimo601.iteye.com/blog/1634748</a></strong></p><ul><li>Mysql的limit用法<ul><li>SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset</li><li>LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</li></ul></li><li>最基本的分页方式：SELECT … FROM … WHERE … ORDER BY … LIMIT …</li><li>子查询的分页方式：</li></ul><p><strong>8.数据库ACID</strong></p><ul><li>原子性(Atomicity)：保证事务中的所有操作全部执行或全部不执行</li><li>一致性(Consistency)：保证数据库始终保持数据的一致性——事务操作之前和之后都是一致的</li><li>隔离性(Isolation)：多个事务并发执行的话，结果应该与多个事务串行执行效果是一样的</li><li>持久性(Durability)：事务操作完成之后，对数据库的影响是持久的，即使数据库因故障而受到破坏，数据库也能够恢复(日志)</li></ul><p><strong>9.脏读、不可重复读和幻读</strong></p><ul><li>脏读：事务T1更新了一行记录的内容，但是并没有提交所做的修改。事务T2读取更新后的行，然后T1执行了回滚操作，取消了刚才所做的修改。现在T2读取的行就无效了（一个事务读取了另一个事务未提交的数据）</li><li>不可重复读：事务T1读取了一行记录，紧接着T2修改了T1刚才读取的那一行记录，然后T1又再次读取这行记录，发现与刚才读取的结果不同。</li><li>幻读：事务T1读取一条指定的Where子句所返回的结果集，然后T2事务新插入一行记录，这行记录恰好可以满足T1所使用的查询条件。然后T1再次对表进行检索，但又看到了T2插入的数据。</li></ul><p><strong>10.MyISAM和InnoDB引擎的区别</strong></p><ul><li><p>主要区别：</p><ul><li>MyISAM是非事务安全型的，而InnoDB是事务安全型的。</li><li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</li><li>MyISAM支持全文类型索引，而InnoDB不支持全文索引。</li><li>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</li><li>MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li><li>InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。</li></ul></li><li><p>应用场景：</p><ul><li>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</li><li>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章是对数据库基础的总结和归纳。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章是对数据库基础的总结和归纳。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章是对数据库基础的总结和归纳。&quot;&gt;&lt;/a&gt;摘要：这篇文章是对数据库基础的总结和归纳。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot;&gt;&lt;a href=&quot;#前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot; class=&quot;headerlink&quot; title=&quot;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&quot;&gt;&lt;/a&gt;前言：上一篇我们已经把java基础复习了一遍，现在我们来复习一下数据库的有关内容。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="数据库" scheme="https://www.blog.ajie39.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="数据库" scheme="https://www.blog.ajie39.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis 是单线程的？？？？你别唬我，我可不是厦（吓）大的</title>
    <link href="https://www.blog.ajie39.top/2021/05/09/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84/"/>
    <id>https://www.blog.ajie39.top/2021/05/09/Redis%20%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%A0%E5%88%AB%E5%94%AC%E6%88%91%EF%BC%8C%E6%88%91%E5%8F%AF%E4%B8%8D%E6%98%AF%E5%8E%A6%EF%BC%88%E5%90%93%EF%BC%89%E5%A4%A7%E7%9A%84/</id>
    <published>2021-05-09T12:53:14.000Z</published>
    <updated>2021-05-09T12:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。"><a href="#摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。" class="headerlink" title="摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。"></a>摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。</h1><hr><h1 id="前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。"><a href="#前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。" class="headerlink" title="前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。"></a>前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。</h1><hr><span id="more"></span><h2 id="一、Redis-是否真的是单线程？"><a href="#一、Redis-是否真的是单线程？" class="headerlink" title="一、Redis 是否真的是单线程？"></a>一、Redis 是否真的是单线程？</h2><p>​        <code>Redis 服务器</code>使用<code>单线程单进程</code>的方式来处理命令请求， 并与多个客户端进行网络通信。Redis 网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。所以说 Redis 不是所有模块都是单线程的。</p><p>​         Redis 服务器是典型的一对多服务器程序： 一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求， 并向客户端返回命令回复。</p><p>​    Redis 服务器状态结构的 clients 属性是一个链表。这个链表保存了所有与服务器连接的客户端的状态结构，对客户端执行批量操作，或者查找某个指定的客户端，都可以通过遍历 clients 链表来完成。</p><ul><li>Redis v4.0（引入多线程处理异步任务）</li><li>Redis v6.0（正式在网络模型中实现 I/O 多线程）</li></ul><h2 id="二、Redis-单线程模型"><a href="#二、Redis-单线程模型" class="headerlink" title="二、Redis 单线程模型"></a>二、Redis 单线程模型</h2><p>Redis作为一个成熟的分布式缓存框架，它由很多个模块组成，如网络请求模块、索引模块、存储模块、高可用集群支撑模块、数据操作模块等。</p><p>我们所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。</p><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所以每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题。</p><h2 id="三、Redis-客户端到服务端请求过程"><a href="#三、Redis-客户端到服务端请求过程" class="headerlink" title="三、Redis 客户端到服务端请求过程"></a>三、Redis 客户端到服务端请求过程</h2><ol><li>客户端到服务端建立网络连接</li><li>客户端发生读写事件并向服务器端发送请求数据</li><li>服务端进行数据处理</li><li>服务端数据返回</li></ol><h3 id="1、客户端到服务端建立网络连接"><a href="#1、客户端到服务端建立网络连接" class="headerlink" title="1、客户端到服务端建立网络连接"></a>1、客户端到服务端建立网络连接</h3><p>首先，客户端和服务端是 socket 通信方式，socket 服务端监听可同时接受多个客户端请求，这点很重要，如果不理解可先记住。注意这里可以理解为本质上与 redis 无关，这里仅仅做网络连接，或者可以理解为，为 redis 服务端提供网络交互api。</p><p>假设建立网络连接需要15秒（实际上比这个时间小非常多）。</p><h3 id="2、客户端发生读写事件并向服务端发送请求数据"><a href="#2、客户端发生读写事件并向服务端发送请求数据" class="headerlink" title="2、客户端发生读写事件并向服务端发送请求数据"></a>2、客户端发生读写事件并向服务端发送请求数据</h3><p>首先确定一点，redis的客户端与服务端通信是基于TCP连接，第一阶段仅仅是建立了客户端到服务端的网络连接，然后才是发生第二阶段的读写事件。</p><p>完成了上一个阶段的网络连接，redis客户端开始真正向服务端发起读写事件，假设是set（写）事件，此时redis客户端开始向建立的网络流中送数据，服务端可以理解为给每一个网络连接创建一个线程同时接收客户端的请求数据。<br>假设从客户端发数据，到服务端接收完数据需要5秒。</p><h3 id="3、Redis-服务器进行数据处理"><a href="#3、Redis-服务器进行数据处理" class="headerlink" title="3、Redis 服务器进行数据处理"></a>3、Redis 服务器进行数据处理</h3><p>服务端完成了第二阶段的数据接收，接下来开始依据接收到的数据做逻辑处理，然后得到处理后的数据。数据处理可以理解为一次方法调用，带参调用方法，最终得到方法返回值。不要想复杂，重在理解流程。假设redis服务端处理数据需要0.1秒</p><h3 id="4、服务器数据返回"><a href="#4、服务器数据返回" class="headerlink" title="4、服务器数据返回"></a>4、服务器数据返回</h3><p>这一阶段很简单，当reids服务端数据处理完后 就会立即返回处理后的数据，没什么特别需要强调的。假设服务端把处理后的数据回送给客户端需要5秒。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>第一阶段说过，redis 是以 socket 方式通信，socket服务端可同时接受多个客户端请求连接，也就是说，redis服务同时面对多个redis客户端连接请求，而redis服务本身是单线程运行。</p><p>假设，现在有A,B,C,D,E五个客户端同时发起redis请求，A优先稍微一点点第一个到达，然后是B，C，D，E依次到达，此时redis服务端开始处理A请求，建立连接需要15秒，获取请求数据需要5秒，然后处理数据需要0.1秒，回送数据给客户端需要5秒，总共大概需要25.1秒。也就是说，下一个B请求需要等待25.1秒，这里注意，也许这五个几乎同时请求，由于socket可以同时处理多个请求，所以建立网络连接阶段时间差可忽略<code>(也就是说少了15秒)</code>，但是在第二阶段，服务端需要什么事都不干，坐等5秒中，对于CPU和客户端来说是无法忍受的。所以说单线程效率非常，非常低，但是正是因为这些类似问题，Redis单线程本质上并不是如此运行。接下来讨论redis真正的单线程运行方式。</p><h2 id="Redis-单线程运行方式简单理解"><a href="#Redis-单线程运行方式简单理解" class="headerlink" title="Redis 单线程运行方式简单理解"></a>Redis 单线程运行方式简单理解</h2><p>客户端与服务端建立连接交由 socket，可以同时建立多个连接（这里应该是多线程/多进程），建立的连接redis是知道的（不了解的，这里可以去看一下socket编程），然后 redis 会基于这些建立的连接去探测哪个连接已经接收完了客户端的请求数据（注意：不是探测哪个连接建立好了，<code>而是探测哪个接收完了请求数据</code>），而且这里的探测动作就是单线程的开始，一旦探测到则基于接收到的数据开始数据处理阶段，然后返回数据，再继续探测下一个已经接收完请求数据的网络连接。注意，从探测到数据处理再到数据返回，全程单线程。</p><p>从探测到接受完请求数据的网络连接到最终的数据返回，服务器只需要5.1秒，这个时间是我放大N倍后的数据，实际时间远远小于这个，最终的返回数据虽然牵扯到网络，但是网络连接已经建立，这个速度也是非常非常快的，只是比数据处理阶段慢那么一点点。因此单线程方式在效率上其实并不需要担心。</p><h2 id="单线程事件循环"><a href="#单线程事件循环" class="headerlink" title="单线程事件循环"></a>单线程事件循环</h2><h2 id="四、为什么-Redis-网络操作模块和数据存储模块最初并没有使用多线程呢"><a href="#四、为什么-Redis-网络操作模块和数据存储模块最初并没有使用多线程呢" class="headerlink" title="四、为什么 Redis 网络操作模块和数据存储模块最初并没有使用多线程呢?"></a>四、为什么 Redis 网络操作模块和数据存储模块最初并没有使用多线程呢?</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zhuanlan.51cto.com/art/202103/650049.htm">Redis不是一直号称单线程效率也很高吗，为什么又采用多线程了？</a></li><li><a href="https://www.cnblogs.com/myseries/p/11733861.html">Redis 单线程的理解</a></li><li><a href="https://zhuanlan.zhihu.com/p/140927022">Redis 网络通信模块源码分析（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/352557644">Redis 多线程网络模型全面揭秘</a></li><li><a href="https://zhuanlan.zhihu.com/p/345327284">Redis 的通讯协议及事件处理机制</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。&quot;&gt;&lt;a href=&quot;#摘要：Redis-单线程相关内容，包括其中涉及的一些原理等。&quot; class=&quot;headerlink&quot; title=&quot;摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。&quot;&gt;&lt;/a&gt;摘要：Redis 单线程相关内容，包括其中涉及的一些原理等。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。&quot;&gt;&lt;a href=&quot;#前言：相信大家一定和我一样在很多标题党文章中，看到-Redis-是单线程等等相关的说明，但是其中并没系统、完整的总结-Redis-是否真的是单线程，还是-Redis-中的某个模块是单线程。今天我们就一起来揭秘一下这个-“熟悉的陌生人”。&quot; class=&quot;headerlink&quot; title=&quot;前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。&quot;&gt;&lt;/a&gt;前言：相信大家一定和我一样在很多标题党文章中，看到 Redis 是单线程等等相关的说明，但是其中并没系统、完整的总结 Redis 是否真的是单线程，还是 Redis 中的某个模块是单线程。今天我们就一起来揭秘一下这个 “熟悉的陌生人”。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（拓展篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:54:00.000Z</published>
    <updated>2021-05-05T08:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（基础篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（进阶篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？<br>2、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？<br>3、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？<br>4、Redis 常见性能问题和解决方案？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（进阶篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 之从面试题到原理（进阶篇）</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/</id>
    <published>2021-05-05T08:53:50.000Z</published>
    <updated>2021-05-05T08:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。"><a href="#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。" class="headerlink" title="摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。"></a>摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。</h1><hr><h1 id="前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on"><a href="#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on" class="headerlink" title="前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!"></a>前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!</h1><hr><h2 id="文章关联"><a href="#文章关联" class="headerlink" title="文章关联"></a>文章关联</h2><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（基础篇）</a></p><p><a href="https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/"> Redis 之从面试题到原理（拓展篇）</a></p><hr><span id="more"></span><h2 id="题目摘要"><a href="#题目摘要" class="headerlink" title="题目摘要"></a>题目摘要</h2><p>1、说说 Redis 哈希槽的概念？<br>2、Redis 的同步机制了解么？<br>3、是否使用过 Redis 集群，集群的原理是什么？<br>4、Redis 集群方案什么情况下会导致整个集群不可<br>5、Redis 集群的主从复制模型是怎样的？<br>6、Redis 集群会有写操作丢失吗？为什么？<br>7、Redis 集群之间是如何复制的？<br>8、Redis 集群最大节点个数是多少？<br>9、Redis 集群如何选择数据库？<br>10、如何实现集群中的 session 共享存储？</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis实战》</li><li>《Redis设计与实现》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot;&gt;&lt;a href=&quot;#摘要：从面试题入手，带着问题来了解-Redis-中的各种原理。&quot; class=&quot;headerlink&quot; title=&quot;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&quot;&gt;&lt;/a&gt;摘要：从面试题入手，带着问题来了解 Redis 中的各种原理。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot;&gt;&lt;a href=&quot;#前言：大家在平时的开发中或多或少都应该用过-Redis-，就拿我自己来说，虽然用了-Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A-good-day-from-now-on&quot; class=&quot;headerlink&quot; title=&quot;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&quot;&gt;&lt;/a&gt;前言：大家在平时的开发中或多或少都应该用过 Redis ，就拿我自己来说，虽然用了 Redis，但是在大多数的场景下，只是局限于如何使用，对其中的原理没有很深入的了解，这就导致，遇到问题的时候，无法快速定位、排查问题，甚至一开始就使用错误了，其实这个是开发中的大忌—-只知其然，而不知其所以然，为了避免出现类似的情况，接下来让我们来一起学习一下其中的原理吧！下面的内容我会分成3篇文章，分别是基础篇、进阶篇、拓展篇。A good day from now on!&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;文章关联&quot;&gt;&lt;a href=&quot;#文章关联&quot; class=&quot;headerlink&quot; title=&quot;文章关联&quot;&gt;&lt;/a&gt;文章关联&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blog.ajie39.top/2021/05/05/Redis%E4%B9%8B%E4%BB%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%8B%93%E5%B1%95%E7%AF%87%EF%BC%89/&quot;&gt; Redis 之从面试题到原理（拓展篇）&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/categories/%E9%9D%A2%E8%AF%95/Redis/"/>
    
    
    <category term="面试" scheme="https://www.blog.ajie39.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="Redis" scheme="https://www.blog.ajie39.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁原理分析与应用</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2021-05-05T07:54:50.000Z</published>
    <updated>2022-01-17T15:59:28.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：这篇文章主要是介绍分布式锁相关的内容。"><a href="#摘要：这篇文章主要是介绍分布式锁相关的内容。" class="headerlink" title="摘要：这篇文章主要是介绍分布式锁相关的内容。"></a>摘要：这篇文章主要是介绍分布式锁相关的内容。</h1><hr><h1 id="前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"><a href="#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。" class="headerlink" title="前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。"></a>前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。</h1><hr><span id="more"></span><h2 id="分布式锁的使用场景"><a href="#分布式锁的使用场景" class="headerlink" title="分布式锁的使用场景"></a>分布式锁的使用场景</h2><ul><li><p>效率性:使用分布式锁可以避免不同节点重复相同的工作。</p></li><li><p>正确性:分布式锁可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</p></li></ul><h2 id="分布式锁的几种特性"><a href="#分布式锁的几种特性" class="headerlink" title="分布式锁的几种特性"></a>分布式锁的几种特性</h2><ul><li><p>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</p></li><li><p>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</p></li><li><p>锁超时:和本地锁一样支持锁超时，防止死锁。</p></li><li><p>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</p></li><li><p>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</p></li><li><p>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。</p></li></ul><h2 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h2><p>分布式锁有以下几个方式:</p><ul><li>MySql</li><li>Zk</li><li>Redis</li><li>一些自研的分布式锁(Chubby)</li></ul><h3 id="一、基于-Mysql-实现分布式锁"><a href="#一、基于-Mysql-实现分布式锁" class="headerlink" title="一、基于 Mysql 实现分布式锁"></a>一、基于 Mysql 实现分布式锁</h3><p>1、首先，我们需要创建一个锁表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE &#96;resource_lock&#96; (</span><br><span class="line">    &#96;id&#96; int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;resource_name&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;资源名称&#39;,</span><br><span class="line">    &#39;node_info&#39; varchar(128) DEFAULT &#39;0&#39; COMMENT &#39;节点信息&#39;,</span><br><span class="line">    &#39;count&#39; int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT  &#39;锁的次数，统计可重入锁&#39;,</span><br><span class="line">    &#39;desc&#39; varchar(128) DEFAULT NULL COMMENT &#39;额外的描述信息&#39;,</span><br><span class="line">    &#96;create_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">    &#96;update_time&#96; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,</span><br><span class="line">    PRIMARY KEY (&#39;id&#39;),</span><br><span class="line">    UNIQUE KEY &#39;un_resource_name&#39; (&#39;resource_name&#39;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET &#x3D; utf8mb4;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、lock</p><p>先进行查询，如果有值，那么需要比较 node_info 是否一致，这里的 node_info 可以用机器 IP 和线程名字来表示，如果一致那么就加可重入锁 count 的值，如果不一致那么就返回 false 。如果没有值那么直接插入一条数据。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加事务，原子性</span><br><span class="line">@Transaction</span><br><span class="line">public void lock() &#123;</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断节点信息是否一致</span><br><span class="line">        if (currentNodeInfo &#x3D;&#x3D; resultNodeInfo) &#123;</span><br><span class="line">            &#x2F;&#x2F; 保住锁的可重入性</span><br><span class="line">            update resource_lock set count &#x3D; count + 1 where resource_name &#x3D; &#39;xxx&#39;;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 插入新数据</span><br><span class="line">        insert into resourceLock;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、tryLock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean tryLock(long timeOut) &#123;</span><br><span class="line">    long stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    long endTimeOut &#x3D; stTime + timeOut;</span><br><span class="line"></span><br><span class="line">    while (endTimeOut &gt; stTime) &#123;</span><br><span class="line">        if (mysqlLock.lock()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 休眠3s后重试</span><br><span class="line">        LockSupport.parkNanos(1000 * 1000 * 1000 * 1);</span><br><span class="line">        stTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、unlock</p><p>伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Transaction</span><br><span class="line">public boolean unlock() &#123;</span><br><span class="line">    &#x2F;&#x2F; 查询是否有数据</span><br><span class="line">    if (select * from resource_lock where resource_name &#x3D; &#39;xxx&#39; for update;) &#123;</span><br><span class="line">        &#x2F;&#x2F; count为1那么可以删除，如果大于1那么需要减去1。</span><br><span class="line">        if (count &gt; 1) &#123;</span><br><span class="line">            update count &#x3D; count - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、定时清理因为机器宕机导致的锁未被释放的问题</p><p>启动一个定时任务，当这个锁远超过任务的执行时间，没有被释放我们就可以认定是节点挂了然后将其直接释放。</p><h3 id="二、基于单Redis节点的分布式锁"><a href="#二、基于单Redis节点的分布式锁" class="headerlink" title="二、基于单Redis节点的分布式锁"></a>二、基于单Redis节点的分布式锁</h3><p>首先，Redis客户端为了获取锁，向Redis节点发送如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SET resource_name my_random_value NX PX 30000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。</p><p>注意，在上面的SET命令中：</p><ul><li>my_random_value是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。</li><li>NX表示只有当resource_name对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。</li><li>PX 30000表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。</li></ul><p>最后，当客户端完成了对共享资源的操作之后，执行下面的Redis Lua脚本来释放锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">     return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line"> else</span><br><span class="line">     return 0</span><br><span class="line"> end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段Lua脚本在执行的时候要把前面的my_random_value作为 ARGV[1] 的值传进去，把 resource_name 作为 KEYS[1] 的值传进去。</p><p>至此，基于单Redis节点的分布式锁的算法就描述完了。</p><h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><h5 id="第一点：过期时间"><a href="#第一点：过期时间" class="headerlink" title="第一点：过期时间"></a>第一点：过期时间</h5><p>首先第一个问题，这个锁必须要设置一个过期时间。<br>否则的话，当一个客户端获取锁成功之后，假如它崩溃了，或者由于发生了网络分割（network partition）导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了，而且把这个过期时间称为锁的有效时间(lock validity time)。获得锁的客户端必须在这个时间之内完成对共享资源的访问。</p><h5 id="第二点：获取锁"><a href="#第二点：获取锁" class="headerlink" title="第二点：获取锁"></a>第二点：获取锁</h5><p>第二个问题，第一步获取锁的操作，网上不少文章把它实现成了两个Redis命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SETNX resource_name my_random_value</span><br><span class="line">EXPIRE resource_name 30</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然这两个命令和前面算法描述中的一个SET命令执行效果相同，但却不是原子的。如果客户端在执行完SETNX后崩溃了，那么就没有机会执行EXPIRE了，导致它一直持有这个锁。</p><h5 id="第三点：my-random-value"><a href="#第三点：my-random-value" class="headerlink" title="第三点：my_random_value"></a>第三点：my_random_value</h5><p>第三个问题，设置一个随机字符串 my_random_value 是很有必要的，它保证了一个客户端释放的锁必须是自己持有的那个锁。</p><p>假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1在某个操作上阻塞了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，释放掉了客户端2持有的锁。</li><li>之后，客户端2在访问共享资源的时候，就没有锁为它提供保护了。</li></ul><h5 id="第四点：Lua脚本"><a href="#第四点：Lua脚本" class="headerlink" title="第四点：Lua脚本"></a>第四点：Lua脚本</h5><p>第四个问题，释放锁的操作必须使用Lua脚本来实现。释放锁其实包含三步操作：获取、判断和删除，用Lua脚本来实现能保证这三步的原子性。</p><p>否则，如果把这三步操作放到客户端逻辑中去执行的话，就有可能发生与前面第三个问题类似的执行序列：</p><ul><li>客户端1获取锁成功。</li><li>客户端1访问共享资源。</li><li>客户端1为了释放锁，先执行’GET’操作获取随机字符串的值。</li><li>客户端1判断随机字符串的值，与预期的值相等。</li><li>客户端1由于某个原因阻塞住了很长时间。</li><li>过期时间到了，锁自动释放了。</li><li>客户端2获取到了对应同一个资源的锁。</li><li>客户端1从阻塞中恢复过来，执行DEL操纵，释放掉了客户端2持有的锁。</li></ul><p>实际上，在上述第三个问题和第四个问题的分析中，如果不是客户端阻塞住了，而是出现了大的网络延迟，也有可能导致类似的执行序列发生。</p><p>这四个问题，只要实现分布式锁的时候加以注意，就都能够被正确处理。</p><p>但除此之外，还有一个问题，是由 failover（故障转移） 引起的，却是基于单Redis节点的分布式锁无法解决的。正是这个问题催生了Redlock的出现。</p><h5 id="多个Redis节点的情况下会产生的问题"><a href="#多个Redis节点的情况下会产生的问题" class="headerlink" title="多个Redis节点的情况下会产生的问题"></a>多个Redis节点的情况下会产生的问题</h5><p>这个问题是这样的。假如Redis节点宕机了，那么所有客户端就都无法获得锁了，服务变得不可用。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。</p><p>例如下面的执行序列：</p><ul><li>客户端1从Master获取了锁。</li><li>Master宕机了，存储锁的key还没有来得及同步到Slave上。</li><li>Slave升级为Master。</li><li>客户端2从新的Master获取到了对应同一个资源的锁。</li></ul><p>于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破。</p><h4 id="三、分布式锁-Redlock"><a href="#三、分布式锁-Redlock" class="headerlink" title="三、分布式锁 Redlock"></a>三、分布式锁 Redlock</h4><p>前面介绍的基于单Redis节点的分布式锁在failover的时候会产生解决不了的安全性问题，因此antirez提出了新的分布式锁的算法Redlock，它基于N个完全独立的Redis节点（通常情况下N可以设置成5）。</p><p>运行Redlock算法的客户端依次执行下面各个步骤，来完成获取锁的操作：</p><p>1、获取当前时间（毫秒数）。</p><p>2、按顺序依次向N个Redis节点执行获取锁的操作。这个获取操作跟前面基于单Redis节点的获取锁的过程相同，包含随机字符串my_random_value，也包含过期时间(比如PX 30000，即锁的有效时间)。为了保证在某个Redis节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间(time out)，它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个Redis节点获取锁失败以后，应该立即尝试下一个Redis节点。这里的失败，应该包含任何类型的失败，比如该Redis节点不可用，或者该Redis节点上的锁已经被其它客户端持有（注：Redlock原文中这里只提到了Redis节点不可用的情况，但也应该包含其它的失败情况）。</p><p>3、计算整个获取锁的过程总共消耗了多长时间，计算方法是用当前时间减去第1步记录的时间。如果客户端从大多数Redis节点（&gt;= N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间(lock validity time)，那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。</p><p>4、如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第3步计算出来的获取锁消耗的时间。</p><p>5、如果最终获取锁失败了（可能由于获取到锁的Redis节点个数少于N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有Redis节点发起释放锁的操作（即前面介绍的Redis Lua脚本）。</p><p>上面描述的只是获取锁的过程，而释放锁的过程比较简单：客户端向所有Redis节点发起释放锁的操作，不管这些节点当时在获取锁的时候成功与否。</p><p>由于N个Redis节点中的大多数能正常工作就能保证Redlock正常工作，因此理论上它的可用性更高。我们前面讨论的单Redis节点的分布式锁在failover的时候锁失效的问题，在Redlock中不存在了，但如果有节点发生崩溃重启，还是会对锁的安全性有影响的。具体的影响程度跟Redis对数据的持久化程度有关。</p><h5 id="节点崩溃可能导致的问题"><a href="#节点崩溃可能导致的问题" class="headerlink" title="节点崩溃可能导致的问题"></a>节点崩溃可能导致的问题</h5><p>假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：</p><p>1、客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。</p><p>2、节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。</p><p>3、节点C重启后，客户端2锁住了C, D, E，获取锁成功。</p><p>4、这样，客户端1和客户端2同时获得了锁（针对同一资源）。</p><p>在默认情况下，Redis的AOF持久化方式是每秒写一次磁盘（即执行fsync），因此最坏情况下可能丢失1秒的数据。为了尽可能不丢数据，Redis允许设置成每次修改数据都进行fsync，但这会降低性能。当然，即使执行了fsync也仍然有可能丢失数据（这取决于系统而不是Redis的实现）。所以，上面分析的由于节点重启引发的锁失效问题，总是有可能出现的。为了应对这一问题，antirez又提出了延迟重启(delayed restarts)的概念。也就是说，一个节点崩溃后，先不立即重启它，而是等待一段时间再重启，这段时间应该大于锁的有效时间(lock validity time)。这样的话，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。</p><h5 id="客户端应该向所有Redis节点发起释放锁的操作？"><a href="#客户端应该向所有Redis节点发起释放锁的操作？" class="headerlink" title="客户端应该向所有Redis节点发起释放锁的操作？"></a>客户端应该向所有Redis节点发起释放锁的操作？</h5><p>在最后释放锁的时候，antirez在算法描述中特别强调，客户端应该向所有Redis节点发起释放锁的操作。也就是说，即使当时向某个节点获取锁没有成功，在释放锁的时候也不应该漏掉这个节点。这是为什么呢？</p><p>设想这样一种情况，客户端发给某个Redis节点的获取锁的请求成功到达了该Redis节点，这个节点也成功执行了SET操作，但是它返回给客户端的响应包却丢失了。这在客户端看来，获取锁的请求由于超时而失败了，但在Redis这边看来，加锁已经成功了。因此，释放锁的时候，客户端也应该对当时获取锁失败的那些Redis节点同样发起请求。实际上，这种情况在异步通信模型中是有可能发生的：客户端向服务器通信是正常的，但反方向却是有问题的。</p><h3 id="四、基于zk实现分布式锁"><a href="#四、基于zk实现分布式锁" class="headerlink" title="四、基于zk实现分布式锁"></a>四、基于zk实现分布式锁</h3><p>ZooKeeper是以Paxos算法为基础分布式应用程序协调服务。Zk的数据节点和文件目录类似，所以我们可以用此特性实现分布式锁。</p><p>基本实现步骤如下：</p><p>1、客户端尝试创建一个znode节点，比如/lock。那么第一个客户端就创建成功了，相当于拿到了锁；而其它的客户端会创建失败（znode已存在），获取锁失败。</p><p>2、持有锁的客户端访问共享资源完成后，将znode删掉，这样其它客户端接下来就能来获取锁了。</p><p>注意：<br>  这里的znode应该被创建成ephemeral的（临时节点）。这是znode的一个特性，它保证如果创建znode的那个客户端崩溃了，那么相应的znode会被自动删除。这保证了锁一定会被释放。</p><h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><p>看起来这个锁相当完美，没有Redlock过期时间的问题，而且能在需要的时候让锁自动释放。但其实也存在这其中也存在问题。</p><p>ZooKeeper是怎么检测出某个客户端已经崩溃了呢？实际上，每个客户端都与ZooKeeper的某台服务器维护着一个Session，这个Session依赖定期的心跳(heartbeat)来维持。如果ZooKeeper长时间收不到客户端的心跳（这个时间称为Sesion的过期时间），那么它就认为Session过期了，通过这个Session所创建的所有的ephemeral类型的znode节点都会被自动删除。</p><p>假如按照下面的顺序执行：</p><p>1、客户端1创建了znode节点/lock，获得了锁。</p><p>2、客户端1进入了长时间的GC pause。</p><p>3、客户端1连接到ZooKeeper的Session过期了。znode节点/lock被自动删除。</p><p>4、客户端2创建了znode节点/lock，从而获得了锁。</p><p>5、客户端1从GC pause中恢复过来，它仍然认为自己持有锁。</p><p>由上面的执行顺序，可以发现最后客户端1和客户端2都认为自己持有了锁，冲突了。所以说，用ZooKeeper实现的分布式锁也不一定就是安全的，该有的问题它还是有。</p><h4 id="zk的watch机制"><a href="#zk的watch机制" class="headerlink" title="zk的watch机制"></a>zk的watch机制</h4><p>ZooKeeper有个很特殊的机制–watch机制。这个机制可以这样来使用，比如当客户端试图创建 /lock 节点的时候，发现它已经存在了，这时候创建失败，但客户端不一定就此对外宣告获取锁失败。客户端可以进入一种等待状态，等待当/lock节点被删除的时候，ZooKeeper通过watch机制通知它，这样它就可以继续完成创建操作（获取锁）。这可以让分布式锁在客户端用起来就像一个本地的锁一样：加锁失败就阻塞住，直到获取到锁为止。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6844903688088059912">https://juejin.cn/post/6844903688088059912</a></li><li>Redlock的算法：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></li><li><a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></li><li>linux的同步IO操作函数: sync、fsync与fdatasync：<a href="https://my.oschina.net/u/1377774/blog/529847">https://my.oschina.net/u/1377774/blog/529847</a></li><li><a href="https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w">https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;a href=&quot;#摘要：这篇文章主要是介绍分布式锁相关的内容。&quot; class=&quot;headerlink&quot; title=&quot;摘要：这篇文章主要是介绍分布式锁相关的内容。&quot;&gt;&lt;/a&gt;摘要：这篇文章主要是介绍分布式锁相关的内容。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;a href=&quot;#前言：对于锁大家肯定不会陌生，比如-synchronized-关键字-和-ReentrantLock-可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot; class=&quot;headerlink&quot; title=&quot;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&quot;&gt;&lt;/a&gt;前言：对于锁大家肯定不会陌生，比如 synchronized 关键字 和 ReentrantLock 可重入锁，一般我们用其在多线程环境中控制对资源的并发访问。但是随着业务的发展，分布式的概念逐渐出现在我们系统中，我们在开发的过程中经常需要进行多个系统之间的交互，于是上面的加锁方法就会失去作用。于是在分布式锁就自然而然的诞生了，接下来我们来聊一聊分布式锁实现的几种方式。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://www.blog.ajie39.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式锁" scheme="https://www.blog.ajie39.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>YAML的常用语法</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/YAML%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/YAML%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</id>
    <published>2021-05-05T04:26:56.000Z</published>
    <updated>2021-05-05T04:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：主要介绍YAML的常用语法"><a href="#摘要：主要介绍YAML的常用语法" class="headerlink" title="摘要：主要介绍YAML的常用语法"></a>摘要：主要介绍YAML的常用语法</h1><hr><h1 id="前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。"><a href="#前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。" class="headerlink" title="前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。"></a>前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。</h1><hr><span id="more"></span><h1 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h1><h2 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h2><p><strong>诞生</strong></p><p>  YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822。Clark Evans在2001年5月在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。</p><p><strong>命名</strong></p><p>  YAML是<code>&quot;YAML Ain&#39;t a Markup Languag&quot;</code>（YAML不是一种置标语言）的递归缩写。在开发的这种语言时，YAML的意思其实是：Yet Another Markup Language（仍是一种置标语言）。</p><p><strong>功能</strong></p><p>  YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表，标量等资料形态、。它使用空白符号缩排和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种设定档、倾印除错内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。尽管它比较适合用来表达阶层式（hierarchical model）的数据结构，不过也有精致的语法可以表示关联性（relational model）的资料。由于YAML使用空白字符和分行来分隔资料，使得它他特别适合用grep、Python、Perl、Ruby操作。其让人最容易上手的特色是巧妙避开各种封闭符号，如：引号、各种括号等，这些符号在嵌套结构中会变得复杂而难以辨认。</p><p><strong>它的基本语法规则如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 大小写敏感。</span><br><span class="line">- 使用缩进表示层级关系。</span><br><span class="line">- 缩进时不允许使用Tab键，只允许使用空格。</span><br><span class="line">- 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可。</span><br></pre></td></tr></table></figure><p><code># 表示注释，从这个字符一直到行尾，都会被解析器忽略。</code></p><p><strong>YAML 支持的数据结构有三种：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hashes） &#x2F; 字典（dictionary）</span><br><span class="line">- 数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</span><br><span class="line">- 纯量（scalars）：单个的、不可再分的值</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的一组键值对，使用冒号结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal: pets</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal: &#39;pets&#39; &#125;</span><br></pre></td></tr></table></figure><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash: &#123; name: Steve, foo: bar &#125;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; hash: &#123; name: &#39;Steve&#39;, foo: &#39;bar&#39; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一组连词线开头的行，构成一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Cat</span><br><span class="line">- Dog</span><br><span class="line">- Goldfish</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#39;Cat&#39;, &#39;Dog&#39;, &#39;Goldfish&#39; ]</span><br></pre></td></tr></table></figure><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line"> - Cat</span><br><span class="line"> - Dog</span><br><span class="line"> - Goldfish</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ &#39;Cat&#39;, &#39;Dog&#39;, &#39;Goldfish&#39; ] ]</span><br></pre></td></tr></table></figure><p>数组也可以采用行内表示法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal: [Cat, Dog]</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal: [ &#39;Cat&#39;, &#39;Dog&#39; ] &#125;</span><br></pre></td></tr></table></figure><h3 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h3><p>对象和数组可以结合使用，形成复合结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">languages:</span><br><span class="line"> - Ruby</span><br><span class="line"> - Perl</span><br><span class="line"> - Python</span><br><span class="line">websites:</span><br><span class="line"> YAML: yaml.org</span><br><span class="line"> Ruby: ruby-lang.org</span><br><span class="line"> Python: python.org</span><br><span class="line"> Perl: use.perl.org</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; languages: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39; ],</span><br><span class="line">  websites:</span><br><span class="line">   &#123; YAML: &#39;yaml.org&#39;,</span><br><span class="line">     Ruby: &#39;ruby-lang.org&#39;,</span><br><span class="line">     Python: &#39;python.org&#39;,</span><br><span class="line">     Perl: &#39;use.perl.org&#39; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h3><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串</span><br><span class="line">布尔值</span><br><span class="line">整数</span><br><span class="line">浮点数</span><br><span class="line">Null</span><br><span class="line">时间</span><br><span class="line">日期</span><br></pre></td></tr></table></figure><p>数值直接以字面量的形式表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number: 12.30</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; number: 12.30 &#125;</span><br></pre></td></tr></table></figure><p>布尔值用true和false表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isSet: true</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; isSet: true &#125;</span><br></pre></td></tr></table></figure><p>null用~表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent: ~</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; parent: null &#125;</span><br></pre></td></tr></table></figure><p>时间采用 ISO8601 格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iso8601: 2001-12-14t21:59:43.10-05:00</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; iso8601: new Date(&#39;2001-12-14t21:59:43.10-05:00&#39;) &#125;</span><br></pre></td></tr></table></figure><p>日期采用复合 iso8601 格式的年、月、日表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date: 1976-07-31</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; date: new Date(&#39;1976-07-31&#39;) &#125;</span><br></pre></td></tr></table></figure><p>YAML 允许使用两个感叹号，强制转换数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e: !!str 123</span><br><span class="line">f: !!str true</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; e: &#39;123&#39;, f: &#39;true&#39; &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是最常见，也是最复杂的一种数据类型。</p><p>字符串默认不使用引号表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: 这是一行字符串</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;这是一行字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>如果字符串之中包含空格或特殊字符，需要放在引号之中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: &#39;内容： 字符串&#39;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;内容: 字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>单引号和双引号都可以使用，双引号不会对特殊字符转义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1: &#39;内容\n字符串&#39;</span><br><span class="line">s2: &quot;内容\n字符串&quot;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; s1: &#39;内容\\n字符串&#39;, s2: &#39;内容\n字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>单引号之中如果还有单引号，必须连续使用两个单引号转义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: &#39;labor&#39;&#39;s day&#39;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;labor\&#39;s day&#39; &#125;</span><br></pre></td></tr></table></figure><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str: 这是一段</span><br><span class="line">  多行</span><br><span class="line">  字符串</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; str: &#39;这是一段 多行 字符串&#39; &#125;</span><br></pre></td></tr></table></figure><p>多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this: |</span><br><span class="line">  Foo</span><br><span class="line">  Bar</span><br><span class="line">that: &gt;</span><br><span class="line">  Foo</span><br><span class="line">  Bar</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; this: &#39;Foo\nBar\n&#39;, that: &#39;Foo Bar\n&#39; &#125;</span><br></pre></td></tr></table></figure><p>+表示保留文字块末尾的换行，-表示删除字符串末尾的换行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1: |</span><br><span class="line">  Foo</span><br><span class="line"></span><br><span class="line">s2: |+</span><br><span class="line">  Foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s3: |-</span><br><span class="line">  Foo</span><br></pre></td></tr></table></figure><p>转为 JavaScript 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; s1: &#39;Foo\n&#39;, s2: &#39;Foo\n\n\n&#39;, s3: &#39;Foo&#39; &#125;</span><br></pre></td></tr></table></figure><p>字符串之中可以插入 HTML 标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message: |</span><br><span class="line"></span><br><span class="line">  &lt;p style&#x3D;&quot;color: red&quot;&gt;</span><br><span class="line">    段落</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; message: &#39;\n&lt;p style&#x3D;&quot;color: red&quot;&gt;\n  段落\n&lt;&#x2F;p&gt;\n&#39; &#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaults: &amp;defaults</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure><p>等同于下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaults:</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br></pre></td></tr></table></figure><p><code>&amp;</code>用来建立锚点（defaults），<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点。</p><p>下面是另一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- &amp;showell Steve</span><br><span class="line">- Clark</span><br><span class="line">- Brian</span><br><span class="line">- Oren</span><br><span class="line">- *showell</span><br></pre></td></tr></table></figure><p>转为 JavaScript 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#39;Steve&#39;, &#39;Clark&#39;, &#39;Brian&#39;, &#39;Oren&#39;, &#39;Steve&#39; ]</span><br></pre></td></tr></table></figure><h3 id="函数和正则表达式的转换"><a href="#函数和正则表达式的转换" class="headerlink" title="函数和正则表达式的转换"></a>函数和正则表达式的转换</h3><p>这是<a href="https://github.com/nodeca/js-yaml">JS-YAML</a>库特有的功能，可以把函数和正则表达式转为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># example.yml</span><br><span class="line">fn: function () &#123; return 1 &#125;</span><br><span class="line">reg: &#x2F;test&#x2F;</span><br></pre></td></tr></table></figure><p>解析上面的 yml 文件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var yaml &#x3D; require(&#39;js-yaml&#39;);</span><br><span class="line">var fs   &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  var doc &#x3D; yaml.load(</span><br><span class="line">    fs.readFileSync(&#39;.&#x2F;example.yml&#39;, &#39;utf8&#39;)</span><br><span class="line">  );</span><br><span class="line">  console.log(doc);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 JavaScript 对象还原到 yaml 文件的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var yaml &#x3D; require(&#39;js-yaml&#39;);</span><br><span class="line">var fs   &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  fn: function () &#123; return 1 &#125;,</span><br><span class="line">  reg: &#x2F;test&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    &#39;.&#x2F;example.yml&#39;,</span><br><span class="line">    yaml.dump(obj),</span><br><span class="line">    &#39;utf8&#39;</span><br><span class="line">  );</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：主要介绍YAML的常用语法&quot;&gt;&lt;a href=&quot;#摘要：主要介绍YAML的常用语法&quot; class=&quot;headerlink&quot; title=&quot;摘要：主要介绍YAML的常用语法&quot;&gt;&lt;/a&gt;摘要：主要介绍YAML的常用语法&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot;&gt;&lt;a href=&quot;#前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot; class=&quot;headerlink&quot; title=&quot;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&quot;&gt;&lt;/a&gt;前言：上一篇文章我们已经学会了一些基本美化博客的技巧，接下来我们将学习YAML的常用语法。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="杂项" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    <category term="Blog" scheme="https://www.blog.ajie39.top/categories/%E6%9D%82%E9%A1%B9/Blog/"/>
    
    
    <category term="YAML" scheme="https://www.blog.ajie39.top/tags/YAML/"/>
    
  </entry>
  
  <entry>
    <title>Spring中常用的注解</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/Spring%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/Spring%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-05-05T04:26:50.000Z</published>
    <updated>2021-05-05T04:26:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：本文主要总结了一些Spring和Spring-MVC中常用的注解。"><a href="#摘要：本文主要总结了一些Spring和Spring-MVC中常用的注解。" class="headerlink" title="摘要：本文主要总结了一些Spring和Spring MVC中常用的注解。"></a>摘要：本文主要总结了一些Spring和Spring MVC中常用的注解。</h1><hr><h1 id="前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。"><a href="#前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。" class="headerlink" title="前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。"></a>前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。</h1><hr><span id="more"></span><h2 id="Spring中常用注解"><a href="#Spring中常用注解" class="headerlink" title="Spring中常用注解"></a>Spring中常用注解</h2><h3 id="1、声明bean的注解"><a href="#1、声明bean的注解" class="headerlink" title="1、声明bean的注解"></a>1、声明bean的注解</h3><ul><li><p>@Component：这个更多对应的是一个组件的概念，如果一个Bean不知道属于哪个层，可以使用@Component注解标注</p><ol><li>@Component作用在类上</li><li>@Component注解作用域默认为singleton</li><li>使用注解配置和类路径扫描时，被@Component注解标注的类会被Spring扫描并注册为Bean</li><li>@Component使用在不确定哪一个层的时候使用，可以作用在任何层次，把普通pojo实例化到spring容器，不推荐使用@Component注解，而应该使用它的扩展，如@Service、@Repository</li><li>@Component使用时没有传参数，Bean名称默认为当前类的类名，首字母小写</li><li>@Component(“serviceBeanId”)或 @Component(value=”serviceBeanId”)使用时传参数，使用value作为Bean名字</li></ol></li><li><p>@Service：对应的是服务层即Service层，其作用是对单条/多条Sql语句进行组合处理，当然如果简单的话就直接调用Dao层的某个方法了</p><ol><li><p>@Service是@Component注解的一个特例，作用在类上</p></li><li><p>@Service注解作用域默认为singleton</p></li><li><p>使用注解配置和类路径扫描时，被@Service注解标注的类会被Spring扫描并注册为Bean</p></li><li><p>@Service用于标注业务层组件,表示定义一个bean</p></li><li><p>@Service使用时没有传参数，Bean名称默认为当前类的类名，首字母小写</p></li><li><p>@Service(“serviceBeanId”)或 @Service(value=”serviceBeanId”)使用时传参数，使用value作为Bean名字</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @service注解举例 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.demo.annotation.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name = <span class="string">&quot;UserServiceImpl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@Service(value=&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImplWithParam</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;UserServiceImplWithParam&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.DemoApplication;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.annotation.IUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        IUser serviceImpl1 = (UserServiceImpl) context.getBean(<span class="string">&quot;userServiceImpl&quot;</span>);</span><br><span class="line">        System.out.println(serviceImpl1.get());</span><br><span class="line"></span><br><span class="line">        IUser serviceImpl2 = (UserServiceImplWithParam)context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(serviceImpl2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  结果为:</span></span><br><span class="line"><span class="comment">          userServiceImpl</span></span><br><span class="line"><span class="comment">          UserServiceImplWithParam</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>@Repository：对应的是持久层即Dao层，其作用是直接和数据库交互，通常来说一个方法对应一条具体的Sql语句</p><ol><li>@Repository注解作用在类上</li><li>@Repository注解作用域默认为singleton</li><li>使用注解配置和类路径扫描时，被@Reposito注解标注的类会被Spring扫描并注册为Bean</li><li>@Repository注解用于标注数据访问组件，即DAO组件</li><li>@Repository注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* @Repository注解举例 */</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Repository注解默认作用域为singleton</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">UserRepositoryImpl</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Repository注解测试</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepopsitoryApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(RepopsitoryApplication.class, args);</span><br><span class="line"></span><br><span class="line">        UserRepositoryImpl userRepositoryImpl1 = (UserRepositoryImpl) context.getBean(<span class="string">&quot;userRepositoryImpl&quot;</span>);</span><br><span class="line">        UserRepositoryImpl userRepositoryImpl2 = (UserRepositoryImpl) context.getBean(<span class="string">&quot;userRepositoryImpl&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;@Repository注解默认作用域为singleton，返回true： &quot;</span> + userRepositoryImpl1.equals(userRepositoryImpl2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果为：<span class="doctag">@Repository</span>注解默认作用域为singleton，返回true：true</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>@Controller：对应的是控制层即MVC设计模式中的控制层，其作用是接收用户请求，根据请求调用不同的Service取数据，并根据需求对数据进行组合、包装返回给前端</p><ol><li>@Controller注解作用在类上</li><li>使用注解配置和类路径扫描时，被@Controller注解标注的类会被Spring扫描并注册为Bean</li><li>@Controller用于标注Web中控制层组件</li><li>被@Controller标注的类负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model返回给对应的View进行展示</li><li>@Controller和@RequestMapping、@RequestParam等一些注解共同处理URL的映射</li></ol></li></ul><h3 id="2、-Bean的属性支持"><a href="#2、-Bean的属性支持" class="headerlink" title="2、@Bean的属性支持"></a>2、@Bean的属性支持</h3><ul><li><p>@Scope：</p><ol><li><p>@Scope作用在类上和方法上</p></li><li><p>@Scope用来配置 spring bean 的作用域，它标识 bean 的作用域</p></li><li><p>@Scope有5中取值：</p><ul><li><p>基本作用域：</p><ol><li>org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_SINGLETON = “singleton”</li><li>org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_PROTOTYPE = “prototype”</li></ol></li><li><p>Web作用域：</p><ol><li>org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST = “request”</li><li>org.springframework.web.context.WebApplicationContext#SCOPE_SESSION = “session”</li><li>org.springframework.web.context.WebApplicationContext#SCOPE_APPLICATION = “application”</li></ol></li><li><p>singleton单例模式：</p><p>Spring 容器中有且只有一个Bean实例，只要Spring容器不销毁或退出，该Bean实例就会一直存活。</p></li><li><p>prototype原型模式：</p><p>每次获取Bean的时候会有一个新的实例，Spring容器不能对返回Bean实例的整个生命周期负责。</p></li><li><p>request模式：</p><p>request只适用于Web程序，每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，当请求结束后，该对象的生命周期即告结束。</p></li><li><p>session模式：</p><p>session只适用于Web程序，session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效。</p></li><li><p>application模式：</p><p>application只适用于Web程序，全局作用域。</p></li></ul></li></ol></li><li><p>@StepScope 在Spring Batch中还有涉及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(value=&quot;step&quot;,proxyMode=TARGET_CLASS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(value=RUNTIME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> StepScope</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Convenient annotation for step scoped beans that defaults the proxy mode, so that it doesn&#x27;t have to be</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> specified explicitly on every bean definition. Use this on any @Bean that needs to inject @Values from the step</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> context, and any bean that needs to share a lifecycle with a step execution (e.g. an ItemStream). E.g.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@StepScope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Callable&lt;String&gt; <span class="title">value</span><span class="params">(<span class="meta">@Value(&quot;#&#123;stepExecution.stepName&#125;&quot;)</span> <span class="keyword">final</span> String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimpleCallable(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Marking a @Bean as @StepScope is equivalent to marking it as @Scope(value=&quot;step&quot;, proxyMode=TARGET_CLASS) */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>@PostConstruct：被 @PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的inti()方法。被 @PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。</p></li><li><p>@PreDestory：被 @PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被 @PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前。</p></li></ul><h3 id="3、注入bean的注解"><a href="#3、注入bean的注解" class="headerlink" title="3、注入bean的注解"></a>3、注入bean的注解</h3><ul><li><p>@Autowired：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 源码 */</span></span><br><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. <span class="doctag">@since</span> 2.5</span></span><br><span class="line"><span class="comment"> 2. <span class="doctag">@see</span> AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> 3. <span class="doctag">@see</span> Qualifier</span></span><br><span class="line"><span class="comment"> 4. <span class="doctag">@see</span> Value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER,</span></span><br><span class="line"><span class="meta">   ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Autowired注解作用在构造函数、方法、方法参数、类字段以及注解上</li><li>@Autowired注解可以实现Bean的自动注入</li></ul><p>原理：</p><p>在Spring Boot应用启动时，Spring容器会自动装载一个org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor处理器，当容器扫描到@Autowired注解时，就会在IoC容器就会找相应类型的Bean，并且实现注入。</p><ol><li>在使用@Autowired注解时，首先在容器中查询对应类型的bean</li><li>如果查询结果Bean刚好为一个，自动注入</li><li>如果查询结果Bean不止一个，通过@Qualifier注解指定自动装配Bean的名称</li><li>如果没有查询到对应类型的Bean，由于默认@Autowired(required=true)，会抛出异常，解决方法是使用@Autoiwired(required=false)</li><li>@Autowired(required=true)意味着依赖是必须的</li><li>@Autowired(required=false)等于告诉 Spring：在找不到匹配 Bean 时也不报错</li></ol><p>使用：</p><p>在Web MVC中控制层（Controller）访问的是业务层（Service），而业务层（Service）访问的是数据层（Dao）,使用@Autowired注解实现注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据层接口，用于访问数据库，返回数据给业务层</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据层接口实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.数据层Bean用<span class="doctag">@Repository</span>标注</span></span><br><span class="line"><span class="comment"> * 2.当前Bean的名称是&quot;autowiredUserDaoImpl&quot;</span></span><br><span class="line"><span class="comment"> * 3.设置当前Bean的为原型模式，即每次获取Bean时都创建一个新实例</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Repository(&quot;autowiredUserDaoImpl&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">IDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;@Autowired注解实现自动装配&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务层接口</span></span><br><span class="line"><span class="comment"> * 从数据层获取数据，处理结果返回给控制层</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务层接口实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.数据层Bean用<span class="doctag">@Service</span>标注</span></span><br><span class="line"><span class="comment"> * 2.当前Bean的名称是&quot;autowiredUserServiceImpl&quot;</span></span><br><span class="line"><span class="comment"> * 3.设置当前Bean的为原型模式，即每次获取Bean时都创建一个新实例</span></span><br><span class="line"><span class="comment"> * 4.业务层有一个数据层接口IDao，使用<span class="doctag">@Autowired</span>注解标注</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;autowiredUserServiceImpl&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Autowired</span>实现自动装配</span></span><br><span class="line"><span class="comment">     * Spring IoC容器扫描到<span class="doctag">@Autowired</span>注解会去查询IDao的实现类，并自动注入</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Bean通过注解@Service声明为一个Spring容器管理的Bean，Spring容器会扫描classpath路径下的所有类，找到带有@Service注解的UserServiceImpl类，并根据Spring注解对其进行初始化和增强，命名为autowiredUserServiceImpl。</li><li>Spring容器如果发现此类属性dao也有注解@Autowired，则会从Spring容器中查找一个已经初始化好的IDao的实现类，如果没有找到，则先初始化一个IDao实现类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.chapter1.useannotation.autowired.service.IService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 1. 控制层</span></span><br><span class="line"><span class="comment"> 2.</span></span><br><span class="line"><span class="comment"> 3. 1.控制层使用<span class="doctag">@RestController</span>注解标注，返回json格式的字符串</span></span><br><span class="line"><span class="comment"> 4. 2.获取业务层返回的数据，输出到客户端</span></span><br><span class="line"><span class="comment"> 5. 3.请求：http:localhost:8080/autowiredController</span></span><br><span class="line"><span class="comment"> 6. */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/autowiredController&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Inject： @Inject支持构造函数、方法和字段注解，也可能使用于静态实例成员。可注解成员可以是任意修饰符（private,package-private,protected,public）。注入顺序：构造函数、字段，然后是方法。父类的字段和方法注入优先于子类的字段和方法，同一类中的字段和方法是没有顺序的。</p><ul><li><p>@Inject注解的构造函数可以是无参或多个参数的构造函数。@Inject每个类中最多注解一个构造函数。</p></li><li><p>在字段注解：</p><ul><li>用@Inject注解</li><li>字段不能是final的</li><li>拥有一个合法的名称</li></ul></li><li><p>在方法上注解：</p><ul><li>用@Inject注解</li><li>不能是抽象方法</li><li>不能声明自身参数类型</li><li>可以有返回结果</li><li>拥有一个合法的名称</li><li>可以有0个或多个参数</li></ul></li></ul></li><li><p>@Resource：@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行，按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;baseDao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> BaseDao baseDao;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4、java配置类相关注解"><a href="#4、java配置类相关注解" class="headerlink" title="4、java配置类相关注解"></a>4、java配置类相关注解</h3><ul><li><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）。</p></li><li><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）。</p></li><li><p>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）。</p></li><li><p>@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）。</p></li><li><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解。</p></li></ul><h3 id="5、切面（AOP）相关注解"><a href="#5、切面（AOP）相关注解" class="headerlink" title="5、切面（AOP）相关注解"></a>5、切面（AOP）相关注解</h3><p>Spring支持AspectJ的注解式切面编程。</p><ul><li><p>@Aspect 声明一个切面（类上）：使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。</p><ul><li>@After 在方法执行之后执行（方法上）</li><li>@Before 在方法执行之前执行（方法上）</li><li>@Around 在方法执行之前与之后执行（方法上）</li></ul></li><li><p>@PointCut 声明切点：在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）</p></li></ul><h3 id="6、-Value注解"><a href="#6、-Value注解" class="headerlink" title="6、@Value注解"></a>6、@Value注解</h3><h4 id="Value-为属性注入值（属性上）"><a href="#Value-为属性注入值（属性上）" class="headerlink" title="@Value 为属性注入值（属性上）"></a>@Value 为属性注入值（属性上）</h4><p>支持如下方式的注入：</p><ol><li>注入普通字符：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;Michael Jackson&quot;)</span></span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><ol start="2"><li>注入操作系统属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;os.name&#x27;]&#125;&quot;)</span></span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><ol start="3"><li>注入表达式结果</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;T(java.lang.Math).random() * 100&#125;&quot;)</span></span><br><span class="line">String randomNumber;</span><br></pre></td></tr></table></figure><ol start="4"><li>注入其他bean属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;domeClass.name&#125;&quot;)</span></span><br><span class="line">String name;</span><br></pre></td></tr></table></figure><ol start="5"><li>注入文件资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;classpath:com/hello/hello/text.txt&quot;)</span></span><br><span class="line">String Resource file;</span><br></pre></td></tr></table></figure><ol start="6"><li>注入网站资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;http://www.cznovel.com&quot;)</span></span><br><span class="line">Resource url;</span><br></pre></td></tr></table></figure><ol start="7"><li>注入配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span></span><br><span class="line">String bookname;</span><br></pre></td></tr></table></figure><h4 id="注入配置使用方法"><a href="#注入配置使用方法" class="headerlink" title="注入配置使用方法"></a>注入配置使用方法</h4><p>①. 编写配置文件（test.properties）</p><p>②. @PropertySource加载配置文件（类上）</p><p>③. 还需要配置一个PropertySourcesPlaceholderConfigurer的bean</p><h3 id="7、环境切换"><a href="#7、环境切换" class="headerlink" title="7、环境切换"></a>7、环境切换</h3><ul><li>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）</li><li>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</li></ul><h3 id="8、异步相关"><a href="#8、异步相关" class="headerlink" title="8、异步相关"></a>8、异步相关</h3><ul><li>@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上）</li><li>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务）</li></ul><h3 id="9、定时任务相关"><a href="#9、定时任务相关" class="headerlink" title="9、定时任务相关"></a>9、定时任务相关</h3><ul><li>@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）</li><li>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</li></ul><h3 id="10、-Enable-注解说明"><a href="#10、-Enable-注解说明" class="headerlink" title="10、@Enable*注解说明"></a>10、@Enable*注解说明</h3><p>这些注解主要用来开启对xxx的支持：</p><ul><li><p>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</p></li><li><p>@EnableAsync 开启异步方法的支持</p></li><li><p>@EnableScheduling 开启计划任务的支持</p></li><li><p>@EnableWebMvc 开启Web MVC的配置支持</p></li><li><p>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</p></li><li><p>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</p></li><li><p>@EnableTransactionManagement 开启注解式事务的支持</p></li><li><p>@EnableTransactionManagement 开启注解式事务的支持</p></li><li><p>@EnableCaching 开启注解式的缓存支持</p></li></ul><h3 id="11、测试相关注解"><a href="#11、测试相关注解" class="headerlink" title="11、测试相关注解"></a>11、测试相关注解</h3><ul><li>@RunWith 运行器，Spring中通常用于对JUnit的支持</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br></pre></td></tr></table></figure><ul><li>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes=&#123;TestConfig.class&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="Spring-MVC中常用注解"><a href="#Spring-MVC中常用注解" class="headerlink" title="Spring MVC中常用注解"></a>Spring MVC中常用注解</h2><ol><li><p>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。</p></li><li><p>@Controller 声明该类为SpringMVC中的Controller</p></li><li><p>@RequestMapping RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p></li><li><p>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</p></li><li><p>@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）</p></li><li><p>@PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p></li><li><p>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。</p></li><li><p>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，这对所有注解了 @RequestMapping的控制器内的方法有效。</p></li><li><p>@ExceptionHandler 用于全局处理控制器里的异常</p></li><li><p>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。</p></li><li><p>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的 @RequestMapping都能获得在此处设置的键值对。</p></li></ol><h2 id="其它注解"><a href="#其它注解" class="headerlink" title="其它注解"></a>其它注解</h2><ol><li><p>@SpringBootApplication： @SpringBootApplication是一个复合注解，包括@ComponentScan，和@SpringBootConfiguration，@EnableAutoConfiguration。</p><ul><li><p>@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到srping容器中，并且实例名就是方法名。</p></li><li><p>@EnableAutoConfiguration的作用启动自动的配置，@EnableAutoConfiguration注解的意思就是Springboot根据你添加的jar包来配置你项目的默认配置，比如根据spring-boot-starter-web ，来判断你的项目是否需要添加了webmvc和tomcat，就会自动的帮你配置web项目中所需要的默认配置。在下面博客会具体分析这个注解，快速入门的demo实际没有用到该注解。</p></li><li><p>@ComponentScan，扫描当前包及其子包下被@Component，@Controller，@Service，@Repository注解标记的类并纳入到spring容器中进行管理。是以前的<a href="context:component-scan">context:component-scan</a>（以前使用在xml中使用的标签，用来扫描包配置的平行支持）。所以本demo中的User为何会被spring容器管理。</p></li></ul></li><li><p>@RestController</p></li></ol><p>Spring4之后新加入的注解，原来返回json需要@ResponseBody和@Controller配合。</p><p>即@RestController是@ResponseBody和@Controller的组合注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello&quot;,method= RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/hello&quot;,method= RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>@Slf4j</li></ol><p>@slf4j注解用于打印日志，如果注解@Slf4j注入后找不到变量log，那就给IDE安装lombok插件</p><p>安装步骤：</p><p>Settings→Plugins→Browse repositories→lombok plugin</p><ol start="3"><li>@Override</li></ol><p>如果想重写父类的方法，比如toString()方法的话，在方法前面加上@Override 系统可以帮你检查方法的正确性。它说明了被标注的方法重载了父类的方法，起到了断言的作用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：本文主要总结了一些Spring和Spring-MVC中常用的注解。&quot;&gt;&lt;a href=&quot;#摘要：本文主要总结了一些Spring和Spring-MVC中常用的注解。&quot; class=&quot;headerlink&quot; title=&quot;摘要：本文主要总结了一些Spring和Spring MVC中常用的注解。&quot;&gt;&lt;/a&gt;摘要：本文主要总结了一些Spring和Spring MVC中常用的注解。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。&quot;&gt;&lt;a href=&quot;#前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。&quot; class=&quot;headerlink&quot; title=&quot;前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。&quot;&gt;&lt;/a&gt;前言：今天总结了一下这周所学习的内容，这是第一篇Spring中常用注解的总结。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/categories/Java/"/>
    
    <category term="Spring" scheme="https://www.blog.ajie39.top/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://www.blog.ajie39.top/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.blog.ajie39.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>python之操作Excel模块</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/python%E4%B9%8B%E6%93%8D%E4%BD%9CExcel%E6%A8%A1%E5%9D%97/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/python%E4%B9%8B%E6%93%8D%E4%BD%9CExcel%E6%A8%A1%E5%9D%97/</id>
    <published>2021-05-05T04:26:48.000Z</published>
    <updated>2021-05-05T04:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：python操作Excel文件，第三方模块汇总。"><a href="#摘要：python操作Excel文件，第三方模块汇总。" class="headerlink" title="摘要：python操作Excel文件，第三方模块汇总。"></a>摘要：python操作Excel文件，第三方模块汇总。</h1><hr><h1 id="前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。"><a href="#前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。" class="headerlink" title="前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。"></a>前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。</h1><hr><span id="more"></span><h2 id="常见库简介"><a href="#常见库简介" class="headerlink" title="常见库简介"></a>常见库简介</h2><h3 id="1-xlrd"><a href="#1-xlrd" class="headerlink" title="1.xlrd"></a>1.xlrd</h3><p>xlrd是一个从Excel文件读取数据和格式化信息的库，支持.xls以及.xlsx文件。<br><a href="http://xlrd.readthedocs.io/en/latest/">http://xlrd.readthedocs.io/en/latest/</a><br>    1、xlrd支持.xls，.xlsx文件的读<br>    2、通过设置on_demand变量使open_workbook()函数只加载那些需要的sheet，从而节省时间和内存（该方法对.xlsx文件无效）。<br>    3、xlrd.Book对象有一个unload_sheet方法，它将从内存中卸载工作表，由工作表索引或工作表名称指定（该方法对.xlsx文件无效）</p><h3 id="2-xlwt"><a href="#2-xlwt" class="headerlink" title="2.xlwt"></a>2.xlwt</h3><p>xlwt是一个用于将数据和格式化信息写入旧Excel文件的库（如.xls）。<br><a href="https://xlwt.readthedocs.io/en/latest/">https://xlwt.readthedocs.io/en/latest/</a><br>    1、xlwt支持.xls文件写。</p><h3 id="3-xlutils"><a href="#3-xlutils" class="headerlink" title="3.xlutils"></a>3.xlutils</h3><p>xlutils是一个处理Excel文件的库，依赖于xlrd和xlwt。<br><a href="http://xlutils.readthedocs.io/en/latest/">http://xlutils.readthedocs.io/en/latest/</a><br>    1、xlutils支持.xls文件。<br>    2、支持Excel操作。</p><h3 id="4-xlwings"><a href="#4-xlwings" class="headerlink" title="4.xlwings"></a>4.xlwings</h3><p>xlwings是一个可以实现从Excel调用Python，也可在python中调用Excel的库。<br><a href="http://docs.xlwings.org/en/stable/index.html">http://docs.xlwings.org/en/stable/index.html</a><br>    1、xlwings支持.xls读，支持.xlsx文件读写。<br>    2、支持Excel操作。<br>    3、支持VBA。<br>    4、强大的转换器可以处理大部分数据类型，包括在两个方向上的numpy array和pandas DataFrame。</p><h3 id="5-openpyxl"><a href="#5-openpyxl" class="headerlink" title="5.openpyxl"></a>5.openpyxl</h3><p>openpyxl是一个用于读取和编写Excel 2010 xlsx/xlsm/xltx/xltm文件的库。<br><a href="https://openpyxl.readthedocs.io/en/stable/">https://openpyxl.readthedocs.io/en/stable/</a><br>    1、openpyxl支持.xlsx文件的读写。<br>    2、支持Excel操作。<br>    3、加载大.xlsx文件可以使用read_only模式。<br>    4、写入大.xlsx文件可以使用write_only模式。</p><h3 id="6-xlsxwriter"><a href="#6-xlsxwriter" class="headerlink" title="6.xlsxwriter"></a>6.xlsxwriter</h3><p>xlsxwriter是一个用于创建Excel .xlsx文件的库。<br><a href="https://xlsxwriter.readthedocs.io/">https://xlsxwriter.readthedocs.io/</a><br>    1、xlswriter支持.xlsx文件的写。<br>    2、支持VBA。<br>    3、写入大.xlsx文件时使用内存优化模式。</p><h3 id="7-win32com"><a href="#7-win32com" class="headerlink" title="7.win32com"></a>7.win32com</h3><p>win32com库存在于pywin32中，是一个读写和处理Excel文件的库。<br><a href="http://pythonexcels.com/python-excel-mini-cookbook/">http://pythonexcels.com/python-excel-mini-cookbook/</a><br>    1、win32com支持.xls，.xlsx文件的读写，支持.xlsx文件的写。<br>    2、支持Excel操作。</p><h3 id="8-DataNitro"><a href="#8-DataNitro" class="headerlink" title="8.DataNitro"></a>8.DataNitro</h3><p>DataNitro是一个内嵌在Excel中的插件。<br><a href="https://datanitro.com/docs/">https://datanitro.com/docs/</a> <br>    1、DataNitro支持.xls，.xlsx文件的读写。<br>    2、支持Excel操作。<br>    3、支持VBA。<br>    4、收费</p><h3 id="9-pandas"><a href="#9-pandas" class="headerlink" title="9.pandas"></a>9.pandas</h3><p>pandas通过对Excel文件的读写实现数据输入输出<br><a href="http://pandas.pydata.org/">http://pandas.pydata.org/</a><br>    1、pandas支持.xls，.xlsx文件的读写。<br>    2、支持只加载每个表的单一工作页。</p><table><thead><tr><th></th><th>win</th><th>MAC</th><th>Py2</th><th>Py3</th><th>.xls</th><th>.xlsx</th><th>读</th><th>写</th><th>修改</th></tr></thead><tbody><tr><td>xlrd</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td></tr><tr><td>xlwt</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>xlutils</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&chi;</td><td>&chi;</td><td>&radic;</td></tr><tr><td>xlwings</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>openpyxl</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>xlswriter</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&chi;</td></tr><tr><td>win32com</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td></tr><tr><td>DataNitro</td><td>&radic;</td><td>&chi;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td></tr><tr><td>pandas</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&radic;</td><td>&chi;</td></tr></tbody></table><h3 id="提醒及注意："><a href="#提醒及注意：" class="headerlink" title="提醒及注意："></a>提醒及注意：</h3><p>xlutils 仅支持 xls 文件，即2003以下版本；<br>win32com 与 DataNitro 仅支持 windows 系统；<br>xlwings 安装成功后，如果运行提示报错“ImportError: no module named win32api”，请再安装 pypiwin32 或者 pywin32 包；<br>win32com 不是独立的扩展库，而是集成在其他库中，安装 pypiwin32 或者 pywin32 包即可使用；<br>DataNitro 是 Excel 的插件，安装需到官网下载。</p><h2 id="基本功能："><a href="#基本功能：" class="headerlink" title="基本功能："></a>基本功能：</h2><p>由于设计目的不同，每个模块通常着重于某一方面功能，各有所长。</p><h3 id="1-xlwings"><a href="#1-xlwings" class="headerlink" title="1.xlwings"></a>1.xlwings</h3><p>可结合 VBA 实现对 Excel 编程，强大的数据输入分析能力，同时拥有丰富的接口，结合 pandas/numpy/matplotlib 轻松应对 Excel 数据处理工作。</p><h3 id="2-openpyxl"><a href="#2-openpyxl" class="headerlink" title="2.openpyxl"></a>2.openpyxl</h3><p>简单易用，功能广泛，单元格格式/图片/表格/公式/筛选/批注/文件保护等等功能应有尽有，图表功能是其一大亮点，缺点是对 VBA 支持的不够好。</p><h3 id="3-pandas"><a href="#3-pandas" class="headerlink" title="3.pandas"></a>3.pandas</h3><p>数据处理是 pandas 的立身之本，Excel 作为 pandas 输入/输出数据的容器。</p><h3 id="4-win32com"><a href="#4-win32com" class="headerlink" title="4.win32com"></a>4.win32com</h3><p>从命名上就可以看出，这是一个处理 windows 应用的扩展，Excel 只是该库能实现的一小部分功能。该库还支持 office 的众多操作。需要注意的是，该库不单独存在，可通过安装 pypiwin32 或者 pywin32 获取。</p><h3 id="5-xlsxwriter"><a href="#5-xlsxwriter" class="headerlink" title="5.xlsxwriter"></a>5.xlsxwriter</h3><p>拥有丰富的特性，支持图片/表格/图表/筛选/格式/公式等，功能与openpyxl相似，优点是相比 openpyxl 还支持 VBA 文件导入，迷你图等功能，缺点是不能打开/修改已有文件，意味着使用 xlsxwriter 需要从零开始。</p><h3 id="6-DataNitro"><a href="#6-DataNitro" class="headerlink" title="6.DataNitro"></a>6.DataNitro</h3><p>作为插件内嵌到 Excel 中，可完全替代 VBA，在 Excel 中使用 python 脚本。既然被称为 Excel 中的 python，协同其他 python 库亦是小事一桩。然而，这是付费插件…</p><h3 id="7-xlutils"><a href="#7-xlutils" class="headerlink" title="7.xlutils"></a>7.xlutils</h3><p>基于 xlrd/xlwt，老牌 python 包，算是该领域的先驱，功能特点中规中矩，比较大的缺点是仅支持 xls 文件。</p><h2 id="读写测试"><a href="#读写测试" class="headerlink" title="读写测试"></a>读写测试</h2><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>用例1. 读.xls文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例2. 读.xlsx文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例3. 读.xls文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例4. 读.xlsx文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例5. 写.xls文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例6. 写.xlsx文件的整个表（表有5个分页，每个分页有2000行1200列的整数）。<br>用例7. 写.xls文件的整个表（表有1个分页，页有2000行1200列的整数）。<br>用例8. 写.xlsx文件的整个表（表有1个分页，页有2000行1200列的整数）。</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th>测试模块</th><th>用例1</th><th>用例2</th><th>用例3</th><th>用例4</th><th>用例5</th><th>用例6</th><th>用例7</th><th>用例8</th></tr></thead><tbody><tr><td>xlrd</td><td>5.77</td><td>98.06</td><td>1.28</td><td>19.72</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td></td></tr><tr><td>xlwt</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>20.33</td><td>&mdash;</td><td>4.06</td><td>&mdash;</td></tr><tr><td>xlwings</td><td>1.57</td><td>11.91</td><td>2.01</td><td>3.09</td><td>&mdash;</td><td>44.00</td><td>&mdash;</td><td>9.30</td></tr><tr><td>openpyxl</td><td>&mdash;</td><td>321.70/0.01</td><td>&mdash;</td><td>42.42/0.01</td><td>&mdash;</td><td>2109.93/135.5</td><td>&mdash;</td><td>31.84/25.0</td></tr><tr><td>xlsxwriter</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>&mdash;</td><td>152.28</td><td>&mdash;</td><td>24.09</td></tr><tr><td>win32com</td><td>0.37</td><td>10.16</td><td>0.36</td><td>2.26</td><td>&mdash;</td><td>32.48</td><td>&mdash;</td><td>26.78</td></tr><tr><td>pandas</td><td>32.34</td><td>553.15</td><td>1.82</td><td>22.42</td><td>34.66</td><td>40.43</td><td>6.92</td><td>8.02</td></tr></tbody></table><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>1.xlwt和pandas每个工作页最多写入256列，因此测试用例修改为每页有2000行256列的整数.<br>2.xlutils读写依赖于xlrd和xlwt，不单独测试。<br>3.openpyxl测试两种模式，一是普通加载写入，二是read_only/write_only模式下的加载写入。<br>4.DataNitro要收费，且需依托Excel使用，本次不测试。</p><h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><p>  单从读写的性能上考虑，win32com的性能是最好的，xlwings其次。</p><p>  openpyxl虽然操作Excel的功能强大，但读写性能过于糟糕，尤其是写大表时，会占用大量内存（把我的4G内存用完了），开启read_only和write_only模式后对其性能有大幅提升，尤其是对读的性能提升很大，使其几乎不耗时（0.01秒有点夸张，不过确实是加载上了）。pandas把Excel当作数据读写的容器，为其强大的数据分析服务，因此读写性能表现中规中矩，但其对Excel文件兼容性是最好的，支持读写.xls，.xlsx文件，且支持只读表中单一工作页。同样支持此功能的库还有xlrd，但xlrd只支持读，并不支持写，且性能不突出，需要配合xlutils进行Excel操作，并使用xlwt保存数据，而xlwt只能写入.xls文件（另一个可以写入.xls文件的库是pandas，且这两个写入的Excel文件最多只能有256列，其余库就我目前的了解均只能写入.xlsx文件），性能一般。xlsxwriter功能单一，一般用来创建.xlsx文件，写入性能中庸。win32com拥有最棒的读写性能，但该库存在于pywin32的库中，自身没有完善的文档，使用略吃力。xlwings拥有和win32com不相伯仲的读写性能，强大的转换器可以处理大部分数据类型，包括二维的numpy array和pandas DataFrame，可以轻松搞定数据分析的工作。</p><p>  综合考虑，xlwings的表现最佳，正如其名，xlwings——Make Excel Fly！</p><h3 id="便捷性比较"><a href="#便捷性比较" class="headerlink" title="便捷性比较"></a>便捷性比较</h3><p>    本测试目前只是针对Excel文件的读写，并未涉及Excel操作，单从读写的便捷性来讲，各库的表现难分上下，但是win32com和xlwings这两个库可以在程序运行时实时在打开的Excel文件中进行操作，实现过程的可视化，其次xlwings的数据结构转换器使其可以快速的为Excel文件添加二维数据结构而不需要在Excel文件中重定位数据的行和列，因此从读写的便捷性来比较，仍是xlwings胜出。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>最后，附上一些演示代码，大家可自行体会下不同模块的使用。</p><h3 id="6-1-xlwings基本代码"><a href="#6-1-xlwings基本代码" class="headerlink" title="6.1 xlwings基本代码"></a>6.1 xlwings基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwings <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment">#连接到excel</span></span><br><span class="line">workbook = xw.Book(<span class="string">r&#x27;path/myexcel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">#连接到指定单元格</span></span><br><span class="line">data_range = workbook.sheets(<span class="string">&#x27;Sheet1&#x27;</span>).<span class="built_in">range</span>(<span class="string">&#x27;A1&#x27;</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">data_range.value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">workbook.save()</span><br></pre></td></tr></table></figure><h3 id="6-2-xlsxwriter基本代码"><a href="#6-2-xlsxwriter基本代码" class="headerlink" title="6.2 xlsxwriter基本代码"></a>6.2 xlsxwriter基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlsxwriter <span class="keyword">as</span> xw</span><br><span class="line"><span class="comment">#新建excel</span></span><br><span class="line">workbook  = xw.Workbook(<span class="string">&#x27;myexcel.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment">#新建工作薄</span></span><br><span class="line">worksheet = workbook.add_worksheet()</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">worksheet.write(<span class="string">&#x27;A1&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#关闭保存</span></span><br><span class="line">workbook.close()</span><br></pre></td></tr></table></figure><h3 id="6-3-xlutils基本代码import-xlrd-读取数据"><a href="#6-3-xlutils基本代码import-xlrd-读取数据" class="headerlink" title="6.3 xlutils基本代码import xlrd #读取数据"></a>6.3 xlutils基本代码import xlrd #读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlwt <span class="comment">#写入数据</span></span><br><span class="line"><span class="keyword">import</span> xlutils <span class="comment">#操作excel</span></span><br><span class="line"><span class="comment">#----xlrd库</span></span><br><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">workbook = xlrd.open_workbook(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#获取表单</span></span><br><span class="line">worksheet = workbook.sheet_by_index(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">data = worksheet.cell_value(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#----xlwt库</span></span><br><span class="line"><span class="comment">#新建excel</span></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"><span class="comment">#添加工作薄</span></span><br><span class="line">sh = wb.add_sheet(<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">sh.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"><span class="comment">#保存文件</span></span><br><span class="line">wb.save(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#----xlutils库</span></span><br><span class="line"><span class="comment">#打开excel文件</span></span><br><span class="line">book = xlrd.open_workbook(<span class="string">&#x27;myexcel.xls&#x27;</span>)</span><br><span class="line"><span class="comment">#复制一份</span></span><br><span class="line">new_book = xlutils.copy(book)</span><br><span class="line"><span class="comment">#拿到工作薄</span></span><br><span class="line">worksheet = new_book.getsheet(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">worksheet.write(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;new data&#x27;</span>)</span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">new_book.save()</span><br></pre></td></tr></table></figure><h3 id="6-4-win32com基本代码"><a href="#6-4-win32com基本代码" class="headerlink" title="6.4 win32com基本代码"></a>6.4 win32com基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32com.client <span class="keyword">as</span> wc</span><br><span class="line"><span class="comment">#启动Excel应用</span></span><br><span class="line">excel_app = wc.Dispatch(<span class="string">&#x27;Excel.Application&#x27;</span>)</span><br><span class="line"><span class="comment">#连接excel</span></span><br><span class="line">workbook = excel_app.Workbooks.Open(<span class="string">r&#x27;e:/myexcel.xlsx&#x27;</span> )</span><br><span class="line"><span class="comment">#写入数据</span></span><br><span class="line">workbook.Worksheets(<span class="string">&#x27;Sheet1&#x27;</span>).Cells(<span class="number">1</span>,<span class="number">1</span>).Value = <span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment">#关闭并保存</span></span><br><span class="line">workbook.SaveAs(<span class="string">&#x27;newexcel.xlsx&#x27;</span>)</span><br><span class="line">excel_app.Application.Quit()</span><br></pre></td></tr></table></figure><h3 id="6-5-openpyxl基本代码"><a href="#6-5-openpyxl基本代码" class="headerlink" title="6.5 openpyxl基本代码"></a>6.5 openpyxl基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line">workbook = openpyxl.Workbook()</span><br><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">sheet = workbook.activesheet[<span class="string">&#x27;A1&#x27;</span>]=<span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">workbook.save(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="6-6-DataNitro基本代码"><a href="#6-6-DataNitro基本代码" class="headerlink" title="6.6 DataNitro基本代码"></a>6.6 DataNitro基本代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单一单元格赋值</span></span><br><span class="line">Cell(<span class="string">&#x27;A1&#x27;</span>).value = <span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="comment">#单元区域赋值</span></span><br><span class="line">CellRange(<span class="string">&#x27;A1:B2&#x27;</span>).value = <span class="string">&#x27;data&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="openpyxl具体使用"><a href="#openpyxl具体使用" class="headerlink" title="openpyxl具体使用"></a>openpyxl具体使用</h3><h4 id="1、-创建一个excel-文件，并写入不同类的内容"><a href="#1、-创建一个excel-文件，并写入不同类的内容" class="headerlink" title="1、 创建一个excel 文件，并写入不同类的内容"></a>1、 创建一个excel 文件，并写入不同类的内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件对象</span></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 获取第一个sheet</span></span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第1行第A列，写入数字23333</span></span><br><span class="line">ws[<span class="string">&#x27;A1&#x27;</span>] = <span class="number">23333</span></span><br><span class="line"><span class="comment"># 写入中文（unicode中文也可以）</span></span><br><span class="line">ws[<span class="string">&#x27;B1&#x27;</span>] = <span class="string">&quot;你好！&quot;</span>+<span class="string">&quot;欢迎使用openpyxl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在下一行，写入多个单元格</span></span><br><span class="line">ws.append([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入一个当前时间</span></span><br><span class="line">ws[<span class="string">&#x27;A2&#x27;</span>] = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入一个自定义的时间格式</span></span><br><span class="line">ws[<span class="string">&#x27;A3&#x27;</span>] = time.strftime(<span class="string">&#x27;%Y&#123;y&#125;%m&#123;m&#125;%d&#123;d&#125;%H&#123;h&#125;%M&#123;f&#125;%S&#123;s&#125;&#x27;</span>, time.localtime()).<span class="built_in">format</span>(y=<span class="string">&#x27;年&#x27;</span>, m=<span class="string">&#x27;月&#x27;</span>, d=<span class="string">&#x27;日&#x27;</span>, h=<span class="string">&#x27;时&#x27;</span>, f=<span class="string">&#x27;分&#x27;</span>, s=<span class="string">&#x27;秒&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件，注意文件覆盖</span></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br><span class="line"><span class="comment"># 关闭流</span></span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="2、创建sheet"><a href="#2、创建sheet" class="headerlink" title="2、创建sheet"></a>2、创建sheet</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;sheet1&quot;</span>)</span><br><span class="line"><span class="comment"># 设定一个sheet的名字</span></span><br><span class="line">ws1.title = <span class="string">&quot;sheet1 Title&quot;</span></span><br><span class="line"><span class="comment"># 设定sheet的插入位置 默认插在后面</span></span><br><span class="line">ws2 = wb.create_sheet(<span class="string">&quot;Mysheet&quot;</span>, <span class="number">0</span>)</span><br><span class="line">ws2.title = <span class="string">&quot;Mysheet&quot;</span></span><br><span class="line"><span class="comment"># 设定sheet的标签的背景颜色</span></span><br><span class="line">ws1.sheet_properties.tabColor = <span class="string">&quot;1072BA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某个sheet对象</span></span><br><span class="line"><span class="built_in">print</span>(wb[<span class="string">&quot;sheet1 Title&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(wb[<span class="string">&quot;Mysheet&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取全部sheet的名字，遍历sheet名字</span></span><br><span class="line"><span class="built_in">print</span>(wb.sheetnames)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> wb.sheetnames:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sheet <span class="keyword">in</span> wb:</span><br><span class="line">    <span class="built_in">print</span>(sheet.title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将sheet1中的A1单元格赋值为zeke</span></span><br><span class="line">wb[<span class="string">&quot;sheet1 Title&quot;</span> ][<span class="string">&quot;A1&quot;</span>] = <span class="string">&quot;zeke&quot;</span></span><br><span class="line"><span class="comment"># 复制一个sheet</span></span><br><span class="line">source = wb[<span class="string">&quot;sheet1 Title&quot;</span>]</span><br><span class="line">target = wb.copy_worksheet(source)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test2.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="3、操作单元格"><a href="#3、操作单元格" class="headerlink" title="3、操作单元格"></a>3、操作单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;Sheet1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将A1单元格赋值为123.11</span></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">123.11</span></span><br><span class="line"><span class="comment"># 将B2单元格赋值为你好</span></span><br><span class="line">ws1[<span class="string">&quot;B2&quot;</span>] = <span class="string">&quot;你好&quot;</span></span><br><span class="line"><span class="comment"># 将第4行第2列的单元赋值为10</span></span><br><span class="line">temp = ws1.cell(row=<span class="number">4</span>, column=<span class="number">2</span>, value=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A1&quot;</span>].value)</span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;B2&quot;</span>].value)</span><br><span class="line"><span class="built_in">print</span>(temp.value)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test3.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="4、操作已存在的文件"><a href="#4、操作已存在的文件" class="headerlink" title="4、操作已存在的文件"></a>4、操作已存在的文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开test5.xlsx文件</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test5.xlsx&#x27;</span>)</span><br><span class="line"><span class="comment"># 猜测格式类型</span></span><br><span class="line">wb.guess_types = <span class="literal">True</span></span><br><span class="line">ws = wb.active</span><br><span class="line">ws[<span class="string">&quot;A1&quot;</span>] = <span class="string">&quot;12%&quot;</span></span><br><span class="line"><span class="built_in">print</span>(ws[<span class="string">&quot;A1&quot;</span>].value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意如果原文件有一些图片或者图标，则保存的时候可能会导致图片丢失</span></span><br><span class="line">wb.save(<span class="string">&quot;test5.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="5、操作批量的单元格"><a href="#5、操作批量的单元格" class="headerlink" title="5、操作批量的单元格"></a>5、操作批量的单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line"><span class="comment"># 创建一个sheet</span></span><br><span class="line">ws1 = wb.create_sheet(<span class="string">&quot;Sheet&quot;</span>)</span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">1</span></span><br><span class="line">ws1[<span class="string">&quot;A2&quot;</span>] = <span class="number">2</span></span><br><span class="line">ws1[<span class="string">&quot;A3&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;B1&quot;</span>] = <span class="number">4</span></span><br><span class="line">ws1[<span class="string">&quot;B2&quot;</span>] = <span class="number">5</span></span><br><span class="line">ws1[<span class="string">&quot;B3&quot;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;C1&quot;</span>] = <span class="number">7</span></span><br><span class="line">ws1[<span class="string">&quot;C2&quot;</span>] = <span class="number">8</span></span><br><span class="line">ws1[<span class="string">&quot;C3&quot;</span>] = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作单列</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> ws1[<span class="string">&quot;A&quot;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从A列到C列,获取每一个值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A:C&quot;</span>])</span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> ws1[<span class="string">&quot;A:C&quot;</span>]:</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> column:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第1行到第3行，获取每一个值</span></span><br><span class="line">row_range = ws1[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(row_range)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> row_range:</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第1行到第3行，从第1列到第3列</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws1.iter_rows(min_row=<span class="number">1</span>, min_col=<span class="number">1</span>, max_col=<span class="number">3</span>, max_row=<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有行</span></span><br><span class="line"><span class="built_in">print</span>(ws1.rows)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws1.rows:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有列</span></span><br><span class="line"><span class="built_in">print</span>(ws1.columns)</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ws1.columns:</span><br><span class="line">    <span class="built_in">print</span>(col)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test4.xlsx&quot;</span>)</span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="6、获取所有的行-列-对象："><a href="#6、获取所有的行-列-对象：" class="headerlink" title="6、获取所有的行(列)对象："></a>6、获取所有的行(列)对象：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开test5.xlsx文件</span></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test5.xlsx&#x27;</span>)</span><br><span class="line">ws = wb.active</span><br><span class="line">rows = []</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.iter_rows():</span><br><span class="line">    rows.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有行</span></span><br><span class="line"><span class="built_in">print</span>(rows)</span><br><span class="line"><span class="comment"># 获取第一行</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一行第一列的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一行第一列的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="number">0</span>][<span class="number">0</span>].value)</span><br><span class="line"><span class="comment"># 获取最后行 print rows[-1]</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取第后一行和最后一列的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>][<span class="built_in">len</span>(rows[<span class="number">0</span>]) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取第后一行和最后一列的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(rows[<span class="built_in">len</span>(rows) - <span class="number">1</span>][<span class="built_in">len</span>(rows[<span class="number">0</span>]) - <span class="number">1</span>].value)</span><br><span class="line"></span><br><span class="line">cols = []</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ws.iter_cols():</span><br><span class="line">    cols.append(col)</span><br><span class="line"><span class="comment"># 所有列</span></span><br><span class="line"><span class="built_in">print</span>(cols)</span><br><span class="line"><span class="comment"># 获取第一列</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一列的第一行的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取第一列的第一行的值</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="number">0</span>][<span class="number">0</span>].value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 获取最后一列</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>] )</span><br><span class="line"><span class="comment"># 获取最后一列的最后一行的单元格对象</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>][<span class="built_in">len</span>(cols[<span class="number">0</span>]) - <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 获取最后一列的最后一行的单元格对象的值</span></span><br><span class="line"><span class="built_in">print</span>(cols[<span class="built_in">len</span>(cols) - <span class="number">1</span>][<span class="built_in">len</span>(cols[<span class="number">0</span>]) - <span class="number">1</span>].value)</span><br><span class="line"></span><br><span class="line">wb.close()</span><br></pre></td></tr></table></figure><h4 id="7、使用公式"><a href="#7、使用公式" class="headerlink" title="7、使用公式"></a>7、使用公式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br><span class="line">ws1 = wb.active</span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A1&quot;</span>] = <span class="number">1</span></span><br><span class="line">ws1[<span class="string">&quot;A2&quot;</span>] = <span class="number">2</span></span><br><span class="line">ws1[<span class="string">&quot;A3&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">ws1[<span class="string">&quot;A4&quot;</span>] = <span class="string">&quot;=SUM(1, 1)&quot;</span></span><br><span class="line">ws1[<span class="string">&quot;A5&quot;</span>] = <span class="string">&quot;=SUM(A1:A3)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印的是公式内容，不是公式计算后的值,程序无法取到计算后的值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A4&quot;</span>].value)</span><br><span class="line"><span class="comment"># 打印的是公式内容，不是公式计算后的值,程序无法取到计算后的值</span></span><br><span class="line"><span class="built_in">print</span>(ws1[<span class="string">&quot;A5&quot;</span>].value)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="8、合并单元格"><a href="#8、合并单元格" class="headerlink" title="8、合并单元格"></a>8、合并单元格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line">wb = load_workbook(<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line">ws.merge_cells(<span class="string">&#x27;A2:D2&#x27;</span>)</span><br><span class="line"><span class="comment"># 合并后的单元格，脚本单独执行拆分操作会报错，需要重新执行合并操作再拆分</span></span><br><span class="line">ws.unmerge_cells(<span class="string">&#x27;A2:D2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ws.merge_cells(start_row=<span class="number">2</span>, start_column=<span class="number">1</span>, end_row=<span class="number">2</span>, end_column=<span class="number">4</span>)</span><br><span class="line">ws.unmerge_cells(start_row=<span class="number">2</span>, start_column=<span class="number">1</span>, end_row=<span class="number">2</span>, end_column=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;test.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/zeke-python-road/p/8986318.html">https://www.cnblogs.com/zeke-python-road/p/8986318.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：python操作Excel文件，第三方模块汇总。&quot;&gt;&lt;a href=&quot;#摘要：python操作Excel文件，第三方模块汇总。&quot; class=&quot;headerlink&quot; title=&quot;摘要：python操作Excel文件，第三方模块汇总。&quot;&gt;&lt;/a&gt;摘要：python操作Excel文件，第三方模块汇总。&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot;&gt;&lt;a href=&quot;#前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot; class=&quot;headerlink&quot; title=&quot;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&quot;&gt;&lt;/a&gt;前言：本篇文章主要总结了一下利用python操作Excel文件的第三方库和方法。&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/categories/python/"/>
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python数据可视化</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</id>
    <published>2021-05-05T04:26:44.000Z</published>
    <updated>2021-05-05T04:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：python数据可视化"><a href="#摘要：python数据可视化" class="headerlink" title="摘要：python数据可视化"></a>摘要：python数据可视化</h1><hr><h1 id="前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！"><a href="#前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！" class="headerlink" title="前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！"></a>前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！</h1><hr><span id="more"></span><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>安装matplotlib</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user matplotlib</span><br></pre></td></tr></table></figure><h3 id="1、绘制简单的折线图"><a href="#1、绘制简单的折线图" class="headerlink" title="1、绘制简单的折线图"></a>1、绘制简单的折线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">plt.plot(squares)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、修改标签文字和线条粗细"><a href="#2、修改标签文字和线条粗细" class="headerlink" title="2、修改标签文字和线条粗细"></a>2、修改标签文字和线条粗细</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">plt.plot(squares, linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、校正图形"><a href="#3、校正图形" class="headerlink" title="3、校正图形"></a>3、校正图形</h3><p>当你向plot()提供一系列数字时，它假设第一个数据点对应的x坐标值为0，但我们的第一个点对应的x值为1。为改变这种默认行为，我们可以给plot()同时提供输入值和输出值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">input_values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squares = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">plt.plot(input_values, squares, linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、使用scatter-绘制散点图并设置其样式"><a href="#4、使用scatter-绘制散点图并设置其样式" class="headerlink" title="4、使用scatter()绘制散点图并设置其样式"></a>4、使用scatter()绘制散点图并设置其样式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(<span class="number">2</span>, <span class="number">4</span>, s=<span class="number">200</span>)</span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5、使用scatter-绘制一系列点"><a href="#5、使用scatter-绘制一系列点" class="headerlink" title="5、使用scatter()绘制一系列点"></a>5、使用scatter()绘制一系列点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y_values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6、自动计算数据"><a href="#6、自动计算数据" class="headerlink" title="6、自动计算数据"></a>6、自动计算数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每个坐标轴的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">1100</span>, <span class="number">0</span>, <span class="number">1100000</span>])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7、删除数据点的轮廓"><a href="#7、删除数据点的轮廓" class="headerlink" title="7、删除数据点的轮廓"></a>7、删除数据点的轮廓</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plt.scatter(x_values, y_values, edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8、自定义颜色"><a href="#8、自定义颜色" class="headerlink" title="8、自定义颜色"></a>8、自定义颜色</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要修改数据点的颜色，可向scatter()传递参数c，</span><br><span class="line">并将其设置为要使用的颜色的名称，如下所示：</span><br><span class="line">plt.scatter(x_values, y_values, c=<span class="string">&#x27;red&#x27;</span>, edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">你还可以使用RGB颜色模式自定义颜色。要指定自定义颜色，可传递参数c，</span><br><span class="line">并将其设置为一个元组，其中包含三个<span class="number">0</span>~<span class="number">1</span>之间的小数值，</span><br><span class="line">它们分别表示红色、绿色和蓝色分量。例如，下面的代码行创建一个由淡蓝色点组成的散点图：</span><br><span class="line">plt.scatter(x_values, y_values, c=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>), edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9、使用颜色映射"><a href="#9、使用颜色映射" class="headerlink" title="9、使用颜色映射"></a>9、使用颜色映射</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line"><span class="comment">#我们将参数c设置成了一个y值列表，并使用参数cmap告诉pyplot使用哪个颜色映射。</span></span><br><span class="line"><span class="comment">#这些代码将y值较小的点显示为浅蓝色，并将y值较大的点显示为深蓝色.</span></span><br><span class="line">plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues,</span><br><span class="line">            edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">14</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10、自动保存图表"><a href="#10、自动保存图表" class="headerlink" title="10、自动保存图表"></a>10、自动保存图表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#可将对可将对plt.show()的调用替换为对plt.savefig()的调用</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;squares_plot.png&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line"></span><br><span class="line">第一个实参指定要以什么样的文件名保存图表，</span><br><span class="line">这个文件将存储到scatter_squares.py所在的目录中；</span><br><span class="line">第二个实参指定将图表多余的空白区域裁剪掉。</span><br><span class="line">如果要保留图表周围多余的空白区域，可省略这个实参。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11、随机漫步"><a href="#11、随机漫步" class="headerlink" title="11、随机漫步"></a>11、随机漫步</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWalk</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_points=<span class="number">5000</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot;</span></span><br><span class="line">        self.num_points = num_points</span><br><span class="line">        <span class="comment"># 所有随机漫步都始于(0, 0)</span></span><br><span class="line">        self.x_values = [<span class="number">0</span>]</span><br><span class="line">        self.y_values = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算随机漫步包含的所有点&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不断漫步，直到列表达到指定的长度</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.x_values) &lt; self.num_points:</span><br><span class="line">            <span class="comment"># 决定前进方向以及沿这个方向前进的距离</span></span><br><span class="line"></span><br><span class="line">            x_direction = choice([<span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">            x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            x_step = x_direction * x_distance</span><br><span class="line"></span><br><span class="line">            y_direction = choice([<span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">            y_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            y_step = y_direction * y_distance</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 拒绝原地踏步</span></span><br><span class="line">            <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算下一个点的x和y值</span></span><br><span class="line">            next_x = self.x_values[-<span class="number">1</span>] + x_step</span><br><span class="line">            next_y = self.y_values[-<span class="number">1</span>] + y_step</span><br><span class="line"></span><br><span class="line">            self.x_values.append(next_x)</span><br><span class="line">            self.y_values.append(next_y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line"><span class="comment"># rw = RandomWalk()</span></span><br><span class="line"><span class="comment"># rw.fill_walk()</span></span><br><span class="line"><span class="comment"># plt.scatter(rw.x_values, rw.y_values, s=15)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只要程序处于活动状态，就不断地模拟随机漫步</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">    rw = RandomWalk(<span class="number">50000</span>)</span><br><span class="line">    rw.fill_walk()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置绘图窗口的尺寸</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">    point_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,</span><br><span class="line">                edgecolor=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">&#x27;green&#x27;</span>, edgecolors=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.scatter(rw.x_values[-<span class="number">1</span>], rw.y_values[-<span class="number">1</span>], c=<span class="string">&#x27;red&#x27;</span>, edgecolors=<span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">                s=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐藏坐标轴</span></span><br><span class="line">    plt.axes().get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    plt.axes().get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line">    keep_running = <span class="built_in">input</span>(<span class="string">&quot;Make another walk? (y/n): &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调整尺寸以适合屏幕"><a href="#调整尺寸以适合屏幕" class="headerlink" title="调整尺寸以适合屏幕"></a>调整尺寸以适合屏幕</h3><p>函数figure()用于指定图表的宽度、高度、分辨率和背景色。你需要给形参figsize指定一个元组，向matplotlib指出绘图窗口的尺寸，单位为英寸。</p><p>plt.figure(dpi=128, figsize=(10, 6))</p><h3 id="使用Pygal-模拟掷骰子"><a href="#使用Pygal-模拟掷骰子" class="headerlink" title="使用Pygal 模拟掷骰子"></a>使用Pygal 模拟掷骰子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Die</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;表示一个骰子的类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_sides=<span class="number">6</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;骰子默认为6面&quot;&quot;&quot;</span></span><br><span class="line">        self.num_sides = num_sides</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;返回一个位于1和骰子面数之间的随机值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> randint(<span class="number">1</span>, self.num_sides)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个D6</span></span><br><span class="line">die = Die()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 掷几次骰子，并将结果存储在一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    result = die.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, die.num_sides+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对结果进行可视化</span></span><br><span class="line">hist = pygal.Bar()</span><br><span class="line"></span><br><span class="line">hist.title = <span class="string">&quot;Results of rolling one D6 1000 times.&quot;</span></span><br><span class="line">hist.x_labels = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>]</span><br><span class="line">hist.x_title = <span class="string">&quot;Result&quot;</span></span><br><span class="line">hist.y_title = <span class="string">&quot;Frequency of Result&quot;</span></span><br><span class="line"></span><br><span class="line">hist.add(<span class="string">&#x27;D6&#x27;</span>, frequencies)</span><br><span class="line">hist.render_to_file(<span class="string">&#x27;die_visual.png&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><p>读取csv文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中获取日期、最高气温和最低气温</span></span><br><span class="line">filename = <span class="string">&#x27;sitka_weather_2014.csv&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line"></span><br><span class="line">    highs = []</span><br><span class="line">    dates = []</span><br><span class="line">    lows = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">&quot;%Y-%m-%d&quot;</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        high = <span class="built_in">int</span>(row[<span class="number">1</span>])</span><br><span class="line">        highs.append(high)</span><br><span class="line">        low = <span class="built_in">int</span>(row[<span class="number">3</span>])</span><br><span class="line">        lows.append(low)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(highs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(dates, highs, c=<span class="string">&#x27;red&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.plot(dates, lows, c=<span class="string">&#x27;blue&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=<span class="string">&#x27;blue&#x27;</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">&quot;Daily high and low temperatures - 2014&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;&#x27;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">&quot;Temperature (F)&quot;</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.show()s</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="读取json文件"><a href="#读取json文件" class="headerlink" title="读取json文件"></a>读取json文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pygal_maps_world.maps</span><br><span class="line"><span class="keyword">from</span> pygal_maps_world.maps <span class="keyword">import</span> COUNTRIES</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> RotateStyle</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据加载到一个列表中</span></span><br><span class="line">filename = <span class="string">&#x27;population_data.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_country_code</span>(<span class="params">country_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据指定的国家，返回Pygal使用的两个字母的国别码&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> code, name <span class="keyword">in</span> COUNTRIES.items():</span><br><span class="line">        <span class="keyword">if</span> name == country_name:</span><br><span class="line">            <span class="keyword">return</span> code</span><br><span class="line"><span class="comment"># 如果没有找到指定的国家，就返回None</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含人口数量的字典</span></span><br><span class="line">cc_populations = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">&#x27;Year&#x27;</span>] == <span class="string">&#x27;2010&#x27;</span>:</span><br><span class="line">        country = pop_dict[<span class="string">&#x27;Country Name&#x27;</span>]</span><br><span class="line">        population = <span class="built_in">int</span>(<span class="built_in">float</span>(pop_dict[<span class="string">&#x27;Value&#x27;</span>]))</span><br><span class="line">        code = get_country_code(country)</span><br><span class="line">        <span class="keyword">if</span> code:</span><br><span class="line">            cc_populations[code] = population</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据人口数量将所有的国家分成三组</span></span><br><span class="line">cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> cc, pop <span class="keyword">in</span> cc_populations.items():</span><br><span class="line">    <span class="keyword">if</span> pop &lt; <span class="number">10000000</span>:</span><br><span class="line">        cc_pops_1[cc] = pop</span><br><span class="line">    <span class="keyword">elif</span> pop &lt; <span class="number">1000000000</span>:</span><br><span class="line">        cc_pops_2[cc] = pop</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cc_pops_3[cc] = pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看看每组分别包含多少个国家</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(cc_pops_1), <span class="built_in">len</span>(cc_pops_2), <span class="built_in">len</span>(cc_pops_3))</span><br><span class="line"></span><br><span class="line">wm_style = RotateStyle(<span class="string">&#x27;#336699&#x27;</span>)</span><br><span class="line">wm_style = LightColorizedStyle</span><br><span class="line">wm = pygal_maps_world.maps.World(style=wm_style)</span><br><span class="line">wm.title = <span class="string">&#x27;World Population in 2010, by Country&#x27;</span></span><br><span class="line">wm.add(<span class="string">&#x27;0-10m&#x27;</span>, cc_pops_1)</span><br><span class="line">wm.add(<span class="string">&#x27;10m-1bn&#x27;</span>, cc_pops_2)</span><br><span class="line">wm.add(<span class="string">&#x27;&gt;1bn&#x27;</span>, cc_pops_3)</span><br><span class="line"></span><br><span class="line">wm.render_to_file(<span class="string">&#x27;world_population.svg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：python数据可视化&quot;&gt;&lt;a href=&quot;#摘要：python数据可视化&quot; class=&quot;headerlink&quot; title=&quot;摘要：python数据可视化&quot;&gt;&lt;/a&gt;摘要：python数据可视化&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！&quot;&gt;&lt;a href=&quot;#前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！&quot; class=&quot;headerlink&quot; title=&quot;前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！&quot;&gt;&lt;/a&gt;前言：昨天已经把python过完了，今天开始准备学习数据可视化的内容了，冲！！冲！！&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/categories/python/"/>
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/tags/python/"/>
    
    <category term="数据可视化" scheme="https://www.blog.ajie39.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="https://www.blog.ajie39.top/2021/05/05/python%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.blog.ajie39.top/2021/05/05/python%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-05T04:26:38.000Z</published>
    <updated>2021-05-05T04:26:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要：python一些入门基础总结"><a href="#摘要：python一些入门基础总结" class="headerlink" title="摘要：python一些入门基础总结"></a>摘要：python一些入门基础总结</h1><hr><h1 id="前言：这几天着手学爬虫，前4天把python基础过一遍，这篇文章是python入门基础的总结"><a href="#前言：这几天着手学爬虫，前4天把python基础过一遍，这篇文章是python入门基础的总结" class="headerlink" title="前言：这几天着手学爬虫，前4天把python基础过一遍，这篇文章是python入门基础的总结"></a>前言：这几天着手学爬虫，前4天把python基础过一遍，这篇文章是python入门基础的总结</h1><hr><span id="more"></span><h2 id="变量和简单数据类型"><a href="#变量和简单数据类型" class="headerlink" title="变量和简单数据类型"></a>变量和简单数据类型</h2><h3 id="用引号括起的都是字符串，单引号和双引号都可以"><a href="#用引号括起的都是字符串，单引号和双引号都可以" class="headerlink" title="用引号括起的都是字符串，单引号和双引号都可以"></a>用引号括起的都是字符串，单引号和双引号都可以</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;ada lovelace&quot;</span></span><br><span class="line">name = <span class="string">&#x27;ada lovelace&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="title-首字母大写"><a href="#title-首字母大写" class="headerlink" title="title()首字母大写"></a>title()首字母大写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(name.title())</span><br></pre></td></tr></table></figure><h3 id="upper-全部大写"><a href="#upper-全部大写" class="headerlink" title="upper()全部大写"></a>upper()全部大写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(name.upper())</span><br></pre></td></tr></table></figure><h3 id="lower-全部小写"><a href="#lower-全部小写" class="headerlink" title="lower()全部小写"></a>lower()全部小写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;ABCD&quot;</span></span><br><span class="line"><span class="built_in">print</span>(name.lower())</span><br></pre></td></tr></table></figure><h3 id="合并（拼接）字符串"><a href="#合并（拼接）字符串" class="headerlink" title="合并（拼接）字符串"></a>合并（拼接）字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&#x27;ada&#x27;</span></span><br><span class="line">last_name = <span class="string">&#x27;lovelace&#x27;</span></span><br><span class="line">full_name = first_name + <span class="string">&quot; &quot;</span> + last_name</span><br><span class="line"><span class="built_in">print</span>(full_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + full_name.title() + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">messages = <span class="string">&quot;Hello, &quot;</span> + full_name.title() + <span class="string">&quot;!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(messages)</span><br></pre></td></tr></table></figure><h3 id="t制表符，-n换行"><a href="#t制表符，-n换行" class="headerlink" title="\t制表符，\n换行"></a>\t制表符，\n换行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tpython&quot;</span>.title())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\tpython \n\thello&quot;</span>.title())</span><br></pre></td></tr></table></figure><h3 id="rstrip-删除字符串末尾多余的空白"><a href="#rstrip-删除字符串末尾多余的空白" class="headerlink" title="rstrip()删除字符串末尾多余的空白"></a>rstrip()删除字符串末尾多余的空白</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">favorite_language = <span class="string">&#x27; hello python &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(favorite_language.rstrip())</span><br></pre></td></tr></table></figure><h3 id="lstrip-删除字符串开头多余的空白"><a href="#lstrip-删除字符串开头多余的空白" class="headerlink" title="lstrip()删除字符串开头多余的空白"></a>lstrip()删除字符串开头多余的空白</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(favorite_language.lstrip())</span><br></pre></td></tr></table></figure><h3 id="strip-删除字符串两端的空白"><a href="#strip-删除字符串两端的空白" class="headerlink" title="strip()删除字符串两端的空白"></a>strip()删除字符串两端的空白</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(favorite_language.strip())</span><br></pre></td></tr></table></figure><h3 id="python使用两个乘号表示乘方运算"><a href="#python使用两个乘号表示乘方运算" class="headerlink" title="python使用两个乘号表示乘方运算"></a>python使用两个乘号表示乘方运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3</span> ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">结果为：<span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="python支持运算次序，可以使用括号来修改运算次序"><a href="#python支持运算次序，可以使用括号来修改运算次序" class="headerlink" title="python支持运算次序，可以使用括号来修改运算次序"></a>python支持运算次序，可以使用括号来修改运算次序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> + <span class="number">3</span> * <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>((<span class="number">2</span> + <span class="number">3</span>) * <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="str-将非字符串表示成字符串"><a href="#str-将非字符串表示成字符串" class="headerlink" title="str()将非字符串表示成字符串"></a>str()将非字符串表示成字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">23</span></span><br><span class="line">message = <span class="string">&quot;Happy &quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot;rd Birthday!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><h3 id="python2-7中：，计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除。"><a href="#python2-7中：，计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除。" class="headerlink" title="python2.7中：，计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除。"></a>python2.7中：，计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3</span>/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">结果为：<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="在Python-2中，若要避免这种情况，务必确保至少有一个操作数为浮点数，这样结果也将为浮点数"><a href="#在Python-2中，若要避免这种情况，务必确保至少有一个操作数为浮点数，这样结果也将为浮点数" class="headerlink" title="在Python 2中，若要避免这种情况，务必确保至少有一个操作数为浮点数，这样结果也将为浮点数"></a>在Python 2中，若要避免这种情况，务必确保至少有一个操作数为浮点数，这样结果也将为浮点数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">3.0</span>/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 这是一个注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import this</span><br><span class="line"></span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#39;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#39;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#39;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#39;s do more of those!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>列表由一系列按特定顺序排列的元素组成。</li><li>其中的元素之间可以没有任何关系。</li><li>索引从0 而不是1 开始。</li><li>通过将索引指定为-1，可让Python返回最后一个列表元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="string">&#x27;a&#x27;</span>,<span class="number">8</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(arr[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="修改、添加和删除元素"><a href="#修改、添加和删除元素" class="headerlink" title="修改、添加和删除元素"></a>修改、添加和删除元素</h3><h4 id="修改列表元素"><a href="#修改列表元素" class="headerlink" title="修改列表元素"></a>修改列表元素</h4><p>通过列表下标修改元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles[<span class="number">0</span>] = <span class="string">&#x27;ducati&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">[<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;ducati&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="在列表中添加元素"><a href="#在列表中添加元素" class="headerlink" title="在列表中添加元素"></a>在列表中添加元素</h4><h5 id="1、在列表末尾添加元素"><a href="#1、在列表末尾添加元素" class="headerlink" title="1、在列表末尾添加元素"></a>1、在列表末尾添加元素</h5><p>使用方法append()将元素添加到了列表末尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles.append(<span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2、在列表中插入元素"><a href="#2、在列表中插入元素" class="headerlink" title="2、在列表中插入元素"></a>2、在列表中插入元素</h5><p>使用方法insert()可在列表的任何位置添加新元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="从列表中删除元素"><a href="#从列表中删除元素" class="headerlink" title="从列表中删除元素"></a>从列表中删除元素</h4><h5 id="1、使用del语句删除元素"><a href="#1、使用del语句删除元素" class="headerlink" title="1、使用del语句删除元素"></a>1、使用del语句删除元素</h5><p>如果知道要删除的元素在列表中的位置，可使用del语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2、使用方法pop-删除元素"><a href="#2、使用方法pop-删除元素" class="headerlink" title="2、使用方法pop()删除元素"></a>2、使用方法pop()删除元素</h5><p>方法pop()可删除列表末尾的元素，并让你能够接着使用它。术语弹出（pop）源自这样的类<br>比：列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line">popped_motorcycle = motorcycles.pop()</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"><span class="built_in">print</span>(popped_motorcycle)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3、弹出列表中任何位置处的元素"><a href="#3、弹出列表中任何位置处的元素" class="headerlink" title="3、弹出列表中任何位置处的元素"></a>3、弹出列表中任何位置处的元素</h5><p>实际上，可以使用pop()来删除列表中任何位置的元素，只需在括号中指定要删除的元素<br>的索引即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">first_owned = motorcycles.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The first motorcycle I owned was a &#x27;</span> + first_owned.title() + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">The first motorcycle I owned was a Yamaha.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你不确定该使用del语句还是pop()方法，下面是一个简单的判断标准：如果你要从列表<br>中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续<br>使用它，就使用方法pop()。</p><h5 id="4、根据值删除元素"><a href="#4、根据值删除元素" class="headerlink" title="4、根据值删除元素"></a>4、根据值删除元素</h5><p>如果你只知道要删除的元素的值，可使用方法remove()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>, <span class="string">&#x27;ducati&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line">motorcycles.remove(<span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要<br>使用循环来判断是否删除了所有这样的值。</p><h3 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h3><h4 id="1、使用方法sort-对列表进行永久性排序"><a href="#1、使用方法sort-对列表进行永久性排序" class="headerlink" title="1、使用方法sort()对列表进行永久性排序"></a>1、使用方法sort()对列表进行永久性排序</h4><p>方法sort()是永久性地修改了列表元素的排列顺序，再也无法恢复到原来的排列顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.sort()</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以按与字母顺序相反的顺序排列列表元素，为此，只需向sort()方法传递参数<br>reverse=True。下面的示例将汽车列表按与字母顺序相反的顺序排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、使用函数sorted-对列表进行临时排序"><a href="#2、使用函数sorted-对列表进行临时排序" class="headerlink" title="2、使用函数sorted()对列表进行临时排序"></a>2、使用函数sorted()对列表进行临时排序</h4><p>要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted()。函数<br>sorted()让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here is the original list:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nHere is the sorted list:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(cars))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nHere is the original list again:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">Here <span class="keyword">is</span> the original <span class="built_in">list</span>:</span><br><span class="line">[<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Here <span class="keyword">is</span> the <span class="built_in">sorted</span> <span class="built_in">list</span>:</span><br><span class="line">[<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Here <span class="keyword">is</span> the original <span class="built_in">list</span> again:</span><br><span class="line">[<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"></span><br><span class="line">注意，调用函数<span class="built_in">sorted</span>()后，列表元素的排列顺序并没有变。如果你要按与字母顺序相反的顺序显示列表，也可向函数<span class="built_in">sorted</span>()传递参数reverse=<span class="literal">True</span>。</span><br></pre></td></tr></table></figure><h4 id="3、倒着打印列表"><a href="#3、倒着打印列表" class="headerlink" title="3、倒着打印列表"></a>3、倒着打印列表</h4><p>要反转列表元素的排列顺序，可使用方法reverse()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line">cars.reverse()</span><br><span class="line"><span class="built_in">print</span>(cars)</span><br><span class="line"></span><br><span class="line">注意，reverse()不是指按与字母顺序相反的顺序排列列表元素，而只是反转列表元素的排列顺序：</span><br><span class="line">[<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;bmw&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4、确定列表的长度"><a href="#4、确定列表的长度" class="headerlink" title="4、确定列表的长度"></a>4、确定列表的长度</h4><p>使用函数len()可快速获悉列表的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(cars))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><h3 id="遍历整个列表"><a href="#遍历整个列表" class="headerlink" title="遍历整个列表"></a>遍历整个列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">magicians = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;david&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    <span class="built_in">print</span>(magician)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">    magicians[i] = magicians[i] + <span class="string">&quot;ggggg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    <span class="built_in">print</span>(magician)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建数值列表"><a href="#创建数值列表" class="headerlink" title="创建数值列表"></a>创建数值列表</h3><h4 id="1、使用函数range"><a href="#1、使用函数range" class="headerlink" title="1、使用函数range()"></a>1、使用函数range()</h4><p>Python函数range()让你能够轻松地生成一系列的数字。例如，可以像下面这样使用函数<br>range()来打印一系列的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、使用range-创建数字列表"><a href="#2、使用range-创建数字列表" class="headerlink" title="2、使用range()创建数字列表"></a>2、使用range()创建数字列表</h4><p>要创建数字列表，可使用函数list()将range()的结果直接转换为列表。如果将range()作为list()的参数，输出将为一个数字列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">使用函数<span class="built_in">range</span>()时，还可指定步长。例如，下面的代码打印<span class="number">1</span>~<span class="number">10</span>内的偶数：</span><br><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(even_numbers)</span><br><span class="line"></span><br><span class="line">在这个示例中，函数<span class="built_in">range</span>()从<span class="number">2</span>开始数，然后不断地加<span class="number">2</span>，直到达到或超过终值（<span class="number">11</span>），因此</span><br><span class="line">输出如下：</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    squares.append(value ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、对数字列表执行简单的统计计算"><a href="#3、对数字列表执行简单的统计计算" class="headerlink" title="3、对数字列表执行简单的统计计算"></a>3、对数字列表执行简单的统计计算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">digits = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(digits))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(digits))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(digits))</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4、列表解析"><a href="#4、列表解析" class="headerlink" title="4、列表解析"></a>4、列表解析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要使用这种语法，首先指定一个描述性的列表名，如squares；然后，指定一个左方括号，并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为value**<span class="number">2</span>，它计算平方值。接下来，编写一个<span class="keyword">for</span>循环，用于给表达式提供值，再加上右方括号。</span><br><span class="line"></span><br><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"><span class="built_in">print</span>(squares)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4、列表解析（切片）"><a href="#4、列表解析（切片）" class="headerlink" title="4、列表解析（切片）"></a>4、列表解析（切片）</h4><p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引。与函数range()一样，Python在到达你指定的第二个索引前面的元素后停止。要输出列表中的前三个元素，需要指定索引0~3，这将输出分别为0、1和2的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">[<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>]</span><br><span class="line"></span><br><span class="line">如果你没有指定第一个索引，Python将自动从列表开头开始：</span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">[<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>]</span><br><span class="line"></span><br><span class="line">要让切片终止于列表末尾，也可使用类似的语法。例如，如果要提取从第<span class="number">3</span>个元素到列表末</span><br><span class="line">尾的所有元素，可将起始索引指定为<span class="number">2</span>，并省略终止索引：</span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">[<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"></span><br><span class="line">负数索引返回离列表末尾相应距离的元素，因此你可以输出列表末尾的任何切片。例如，如果你</span><br><span class="line">要输出名单上的最后三名队员，可使用切片players[-<span class="number">3</span>:]：</span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[-<span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">[<span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5、遍历切片"><a href="#5、遍历切片" class="headerlink" title="5、遍历切片"></a>5、遍历切片</h4><p>如果要遍历列表的部分元素，可在for循环中使用切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here are the first three players on my team:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[:<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(player.title())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6、复制列表"><a href="#6、复制列表" class="headerlink" title="6、复制列表"></a>6、复制列表</h4><p>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]）。<br>这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line">friend_foods = my_foods[:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My favorite foods are:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_foods)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(friend_foods)</span><br><span class="line"></span><br><span class="line">倘若我们只是简单地将my_foods赋给friend_foods，就不能得到两个列表。</span><br><span class="line">例如，下例演示了在不使用切片的情况下复制列表的情况：</span><br><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line"><span class="comment">#这行不通</span></span><br><span class="line">friend_foods = my_foods</span><br><span class="line">my_foods.append(<span class="string">&#x27;cannoli&#x27;</span>)</span><br><span class="line">friend_foods.append(<span class="string">&#x27;ice cream&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My favorite foods are:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_foods)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nMy friend&#x27;s favorite foods are:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(friend_foods)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">My favorite foods are:</span><br><span class="line">[<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>, <span class="string">&#x27;cannoli&#x27;</span>, <span class="string">&#x27;ice cream&#x27;</span>]</span><br><span class="line"></span><br><span class="line">My friend<span class="string">&#x27;s favorite foods are:</span></span><br><span class="line"><span class="string">[&#x27;</span>pizza<span class="string">&#x27;, &#x27;</span>falafel<span class="string">&#x27;, &#x27;</span>carrot cake<span class="string">&#x27;, &#x27;</span>cannoli<span class="string">&#x27;, &#x27;</span>ice cream<span class="string">&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这里将my_foods赋给friend_foods，而不是将my_foods的副本存储到friend_foods。</span></span><br><span class="line"><span class="string">这种语法实际上是让Python将新变量friend_foods关联到包含在my_foods中的列表，因此这两个</span></span><br><span class="line"><span class="string">变量都指向同一个列表。鉴于此，当我们将&#x27;</span>cannoli<span class="string">&#x27;添加到my_foods中时，它也将出现在</span></span><br><span class="line"><span class="string">friend_foods中；同样，虽然&#x27;</span>ice cream<span class="string">&#x27;好像只被加入到了friend_foods中，但它也将出现在这</span></span><br><span class="line"><span class="string">两个列表中。</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>Python将不能修改的值称为不可变的，而不可变的列表被称为元组。</p><h3 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h3><p>元组看起来犹如列表，但使用圆括号而不是方括号来标识。定义元组后，就可以使用索引来<br>访问其元素，就像访问列表元素一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"></span><br><span class="line">dimensions[<span class="number">0</span>] = <span class="number">250</span></span><br><span class="line"><span class="built_in">print</span>(dimensions[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/ProgramFiles/python/poj/venv/demo_02.py&quot;</span>, line <span class="number">71</span>, <span class="keyword">in</span> &lt;module</span><br><span class="line">    dimensions[<span class="number">0</span>] = <span class="number">250</span></span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="遍历元组中的所有值"><a href="#遍历元组中的所有值" class="headerlink" title="遍历元组中的所有值"></a>遍历元组中的所有值</h3><p>像列表一样，也可以使用for循环来遍历元组中的所有值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line"><span class="built_in">print</span>(dimension)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改元组变量"><a href="#修改元组变量" class="headerlink" title="修改元组变量"></a>修改元组变量</h3><p>虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺<br>寸，可重新定义整个元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Original dimensions:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">Original dimensions:</span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"></span><br><span class="line">dimensions = (<span class="number">400</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nModified dimensions:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line">    <span class="built_in">print</span>(dimension)</span><br><span class="line"></span><br><span class="line">结果为：</span><br><span class="line">Modified dimensions:</span><br><span class="line"><span class="number">400</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cars = [<span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> car <span class="keyword">in</span> cars:</span><br><span class="line">    <span class="keyword">if</span> car == <span class="string">&#x27;bmw&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(car.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(car.title())</span><br><span class="line"></span><br><span class="line">requested_topping = <span class="string">&#x27;mushrooms&#x27;</span></span><br><span class="line"><span class="keyword">if</span> requested_topping.lower() != <span class="string">&#x27;anchovies&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hold the anchovies!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="检查多个条件"><a href="#检查多个条件" class="headerlink" title="检查多个条件"></a>检查多个条件</h3><p>使用and检查多个条件，如果每个测试都通过了，整个表达式就为True；如果至少有一个测试没有通过，整个表达式就为False。</p><p>关键字or也能够让你检查多个条件，但只要至少有一个条件满足，就能通过整个测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a1 = <span class="number">29</span></span><br><span class="line">a2 = <span class="number">66</span></span><br><span class="line"><span class="keyword">if</span> a1 &gt;= <span class="number">25</span> <span class="keyword">and</span> a2 &lt; <span class="number">55</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;yes and&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> a1 &gt;= <span class="number">25</span> <span class="keyword">or</span> a2 &lt; <span class="number">55</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;yes or&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;GG&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="检查特定值是否包含在列表中"><a href="#检查特定值是否包含在列表中" class="headerlink" title="检查特定值是否包含在列表中"></a>检查特定值是否包含在列表中</h3><p>要判断特定的值是否已包含在列表中，可使用关键字in。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;onions&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pepperoni&#x27;</span> <span class="keyword">in</span> requested_toppings)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="检查特定值是否不包含在列表中"><a href="#检查特定值是否不包含在列表中" class="headerlink" title="检查特定值是否不包含在列表中"></a>检查特定值是否不包含在列表中</h3><p>有些时候，确定特定的值未包含在列表中很重要；在这种情况下，可使用关键字not in。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">banned_users = [<span class="string">&#x27;andrew&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>, <span class="string">&#x27;david&#x27;</span>]</span><br><span class="line">user = <span class="string">&#x27;marie&#x27;</span></span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">not</span> <span class="keyword">in</span> banned_users:</span><br><span class="line">    <span class="built_in">print</span>(user.title() + <span class="string">&quot;, you can post a response if you wish.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="if-elif-else-结构"><a href="#if-elif-else-结构" class="headerlink" title="if-elif-else 结构"></a>if-elif-else 结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">age = <span class="number">12</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span>:</span><br><span class="line">    price = <span class="number">10</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your admission cost is $&quot;</span> + <span class="built_in">str</span>(price) + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试多个条件"><a href="#测试多个条件" class="headerlink" title="测试多个条件"></a>测试多个条件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Adding mushrooms.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;pepperoni&#x27;</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Adding pepperoni.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;extra cheese&#x27;</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Adding extra cheese.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nFinished making your pizza!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>在Python中，字典是一系列键—值对。每个键都与一个值相关联，你可以使用键来访问与之相关联的值，可将任何Python对象用作字典中的值。</p><p>在Python中，字典用放在花括号{}中的一系列键—值对表示，如示例所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;color&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;points&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1、添加键值对"><a href="#1、添加键值对" class="headerlink" title="1、添加键值对"></a>1、添加键值对</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line">alien_0[<span class="string">&#x27;x_position&#x27;</span>] = <span class="number">0</span></span><br><span class="line">alien_0[<span class="string">&#x27;y_position&#x27;</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、修改字典中的值"><a href="#2、修改字典中的值" class="headerlink" title="2、修改字典中的值"></a>2、修改字典中的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The alien is &quot;</span> + alien_0[<span class="string">&#x27;color&#x27;</span>] + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The alien is now &quot;</span> + alien_0[<span class="string">&#x27;color&#x27;</span>] + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、删除键—值对"><a href="#3、删除键—值对" class="headerlink" title="3、删除键—值对"></a>3、删除键—值对</h3><p>对于字典中不再需要的信息，可使用del语句将相应的键—值对彻底删除。使用del语句时，必须指定字典名和要删除的键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line"><span class="keyword">del</span> alien_0[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(alien_0)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4、遍历字典"><a href="#4、遍历字典" class="headerlink" title="4、遍历字典"></a>4、遍历字典</h3><h4 id="遍历所有的键—值对"><a href="#遍历所有的键—值对" class="headerlink" title="遍历所有的键—值对"></a>遍历所有的键—值对</h4><p>方法items()它返回一个键—值对列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user_0 = &#123;</span><br><span class="line"><span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;efermi&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;enrico&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;fermi&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_0.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nKey: &quot;</span> + key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Value: &quot;</span> + value)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历字典中的所有键"><a href="#遍历字典中的所有键" class="headerlink" title="遍历字典中的所有键"></a>遍历字典中的所有键</h4><p>方法keys()它返回一个键</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line"><span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="按顺序遍历字典中的所有键"><a href="#按顺序遍历字典中的所有键" class="headerlink" title="按顺序遍历字典中的所有键"></a>按顺序遍历字典中的所有键</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line"><span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(favorite_languages.keys()):</span><br><span class="line">    <span class="built_in">print</span>(name.title() + <span class="string">&quot;, thank you for taking the poll.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="遍历字典中的所有值"><a href="#遍历字典中的所有值" class="headerlink" title="遍历字典中的所有值"></a>遍历字典中的所有值</h4><p>使用方法values()，它返回一个值列表，而不包含任何键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line"><span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;ruby&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;phil&#x27;</span>: <span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The following languages have been mentioned:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br><span class="line"></span><br><span class="line">剔除重复项，可使用集合（<span class="built_in">set</span>），集合类似于列表，但每个元素都必须是独一无二。</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_languages.values()):</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="用户输入和while循环"><a href="#用户输入和while循环" class="headerlink" title="用户输入和while循环"></a>用户输入和while循环</h2><h3 id="函数input"><a href="#函数input" class="headerlink" title="函数input()"></a>函数input()</h3><p>函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在<br>一个变量中，以方便你使用。input()将输入解读为字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;Please enter your name: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;If you tell us who you are, we can personalize the messages you see.&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nWhat is your first name? &quot;</span></span><br><span class="line">name = <span class="built_in">input</span>(prompt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nHello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果你使用的是Python <span class="number">2.7</span>，应使用函数raw_input()来提示用户输入。这个函数与Python <span class="number">3</span></span><br><span class="line">中的<span class="built_in">input</span>()一样，也将输入解读为字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数int"><a href="#函数int" class="headerlink" title="函数int()"></a>函数int()</h3><p>使用函数int()，它让Python将输入视为数值。函数int()将数字的字符串表示转换为数值表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;How old are you? &quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(age)</span><br><span class="line"><span class="built_in">print</span>(age &gt;= <span class="number">18</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求模运算符"><a href="#求模运算符" class="headerlink" title="求模运算符"></a>求模运算符</h3><p>求模运算符（%），它将两个数相除并返回余数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>%<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>%<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">6</span>%<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>%<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用while-循环"><a href="#使用while-循环" class="headerlink" title="使用while 循环"></a>使用while 循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">current_number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> current_number &lt;= <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(current_number)</span><br><span class="line">    current_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> current_number == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> + username.title() + <span class="string">&quot;!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet_user(<span class="string">&#x27;jesse&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><p>在函数greet_user()的定义中，变量username是一个形参——函数完成其工作所需的一项信息。在代码greet_user(‘jesse’)中，值’jesse’是一个实参。实参是调用函数时传递给函数的信息。我们调用函数时，将要让函数使用的信息放在括号内。在greet_user(‘jesse’)中，将实参’jesse’传递给了函数greet_user()，这个值被存储在形参username中。</p><h3 id="位置实参"><a href="#位置实参" class="headerlink" title="位置实参"></a>位置实参</h3><p>你调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，<br>最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。</p><ol><li>调用函数多次</li><li>位置实参的顺序很重要</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;hamster&#x27;</span>, <span class="string">&#x27;harry&#x27;</span>)</span><br><span class="line">describe_pet(<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;willie&#x27;</span>)</span><br><span class="line"></span><br><span class="line">实参位置必须对应：</span><br><span class="line">describe_pet(<span class="string">&#x27;harry&#x27;</span>, <span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关键字实参"><a href="#关键字实参" class="headerlink" title="关键字实参"></a>关键字实参</h3><p>关键字实参是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆（不会得到名为Hamster的harry这样的结果）。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">pet_name, animal_type=<span class="string">&#x27;dog&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示宠物的信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI have a &quot;</span> + animal_type + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;My &quot;</span> + animal_type + <span class="string">&quot;&#x27;s name is &quot;</span> + pet_name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;willie&#x27;</span>)</span><br><span class="line"></span><br><span class="line">由于没有给animal_type提供实参，因此Python使用其默认值<span class="string">&#x27;dog&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在函数中，可使用return语句将值返回到调用函数的代码行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot;</span></span><br><span class="line">    full_name = first_name + <span class="string">&#x27; &#x27;</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="让实参变成可选的"><a href="#让实参变成可选的" class="headerlink" title="让实参变成可选的"></a>让实参变成可选的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name, last_name, middle_name=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回整洁的姓名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> middle_name:</span><br><span class="line">        full_name = first_name + <span class="string">&#x27; &#x27;</span> + middle_name + <span class="string">&#x27; &#x27;</span> + last_name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first_name + <span class="string">&#x27; &#x27;</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;hooker&#x27;</span>, <span class="string">&#x27;lee&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="返回字典"><a href="#返回字典" class="headerlink" title="返回字典"></a>返回字典</h3><p>函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_person</span>(<span class="params">first_name, last_name</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回一个字典，其中包含有关一个人的信息&quot;&quot;&quot;</span></span><br><span class="line">    person = &#123;<span class="string">&#x27;first&#x27;</span>: first_name, <span class="string">&#x27;last&#x27;</span>: last_name&#125;</span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line">musician = build_person(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(musician)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="传递列表"><a href="#传递列表" class="headerlink" title="传递列表"></a>传递列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_users</span>(<span class="params">names</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;向列表中的每位用户都发出简单的问候&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        msg = <span class="string">&quot;Hello, &quot;</span> + name.title() + <span class="string">&quot;!&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">usernames = [<span class="string">&#x27;hannah&#x27;</span>, <span class="string">&#x27;ty&#x27;</span>, <span class="string">&#x27;margot&#x27;</span>]</span><br><span class="line">greet_users(usernames)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="禁止函数修改列表"><a href="#禁止函数修改列表" class="headerlink" title="禁止函数修改列表"></a>禁止函数修改列表</h3><p>可向函数传递列表的副本而不是原件；这样函数所做的任何修改都只影响副本，而丝毫不影响原件。要将列表的副本传递给函数，可以像下面这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function_name(list_name[:])</span><br><span class="line"></span><br><span class="line">print_models(unprinted_designs[:], completed_models)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这样函数print_models()依然能够完成其工作，因为它获得了所有未打印的设计的名称，但</span><br><span class="line">它使用的是列表unprinted_designs的副本，而不是列表unprinted_designs本身。</span><br><span class="line"></span><br><span class="line">虽然向函数传递列表的副本可保留原始列表的内容，但除非有充分的理由需要传递副本，否</span><br><span class="line">则还是应该将原始列表传递给函数，因为让函数使用现成列表可避免花时间和内存创建副本，从</span><br><span class="line">而提高效率，在处理大型列表时尤其如此。</span><br></pre></td></tr></table></figure><h3 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">*toppings</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;打印顾客点的所有配料&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(toppings)</span><br><span class="line">make_pizza(<span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"></span><br><span class="line">形参名*toppings中的星号让Python创建一个名为toppings的空元组，并将收到的所有值都封</span><br><span class="line">装到这个元组中。函数体内的<span class="built_in">print</span>语句通过生成输出来证明Python能够处理使用一个值调用函</span><br><span class="line">数的情形，也能处理使用三个值来调用函数的情形。它以类似的方式处理不同的调用，注意，</span><br><span class="line">Python将实参封装到一个元组中，即便函数只收到一个值也如此：</span><br><span class="line">(<span class="string">&#x27;pepperoni&#x27;</span>,)</span><br><span class="line">(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结合使用位置实参和任意数量实参"><a href="#结合使用位置实参和任意数量实参" class="headerlink" title="结合使用位置实参和任意数量实参"></a>结合使用位置实参和任意数量实参</h3><p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">size, *toppings</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nMaking a &quot;</span> + <span class="built_in">str</span>(size) +</span><br><span class="line">          <span class="string">&quot;-inch pizza with the following toppings:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;- &quot;</span> + topping)</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用任意数量的关键字实参"><a href="#使用任意数量的关键字实参" class="headerlink" title="使用任意数量的关键字实参"></a>使用任意数量的关键字实参</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span>(<span class="params">first, last, **user_info</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot;</span></span><br><span class="line">    profile = &#123;&#125;</span><br><span class="line">    profile[<span class="string">&#x27;first_name&#x27;</span>] = first</span><br><span class="line">    profile[<span class="string">&#x27;last_name&#x27;</span>] = last</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> user_info.items():</span><br><span class="line">        profile[key] = value</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_profile = build_profile(<span class="string">&#x27;albert&#x27;</span>, <span class="string">&#x27;einstein&#x27;</span>,</span><br><span class="line">                             location=<span class="string">&#x27;princeton&#x27;</span>,</span><br><span class="line">                             field=<span class="string">&#x27;physics&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(user_profile)</span><br><span class="line"></span><br><span class="line">函数build_profile()的定义要求提供名和姓，同时允许用户根据需要提供任意数量的名称—</span><br><span class="line">值对。形参**user_info中的两个星号让Python创建一个名为user_info的空字典，并将收到的所</span><br><span class="line">有名称—值对都封装到这个字典中。在这个函数中，可以像访问其他字典那样访问user_info中的</span><br><span class="line">名称—值对。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a>将函数存储在模块中</h3><h4 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h4><p>import语句允许在当前运行的程序文件中使用模块中的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="导入特定的函数"><a href="#导入特定的函数" class="headerlink" title="导入特定的函数"></a>导入特定的函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_0, function_1, function_2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用as-给函数指定别名"><a href="#使用as-给函数指定别名" class="headerlink" title="使用as 给函数指定别名"></a>使用as 给函数指定别名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line">mp(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">mp(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"></span><br><span class="line">通用语法：</span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name <span class="keyword">as</span> fn</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用as-给模块指定别名"><a href="#使用as-给模块指定别名" class="headerlink" title="使用as 给模块指定别名"></a>使用as 给模块指定别名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pizza <span class="keyword">as</span> p</span><br><span class="line"></span><br><span class="line">p.make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">p.make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"></span><br><span class="line">通用语法：</span><br><span class="line"><span class="keyword">import</span> module_name <span class="keyword">as</span> mn</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="导入模块中的所有函数"><a href="#导入模块中的所有函数" class="headerlink" title="导入模块中的所有函数"></a>导入模块中的所有函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">&#x27;pepperoni&#x27;</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>)</span><br><span class="line"></span><br><span class="line">通用语法：</span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗被命令时蹲下&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; is now sitting.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟小狗被命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(self.name.title() + <span class="string">&quot; rolled over!&quot;</span>)</span><br><span class="line"></span><br><span class="line">python2<span class="number">.7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    --snip--</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据类创建实例</span></span><br><span class="line">my_dog = Dog(<span class="string">&#x27;willie&#x27;</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog&#x27;s name is &quot;</span> + my_dog.name.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My dog is &quot;</span> + <span class="built_in">str</span>(my_dog.age) + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法__init__()是一个特殊的方法，每当你根据Dog类创建新实例时，Python都会自动运行它。在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。我们将方法__init__()定义成了包含三个形参：self、name和age。在这个方法的定义中，形参self必不可少，还必须位于其他形参的前面。为何必须在方法定义中包含形参self呢？因为Python调用这个__init__()方法来创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">&#x27; &#x27;</span> + self.make + <span class="string">&#x27; &#x27;</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This car has &quot;</span> + <span class="built_in">str</span>(self.odometer_reading) + <span class="string">&quot; miles on it.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span>(<span class="params">self, mileage</span>):</span></span><br><span class="line">        <span class="keyword">if</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span>(<span class="params">self, miles</span>):</span></span><br><span class="line">        self.odometer_reading += miles</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model s&#x27;</span>, <span class="number">2016</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tesla.get_descriptive_name())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">python2<span class="number">.7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        --snip--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, make, model, year</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(ElectricCar, self).__init__(make, model, year)</span><br><span class="line">        --snip--</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建子类时，父类必须包含在当前文件中，且位于子类前面。我们定义了子类ElectricCar。定义子类时，必须在括号内指定父类的名称。方法__init__()接受创建Car实例所需的信息。super()是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法__init__()，让ElectricCar实例包含父类的所有属性。父类也称为超类（superclass），名称super因此而得名。</p><h3 id="导入类"><a href="#导入类" class="headerlink" title="导入类"></a>导入类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#从一个模块中导入多个类</span></span><br><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car, ElectricCar</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入整个模块</span></span><br><span class="line"><span class="keyword">import</span> car</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入模块中的所有类</span></span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> *</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="顺序字典"><a href="#顺序字典" class="headerlink" title="顺序字典"></a>顺序字典</h3><p>要创建字典并记录其中的键—值对的添加顺序，可使用模块collections中的OrderedDict类。OrderedDict实例的行为几乎与字典相同，区别只在于记录了键—值对的添加顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">favorite_languages = OrderedDict()</span><br><span class="line">favorite_languages[<span class="string">&#x27;jen&#x27;</span>] = <span class="string">&#x27;python&#x27;</span></span><br><span class="line">favorite_languages[<span class="string">&#x27;sarah&#x27;</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">favorite_languages[<span class="string">&#x27;edward&#x27;</span>] = <span class="string">&#x27;ruby&#x27;</span></span><br><span class="line">favorite_languages[<span class="string">&#x27;phil&#x27;</span>] = <span class="string">&#x27;python&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, language <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    <span class="built_in">print</span>(name.title() + <span class="string">&quot;&#x27;s favorite language is &quot;</span> +</span><br><span class="line">        language.title() + <span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h2><h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;text.txt&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    contents = file_object.read()</span><br><span class="line">    <span class="built_in">print</span>(contents.rstrip())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;pi_digits.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line">每行的末尾都有一个看不见的换行符，而<span class="built_in">print</span>语句也会加上一个换行符，</span><br><span class="line">因此每行末尾都有两个换行符：一个来自文件，另一个来自<span class="built_in">print</span>语句。</span><br><span class="line">要消除这些多余的空白行，可在<span class="built_in">print</span>语句中使用rstrip()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(line.rstrip())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>打开文件时，可指定读取模式（’r’）、写入模式（’w’）、附加模式（’a’）或让你能够读取和写入文件的模式（’r+’）。如果你省略了模式实参，Python将以默认的只读模式打开文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming.&quot;</span>)</span><br><span class="line"></span><br><span class="line">如果你要写入的文件不存在，函数<span class="built_in">open</span>()将自动创建它。</span><br><span class="line">然而，以写入（<span class="string">&#x27;w&#x27;</span>）模式打开文件时千万要小心，</span><br><span class="line">因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="写入多行"><a href="#写入多行" class="headerlink" title="写入多行"></a>写入多行</h3><p>函数write()不会在你写入的文本末尾添加换行符，因此如果你写入多行时没有指定换行符，文件看起来可能不是你希望的那样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming.&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating new games.&quot;</span>)</span><br><span class="line"></span><br><span class="line">要让每个字符串都单独占一行，需要在write()语句中包含换行符</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I love programming.\n&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating new games.\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="附加到文件"><a href="#附加到文件" class="headerlink" title="附加到文件"></a>附加到文件</h3><p>如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式打开文件。你以附加模式打开文件时，Python不会在返回文件对象前清空文件，而你写入到文件的行都将添加到文件末尾。如果指定的文件不存在，Python将为你创建一个空文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;programming.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">&quot;I also love finding meaning in large datasets.\n&quot;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;I love creating apps that can run in a browser.\n&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback。</p><h3 id="使用try-except代码块"><a href="#使用try-except代码块" class="headerlink" title="使用try-except代码块"></a>使用try-except代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="else-代码块"><a href="#else-代码块" class="headerlink" title="else 代码块"></a>else 代码块</h3><p>try-except-else代码块的工作原理大致如下：Python尝试执行try代码块中的代码；只有可能引发异常的代码才需要放在try语句中。有时候，有一些仅在try代码块成功执行时才需要运行的代码；这些代码应放在else代码块中。except代码块告诉Python，如果它尝试运行try代码块中的代码时引发了指定的异常，该怎么办。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Give me two numbers, and I&#x27;ll divide them.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Enter &#x27;q&#x27; to quit.&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    first_number = <span class="built_in">input</span>(<span class="string">&quot;\nFirst number: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_number == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    second_number = <span class="built_in">input</span>(<span class="string">&quot;Second number: &quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        answer = <span class="built_in">int</span>(first_number) / <span class="built_in">int</span>(second_number)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by 0!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(answer)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="处理FileNotFoundError-异常"><a href="#处理FileNotFoundError-异常" class="headerlink" title="处理FileNotFoundError 异常"></a>处理FileNotFoundError 异常</h3><p>使用文件时，一种常见的问题是找不到文件：你要查找的文件可能在其他地方、文件名可能不正确或者这个文件根本就不存在。对于所有这些情形，都可使用try-except代码块以直观的方式进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;alice.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    msg = <span class="string">&quot;Sorry, the file &quot;</span> + filename + <span class="string">&quot; does not exist.&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分析文本"><a href="#分析文本" class="headerlink" title="分析文本"></a>分析文本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算一个文件大致包含多少个单词&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            contents = f_obj.read()</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        msg = <span class="string">&quot;Sorry, the file &quot;</span> + filename + <span class="string">&quot; does not exist.&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 计算文件大致包含多少个单词</span></span><br><span class="line">        words = contents.split()</span><br><span class="line">        num_words = <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The file &quot;</span> + filename + <span class="string">&quot; has about &quot;</span> + <span class="built_in">str</span>(num_words) +</span><br><span class="line">              <span class="string">&quot; words.&quot;</span>)</span><br><span class="line"></span><br><span class="line">filenames = [<span class="string">&#x27;alice.txt&#x27;</span>, <span class="string">&#x27;siddhartha.txt&#x27;</span>, <span class="string">&#x27;moby_dick.txt&#x27;</span>, <span class="string">&#x27;little_women.txt&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">    count_words(filename)</span><br><span class="line"></span><br><span class="line">Python有一个<span class="keyword">pass</span>语句，可在代码块中使用它来让Python什么都不要做</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算一个文件大致包含多少个单词&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        --snip--</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        --snip--</span><br></pre></td></tr></table></figure><h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3><h4 id="使用json-dump-和json-load"><a href="#使用json-dump-和json-load" class="headerlink" title="使用json.dump()和json.load()"></a>使用json.dump()和json.load()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">filename = <span class="string">&#x27;numbers.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    json.dump(numbers, f_obj)</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;numbers.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">    numbers = json.load(f_obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;摘要：python一些入门基础总结&quot;&gt;&lt;a href=&quot;#摘要：python一些入门基础总结&quot; class=&quot;headerlink&quot; title=&quot;摘要：python一些入门基础总结&quot;&gt;&lt;/a&gt;摘要：python一些入门基础总结&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;前言：这几天着手学爬虫，前4天把python基础过一遍，这篇文章是python入门基础的总结&quot;&gt;&lt;a href=&quot;#前言：这几天着手学爬虫，前4天把python基础过一遍，这篇文章是python入门基础的总结&quot; class=&quot;headerlink&quot; title=&quot;前言：这几天着手学爬虫，前4天把python基础过一遍，这篇文章是python入门基础的总结&quot;&gt;&lt;/a&gt;前言：这几天着手学爬虫，前4天把python基础过一遍，这篇文章是python入门基础的总结&lt;/h1&gt;&lt;hr&gt;</summary>
    
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/categories/python/"/>
    
    
    <category term="python" scheme="https://www.blog.ajie39.top/tags/python/"/>
    
  </entry>
  
</feed>
